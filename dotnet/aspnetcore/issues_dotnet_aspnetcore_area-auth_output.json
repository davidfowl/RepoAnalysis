[
  {
    "id": "MDU6SXNzdWUzOTA0NjgyMDM=",
    "title": "Verify external providers are using latest APIs",
    "url": "https://github.com/dotnet/aspnetcore/issues/4684",
    "createdAt": "2014-11-13T18:44:41Z",
    "lastUpdated": "2024-09-10T19:33:13Z",
    "body": "RTM milestone.\n\nExternal login providers routinely update their APIs and deprecate the old ones. Before we ship RTM we need to verify that each of our implementations is targeting the latest provider API versions to ensure our packages have the longest useful lifespan.\n\nExample: #85\n",
    "upvotes": 0,
    "labels": [
      "task",
      "area-auth",
      "affected-most",
      "severity-minor"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyMjI4MTQ0",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "What is the definition for an \u0027External login provider\u0027?\n",
        "createdAt": "2015-01-30T16:30:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-72228144"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyMjI4MzI0",
        "parentId": null,
        "author": "Praburaj",
        "content": "Like Google, Facebook, Twitter, MicrosoftAccount etc. \n",
        "createdAt": "2015-01-30T16:31:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-72228324"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDEyNjA2NzIwMw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "FYI: Facebook is up to v2.4: https://developers.facebook.com/blog/post/2015/07/08/graph-api-v2.4/\nhttps://katanaproject.codeplex.com/workitem/417\nhttps://github.com/aspnet/Security/issues/365\n",
        "createdAt": "2015-07-29T19:24:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-126067203"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDE1ODEwNDQ1MQ==",
        "parentId": null,
        "author": "muratg",
        "content": "Let\u0027s have a look in RC2.\n",
        "createdAt": "2015-11-19T16:15:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-158104451"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDE4MzAyNzI1MQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "MSA: https://github.com/aspnet/Security/pull/691\n",
        "createdAt": "2016-02-11T19:35:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-183027251"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDIyMDcxODY2Ng==",
        "parentId": null,
        "author": "HaoK",
        "content": "Google Token Endpoint to v4: https://github.com/aspnet/Security/pull/829\n",
        "createdAt": "2016-05-20T21:06:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-220718666"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDIyMDcxODc3Nw==",
        "parentId": null,
        "author": "HaoK",
        "content": "FB to v2.6 https://github.com/aspnet/Security/pull/828\n",
        "createdAt": "2016-05-20T21:07:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-220718777"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDIyMDcxODgyMA==",
        "parentId": null,
        "author": "HaoK",
        "content": "Twitter looks fine\n",
        "createdAt": "2016-05-20T21:07:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-220718820"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDIyMTA0NjQ0Mw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Reviving for the next release.\n",
        "createdAt": "2016-05-23T17:57:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-221046443"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDIyMTA1NDQ5Mg==",
        "parentId": null,
        "author": "HaoK",
        "content": "Its the zombie issue, that will never die...\n",
        "createdAt": "2016-05-23T18:27:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-221054492"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMxMzgyMTAzMw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "*ping* @muratg @Eilon reviving this for 2.0 signoff.",
        "createdAt": "2017-07-08T00:24:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-313821033"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMxNjQ1NDQzMw==",
        "parentId": null,
        "author": "Eilon",
        "content": "@Tratcher - anything we need to do for 2.0 RTM?",
        "createdAt": "2017-07-19T17:11:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-316454433"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMxNjQ1NjI4MQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "I did a pass recently and filed some non-blocking bugs linked above. Move this to 2.1? We should avoid ever putting this issue in the backlog, only the next release.",
        "createdAt": "2017-07-19T17:18:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-316456281"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMxNjQ1ODQ0MA==",
        "parentId": null,
        "author": "Eilon",
        "content": "Ok.",
        "createdAt": "2017-07-19T17:25:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-316458440"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM2MzkzMTg0Mw==",
        "parentId": null,
        "author": "blowdart",
        "content": "Bringing this front and center. Facebook is now at 2.12 and 2.6 will expire in July this year. ",
        "createdAt": "2018-02-07T22:24:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-363931843"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM2MzkzMzM3Mw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "See https://github.com/aspnet/Security/issues/1306 for Facebook",
        "createdAt": "2018-02-07T22:30:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-363933373"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM2OTMzMzQ3Nw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Facebook and Google fixed for 2.1. Twitter and MSA do not appear to require any updates. Punting this zombie issue to 2.2.0.",
        "createdAt": "2018-02-28T18:21:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-369333477"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMTI1NjQ5OQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Update this error message:\r\nhttps://github.com/aspnet/AspNetCore/blob/6c806f91b10c0bf419ab3f2a22c7d64ac5a94663/src/Security/Authentication/Google/src/GoogleHandler.cs#L37\r\n\u0022Please check if the authentication information is correct and the corresponding Google\u002B API is enabled.\u0022",
        "createdAt": "2019-06-12T12:45:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-501256499"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMzY1MTE0NQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Updated facebook for 3.0.0-preivew7.\r\nUpdated the google error message.\r\n\r\nPunting zombie issue again.",
        "createdAt": "2019-06-19T17:17:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-503651145"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNzI3MTA3MA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Moving out of preview1. There\u0027s no expected feature work here, this is just for verification.",
        "createdAt": "2019-10-01T23:20:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-537271070"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzOTEzODAzMw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "3.1-preview2 status: All in-box socal providers as well as OIDC and WsFed are working as expected.\r\nFacebook: We\u0027re using 3.3 but the latest version is 4.0. Updating to 4.0 still works as expected. I\u0027ll send a PR.\r\nAll other providers appear to be up to date.",
        "createdAt": "2019-10-07T18:13:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-539138033"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2NjcwNDMzNw==",
        "parentId": null,
        "author": "blowdart",
        "content": "Once completed, move to next release planning / backlog.",
        "createdAt": "2020-07-30T21:13:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-666704337"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3ODg0MzUwMA==",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\nWe\u0027re moving this issue to the \u0060Next sprint planning\u0060 milestone for future evaluation / consideration. We will evaluate the request when we are planning the work for the next milestone. To learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-08-24T00:05:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-678843500"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3ODg0MzU4Mw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Completed for 5.0.0 RC1. Revisit in 6.0.",
        "createdAt": "2020-08-24T00:05:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-678843583"
      },
      {
        "id": "IC_kwDOAQzde842kPjU",
        "parentId": null,
        "author": "Tratcher",
        "content": "Updated Facebook to v11 for .NET 6 rc2. Other providers are up to date. \r\n\r\nRevisit late in .NET 7.",
        "createdAt": "2021-09-08T18:27:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-915470548"
      },
      {
        "id": "IC_kwDOAQzde85KViwP",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-14T18:39:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-1247161359"
      },
      {
        "id": "IC_kwDOAQzde85OvAIl",
        "parentId": null,
        "author": "FranklinWhale",
        "content": "Both Google and Facebook support PKCE now:\r\nhttps://developers.google.com/identity/protocols/oauth2/native-app#step1-code-verifier\r\nhttps://developers.facebook.com/docs/facebook-login/guides/advanced/oidc-token\r\n\r\nShould \u0060UsePkce\u0060 of [\u0060GoogleOptions\u0060](https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Google/src/GoogleOptions.cs) and [\u0060FacebookOptions\u0060](https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Facebook/src/FacebookOptions.cs) be set to \u0060true\u0060 by default?",
        "createdAt": "2022-11-19T18:43:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-1320944165"
      },
      {
        "id": "IC_kwDOAQzde85O0p61",
        "parentId": null,
        "author": "Tratcher",
        "content": "@FranklinWhale have you tried it? If it works feel free to send us a PR.",
        "createdAt": "2022-11-21T17:39:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-1322426037"
      },
      {
        "id": "IC_kwDOAQzde85O05DH",
        "parentId": null,
        "author": "FranklinWhale",
        "content": "\u003E @FranklinWhale have you tried it? If it works feel free to send us a PR.\r\n\r\nYa, both of them can detect invalid code verifier. I will submit a PR later :)\r\n\r\nShould the tests for Google and Facebook be similar to the one for Microsoft account in #10928?",
        "createdAt": "2022-11-21T18:35:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-1322488007"
      },
      {
        "id": "IC_kwDOAQzde85O06aa",
        "parentId": null,
        "author": "Tratcher",
        "content": "Yes, the tests will look similar to the Microsoft ones.",
        "createdAt": "2022-11-21T18:40:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4684#issuecomment-1322493594"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTA0NjgxNTU=",
    "title": "Offer a built-in JWKS endpoint to support encrypted tokens",
    "url": "https://github.com/dotnet/aspnetcore/issues/4683",
    "createdAt": "2015-09-03T19:58:59Z",
    "lastUpdated": "2020-10-22T21:32:15Z",
    "body": "Wilson doesn\u0027t support JWE yet, but at this moment, we\u0027ll probably want to offer a JWKS endpoint directly in the OIDC middleware (to allow the identity provider to retrieve the public key(s) used to encrypt the identity tokens) and in the JWT bearer middleware (for the access tokens) \n\nRelated specs:\n- JWK/JWKS: http://tools.ietf.org/html/draft-ietf-jose-json-web-key-31\n- OIDC dynamic registration (though dynamic registration is not directly needed to support this feature, it\u0027s the only OIDC specs that contains valuable resources on JWKS): http://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata\n\nRelated tickets:\n- https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/46\n- https://github.com/aspnet-contrib/AspNet.Security.OpenIdConnect.Server/issues/120 (/cc @MonkeyJamboree)\n",
    "upvotes": 1,
    "labels": [
      "investigate",
      "enhancement",
      "area-auth",
      "feature-oidc",
      "affected-few",
      "severity-minor"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDEzNzU4Nzk1OQ==",
        "parentId": null,
        "author": "Eilon",
        "content": "@blowdart are you familiar with this at all?\n",
        "createdAt": "2015-09-03T22:10:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4683#issuecomment-137587959"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDEzNzU4ODM5OQ==",
        "parentId": null,
        "author": "Eilon",
        "content": "Talked to @blowdart and we\u0027re not too eager to support another draft spec right now.\n",
        "createdAt": "2015-09-03T22:13:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4683#issuecomment-137588399"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDEzNzU4OTkyMA==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "JWK is now an official standard (RFC 7517: http://tools.ietf.org/html/rfc7517), but since OIDC specs have been released before JWK, they explicitly target an older draft. Waiting won\u0027t change anything :smile: \n\nMore info at http://openid.net/specs/openid-connect-core-1_0.html#PreFinalIETFSpecs\n",
        "createdAt": "2015-09-03T22:22:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4683#issuecomment-137589920"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDEzNzU5MDQ5Mw==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "BTW, JWK is already implemented by IdentityModel, since it\u0027s required to retrieve the provider metadata of an OIDC server :\u002B1: \n",
        "createdAt": "2015-09-03T22:26:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4683#issuecomment-137590493"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDEzOTQwMDc2NA==",
        "parentId": null,
        "author": "Eilon",
        "content": "Is it really JWE we\u0027re talking about here or JWK/JWKS? We believe that JWK/JWKS are already supported, but that JWE would require more work.\n",
        "createdAt": "2015-09-10T22:30:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4683#issuecomment-139400764"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDEzOTUxMjk3NQ==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "Actually, we\u0027re talking about both ones :smile: \n\nJWK/JWKS is already implemented in Wilson, but is only used by the OIDC middleware to retrieve the certificates/keys exposed by the identity provider. I\u0027m actually suggesting the opposite: adding a JWKS endpoint to the OIDC middleware and the bearer middleware to expose a certificate/public key registered by the user and used by the identity server to encrypt the tokens.\n\nOf course, it won\u0027t be useful until JWE is implemented in Wilson, but as it\u0027s a big feature, that would be great if we had at least a design before RTM.\n",
        "createdAt": "2015-09-11T10:37:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4683#issuecomment-139512975"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDE1NjI2MDg5OA==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "We are trying to get JWE on the schedule, no timeline yet.\n",
        "createdAt": "2015-11-12T22:44:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4683#issuecomment-156260898"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI1NTI0Mjc2OQ==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@PinpointTownes we are closing in on JWE, see the branch: https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/tree/JWE  If a host exposes JWK/JWKS endpoint is there a protocol for the initiator to find the right PublicKey and algorithm to use?\n",
        "createdAt": "2016-10-20T22:12:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4683#issuecomment-255242769"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI1NTI1NTUyNg==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "@brentschmaltz yep, dynreg: https://tools.ietf.org/html/rfc7591#section-2\n",
        "createdAt": "2016-10-20T23:28:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4683#issuecomment-255255526"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3NzM4MTA4OA==",
        "parentId": null,
        "author": "Eilon",
        "content": "@brentschmaltz - some time has elapsed since we looked at this. Any further thoughts on this?",
        "createdAt": "2018-03-29T21:40:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4683#issuecomment-377381088"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3NzY1NjE1NQ==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@Eilon @PinpointTownes help me understand how this would fit in.",
        "createdAt": "2018-03-31T01:27:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4683#issuecomment-377656155"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQyNTI0OTA5NA==",
        "parentId": null,
        "author": "Eilon",
        "content": "@brentschmaltz do you have a recent example of how to get the keys to set on the options?",
        "createdAt": "2018-09-27T21:28:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4683#issuecomment-425249094"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQyNjQ1NDk1Ng==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@PinpointTownes @Eilon Are we speaking about inbound and outbound?\r\nInbound, TokenValidationParameters has three ways to find keys for decryption:\r\n\r\ndelegate: \r\nhttps://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/dev/src/Microsoft.IdentityModel.Tokens/TokenValidationParameters.cs#L113\r\n\r\nset keys directly:\r\nhttps://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/dev/src/Microsoft.IdentityModel.Tokens/TokenValidationParameters.cs#L353\r\n\r\nhttps://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/dev/src/Microsoft.IdentityModel.Tokens/TokenValidationParameters.cs#L556\r\n\r\n\r\n",
        "createdAt": "2018-10-02T22:43:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4683#issuecomment-426454956"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQyNzg3NTg2OQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@brentschmaltz any examples for wiring those up with AAD or any other server? Also, how does the acquisition work?",
        "createdAt": "2018-10-08T15:21:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4683#issuecomment-427875869"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQyNzk1NDI1Nw==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@Tratcher AAD doesn\u0027t have JWE\u0027s yet so nothing for AAD. I\u0027ll leave this issue open until we have a public sample.\r\n\r\nAbout acquisition for outbound, i believe that would be related to what @PinpointTownes has pointed out, we need to obtain a public key from metadata.",
        "createdAt": "2018-10-08T19:36:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4683#issuecomment-427954257"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTA0Njc5MTc=",
    "title": "OpenIdConnectEvents event for RemoteSignOut complete",
    "url": "https://github.com/dotnet/aspnetcore/issues/4678",
    "createdAt": "2016-08-27T13:28:28Z",
    "lastUpdated": "2023-10-28T14:10:09Z",
    "body": "A useful event to have would be one that fires after the sid checking is complete and the authentication cookie has been removed. \n",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI0MzI2ODg5OA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "not until v2.0 unless we find a way not to break everybody. https://github.com/aspnet/Security/issues/942#issuecomment-238947101\n",
        "createdAt": "2016-08-29T21:51:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4678#issuecomment-243268898"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3NzM4MDkxNg==",
        "parentId": null,
        "author": "Eilon",
        "content": "Parking in 2.2.0 milestone for consideration.",
        "createdAt": "2018-03-29T21:40:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4678#issuecomment-377380916"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTA0Njc4Nzg=",
    "title": "OIDC MW: add HandleRemoteSignOutAsync event",
    "url": "https://github.com/dotnet/aspnetcore/issues/4677",
    "createdAt": "2016-08-27T13:39:18Z",
    "lastUpdated": "2023-10-28T14:10:09Z",
    "body": "Should emit cache control headers:\n\n\u0060\u0060\u0060\nCache-Control: no-cache, no-store\nPragma: no-cache\n\u0060\u0060\u0060\n\nhttps://openid.net/specs/openid-connect-frontchannel-1_0-01.html#RPLogout\n",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI0Mjk5MzUxNQ==",
        "parentId": null,
        "author": "brockallen",
        "content": "Well, I guess this does happen but not in the OIDC MW -- rather this is done in the cookie authentication middleware when SignOut is triggered. Feels leaky to rely upon that. \n",
        "createdAt": "2016-08-28T19:16:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4677#issuecomment-242993515"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI0NTc2MTgyMg==",
        "parentId": null,
        "author": "Eilon",
        "content": "We will consider this in a future version.\n",
        "createdAt": "2016-09-08T22:28:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4677#issuecomment-245761822"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3NzM4MDY5MQ==",
        "parentId": null,
        "author": "Eilon",
        "content": "Parking in 2.2.0 milestone for consideration.",
        "createdAt": "2018-03-29T21:39:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4677#issuecomment-377380691"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwNTc1NDkzMg==",
        "parentId": null,
        "author": "Eilon",
        "content": "Should be easy to add the event. Should also consider setting the HTTP headers by default.",
        "createdAt": "2018-07-17T22:59:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4677#issuecomment-405754932"
      },
      {
        "id": "IC_kwDOAQzde8444L1O",
        "parentId": null,
        "author": "Tratcher",
        "content": "The RemoteSignout event was added in 1.0, or am I missing something?\r\nhttps://github.com/dotnet/aspnetcore/commit/d6763bd77c931aeff1024cafd03255abfe55b753#diff-886d1428dbc1c0d2df68b5c60151330d7aff54021b715d48836f266c0bf235ddR41",
        "createdAt": "2021-10-28T21:56:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4677#issuecomment-954252622"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTA0Njc3MDQ=",
    "title": "Certify OIDC middleware?",
    "url": "https://github.com/dotnet/aspnetcore/issues/4674",
    "createdAt": "2017-05-03T14:01:33Z",
    "lastUpdated": "2020-11-10T00:24:54Z",
    "body": "Wouldn\u0027t that be useful??\r\n\r\nhttps://openid.net/certification/",
    "upvotes": 0,
    "labels": [
      "task",
      "area-auth",
      "affected-few",
      "severity-minor"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI5OTU3NzIwMw==",
        "parentId": null,
        "author": "Eilon",
        "content": "We should talk to @vibronet to see what they did.",
        "createdAt": "2017-05-05T21:12:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4674#issuecomment-299577203"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4NTUwMTQ5NQ==",
        "parentId": null,
        "author": "leastprivilege",
        "content": "Vittorio is probably not available anymore. Other ideas?",
        "createdAt": "2018-04-30T19:21:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4674#issuecomment-385501495"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4NTUwMjE5NA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@blowdart ",
        "createdAt": "2018-04-30T19:24:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4674#issuecomment-385502194"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4NTUwMzYwMw==",
        "parentId": null,
        "author": "blowdart",
        "content": "Yea, we should punt this to Mike Jones and the standards folks. At some point. Might was well do it as part of the identity service pieces.",
        "createdAt": "2018-04-30T19:29:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4674#issuecomment-385503603"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ1NzgxMjY2OQ==",
        "parentId": null,
        "author": "leastprivilege",
        "content": "You should do this. My general advice is only use certified OIDC servers/clients. It looks bad it\u0027s not on the list. From a feature point of view you should be complete.",
        "createdAt": "2019-01-26T08:16:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4674#issuecomment-457812669"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyOTc4ODM0Mg==",
        "parentId": null,
        "author": "leastprivilege",
        "content": "ping @blowdart \r\n\r\nWe could do it for you...let me know.",
        "createdAt": "2019-09-10T06:19:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4674#issuecomment-529788342"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTA0Njc2MDA=",
    "title": "Support for token revocation on SignOut in OAuthMiddleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/4672",
    "createdAt": "2017-05-27T10:41:49Z",
    "lastUpdated": "2019-06-05T09:17:52Z",
    "body": "To invalidate refresh tokens when the user signs out, it would be great if the OAuthMiddleware could support OAuth 2.0 Token Revocation ([RFC 7005](https://tools.ietf.org/html/rfc7009)).\r\n\r\nRelated to #1236, I\u0027m interested to consider a PR to add this support.",
    "upvotes": 0,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMwNzQ4NDEzOA==",
        "parentId": null,
        "author": "Eilon",
        "content": "We generally don\u0027t implement proposed standards, but we will keep tracking this to consider for a future version. We\u0027d certainly welcome a PR when the time comes!",
        "createdAt": "2017-06-09T19:52:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4672#issuecomment-307484138"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM2MjQyNDA5Ng==",
        "parentId": null,
        "author": "Eilon",
        "content": "It appears that a \u0022Proposed Standard\u0022 is often as official as an RFC gets, per https://tools.ietf.org/html/rfc7127\r\n\r\nSo, we should certainly consider adding support for this RFC.",
        "createdAt": "2018-02-01T22:30:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4672#issuecomment-362424096"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM2MjQyOTA5Mg==",
        "parentId": null,
        "author": "brockallen",
        "content": "There\u0027s already a library for this: https://github.com/IdentityModel/IdentityModel2/blob/dev/src/IdentityModel/Client/TokenRevocationClient.cs. ",
        "createdAt": "2018-02-01T22:52:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4672#issuecomment-362429092"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM2MjQzOTU0NA==",
        "parentId": null,
        "author": "bgever",
        "content": "Neat @brockallen, useful to show our clients how to do the calls, and maybe we can leverage it ourselves.\r\n\r\nWe\u0027ve been using \u0022proposed standards\u0022 RFC 7005 and [RFC 7523](https://tools.ietf.org/html/rfc7523) successfully for a long time now to handle (JWT) SSO scenarios with our customers.",
        "createdAt": "2018-02-01T23:45:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4672#issuecomment-362439544"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5OTAwNTkzNA==",
        "parentId": null,
        "author": "fredrikhr",
        "content": "I realize that the RFC 7005 is still a proposed standard, but nowadays all the big Social OAuth providers support token revokation, and Dominick from IdentityServer regularly points out in his talks that you should revoke your access token when signing out to make sure in cannot be used later.\r\n\r\nIt is also rather inconvenient to add this functionality yourself in your own app, especially if you have multiple different OAuth providers in your application, because you\u0027d have to implement the revoking capabilities for every single OAuth provider yourself, and then you\u0027d have to add all the convenient extension methods (like \u0060AddGoogle\u0060) and so on.\r\n\r\nMy current workaround for this is to implement an \u0060OAuthSignOutHandler\u0060 that just implements \u0060IAuthenticationSignOutHandler\u0060 and then revokes the tokens based on the \u0060AuthenticationType\u0060 of the user identity. However, this approach is quite hacky and honestly the revoking capability seems much more at home on the actualy \u0060OAuthHandler\u0060 class.\r\n\r\nI have put some thought into how to best integrate this into the existing \u0060OAuthHandler\u0060 so I\u0027d be happy to share a Pull Request.",
        "createdAt": "2019-06-05T09:17:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4672#issuecomment-499005934"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTA0Njc0ODY=",
    "title": "Future AuthZ improvements list",
    "url": "https://github.com/dotnet/aspnetcore/issues/4670",
    "createdAt": "2017-08-10T21:16:52Z",
    "lastUpdated": "2023-02-23T19:24:39Z",
    "body": "This issue will track all the various Authorization improvements we are looking at for 2.1.\r\n\r\nSome initial thoughts:\r\n----\r\nFrom @davidfowl \r\n\r\nWe\u0027ve had a bunch of feedback about our authz system with respect to flowing context from the authorize attribute to the authorization handler:\r\n \r\n- https://github.com/aspnet/Security/issues/670\r\n- https://github.com/aspnet/Mvc/issues/5607\r\n- https://github.com/aspnet/Security/issues/917\r\n- https://github.com/aspnet/Security/issues/1352\r\n\r\nToday the Authorize attribute supports has enough metadata to describe the policy but it doesn\u0027t let you specify the resource (via IAuthorizeData). I think if we solve that, it might solve a bulk of the issues since people will be able to write custom attributes that flow the relevant context to the authorization handler. \r\n \r\nToday that\u0027s only possible when doing imperative authz. I was thinking something like:\r\n \r\n\u0060\u0060\u0060\r\npublic interface IAuthorizeResource\r\n{\r\n    object Resource { get; }\r\n}\r\n\u0060\u0060\u0060\r\n \r\nIf the attribute implemented this, we would flow that as the resource to the handler. This way you implement permissions of whatever you please via resources.\r\n\r\n ----\r\nFrom @rynowak \r\n\r\nLook into providing overriding semantics in MVC, maybe a marker interface: \u0060IAuthorizeMetadata\u0060. Any attributes that implement that interface on the endpoint could be flowed. Then it\u2019s up to developers to build whatever they want.  (Also look into flowing single objects vs many objects \u002B requirements VS resources)\r\n\r\nWe will also look into making it possible to specify requirements via Attributes similar to imperative AuthZ so you don\u0027t have to preconstruct policies for attributes.\r\n\r\nMisc other improvements:\r\n----\r\n- Consider supporting OR logic for policies: https://github.com/aspnet/Security/issues/1356\r\n- Consider enabling policies to be defined in configuration\r\n- Make it easier to be able to display authZ failure reasons in an error page etc https://github.com/aspnet/Security/issues/1530\r\n- Make it easier to pass parameters to policies, i.e. https://github.com/aspnet/Security/issues/1689",
    "upvotes": 0,
    "labels": [
      "Needs: Design",
      "enhancement",
      "area-auth",
      "severity-major",
      "affected-medium"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNDQ3OTcyOQ==",
        "parentId": null,
        "author": "rynowak",
        "content": "My additional thoughts on this. We\u0027re looking at making the concept of an **endpoint** available at a low level from the dispatcher. Endpoints will have arbitrary metadata in an ordered list. This is the equivalent to what MVC does today by passing the action descriptor.\r\n\r\nWe\u0027ll probably also have a concept of *active metadata* which are metadata items that have been hydrated with the request context.\r\n\r\nThese might be useful/necessary building blocks for these things.\r\n\r\n-------------------------------------\r\n\r\nAdditionally in the case of MVC, the current \u0060[Authorize]\u0060 has some surprising behaviors compared to other filters. All authorize filters will execute rather than supporting overriding.  Additionally, \u0060[AllowAnonymous]\u0060 cannot be overridden and turns off **all** authorize attributes. These might be consistent with the past, but they don\u0027t really fit with the *zen* of MVC filters.",
        "createdAt": "2017-08-23T22:23:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-324479729"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNDcxNzUyMQ==",
        "parentId": null,
        "author": "HaoK",
        "content": "Interesting, well if we have a new endpoint concept with a clean slate for metadata, we should probably just expose all of the basic building blocks \r\n\r\n1. Building the ClaimsPrincipal, need to end up with 0 or more authentication schemes.  If none are specified, we continue to use the default user aka httpContext.User, otherwise we build a merged user via authenticating all of the schemes.  We could manifest this with a series of [Authenticate(scheme)] attributes.  \r\n\r\n2. Specifying the Authorization requirements, today the metadata only targets policies, but we could have [Authorize(typeof(MyRequirement), typeof(MyOtherRequirement)]\r\n\r\nSome examples:\r\n\r\n\u0060[Authorize]\u0060 \r\n\r\nWould behave the same as today (using some default policy which relies on context.User, and still only does RequireAuthenticatedUser by default\r\n\r\n\u0060[Authenticate(\u0022Bearer\u0022)]\u0060\r\n\u0060[Authorize]\u0060\r\n\r\nWould use the Bearer scheme and only require that it exists.\r\n\r\n\u0060[Authenticate(\u0022Bearer\u0022, \u0022Cookie\u0022)]\u0060\r\n\u0060[Authorize(typeof(RequireAdminClaim)]\u0060\r\n\r\nWould use the merged Bearer Cookie schemes and require an admin claim.",
        "createdAt": "2017-08-24T18:26:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-324717521"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNDc2Nzk0MQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Which challenge would you issue?",
        "createdAt": "2017-08-24T21:53:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-324767941"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNDc2ODE0MQ==",
        "parentId": null,
        "author": "HaoK",
        "content": "All of them, its not any different than today",
        "createdAt": "2017-08-24T21:54:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-324768141"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNDc2ODYzMQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Challenging both Bearer and Cookie is nonsensical.",
        "createdAt": "2017-08-24T21:57:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-324768631"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNDc2ODk0MA==",
        "parentId": null,
        "author": "HaoK",
        "content": "Not disagreeing, but today if you have a policy that has Bearer and Cookies, that\u0027s what it does today as well",
        "createdAt": "2017-08-24T21:58:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-324768940"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNDc2OTA5OA==",
        "parentId": null,
        "author": "HaoK",
        "content": "Unless we want to eliminate being able to specify multiple schemes entirely...  that\u0027s an option that would simplify things...",
        "createdAt": "2017-08-24T21:59:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-324769098"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNDc3NTc2OA==",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E Not disagreeing, but today if you have a policy that has Bearer and Cookies, that\u0027s what it does today as well\r\n\r\nIt does? What happens as a result? Don\u0027t they stomp on each other?",
        "createdAt": "2017-08-24T22:35:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-324775768"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNDc4MTA2MA==",
        "parentId": null,
        "author": "HaoK",
        "content": "Yeah they do, last one wins, multiple auth schemes in policies has always been a bit weird",
        "createdAt": "2017-08-24T23:06:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-324781060"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNDc4MTU1OA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Some are compatible like Bearer, Basic, and Windows.",
        "createdAt": "2017-08-24T23:09:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-324781558"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM2NDI3MDI4Ng==",
        "parentId": null,
        "author": "Eilon",
        "content": "@HaoK please log new issues for any 2.1.0 proposals.",
        "createdAt": "2018-02-08T22:28:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-364270286"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4ODgwMTQzNA==",
        "parentId": null,
        "author": "hmvs",
        "content": "@HaoK Is it going to be a part of 2.1 release? ",
        "createdAt": "2018-05-14T12:36:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-388801434"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4ODgwNTAyMg==",
        "parentId": null,
        "author": "hmvs",
        "content": "I want to have ability to return custom json if specific policy failed. for example \r\n403\r\n{\r\n\u0022errorType\u0022: \u0022PrivalcyPolicyAcceptRequired\u0022,\r\n\u0022errorMessage\u0022: \u0022You token doesn\u0027t have PolicyAccepted claim\u0022\r\n}",
        "createdAt": "2018-05-14T12:50:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-388805022"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4ODg4MDQ0Mg==",
        "parentId": null,
        "author": "HaoK",
        "content": "No the error authZ improvements didn\u0027t make it into 2.1, I\u0027ll try to get them in 2.2",
        "createdAt": "2018-05-14T16:32:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-388880442"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4ODg4MDkyNw==",
        "parentId": null,
        "author": "spottedmahn",
        "content": "I assume that is why the title changed to 2.2 \uD83D\uDE1C\u2049",
        "createdAt": "2018-05-14T16:34:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-388880927"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4ODkxNjA1MQ==",
        "parentId": null,
        "author": "HaoK",
        "content": "Yup, I\u0027ve got some cycles this week so I\u0027ll try to prototype something ",
        "createdAt": "2018-05-14T18:26:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-388916051"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4ODkyMTQ0Mg==",
        "parentId": null,
        "author": "HaoK",
        "content": "So rough idea of some initial AuthZ improvements I\u0027ve got at the top of my head for 2.2\r\n\r\n- For errors, maybe some kind of scoped \u0060IAuthorizationErrorService\u0060, that the authZ services will report errors to with appropriate context.  This should enable apps to write an appropriate detailed authorization error.\r\n\r\n- \u0060UseAuthorize(\u0022policyName\u0022)\u0060 - middleware equivalent of \u0060[Authorize(\u0022policyName\u0022)]\u0060, would behave similarly, and also allow sideffect of setting httpContext.User if AuthenticationScheme is specified in the policy. TBD on what to do for failure, redirect to some access denied page which is able to display the appropriate context seems ideal.\r\n\r\n",
        "createdAt": "2018-05-14T18:44:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-388921442"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4ODk3NTk2NA==",
        "parentId": null,
        "author": "davidfowl",
        "content": "I think we should close this issue and revisit this in 2.2 planning so we can scope it down.",
        "createdAt": "2018-05-14T21:56:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-388975964"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4ODk3NjgwNg==",
        "parentId": null,
        "author": "HaoK",
        "content": "Close or leave it open for planning?",
        "createdAt": "2018-05-14T21:59:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-388976806"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4OTA3NjEyNQ==",
        "parentId": null,
        "author": "hmvs",
        "content": "Have you considered adding some way how we can access the list of policies which is run and which is failed. Also I thought it could be a helpful to have overload of method \u0060context.Fail();\u0060 with some object which can be accessed later.",
        "createdAt": "2018-05-15T07:49:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-389076125"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM5NzkxNjE0MQ==",
        "parentId": null,
        "author": "natelaff",
        "content": "Is this what currently prevents something such as the ability to show a specific page when a specific policy fails. For example, when a policy fails, redirect to a page that shows how to get that particular policy? (i.e. paying for a new membership level).",
        "createdAt": "2018-06-18T00:14:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-397916141"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ0NzY5NTk4Ng==",
        "parentId": null,
        "author": "reddogaw",
        "content": "@natelaff  I\u0027ve seen that there is a \u0060IPolicyEvaluator\u0060 interface you can implement (using a base class of \u0060PolicyEvaluator\u0060 to make it easier). This will allowed me to redirect the user on the event of a forbidden policy.\r\n\r\nIn the example below, I have the same behaviour for all policies, but you could filter it out to trigger only on a specific policy based on the first parameter.\r\n\r\n    private class RedirectingPolicyEvaluator : PolicyEvaluator\r\n    {\r\n        public RedirectingPolicyEvaluator(IAuthorizationService authorization) : base(authorization)\r\n        {\r\n        }\r\n\r\n        public override async Task\u003CPolicyAuthorizationResult\u003E AuthorizeAsync(AuthorizationPolicy policy, AuthenticateResult authenticationResult, HttpContext context, object resource)\r\n        {\r\n            var result = await base.AuthorizeAsync(policy, authenticationResult, context, resource);\r\n            if (result.Forbidden)\r\n            {\r\n                // If user is authenticated but not allowed, send them to a special error page\r\n                if (context.User.Identity.IsAuthenticated)\r\n                {\r\n                    var urlHelper = context.RequestServices.GetRequiredService\u003CIUrlHelper\u003E();\r\n                    var redirectTo = urlHelper.Action(nameof(HomeController.Unauthorized), \u0022Home\u0022, new { ReturnUrl = context.Request.GetEncodedUrl() });\r\n\r\n                    // Redirect the user\r\n                    context.Response.Redirect(redirectTo);\r\n\r\n                    // Return success since we\u0027ve handled it now\r\n                    return PolicyAuthorizationResult.Success();\r\n                }\r\n\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n\r\nAnd registered in my \u0060Startup.cs\u0060 with:\r\n\r\n            services\r\n                .AddAuthorization()\r\n                .AddScoped\u003CIPolicyEvaluator, RedirectingPolicyEvaluator\u003E()\r\n                ;\r\n",
        "createdAt": "2018-12-17T01:24:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-447695986"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ0NzcyODYwNw==",
        "parentId": null,
        "author": "JamesNK",
        "content": "@HaoK @rynowak Yo, I think we can close this now that we have \u0060AuthorizationMiddleware\u0060 \u002B endpoints \u002B \u0060AuthorizeAttribute\u0060. Is there anything left to do?",
        "createdAt": "2018-12-17T05:42:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-447728607"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ0Nzc0Mzk2NQ==",
        "parentId": null,
        "author": "HaoK",
        "content": "This is currently also serving as tracking several other asks we haven\u0027t done yet for AuthZ:\r\n\r\n- Consider supporting OR logic for policies: aspnet/Security#1356\r\n- Consider enabling policies to be defined in configuration\r\n- Make it easier to be able to display authZ failure reasons in an error page etc aspnet/Security#1530\r\n- Make it easier to pass parameters to policies, i.e. aspnet/Security#1689\r\n\r\nWe moved this into backlog in triage last week so I think its safe to just leave this parked there for now",
        "createdAt": "2018-12-17T07:09:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-447743965"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ3Mzk0NDQ1Mw==",
        "parentId": null,
        "author": "RamunasAdamonis",
        "content": "Is there any progress on custom failure message? Or any official workaround?",
        "createdAt": "2019-03-18T14:55:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-473944453"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MjYzMzU2Mg==",
        "parentId": null,
        "author": "rsc82",
        "content": "I too wonder about how to get a custom json body when ForbidResult is called. \r\n\r\nIs there any way to get at the AuthorizationResult(s) later in the pipeline? As far as I can tell it gets swallowed as part of the PolicyEvaluator (line 84 where it calls authorizationService). The following works inside the controller action but it completely bypasses the filters and I really don\u0027t want to go this route. \r\n\r\n\u0060\u0060\u0060c#\r\n//ControllerAction\r\npublic async Task\u003CIActionResult\u003E GetSomeThing() {\r\n  var a = await this._authorizationService.AuthorizeAsync(User, \u0022MyPolicy\u0022);\r\n  if (!a.Succeeded)\r\n  {\r\n    return this.StatusCode(403, a.Failure.FailedRequirements);\r\n  }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nJust putting this out there as part of the conversation, I came across the following issue and being able to map the AuthorizationResult (and FailedRequirements) to a ProblemDetail would be amazing.  \r\nhttps://github.com/aspnet/AspNetCore/issues/10120\r\n\r\n",
        "createdAt": "2019-05-15T12:28:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-492633562"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxNDQyODI2Ng==",
        "parentId": null,
        "author": "bugnuker",
        "content": "Ping! Any progress on these issues in this ticket? \r\n\r\nI am looking for a solution to obtain the reason an AuthorizationPolicy failed, as in, what Claim or scope was missing or whatever the reason might be for the HTTP 403 when access is denied. I would like to provide a JSON body in the 403 reply with said information. ",
        "createdAt": "2019-07-24T00:09:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-514428266"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxNDQzMjkwNA==",
        "parentId": null,
        "author": "reddogaw",
        "content": "@bugnuker As far as I can tell, there\u0027s still no support for specific \u0022reasons\u0022 why an authorization is marked as Forbidden. However, if your system is relatively simple (e.g. mine is mostly just role based), then you could write a \u0060PolicyEvaluator\u0060 (as mentioned above) and look up the existing \u0060policy.Requirements\u0060 to attach detail the redirection. For example:\r\n\r\n\u0060\u0060\u0060\r\n        private class RedirectingPolicyEvaluator : PolicyEvaluator\r\n        {\r\n            internal static object ItemsKey = new object();\r\n\r\n            public RedirectingPolicyEvaluator(IAuthorizationService authorization) : base(authorization)\r\n            {\r\n            }\r\n\r\n            public override async Task\u003CPolicyAuthorizationResult\u003E AuthorizeAsync(AuthorizationPolicy policy, AuthenticateResult authenticationResult, HttpContext context, object resource)\r\n            {\r\n                var result = await base.AuthorizeAsync(policy, authenticationResult, context, resource);\r\n                if (result.Forbidden \u0026\u0026 policy.Requirements.OfType\u003CRolesAuthorizationRequirement\u003E().Any())\r\n                {\r\n                    // If user is authenticated but not allowed, send them to a special error page\r\n                    if (authenticationResult.Succeeded)\r\n                    {\r\n                        // Find all the role name that are required\r\n                        var rolesRequired = policy.Requirements.OfType\u003CRolesAuthorizationRequirement\u003E().SelectMany(r =\u003E r.AllowedRoles).Where(role =\u003E !authenticationResult.Principal.IsInRole(role));\r\n\r\n                        // Get the URL to the help page, with a return url that\u0027s appropriate to the request type\r\n                        var urlHelper = context.RequestServices.GetRequiredService\u003CIUrlHelper\u003E();\r\n                        var returnUrl = context.Request.GetEncodedUrl();\r\n                        if (context.Request.IsAjaxRequest())\r\n                        {\r\n                            returnUrl = FindAjaxRequestReturnUrl(context, urlHelper);\r\n                        }\r\n                        var redirectTo = urlHelper.AbsoluteAction(nameof(HomeController.Unauthorized), \u0022Home\u0022, new { ReturnUrl = returnUrl, RolesRequired = rolesRequired.ToArray() });\r\n\r\n                        // Store an item in the context\r\n                        context.Items[ItemsKey] = new ForbiddenRequestDetails { RedirectTo = redirectTo, RolesRequired = rolesRequired.ToArray() };\r\n                    }\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n\u0060\u0060\u0060\r\n\r\nThen I wrapped/adapted the \u0060IAuthenticationService\u0060 interface to override what happens for \u0060ForbidAsync\u0060 in particular by looking for that \u0060ForbiddenRequestDetails\u0060 in the context items:\r\n\r\n\u0060\u0060\u0060\r\n        private class RedirectingAuthenticationService : IAuthenticationService\r\n        {\r\n            private readonly IAuthenticationService _adaptee;\r\n\r\n            public RedirectingAuthenticationService(IAuthenticationService adaptee)\r\n            {\r\n                _adaptee = adaptee;\r\n            }\r\n\r\n            .... Other methods removed ...\r\n\r\n            public Task ForbidAsync(HttpContext context, string scheme, AuthenticationProperties properties)\r\n            {\r\n                if (context.Items.ContainsKey(RedirectingPolicyEvaluator.ItemsKey))\r\n                {\r\n                    var options = context.Items[RedirectingPolicyEvaluator.ItemsKey] as ForbiddenRequestDetails;\r\n                    var isApi = context.Request.IsAjaxRequest();\r\n                    if (!isApi)\r\n                    {\r\n                        // Redirect the user\r\n                        context.Response.Redirect(options.RedirectTo);\r\n                        return Task.CompletedTask;\r\n                    }\r\n                    else\r\n                    {\r\n                        // Just write some extra stuff to the content body to make it easier\r\n                        var routeData = context.GetRouteData();\r\n                        var actionDescriptor = new ActionDescriptor();\r\n                        var actionContext = new ActionContext(context, routeData, actionDescriptor);\r\n                        var actionResult = new JsonResult(options) { StatusCode = (int)HttpStatusCode.Forbidden };\r\n                        return actionResult.ExecuteResultAsync(actionContext);\r\n                    }\r\n                }\r\n                return _adaptee.ForbidAsync(context, scheme, properties);\r\n            }\r\n     }\r\n\u0060\u0060\u0060",
        "createdAt": "2019-07-24T00:35:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-514432904"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU0MTAyMTYyOA==",
        "parentId": null,
        "author": "TheTechArch",
        "content": "We are also building a Asp.Net Web application with api controllers with Attribute based authorization and need a way to returm some additional information about the reason why a request was forbidden by the authorization handler The possibility to add a custom header or json body would do a lot for us. ",
        "createdAt": "2019-10-11T11:12:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-541021628"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2OTgzNzc4NA==",
        "parentId": null,
        "author": "abowen",
        "content": "Also interested in returning a reason as part failing a policy.\r\n\r\nFor anyone else, there is a very dodgy workaround you can use here\r\nhttps://github.com/aspnet/Security/issues/1560#issue-278186113",
        "createdAt": "2019-12-31T00:42:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-569837784"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYzMzk2NTIzNw==",
        "parentId": null,
        "author": "BorisTheBrave",
        "content": "Returning an auth failure reason now seems to be supported thanks to https://github.com/dotnet/aspnetcore/pull/21117 ?",
        "createdAt": "2020-05-26T11:22:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-633965237"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3NDI4OTQyNg==",
        "parentId": null,
        "author": "ericsampson",
        "content": "@HaoK @blowdart is there any design progress on allowing the construction of AuthorizationAttributes that make use of resources? Instead of having to fall back on imperative resource-based authorization.\r\nThere\u0027s solutions like [this article](https://undocumented.dev/declarative-resource-based-authorisation-with-asp-net-core/), but the potential disconnect between the self-parsed values out of ActionArguments and what MVC etc ends up binding to makes it way too easy to end up with security issues.\r\nThanks!",
        "createdAt": "2020-08-14T22:00:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-674289426"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3NDMwMzIwMA==",
        "parentId": null,
        "author": "blowdart",
        "content": "No there is not. We can\u0027t have model binding before authz, because people do weird things in model binding which can have side effects, which in turn cause security issues. It\u0027s a non-starter.",
        "createdAt": "2020-08-14T22:55:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-674303200"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3NDU4ODEyMw==",
        "parentId": null,
        "author": "rynowak",
        "content": "Regarding this specifically - it\u0027s possible to access routing\u0027s info in AuthZ with the current layering. So you could figure out the \u0060id\u0060 of the item being accessed (in a typical scenario) but without having run any model binding code to turn arbitrary data into arbitrary objects. \r\n\r\nNot sure if this helps \uD83D\uDE06 ",
        "createdAt": "2020-08-16T22:52:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-674588123"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc0NzM1MTk4NA==",
        "parentId": null,
        "author": "xMANIGHTx",
        "content": "I\u0027ve seen that permission based authorizations have finally been taken into account, that\u0027s great! May I suggest hierarchial roles (with parent/child) out of the box?\r\nSince 1997 I find myself skipping over the built-in authorization mechanisms,and writing them from scratch, because of missing permission based authorization and parent/child node structure.\r\nKeep up for your great work! Maybe this time migrating do ASP.NET Core I will be able to use the built in provider... this would be a breakthrough for me! Lol",
        "createdAt": "2020-12-17T10:27:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-747351984"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc0NzQ3Njc1OQ==",
        "parentId": null,
        "author": "ericsampson",
        "content": "@rynowak could you point me towards the doc for doing that when you have a minute sometime? Maybe I\u0027m misunderstanding your suggestion. Thanks so much!!",
        "createdAt": "2020-12-17T14:37:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-747476759"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3Njg4MTUxNg==",
        "parentId": null,
        "author": "ericsampson",
        "content": "@blowdart , I know you\u0027re busy as heck, but do you know what Ryan was referring to here? I can\u0027t figure out what he\u0027s referring to, or find documentation about it. Thanks so much\r\n\r\n\u003E it\u0027s possible to access routing\u0027s info in AuthZ with the current layering. So you could figure out the id of the item being accessed (in a typical scenario) but without having run any model binding code to turn arbitrary data into arbitrary objects.",
        "createdAt": "2021-02-10T17:29:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-776881516"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3Njg4Mjc4Mw==",
        "parentId": null,
        "author": "blowdart",
        "content": "@ericsampson No idea, and he\u0027s moved on from .net. @pranavkm any idea?",
        "createdAt": "2021-02-10T17:31:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-776882783"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3NjkwMDQ2Nw==",
        "parentId": null,
        "author": "pranavkm",
        "content": "There\u0027s some discussion about it here: https://github.com/dotnet/AspNetCore.Docs/issues/12564\r\n\r\ntl,dr:\r\n\r\n* AuthorizationHandlerContext.Resource is an instance of [\u0060Endpoint\u0060](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.endpoint?view=aspnetcore-5.0) with endpoint routing. You can use it to inspect static metadata associated with the endpoint: \r\n\r\n\u0060\u0060\u0060C#\r\nif (context.Resource is Endpoint endpoint)\r\n{\r\n    var controllerActionDescriptor = endpoint.Metadata\r\n        .GetMetadata\u003CControllerActionDescriptor\u003E();\r\n\u200B\r\n    if (controllerActionDescriptor != null)\r\n    {\r\n        // ...\r\n    }\t\r\n}\r\n\u0060\u0060\u0060\r\n\r\n* You can inject an \u0060IHttpContextAccessor\u0060 in to handler to access route values.\r\n\r\n@HaoK to verify if (2) is still the right way to go about this.",
        "createdAt": "2021-02-10T17:59:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-776900467"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3NzAyNDA2NA==",
        "parentId": null,
        "author": "HaoK",
        "content": "Right, with the change that passed the Endpoint as the resource, it should be easier to inspect things from the endpoint without needing to rely on the HttpContext.  I\u0027m not sure what (2) is referring to exactly?",
        "createdAt": "2021-02-10T20:46:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-777024064"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3NzAyODgyNw==",
        "parentId": null,
        "author": "pranavkm",
        "content": "I think (2) is required if you were looking for the \u0060RouteValueDictionary\u0060 which is available as a feature on HttpContext. ",
        "createdAt": "2021-02-10T20:54:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-777028827"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3NzAzMzE1NQ==",
        "parentId": null,
        "author": "ericsampson",
        "content": "is any of this documented in the official docs?",
        "createdAt": "2021-02-10T21:01:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-777033155"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3NzAzNDQ2NA==",
        "parentId": null,
        "author": "HaoK",
        "content": "Ah yes, due to layering with the core authz layer being lower than Http, the handlers just have get IHttpContextAccessor from DI",
        "createdAt": "2021-02-10T21:04:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-777034464"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3NzgzODM0NA==",
        "parentId": null,
        "author": "tb-mtg",
        "content": "If possible, how can the example from @pranavkm (which shows **controllerActionDescriptor**), also be used for razor pages, including getting the razor page handler name?\r\n\r\nAlso is there any way to determine the **HttpMethod** (if it was a **GET** or **POST**) via endpoint metadata as opposed using **IHttpContextAccessor**?\r\n\r\n\u0060\u0060\u0060\r\nif (context.Resource is Endpoint endpoint) {\r\n\r\n  // can PageActionDescriptor be used?\r\n  var pageActionDescriptor = endpoint.Metadata.GetMetadata\u003CPageActionDescriptor\u003E();\u200B\r\n  if (pageActionDescriptor != null) {\r\n    var area = pageActionDescriptor.AreaName;\r\n    var relativePath = pageActionDescriptor.RelativePath;\r\n    var viewEnginePath = pageActionDescriptor.ViewEnginePath;\r\n    var hander = ???;\r\n    var httpMethod = ???;\r\n    // ...\r\n  }\r\n\r\n  // or should CompiledPageActionDescriptor be used?\r\n  var compiledPageActionDescriptor = endpoint.Metadata.GetMetadata\u003CCompiledPageActionDescriptor\u003E();\u200B\r\n  if (compiledPageActionDescriptor != null) {\r\n    var area = compiledPageActionDescriptor.AreaName;\r\n    var relativePath = compiledPageActionDescriptor.RelativePath;\r\n    var viewEnginePath = compiledPageActionDescriptor.ViewEnginePath;\r\n    var hander = ???;\r\n    var httpMethod = ???;\r\n    // ...\r\n  }\r\n\r\n}\r\n\u0060\u0060\u0060",
        "createdAt": "2021-02-11T22:35:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-777838344"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg1MjkzODQ0OA==",
        "parentId": null,
        "author": "jzhouw",
        "content": "AuthorizationFailure.FailedRequirements is empty even AuthorizeAsync result failed? was trying to add customization message based on failed requirements...",
        "createdAt": "2021-06-02T11:11:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-852938448"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg3MjExOTAxMg==",
        "parentId": null,
        "author": "GarvMS",
        "content": "@HaoK Can we add support for populating the failed requirements in case the explicit Fail() was called? We are internally using it since version 2.0.3 but since we are now migrating to .Net Core, thought of asking here if there is anything that is stopping us in terms of design or core principle of Authz? \r\n\r\nLet me know if you want me to raise a PR first and discuss there? ",
        "createdAt": "2021-07-01T10:23:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4670#issuecomment-872119012"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTA0NjczNjQ=",
    "title": "IClaimsTransformation \u0022runs on AuthorizeAsync success\u0022",
    "url": "https://github.com/dotnet/aspnetcore/issues/4668",
    "createdAt": "2017-08-28T18:14:31Z",
    "lastUpdated": "2019-08-16T01:16:18Z",
    "body": "The current action of IClaimsTransformation provides non-deterministic identity types on IPrincipal. For example, in the simple scenario where cookies are enabled, IClaimsTransformation does not get run if no cookies are present. In previous versions this transform could be relied upon to permit casting identity to a custom type. In Core 2.0 code breaks, and distributing null checks throughout code is necessary again, defeating the purpose of the transformation.\r\n\r\nI\u0027d just like to point out that this is an issue commonly seen on and off in various previous versions of Microsoft\u0027s identity, and from my perspective at this point seems to be a serious regression.",
    "upvotes": 0,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNTQzNDg4Mg==",
        "parentId": null,
        "author": "HaoK",
        "content": "If you always want your claims transformation to run on the context.User, you can write a ClaimsTransformationMiddleware that always runs the transformation.    ",
        "createdAt": "2017-08-28T18:19:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4668#issuecomment-325434882"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNTQ3NTU4Nw==",
        "parentId": null,
        "author": "syndicatedshannon",
        "content": "Do you mean that IClaimsTransformation is operating as intended relative to my reported defect? Can you offer a reference to information on, or direct guidance on, using middleware to solve this problem as you\u0027ve suggested? This example https://github.com/IdentityModel/Thinktecture.IdentityModel/tree/master/source/Owin.ClaimsTransformation has multiple connection points that are invalid.\r\n",
        "createdAt": "2017-08-28T20:43:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4668#issuecomment-325475587"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNTQ4NDI4Mw==",
        "parentId": null,
        "author": "HaoK",
        "content": "\u0060\u0060\u0060C#\r\npublic class ClaimsTransformationMiddleware\r\n{\r\n    private readonly RequestDelegate _next;\r\n    private readonly IClaimsTransformation _transform\r\n\r\n    public ClaimsTransformationMiddleware(RequestDelegate next, IClaimsTransformation transform)\r\n    {\r\n        _next = next;\r\n        _transform = transform ?? throw new ArgumentNullException(nameof(transform));\r\n    }\r\n\r\n    public async Task Invoke(HttpContext context)\r\n    {\r\n        context.User = await _transform.TransformAsync(context.User);\r\n        await _next(httpContext);\r\n    }\r\n}\r\n\r\n// in configure call:\r\nIApplicationBuilder.UseMiddleware\u003CClaimsTransformationMiddleware\u003E();\r\n\u0060\u0060\u0060",
        "createdAt": "2017-08-28T21:15:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4668#issuecomment-325484283"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNTQ4NDk4Nw==",
        "parentId": null,
        "author": "syndicatedshannon",
        "content": "awesome, thank you HaoK!",
        "createdAt": "2017-08-28T21:18:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4668#issuecomment-325484987"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNTQ4OTYzNQ==",
        "parentId": null,
        "author": "syndicatedshannon",
        "content": "Side note, this runs the transformation twice every hit. It gives me the info I need to get everything wired in though. Thank you!",
        "createdAt": "2017-08-28T21:35:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4668#issuecomment-325489635"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNTYzODk5Mg==",
        "parentId": null,
        "author": "syndicatedshannon",
        "content": "Also note that Haok\u0027s code depends on injection, so you\u0027ll still need\r\n\r\n\u0060\t\t\tservices.AddSingleton\u003CIClaimsTransformation, CustomClaimTransformer\u003E();\r\n\u0060",
        "createdAt": "2017-08-29T11:46:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4668#issuecomment-325638992"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNjQ0NTU3OQ==",
        "parentId": null,
        "author": "Eilon",
        "content": "Moving to Backlog because there are no plans to implement this at this time.",
        "createdAt": "2017-08-31T23:18:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4668#issuecomment-326445579"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNjU2MjI5MA==",
        "parentId": null,
        "author": "SRJames",
        "content": "This might help other people. \r\nI used this approach when setting up CORS and Windows Authentication in Core 2 hosted in IIS with an Angular UI. \r\nI had to enable anonymous access in IIS to allow preflight checks when POSTing from Angular (not 100% sure that is the correct approach). But when anonymous was allowed using services.AddSingleton\u003CIClaimsTransformation, ClaimsTransformer\u003E();   resulted in no calls to ClaimsTransformer.\r\nI got around the double calls by creating my own interface instead of using IClaimsTransformation.",
        "createdAt": "2017-09-01T11:58:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4668#issuecomment-326562290"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyMTgzNzY0OA==",
        "parentId": null,
        "author": "augustoproiete",
        "content": "It would be great to have a way to configure claims transformation to always run, even if the user is not authenticated.\r\n\r\nWhat\u0027s the recommended way (in terms of design) to implement these kind of switches in aspnetcore? I\u0027d be happy to work on a PR.\r\n\r\n---\r\n\r\nFor now, I\u0027m using @HaoK\u0027s workaround via middleware, but only running the claims transformer if the user is *not* authenticated, in order to avoid running it twice as per @syndicatedshannon\u0027s observation.\r\n\r\n#### ClaimsTransformationMiddleware.cs\r\n\r\n\u0060\u0060\u0060csharp\r\ninternal class ClaimsTransformationMiddleware\r\n{\r\n    private readonly RequestDelegate _next;\r\n    private readonly IClaimsTransformation _transformer;\r\n\r\n    public ClaimsTransformationMiddleware(RequestDelegate next, IClaimsTransformation transformer)\r\n    {\r\n        _next = next;\r\n        _transformer = transformer ?? throw new ArgumentNullException(nameof(transformer));\r\n    }\r\n\r\n    public async Task Invoke(HttpContext httpContext)\r\n    {\r\n        var user = httpContext.User;\r\n\r\n        // IClaimsTransformation only runs on AuthorizeAsync success\r\n        // so we force it to run for users that are not authenticated\r\n        // https://github.com/aspnet/AspNetCore/issues/4668\r\n        if (user?.Identity is null || !user.Identity.IsAuthenticated)\r\n        {\r\n            httpContext.User = await _transformer.TransformAsync(httpContext.User);\r\n        }\r\n\r\n        await _next(httpContext);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n#### Startup.cs\r\n\r\n\u0060\u0060\u0060csharp\r\npublic void ConfigureServices(IServiceCollection services)\r\n{\r\n    // ...\r\n\r\n    services.AddSingleton\u003CIClaimsTransformation, CustomClaimsTransformer\u003E();\r\n}\r\n\r\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env)\r\n{\r\n    // ...\r\n\r\n    app.UseAuthentication();\r\n    app.UseMiddleware\u003CClaimsTransformationMiddleware\u003E();\r\n    app.UseMvc();\r\n}\r\n\u0060\u0060\u0060\r\n\r\n#### CustomClaimsTransformer.cs\r\n\r\n\u0060\u0060\u0060csharp\r\ninternal class CustomClaimsTransformer : IClaimsTransformation\r\n{\r\n    public Task\u003CClaimsPrincipal\u003E TransformAsync(ClaimsPrincipal principal)\r\n    {\r\n        var transformed = new ClaimsPrincipal();\r\n        transformed.AddIdentities(principal.Identities);\r\n        transformed.AddIdentity(new ClaimsIdentity(new Claim[] \r\n        {\r\n            new Claim(\u0022Transformed\u0022, DateTimeOffset.Now.ToString(CultureInfo.InvariantCulture))\r\n        }));\r\n\r\n        // ... (additional transformations)\r\n\r\n        return Task.FromResult(transformed);\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "createdAt": "2019-08-15T23:59:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4668#issuecomment-521837648"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTI3NzE4ODk=",
    "title": "Add support for content security policy",
    "url": "https://github.com/dotnet/aspnetcore/issues/6001",
    "createdAt": "2017-08-29T21:55:11Z",
    "lastUpdated": "2024-12-04T19:00:03Z",
    "body": "This is a placeholder issue.\r\n\r\nSimilar to the support that we have for CORS in APIs, we should have support for Content Security Policy to make sites safer by default.\r\nSupport for CSP would be policy based, similar to the one we offer for CORS.\r\n\r\n# Usage from middleware\r\n\r\n\u0060\u0060\u0060C#\r\nConfigureServices(IServiceCollection services)\r\n{\r\n    ...\r\n    services.AddCsp();\r\n    ...\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060C#\r\nConfigure(IApplicationBuilder app)\r\n{\r\n    ...\r\n    app.UseCsp();\r\n    ...\r\n}\r\n\u0060\u0060\u0060\r\n\r\n# Usage from MVC\r\n\u0060\u0060\u0060C#\r\nConfigureServices(IServiceCollection services)\r\n{\r\n    ...\r\n    services.AddMvc(); // Add MVC will call AddCsp similar to what we do for CORS today.\r\n    ...\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060C#\r\n[EnableCsp]\r\npublic IActionResult Index()\r\n{\r\n    return View();\r\n}\r\n\u0060\u0060\u0060\r\n\r\nWe will provide a default policy that limits content to your domain, defines best practices for HTTPS and will be set to report-only. This behavior can be switched per endpoint so that you can progressively enforce the policy one endpoint at a time.\r\n\r\n# References\r\n\r\nhttps://en.wikipedia.org/wiki/Content_Security_Policy\r\n\r\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/CSP\r\n\r\nhttps://www.w3.org/TR/CSP2/\r\n\r\nhttp://caniuse.com/#search=content%20security%20policy\r\n",
    "upvotes": 36,
    "labels": [
      "Needs: Design",
      "enhancement",
      "blocked",
      "area-auth",
      "severity-minor",
      "affected-medium"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzMDQxNTIwMQ==",
        "parentId": null,
        "author": "muratg",
        "content": "We\u0027ll need a design for this guys.",
        "createdAt": "2018-10-16T21:55:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6001#issuecomment-430415201"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzMDQxNTI0OQ==",
        "parentId": null,
        "author": "muratg",
        "content": "cc @shirhatti ",
        "createdAt": "2018-10-16T21:56:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6001#issuecomment-430415249"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzMTIxNzY1OA==",
        "parentId": null,
        "author": "jrestall",
        "content": "I created a policy based Content Security Policy library to use on my own sites while waiting for this support in the core libraries. Since content security policy support is now planned for 3.0, it might help you with the design discussion. I also followed your standards on the off chance you could use any of the code for this issue.\r\n\r\n### Code\r\n[Microsoft.AspNetCore.Csp](https://github.com/jrestall/BasicMiddleware/tree/jrestall/csp/src/Microsoft.AspNetCore.Csp)\r\n[Microsoft.AspNetCore.Mvc.Csp](https://github.com/jrestall/BasicMiddleware/tree/jrestall/csp/src/Microsoft.AspNetCore.Mvc.Csp)\r\n\r\n### Samples\r\n[CspSample](https://github.com/jrestall/BasicMiddleware/tree/jrestall/csp/samples/CspSample)\r\n[CspSample.Mvc](https://github.com/jrestall/BasicMiddleware/tree/jrestall/csp/samples/CspSample.Mvc)\r\n\r\n\u0060\u0060\u0060csharp\r\npublic void ConfigureServices(IServiceCollection services)\r\n{\r\n    services.AddCsp(options =\u003E\r\n    {\r\n        options.AddPolicy(\u0022Policy1\u0022, policy =\u003E policy\r\n            .AddDefaultSrc(src =\u003E\r\n            {\r\n                src.AllowSchema(CspDirectiveSchemas.Http);\r\n                src.AllowSchema(CspDirectiveSchemas.Https);\r\n                src.AllowSelf();\r\n                src.AllowEval();\r\n                src.AllowHash(\u0022sha256-qznLcsROx4GACP2dm0UCKCzCG\u002BHiZ1guq6ZZDob/Tng=\u0022);\r\n            })\r\n            .AddScriptSrc(src =\u003E src.AddNonce())\r\n            .AddStyleSrc(src =\u003E src.AddNonce())\r\n            .ReportUri(\u0022/csp-reports\u0022)\r\n            .ReportTo(\u0022csp-reports\u0022)\r\n            .AddManifestSrc(src =\u003E\r\n            {\r\n                src.AllowHost(\u0022http://*.example.com\u0022);\r\n            })\r\n            .ReportOnly()\r\n        );\r\n\r\n        options.AddPolicy(\u0022Policy2\u0022, policy =\u003E\r\n            policy.AddDefaultSrc(src =\u003E src.AllowNone().AddNonce())\r\n        );\r\n\r\n        options.AddPolicy(\u0022BetaUsers\u0022, policy =\u003E\r\n            policy.AddDefaultSrc(src =\u003E src.AllowHost(\u0022beta-testers.example.org\u0022))\r\n        );\r\n    });\r\n\r\n    services.AddMvc()\r\n        .AddCspReportMediaType();\r\n\r\n    services.AddMvcCore().AddCsp();\r\n\r\n    services.AddScoped\u003CIConfigureOptions\u003CCspOptions\u003E, TrialUserSrc\u003E();\r\n}\r\n\r\npublic class TrialUserSrc :  IConfigureOptions\u003CCspOptions\u003E\r\n{\r\n    public void Configure (CspOptions options)\r\n    {\r\n        if (context.User.HasClaim(c =\u003E c.Type == ClaimTypes.TrialUser))\r\n        {\r\n            var currentPolicy = options.GetPolicy(\u0022Policy1\u0022);\r\n\t    currentPolicy.Append(policy =\u003E \r\n                policy.AddDefaultSrc(src =\u003E src.AllowHost(\u0022trial.company.com\u0022))\r\n            );\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n### Configuration with MVC Attributes\r\n- AppendCsp and OverrideCsp are optional attributes that modify the main policy on a per action basis.\r\n\u0060\u0060\u0060csharp\r\n[EnableCsp(\u0022Policy1\u0022, \u0022Policy2\u0022)]\r\n[AppendCsp(\u0022BetaUsers\u0022, Targets = \u0022Policy1, Policy2\u0022)]\r\n[OverrideCsp(\u0022BetaUsers\u0022)]\r\npublic IActionResult EnablePolicy1And2()\r\n{\r\n    ...\r\n}\r\n\r\n[DisableCsp]\r\npublic IActionResult Disabled()\r\n{\r\n    ...\r\n}\r\n\u0060\u0060\u0060\r\n\r\n### Default Content-Security-Policy\r\nThis is the default policy I\u0027m using:\r\n\u0060\u0060\u0060csharp\r\n    public class CspOptions\r\n    {\r\n        // Default Content-Security-Policy:\r\n        //     default-src \u0027self\u0027 https:; font-src \u0027self\u0027 https: data:; img-src \u0027self\u0027 https: data:;\r\n        //     object-src \u0027none\u0027; script-src https:; style-src \u0027self\u0027 https: \u0027unsafe-inline\u0027\r\n        private static readonly ContentSecurityPolicy DefaultContentSecurityPolicy\r\n\u0060\u0060\u0060\r\n\r\n### Tag Helpers\r\n\r\n**CspMetaTagHelper** - Adds the content security policies as meta tags to the page.\r\n\r\n\u0060\u0060\u0060html\r\n\u003Cmeta http-equiv=\u0022Content-Security-Policy\u0022 /\u003E\r\n\u0060\u0060\u0060\r\n\r\n**CspNonceTagHelper** - Adds a nonce to script or style tags and automatically ensures a nonce is returned in the HTTP header.\r\n\r\n**CspGenerateHashTagHelper** - Automatically generates hashes for inline scripts and styles and ensures the hashes are in the HTTP header.\r\n\r\n\u0060\u0060\u0060html\r\n\u003Cstyle asp-add-nonce=\u0022true\u0022 asp-generate-hash=\u0022true\u0022\u003E\r\n    p {\r\n        color: #0000ff;\r\n    }\r\n\u003C/style\u003E\r\n\u003Cscript asp-add-nonce=\u0022true\u0022 asp-generate-hash=\u0022true\u0022 asp-generate-hash-algorithms=\u0022HashAlgorithms.SHA256 | HashAlgorithms.SHA512\u0022\u003E\r\n    console.log(\u0022I\u0027m a script that will be hashed dynamically.\u0022);\r\n\u003C/script\u003E\r\n\u0060\u0060\u0060\r\n\r\n**CspPluginTypeTagHelper** - Automatically adds the used plugin types to the content security policy.\r\n\u0060\u0060\u0060html\r\n\u003Cembed asp-type=\u0022application/testplugintype2\u0022 /\u003E\r\n\u0060\u0060\u0060\r\n\r\n**CspFallBackTagHelper** - Generates CSP hashes for the inline scripts that are generated when using asp-fallback-href or asp-fallback-src.\r\n\r\n**CspSubresourceIntegrityTagHelper** - Automatically generates SRI hashes for the remote scripts using a local fallback script.\r\n\r\n\u0060\u0060\u0060html\r\n\u003Clink href=\u0022https://ajax.aspnetcdn.com/ajax/bootstrap/4.0.0/css/bootstrap.min.css\u0022 rel=\u0022stylesheet\u0022\r\n      asp-fallback-href=\u0022~/lib/bootstrap/css/bootstrap.min.css\u0022\r\n      asp-fallback-test-class=\u0022sr-only\u0022 asp-fallback-test-property=\u0022position\u0022 asp-fallback-test-value=\u0022absolute\u0022\r\n      asp-subresource-integrity=\u0022true\u0022\r\n      asp-subresource-integrity-algorithms=\u0022HashAlgorithms.SHA256 | HashAlgorithms.SHA384 | HashAlgorithms.SHA512\u0022 /\u003E\r\n\u0060\u0060\u0060\r\n### CSP Report Support\r\n\r\n- CspReportRequest model\r\n\r\n- Added \u0027application/csp-report\u0027 media type support.\r\n\r\n\u0060\u0060\u0060csharp\r\n/// \u003Csummary\u003E\r\n/// Adds the \u0027application/csp-report\u0027 media type to the JSON input formatter so that csp reports can be received.\r\n/// \u003C/summary\u003E\r\n/// \u003Cparam name=\u0022builder\u0022\u003EThe \u003Csee cref=\u0022IServiceCollection\u0022 /\u003E to add services to.\u003C/param\u003E\r\n/// \u003Creturns\u003EThe \u003Csee cref=\u0022IServiceCollection\u0022/\u003E so that additional calls can be chained.\u003C/returns\u003E\r\npublic static IMvcBuilder AddCspReportMediaType(this IMvcBuilder builder)\r\n\u0060\u0060\u0060\r\ncc @sebastienros - When this feature lands in 3.0 I\u0027ll implement CSP for Orchard Core :tada: ",
        "createdAt": "2018-10-19T01:40:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6001#issuecomment-431217658"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzMTQ0ODEwNA==",
        "parentId": null,
        "author": "javiercn",
        "content": "@jrestall Your approach is pretty solid. It\u0027s pretty much what I had in mind. I have some ideas on how to better integrate this with Razor, but the foundation is solid.\r\n\r\nThe way I see this, there will be a core library (similar to what we have for CORS) and then some MVC specific glue/enhancements/opinions.\r\n\r\nIn particular, I think it might be better to specify the policy as a Razor directive as its very resource specific. In many actions you don\u0027t have the ability to know what\u0027s going to be rendered. By doing it as a razor directive it can be something that you put on a _viewStart, _viewImports (not really sure which one of them yet) or simply at the start of your page or view. \r\n\r\nThat way the policy lives close to the resources, regarding hashes and things like that I would have to think more about this. One thing that I\u0027m concern is the size of the policy on the header growing to a significant size, so I\u0027m more inclined to use/recommend a different approach where you hoist the inline-scripts into js files for most cases.\r\n\r\nI think that you are on point with the need to append to an initial policy and to completely override it in some cases.\r\n\r\nHaving a default policy is also great, but the default for the system should be to simply report so that you can start changing the code base to enforce the policy.",
        "createdAt": "2018-10-19T18:01:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6001#issuecomment-431448104"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ1MzY3MzAyNg==",
        "parentId": null,
        "author": "shirhatti",
        "content": "@mkArtakMSFT @javiercn Is this still happening in 3.0?",
        "createdAt": "2019-01-11T22:09:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6001#issuecomment-453673026"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ3NDM5MDEzMg==",
        "parentId": null,
        "author": "ulrichb",
        "content": "Please don\u0027t forget about the validation summary (inline \u0060style\u0060-element) mentioned in https://github.com/aspnet/AspNetCore/issues/4817#issuecomment-308058241.\r\n\r\nhttps://github.com/aspnet/AspNetCore/blob/bcead68f0cebf53c1c8fe4c1015cc6961f5a757c/src/Mvc/Mvc.ViewFeatures/src/DefaultHtmlGenerator.cs#L24",
        "createdAt": "2019-03-19T14:17:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6001#issuecomment-474390132"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ3NTczOTcyMQ==",
        "parentId": null,
        "author": "chrisdpratt",
        "content": "Interesting that no one has mentioned NWebSec. This library started life adding much needed security enhancements to ASP.NET MVC, and now support ASP.NET Core as well. There\u0027s already a pretty complete CSP implementation here, so at the very least, it might be worth referencing.\r\n\r\nhttps://docs.nwebsec.com/en/latest/nwebsec/libraries.html",
        "createdAt": "2019-03-22T18:51:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6001#issuecomment-475739721"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ4OTc0MDE3Mw==",
        "parentId": null,
        "author": "joeaudette",
        "content": "I\u0027m looking forward to this being part of the aspnet core stack as well. I\u0027ve experimented a bit with NWebSec but it seems it has not been updated in over a year, issues go unanswered and even their SSL cert for their website expired in Feb 2019 and they have not done anything about it. Seems like an abandoned project to me. https://www.nwebsec.com/",
        "createdAt": "2019-05-06T19:13:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6001#issuecomment-489740173"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwNzg1MTExNw==",
        "parentId": null,
        "author": "nbarbettini",
        "content": "NWebSec is solid, but as @joeaudette said it\u0027s under-maintained right now. I would love to see something like @jrestall\u0027s approach built in.\r\n\r\nNWebSec puts everything into \u0060Configure\u0060, but it would be easier to compose with things like the Options pattern if configuration happened in \u0060ConfigureServices\u0060 like in James\u0027 example.",
        "createdAt": "2020-04-02T13:35:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6001#issuecomment-607851117"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2ODIzNDg0OA==",
        "parentId": null,
        "author": "aaronshim",
        "content": "Hi folks,\r\nMy colleague @salcho has been in contact with some of you for adding framework-level support of CSP for ASP.NET. We\u0027ve created #24548 of our proposed changes, so we will welcome any feedback! Thank you!",
        "createdAt": "2020-08-03T20:50:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6001#issuecomment-668234848"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyMjcwNDg2NQ==",
        "parentId": null,
        "author": "V4A001",
        "content": "Is this issue included:  validation summary emitting style=\u0022display:none\u0022.\r\n\u0060[Report\u0060 Only] Refused to apply inline style because it violates the following Content\r\n\r\n\u0060\u003Cdiv asp-validation-summary=\u0022All\u0022 class=\u0022text-danger\u0022\u003E\u003C/div\u003E\r\n        \u003Cdiv class=\u0022text-danger validation-summary-valid\u0022 data-valmsg-summary=\u0022true\u0022\u003E\u003Cul\u003E\u003Cli style=\u0022display:none\u0022\u003E\u003C/li\u003E\u0060",
        "createdAt": "2020-11-05T23:31:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6001#issuecomment-722704865"
      },
      {
        "id": "IC_kwDOAQzde841jgz6",
        "parentId": null,
        "author": "Ponant",
        "content": "@javiercn , I do not see a real benefit of having a csp as a directive. Rather, I think it is better to make the templates more Csp compliant for those who already are implementing Csp (with or without a library) and who may find themselves in using unsafe keywords in the Csp directive set:\r\n\r\nOne example is the style in the default generator as mentioned above\r\nhttps://github.com/dotnet/aspnetcore/blob/ff51fd7105a9003841215f1f3b0b8fc9e2998a67/src/Mvc/Mvc.ViewFeatures/src/DefaultHtmlGenerator.cs#L28 \r\n\r\nAnother one is the injection of javascript during development, see @damienbod here https://github.com/dotnet/aspnetcore/issues/34428\r\n\r\nRegarding the library, from my own experience with Csp at least, I see most benefit in having enable/disable attributes, filters and a global Csp/ReportOnly. For Spa\u0027s, I don\u0027t know yet, so probably meta tags with hashes (?).\r\n \r\n",
        "createdAt": "2021-08-13T14:35:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6001#issuecomment-898501882"
      },
      {
        "id": "IC_kwDOAQzde842WT9t",
        "parentId": null,
        "author": "misterspeedy",
        "content": "\u003E Please don\u0027t forget about the validation summary (inline \u0060style\u0060-element) mentioned in [#4817 (comment)](https://github.com/dotnet/aspnetcore/issues/4817#issuecomment-308058241).\r\n\r\nNarrator: They *did* forget about it.",
        "createdAt": "2021-09-02T15:39:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6001#issuecomment-911818605"
      },
      {
        "id": "IC_kwDOAQzde842v3NP",
        "parentId": null,
        "author": "Ponant",
        "content": "I created a library for CSP because we needed it in production apps and existing libraries including NWebsec did not fully fulfill our conditions. It is based on a *pragmatic* and performance-oriented design philosophy which I believe is worth sharing after a brief exchange with @damienbod  here https://github.com/dotnet/aspnetcore/issues/34428. This lead us to introduce the concept of a CSP Policy Group. This class encompasses the \u0060Content-Security-Policy\u0060 and \u0060Content-Security-Policy-Report-Only\u0060 headers **in one entity**, because they can and should be used in tandem.\r\n\r\nSo I go along by copy pasting some text, and you can get extensive details here\r\nhttps://github.com/Ponant/Galebra.Security/tree/master/src/Galebra.Security.Headers.Csp , in particular the design section, together with a bunch of references. Critics and/or questions are always welcome.\r\n\r\n## Get Started\r\nAll terminology is explained after. The library does not use \u0060EndPoint\u0060 routing, so you can invoke the \u0060UseContentSecurityPolicy\u0060\r\nmiddleware before or after \u0060UseRouting\u0060.\r\n\r\n\u0060\u0060\u0060\u0060csharp\r\napp.UseContentSecurityPolicy();\r\n\u0060\u0060\u0060\u0060\r\n\r\nIt can be placed before \u0060UseStaticFiles\u0060 if you need CSP headers to be delivered with peculiar content such as \u0060SVG\u0060.\r\n\r\nYou configure CSP via *appsettings.json* or via an \u0060Action\u0060 in *Program.cs*.\r\n\r\nWhen using *appsetting.json*:\r\n\r\n\u0060\u0060\u0060\u0060csharp\r\nusing Galebra.Security.Headers.Csp;\r\n\r\nbuilder.Services.AddContentSecurityPolicy(builder.Configuration.GetSection(\u0022Csp\u0022));\r\n\u0060\u0060\u0060\u0060\r\nThere are two services registered, a \u0060Singleton\u0060, essentially holding the configuration, and a \u0060Scoped\u0060 service for nonce generation.\r\n\r\nIn the following, three policy **groups** are registered:\r\n\r\n\u0060\u0060\u0060\u0060json\r\n  \u0022Csp\u0022: {\r\n    \u0022IsDisabled\u0022: false,//default: Will apply the default policy everywhere until overriden by attributes or filters\r\n    \u0022PolicyGroups\u0022: {\r\n      \u0022PolicyGroup1\u0022: {\r\n        \u0022Csp\u0022: {\r\n          \u0022Fixed\u0022: \u0022default-src \u0027none\u0027 \u0027sha256-RFWPLDbv2BY\u002BrCkDzsE\u002B0fr8ylGr2R2faWMhq4lfEQc=\u0027;script-src \u0027self\u0027\u0022\r\n        },\r\n        \u0022IsDefault\u0022: false,\r\n        \u0022NumberOfNonceBytes\u0022: 16//default\r\n      },\r\n      \u0022PolicyGroup2\u0022: {\r\n        \u0022Csp\u0022: {\r\n          \u0022Fixed\u0022: \u0022default-src \u0027self\u0027;base-uri \u0027self\u0027;form-action \u0027self\u0027;object-src;frame-ancestors;connect-src ws://localhost:65412\u0022,\r\n          \u0022Nonceable\u0022: [\r\n            \u0022style-src \u0027self\u0027\u0022\r\n          ]\r\n        },\r\n        \u0022CspReportOnly\u0022: {\r\n          \u0022Fixed\u0022: \u0022default-src;form-action \u0027self\u0027;base-uri;object-src;frame-ancestors;sandbox\u0022,\r\n          \u0022Nonceable\u0022: [\r\n            \u0022style-src\u0022,\r\n            \u0022script-src\u0022\r\n          ]\r\n        },\r\n        \u0022IsDefault\u0022: true,//default\r\n        \u0022NumberOfNonceBytes\u0022: 8\r\n      },\r\n      \u0022PolicyGroup3\u0022: {\r\n        \u0022Csp\u0022: {\r\n          \u0022Nonceable\u0022: [\r\n            \u0022style-src\u0022\r\n          ]\r\n        },\r\n        \u0022IsDefault\u0022: false,\r\n        \u0022NumberOfNonceBytes\u0022: 3\r\n      }\r\n    }\r\n  },\r\n\u0060\u0060\u0060\u0060\r\n\r\nThe first policy group does not require nonces (hence fixed, see below) and only requires the \u0060Content-Security-Policy\u0060 header to be set.\r\nThe second policy group configures the two headers, CSP and CSP-Report-Only, and requires nonces for each of these headers.\r\nThis policy is the default policy, \u0060IsDefault=true\u0060. The \u0060IsDisabled\u0060 property in *Line 1* is set to \u0060false\u0060 (default),\r\nwhich means that the default policy named *PolicyGroup2* will be applied globally unless overridden by attributes or filters.\r\nThe third policy uses **only** nonces, for styles. The default value for nonce generation is 16 bytes.\r\nWe used \u0060connect-src ws://localhost:65412\u0060 in this example to allow \u0060/_framework/aspnetcore-browser-refresh.js\u0060 to work properly.\r\nAlso, we disabled CSS Hot Reload in Visual Studio, see https://github.com/dotnet/aspnetcore/issues/36085, to avoid\r\na weak CSP configuration just for development.\r\n\r\nAlternatively, you can configure everything in code:\r\n\r\n\u0060\u0060\u0060\u0060csharp\r\nbuilder.Services.AddContentSecurityPolicy(c =\u003E\r\n{\r\n    c.IsDisabled = false;\r\n    c.Add(\u0022Policy1\u0022, g =\u003E\r\n    {\r\n        g.Csp.Fixed = \u0022default-src \u0027self\u0027;connect-src ws://localhost:65412\u0022;\r\n        g.Csp.Nonceable.Add(\u0022style-src \u0027self\u0027\u0022);\r\n        g.CspReportOnly.Nonceable.Add(\u0022script-src\u0022);\r\n        g.IsDefault = true;\r\n        g.NumberOfNonceBytes = 32;\r\n    });\r\n    c.Add(\u0022Policy2\u0022, g =\u003E\r\n    {\r\n        g.Csp.Fixed = \u0022default-src \u0027self\u0027;connect-src ws://localhost:65412\u0022;\r\n        g.CspReportOnly.Fixed=\u0022default-src\u0022;\r\n        g.IsDefault = false;\r\n    });\r\n});\r\n\u0060\u0060\u0060\u0060\r\n\r\nAdd nonces to the body by importing the TagHelpers\r\n\r\n\u0060\u0060\u0060\u0060cshtml\r\n@addTagHelper *, Galebra.Security.Headers.Csp\r\n\u0060\u0060\u0060\u0060\r\n\r\nAnd add to **styles, scripts or link tags** the TagHelper:\r\n\r\n\u0060\u0060\u0060\u0060cshtml\r\nnonce-add=true\r\n\u0060\u0060\u0060\u0060\r\n\r\nFor example, for \u0060PolicyGroup3\u0060, that restricts you to use only nonced styles,\r\nyou would allow loading bootstrap like so:\r\n\r\n\u0060\u0060\u0060\u0060cshtml\r\n    \u003Clink rel=\u0022stylesheet\u0022 href=\u0022~/lib/bootstrap/dist/css/bootstrap.min.css\u0022 nonce-add=true/\u003E\r\n\u0060\u0060\u0060\u0060\r\nAs you may agree, this logical structure actually is powerful.\r\n \r\n## Design Philosophy and introduction\r\n\r\nThe following design principles, detailed below, have been followed:\r\n\r\n* CSP configuration is well suited in *appsettings.json* because you need to store long strings\r\n* Configuration via \u0060Action\u0060 should also be possible in *Program.cs*\r\n* Support multiple policies to use in different parts of the website\r\n* Enable and Disable attributes in pages or actions or controllers\r\n* Enable and Disable Filters for folders in razor pages\r\n* Developper provides a default, global policy, and can override\r\n* Possibility to apply the default policy everywhere, and override for parts of the website,\r\nor have no policy applied globally and set them on specific parts only\r\n* Support CSP and a CSP-Report-Only headers simultaneously, each with a different set of policy directives\r\n* Optimize nonce generation for \u0060script\u0060, \u0060style\u0060, and \u0060link\u0060 tags\r\n* Use the latest recommendations for [random number generations](https://github.com/dotnet/runtime/issues/40579)\r\n* Optimize string generation for common CSP string lengths\r\n* Add CSP to headers by using the key already existing in \u0060HttpContext\u0060 to avoid memory allocation\r\n* Each policy is, at the end, a long string.\r\nThis string can be either static (fixed) or generated newly on each request if nonces are required.\r\n\r\nConsider the following arguments. CSP is a set of two headers, whose names can be:\r\n\r\n* Content-Security-Policy\r\n* Content-Security-Policy-Report-Only\r\n\r\nEach policy in those headers is defined by an ordered set of directives.\r\nEach directive is a name/value pair; name is non-empty, but value may be empty.\r\nFor example, \u0060script-src\u0060 is a directive\u0027s *name* and the value can be, for instance, \u0060\u0027self\u0027\u0060 or a url or a set of these.\r\nAnother directive can be \u0060default-src \u0027none\u0027\u0060, where \u0060default-src\u0060 is another directive name.\r\nThe directives forming a policy are separated by semicolons.\r\nFor this example, the Content Security Policy would be the header:\r\n\r\n\u0060\u0060\u0060\u0060\r\nContent-Security-Policy: default-src \u0027none\u0027;script-src \u0027self\u0027\r\n\u0060\u0060\u0060\u0060\r\n\r\nwhich is equivalent to the shorter version\r\n\r\n\u0060\u0060\u0060\u0060\r\nContent-Security-Policy: default-src;script-src \u0027self\u0027\r\n\u0060\u0060\u0060\u0060\r\n\r\nIn theory, you can have [multiple CSP policies](https://w3c.github.io/webappsec-csp/#multiple-policies) **for the same header name**\r\nin the same response header; however, we believe **this should not be recommended** because it makes your policy more convoluted\r\nand rather highlights a design flaw, notwithstanding that you send more bytes to the user\u0027s browser. Consequently, the library\r\noutputs only one CSP header for a given header name.\r\nIn practice, we assign the value for the header key (name) rather than adding a new item in the dictionary.\r\nThis also has the consequence of efficient write.\r\n\r\nSo, with this library, **you cannot have** the following:\r\n\r\n\u0060\u0060\u0060\u0060\r\nContent-Security-Policy: Policy1\r\nContent-Security-Policy: Policy2\r\n\u0060\u0060\u0060\u0060\r\n\r\n## The CspPolicyGroup class\r\n\r\nHowever, you can have both a CSP and a CSP-Report-Only policy, and usually **this is recommended**.\r\nSome libraries do not support this configuration. This library does. For example **you can do** something like this:\r\n\r\n\u0060\u0060\u0060\u0060\r\nContent-Security-Policy: default-src \u0027self\u0027\r\nContent-Security-Policy-Report-Only: default-src;style-src \u0027self\u0027\r\n\u0060\u0060\u0060\u0060\r\n\r\nIn this scenario, the website would run without issues if, loosely speaking, all styles and scripts are loaded from the server\r\n(\u0060\u0027self\u0027\u0060), but the browser will report to you what would break if you disable scripts (\u0027none\u0027) and other fetch directives,\r\nexcept for styles which use \u0060\u0027self\u0027\u0060.\r\nThus, this allows you to enforce a policy and at the same time fine-tune another one which ultimately will become\r\nthe enforcing policy when you are ready.\r\n\r\nAllowing for both CSP and CSP-Report-Only headers to coexist introduces the \u0060CspPolicyGroup\u0060 class.\r\nIt is this group class that you use to configure your policies. This class contains two properties, \u0060Csp\u0060 and \u0060CspReportOnly\u0060, each of\r\nwhich is a \u0060CspPolicy\u0060 class. You can leave one of these properties empty; for example if you want to have only browser reports,\r\nyou would build only the property \u0060CspReportOnly\u0060.\r\n\r\n## The CspPolicy class and Nonce TagHelper\r\n\r\nThe usual route to library design is to use the so-called fluent-api. This gives elegant code,\r\nbut with CSP this is unnecessary complication and makes your *Program.cs* (or *Startup.cs*) rather long.\r\nIn addition, CSP configuration ultimately boils down to outputting one or two strings in the headers,\r\nplus the possibility of nonces in those headers and pages.\r\nA developer will ultimately look at the CSP output in the browser\u0027s tools\r\nto see if the formatting is as expected and nonces properly generated and positioned.\r\nThere is already a lot of resources and services in the pipeline, so we decided to keep it simple and focus on performance.\r\n\r\nThis led us to the following observation. A CSP header value is **always** divided into two groups.\r\nThe first group is a fixed, possibly empty, string, i.e. a string that *does not change upon requests on a given page*,\r\nand another string that is dynamically generated upon each request to include one or more nonces.\r\nTherefore the \u0060CspPolicy\u0060 class has two public properties, a string \u0060Fixed\u0060 and a list of strings called \u0060Nonceable\u0060.\r\n\r\nFor example, the policy:\r\n\r\n\u0060\u0060\u0060\u0060\r\ndefault-src;style-src \u0027self\u0027\r\n\u0060\u0060\u0060\u0060\r\n\r\nwould be set as a \u0060CspPolicy.Fixed\u0060 string because a nonce is not required. In *appsettings.json*, this would be:\r\n\r\n\u0060\u0060\u0060\u0060json\r\n\u0022Fixed\u0022: \u0022default-src;style-src \u0027self\u0027\u0022,\r\n\u0060\u0060\u0060\u0060\r\n\r\nA \u0060sha256-myshacode\u0060, if needed, would be included in the \u0060Fixed\u0060 string.\r\n\r\nIf, now, you want to have this policy, but in addition produce a nonce for styles, then you would need to split your string\r\nand populate the \u0060CspPolicy.Nonceable\u0060 list. In appsettings.json, the split would be like this:\r\n\r\n\u0060\u0060\u0060\u0060json\r\n\u0022Fixed\u0022: \u0022default-src\u0022,\r\n\u0022Nonceable\u0022: [\r\n\u0022style-src \u0027self\u0027\u0022\r\n]\r\n\u0060\u0060\u0060\u0060\r\n\r\nThe \u0060style-src\u0060 is here short, but generally is longer to include for example urls from a Bootstrap CDN. The most important is to\r\nidentify the directive\u0027s name, here \u0060style-src\u0060.\r\n\r\nTo use the nonce on the style in this example, you would invoke the Tag Helper \u0060nonce-add\u0060, e.g.\r\n\r\n\u0060\u0060\u0060\u0060cshtml\r\n\u003Cstyle nonce-add=true\u003E\r\n.myclass{\r\n    background:lightgreen;\r\n}\r\n\u003C/style\u003E\r\n\u003Ch4 class=\u0022myclass\u0022\u003EI am lightgreen, thank you nonce!\u003C/h4\u003E\r\n\u0060\u0060\u0060\u0060\r\n\r\nWhen you use a \u0060nonce\u0060, common libraries are confined to the \u0060script\u0060 and \u0060style\u0060 tags, but \u0060link\u0060 tags are also possible.\r\nNonce generation defaults to the spec-recommended 16 bytes, which gives 256^16=2^128 possibilities,\r\nor a 22 long web-encoded base64 string. You can override this with the property \u0060CspPolicyGroup.NumberOfNonceBytes\u0060,\r\ne.g. in appsettings.json, and the nonce will apply to the entire group.\r\n\r\n\u0060\u0060\u0060\u0060json\r\n\u0022NumberOfNonceBytes\u0022: 8\r\n\u0060\u0060\u0060\u0060\r\n\r\n## Multiple Policies, Attributes, Filters and default CspPolicyGroup\r\n\r\nWhen you implement CSP on a website, often you need several \u0060CspPolicyGroup\u0060 objects depending on the page where the user lands.\r\nFor example, you would have a global CSP policy on all pages, but when processing a payment on a page or Razor Pages folder,\r\nor a Controller, you will want another CSP policy (for example to accept connections to a payment API such as PayPal or Stripe).\r\nThis library allows you to configure many policies and invoke them when needed, through attributes and filters.\r\n\r\nWhen you use the library, unless you override the default described below, the default \u0060CspPolicyGroup\u0060\r\nis applied to all pages as soon as you inject the Middleware in the pipeline.\r\n\r\nYou can apply a given policy to an entire Folder in Razor Pages, e.g. in the *Movies* folder:\r\n\r\n\u0060\u0060\u0060\u0060csharp\r\n//Apply on specific folders\r\nbuilder.Services.AddRazorPages(options =\u003E\r\n{\r\n    options.Conventions.AddFolderApplicationModelConvention(\r\n        \u0022/Movies\u0022,\r\n                model =\u003E model.Filters.Add(new EnableCspPageFilter { PolicyGroupName = \u0022PolicyGroup1\u0022 }));\r\n});\r\n\u0060\u0060\u0060\u0060\r\n\r\nYou can also disable CSP in a folder:\r\n\r\n\u0060\u0060\u0060\u0060chsarp\r\n model =\u003E model.Filters.Add(new DisableCspPageFilter { EnforceMode = false }));\r\n\u0060\u0060\u0060\u0060\r\n\r\nWhere \u0060EnforceMode\u0060 is \u0060true\u0060 by default and is discussed below.\r\n\r\nIn areas, you could do something like this:\r\n\r\n\u0060\u0060\u0060\u0060csharp\r\n    options.Conventions.AddAreaFolderApplicationModelConvention(\u0022Identity\u0022, \u0022/Account\u0022,\r\n     model =\u003E model.Filters.Add(new EnableCspPageFilter { PolicyGroupName = \u0022PolicyGroup1\u0022 }));\r\n\r\n    options.Conventions.AddAreaPageApplicationModelConvention(\u0022Identity\u0022, \u0022/Account/Manage/ChangePassword\u0022,\r\n        model =\u003E model.Filters.Add(new EnableCspPageFilter { PolicyGroupName = \u0022PolicyGroup3\u0022 }));\r\n\u0060\u0060\u0060\u0060\r\n\r\nIn a Razor Page or Action or Controller, you can override the default \u0060CspPolicyGroup\u0060 with an attribute:\r\n\r\n\u0060\u0060\u0060\u0060csharp\r\n[EnableCsp(PolicyGroupName=\u0022PolicyGroup1\u0022)]\r\n\u0060\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060\u0060csharp\r\n[DisableCsp]\r\n\u0060\u0060\u0060\u0060\r\n\r\nThe \u0060[DisableCsp]\u0060 always wins unless you set the \u0060init\u0060 property \u0060DisableCsp.EnforceMode\u0060 to false.\r\nThe enforcement rule is useful in a scenario where an entire folder or a controller needs to have CSP disabled on all routes\r\nexcept for those where the enable attribute is present. For example, in the following we use the \u0060DisableCspPageFilter\u0060\r\nto disable CSP in the *Movies* folder:\r\n\r\n\u0060\u0060\u0060\u0060csharp\r\nbuilder.Services.AddRazorPages(options =\u003E\r\n{\r\n    options.Conventions.AddFolderApplicationModelConvention(\r\n        \u0022/Movies\u0022,\r\n    model =\u003E model.Filters.Add(new DisableCspPageFilter { EnforceMode = false }));\r\n});\r\n\u0060\u0060\u0060\u0060\r\nBecause we have set \u0060EnforceMode = false\u0060, we can set CSP on a page inside the *Movies* folder with an attribute,\r\ne.g. in *Movies/index* \u0060[EnableCsp(PolicyGroupName = \u0022PolicyGroup3\u0022)]\u0060. The same applies for a controller; you would disable CSP\r\nwith \u0060EnforceMode=false\u0060 and use the \u0060EnableCsp\u0060 attribute on an action:\r\n\r\n\u0060\u0060\u0060\u0060csharp\r\n[DisableCsp(EnforceMode = false)]\r\npublic class BooksController : Controller\r\n{\r\n    public ActionResult Index()\r\n    {\r\n        //CSP is disabled here\r\n        return View();\r\n    }\r\n\r\n    // GET: BooksController/Details/5\r\n    [EnableCsp(PolicyGroupName =\u0022PolicyGroup3\u0022)]\r\n    public ActionResult Details(int id)\r\n    {\r\n        //CSP works here owing to EnforceMode=false\r\n        return View();\r\n    }\r\n}\r\n\u0060\u0060\u0060\u0060\r\n\r\n## IsDisabled global boolean\r\n\r\nBy default, the library applies the default \u0060CspPolicyGroup\u0060 to all delivered pages until overwritten by attributes or filters.\r\nYou can override this global behaviour in *Program.cs* or in *appsettings.json* where you can set at the top level\r\n\u0060\u0022IsDisabled\u0022: true,\u0060. This will result in CSP not being applied globally, at all, until you invoke it via attributes or filters.\r\n\r\n\r\n\r\n\r\n",
        "createdAt": "2021-09-13T19:40:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6001#issuecomment-918516559"
      },
      {
        "id": "IC_kwDOAQzde86GyCYc",
        "parentId": null,
        "author": "niemyjski",
        "content": "This would be really nice to be built in. Two other libraries support this as well https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders and https://github.com/juunas11/aspnetcore-security-headers",
        "createdAt": "2024-07-31T19:23:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6001#issuecomment-2261263900"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzODI1Mzc5MjU=",
    "title": "Add auth sample demonstrating how to handle events using the context classes",
    "url": "https://github.com/dotnet/aspnetcore/issues/4114",
    "createdAt": "2017-11-16T21:38:37Z",
    "lastUpdated": "2020-11-10T23:23:07Z",
    "body": "So we can point issues like this: https://github.com/aspnet/Security/issues/1543",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "Samples",
      "affected-few",
      "severity-minor"
    ],
    "comments": []
  },
  {
    "id": "MDU6SXNzdWUzODI1MzgyNTQ=",
    "title": "Add API Key auth handler auth sample",
    "url": "https://github.com/dotnet/aspnetcore/issues/4116",
    "createdAt": "2017-11-20T22:35:47Z",
    "lastUpdated": "2020-11-10T23:23:35Z",
    "body": "The API key may come from a request header, the path, query, or form field.",
    "upvotes": 0,
    "labels": [
      "task",
      "area-auth",
      "Samples",
      "affected-few",
      "severity-minor"
    ],
    "comments": []
  },
  {
    "id": "MDU6SXNzdWUzODI1Mzg0ODg=",
    "title": "Add WindowsAuth samples",
    "url": "https://github.com/dotnet/aspnetcore/issues/4120",
    "createdAt": "2017-12-28T16:49:26Z",
    "lastUpdated": "2023-01-25T07:45:28Z",
    "body": "Windows Auth only (IIS Express vs httpsys)\r\nWindows Auth \u002B impersonation\r\nWindows Auth \u002B anonymous \u002B cors\r\n\r\nMixed auth:\r\nWindows Auth \u002B anonymous\r\nWindows Auth \u002B bearer for different endpoints or the same endpoint\r\nWindows Auth \u002B remote/cookie auth with selection page or automatic selection\r\n",
    "upvotes": 0,
    "labels": [
      "task",
      "Docs",
      "area-auth",
      "Samples",
      "affected-few",
      "severity-minor"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ0MzIzMzk3OA==",
        "parentId": null,
        "author": "RobinHoody",
        "content": "Hi @Tratcher, i followed this from https://github.com/aspnet/Security/issues/1653 Do you know if there\u0027s a working sample for this?\r\n\r\nKind regards,\r\n\r\nDave",
        "createdAt": "2018-11-30T15:14:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4120#issuecomment-443233978"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ0MzI0OTk2MA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Are you looking for something that\u0027s not covered here: https://docs.microsoft.com/en-us/aspnet/core/security/authentication/windowsauth?view=aspnetcore-2.1?",
        "createdAt": "2018-11-30T16:01:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4120#issuecomment-443249960"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5ODcxODExNw==",
        "parentId": null,
        "author": "code2expert",
        "content": "\u003E \r\n\u003E \r\n\u003E Are you looking for something that\u0027s not covered here: https://docs.microsoft.com/en-us/aspnet/core/security/authentication/windowsauth?view=aspnetcore-2.1?\r\n\r\nYes. I am looking to authenticate with windows authentication but using the forms provided for anonymous authentication. I want to be able to control how a user logs into the app even if it\u0027s windows authentication.",
        "createdAt": "2019-06-04T15:20:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4120#issuecomment-498718117"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5ODczNDk4OA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E I am looking to authenticate with windows authentication but using the forms provided for anonymous authentication.\r\n\r\nDo you mean you want them to enter their username and password into your own login form? That\u0027s not a flow we support, nor should you, it\u0027s much weaker than client based windows auth.",
        "createdAt": "2019-06-04T16:00:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4120#issuecomment-498734988"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5ODgxMTM4Mg==",
        "parentId": null,
        "author": "code2expert",
        "content": "Thanks Steve, \r\n\r\nWhat I want is to use my form instead of the pop up that comes up at the moment which I have no control over.",
        "createdAt": "2019-06-04T19:33:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4120#issuecomment-498811382"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5ODgxMzYyOA==",
        "parentId": null,
        "author": "code2expert",
        "content": "I\u0027ll like to control the login/logout sessions as users are accessing a pc.",
        "createdAt": "2019-06-04T19:40:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4120#issuecomment-498813628"
      },
      {
        "id": "IC_kwDOAQzde85LnviY",
        "parentId": null,
        "author": "HaoK",
        "content": "Plan is to write a well commented mixed auth sample and add it to the docs samples",
        "createdAt": "2022-10-05T17:14:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4120#issuecomment-1268709528"
      },
      {
        "id": "IC_kwDOAQzde85LnwIZ",
        "parentId": null,
        "author": "HaoK",
        "content": "@Rick-Anderson in terms of process/PR where should a new mixed auth sample go?  Would it be a new app in https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/common/samples ?",
        "createdAt": "2022-10-05T17:16:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4120#issuecomment-1268711961"
      },
      {
        "id": "IC_kwDOAQzde85LoZI6",
        "parentId": null,
        "author": "Rick-Anderson",
        "content": "\u003E @Rick-Anderson in terms of process/PR where should a new mixed auth sample go? Would it be a new app in https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/common/samples ?\r\n\r\nhttps://github.com/dotnet/AspNetCore.Docs.Samples/tree/main/common",
        "createdAt": "2022-10-05T19:40:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4120#issuecomment-1268879930"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzODI1Mzg2MzU=",
    "title": "Add sample for single remote auth",
    "url": "https://github.com/dotnet/aspnetcore/issues/4122",
    "createdAt": "2017-12-28T16:57:23Z",
    "lastUpdated": "2024-11-27T07:17:50Z",
    "body": "This is a simplified version of the org auth template using any single remote provider as the sole auth mechanism.",
    "upvotes": 0,
    "labels": [
      "task",
      "area-auth",
      "Samples",
      "severity-minor",
      "affected-medium"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86VMir9",
        "parentId": null,
        "author": "davidfowl",
        "content": "Is this still relevant?",
        "createdAt": "2024-11-27T07:17:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4122#issuecomment-2503092989"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzODI1MzgxODU=",
    "title": "Add auth sample for multiple remote auths without Identity",
    "url": "https://github.com/dotnet/aspnetcore/issues/4115",
    "createdAt": "2017-12-28T17:01:37Z",
    "lastUpdated": "2020-11-10T23:23:26Z",
    "body": "This is an expanded version of the single remote provider scenario (https://github.com/aspnet/AuthSamples/issues/16) that includes a login page where you select which provider you want to login with. No Identity is required.",
    "upvotes": 0,
    "labels": [
      "task",
      "area-auth",
      "Samples",
      "affected-few",
      "severity-minor"
    ],
    "comments": []
  },
  {
    "id": "MDU6SXNzdWUzODI1MzgzMTg=",
    "title": "Add auth sample for DI event injection",
    "url": "https://github.com/dotnet/aspnetcore/issues/4117",
    "createdAt": "2017-12-28T17:08:50Z",
    "lastUpdated": "2020-11-10T23:23:48Z",
    "body": "The auth handlers all have event classes that can be passed in directly or injected via DI. We need samples for the DI scenario.",
    "upvotes": 0,
    "labels": [
      "task",
      "area-auth",
      "Samples",
      "severity-minor",
      "affected-very-few"
    ],
    "comments": []
  },
  {
    "id": "MDU6SXNzdWUzODI1Mzg0NTA=",
    "title": "Add links to external auth samples",
    "url": "https://github.com/dotnet/aspnetcore/issues/4119",
    "createdAt": "2017-12-28T17:26:08Z",
    "lastUpdated": "2020-11-10T23:24:01Z",
    "body": "AzureAd:\r\nhttps://github.com/azure-samples?utf8=%E2%9C%93\u0026q=active-directory\u002Bcore\u0026type=\u0026language=\r\nhttps://github.com/Azure-Samples/active-directory-dotnet-webapp-webapi-openidconnect-aspnetcore\r\n\r\nIdentityServer: https://github.com/IdentityServer/IdentityServer4.Samples\r\n\r\nOpenIdDict: https://github.com/openiddict/openiddict-samples",
    "upvotes": 0,
    "labels": [
      "task",
      "area-auth",
      "Samples",
      "affected-few",
      "severity-minor"
    ],
    "comments": []
  },
  {
    "id": "MDU6SXNzdWUyODUzMzA5NTk=",
    "title": "Need a way to handle authorization for static files",
    "url": "https://github.com/dotnet/aspnetcore/issues/2457",
    "createdAt": "2018-01-01T21:41:21Z",
    "lastUpdated": "2024-03-02T00:17:06Z",
    "body": "_From @danroth27 on Thursday, September 24, 2015 11:18:42 AM_\r\n\r\nIn ASP.NET 4.6 you can use the Authorization module to handle authorization for static file requests. We need some what to handle authorization for static files in ASP.NET 5.\n\n@blowdart\n\r\n\r\n_Copied from original issue: aspnet/StaticFiles#70_",
    "upvotes": 4,
    "labels": [
      "Needs: Design",
      "enhancement",
      "feature-static-files",
      "area-auth",
      "affected-few",
      "severity-minor"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NDY3OTE3Mg==",
        "parentId": null,
        "author": "aspnet-hello",
        "content": "_From @blowdart on Thursday, September 24, 2015 11:21:47 AM_\r\n\r\nMy feeling here is we don\u0027t want yet another middleware for this. The Static File middleware should detect the authorization service and enable configuration of policies by path, file type, regex (_kidding - NO REGEX_) or whatever other filtering mechanism they wish to implement.\n\nPushing responsibility off to another middleware, which then becomes order dependent is a path of failure and undiscoverable for most users.\n",
        "createdAt": "2018-01-01T21:41:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2457#issuecomment-354679172"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NDY3OTE3Ng==",
        "parentId": null,
        "author": "aspnet-hello",
        "content": "_From @longday24 on Saturday, April 9, 2016 6:51:53 AM_\r\n\r\nWhat if UseStaticFiles() excepted optional string param of a named authorizationPolicy when passing requestpath?\n\n\u0060public void ConfigureServices(IServiceCollection services)\n{\n    services.AddAuthentication();\n    services.AddAuthorization(options =\u003E\n    {\n        options.AddPolicy(\u0022Authenticated\u0022, policy =\u003E policy.RequireAuthenticatedUser());\n    });\n}\u0060\n\nusage would be something like \u0060.UseStaticFiles(\u0022requestPath\u0022, \u0022Authenticated\u0022);\u0060\n",
        "createdAt": "2018-01-01T21:41:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2457#issuecomment-354679176"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NDY3OTE3OA==",
        "parentId": null,
        "author": "aspnet-hello",
        "content": "_From @kyse on Thursday, June 29, 2017 1:59:57 PM_\r\n\r\nJust to push this along figured I\u0027d throw this out there.\r\n\r\nCreate a StaticFileAuthorizationRequirement file that inherits IAuthorizationRequirement for developers to build AuthorizationHandleres against.  Not essential, we can realistically pass in any requirement in updated options, there\u0027s not really a need for injecting anything specific to this library to the requirement except for is it authorizing a directory browser or static file request, which can just be checked against the context.Resource parameter in the handler.\r\n\r\nUpdate SharedOptions and SharedOptionsBase to provide IEnumerable\u003Cstring\u003E AuthenticationSchemes, IEnumerable\u003CIAuthorizationRequirement\u003E AuthorizationRequirements, and bool AllowAnonymous properties.\r\n\r\nIn Helpers.cs:\r\n\u0060\u0060\u0060c#\r\n        internal static bool IsAuthenticated(this HttpContext context, SharedOptionsBase options)\r\n        {\r\n            if (options.AllowAnonymous)\r\n                return true;\r\n\r\n            var authSchemes = options.AuthenticationSchemes ?? context.Authentication.GetAuthenticationSchemes().Select(desc =\u003E desc.AuthenticationScheme).ToArray();\r\n\r\n            foreach (var authScheme in authSchemes)\r\n            {\r\n                var cp = context.Authentication.AuthenticateAsync(authScheme).Result;\r\n                if (cp == null) continue;\r\n                context.User = cp;\r\n                break;\r\n            }\r\n            return (context.User != null \u0026\u0026 context.User.Identity.IsAuthenticated);\r\n        }\r\n\r\n        internal static bool IsAuthorized(this HttpContext context, ILibrary library, SharedOptionsBase options)\r\n        {\r\n            return options.AllowAnonymous ||\r\n                   !options.AuthorizationRequirements.Any() ||\r\n                   context.RequestServices.GetService\u003CIAuthorizationService\u003E().AuthorizeAsync(context.User, library, options.AuthorizationRequirements).Result;\r\n        }\r\n\u0060\u0060\u0060\r\n\r\nIn the directory browser and static file middleware, update body to include calls to authenticate and authorize.\r\nDirectoryBrowserMiddleware:\r\n\u0060\u0060\u0060c#\r\n            if (!context.IsAuthenticated(_options))\r\n            {\r\n                context.Response.StatusCode = 401;\r\n                return Constants.CompletedTask;\r\n            }\r\n\r\n            if (!context.IsAuthorized(library, _options))\r\n            {\r\n                context.Response.StatusCode = 403;\r\n                return Constants.CompletedTask;\r\n            }\r\n\u0060\u0060\u0060\r\n\r\nStaticFileMiddleware:\r\n\u0060\u0060\u0060c#\r\n            else if (!fileContext.LookupFileInfo())\r\n            {\r\n                _logger.LogFileNotFound(fileContext.SubPath);\r\n            }\r\n            else\r\n            {\r\n                if (!context.IsAuthenticated(_options))\r\n                {\r\n                    _logger.LogNotAuthenticated(fileContext.Library.Name, fileContext.SubPath);\r\n                    return fileContext.SendStatusAsync(Constants.Status401NotAuthenticated);\r\n                }\r\n                if (!context.IsAuthorized(fileContext.Library, _options))\r\n                {\r\n                    _logger.LogNotAuthorized(fileContext.Library.Name, fileContext.SubPath);\r\n                    return fileContext.SendStatusAsync(Constants.Status403NotAuthorized);\r\n                }\r\n\u0060\u0060\u0060\r\n\r\nUpdate logger to expose authenticated and authorized logging templates, as well as Constants to include the two additional status codes.\r\n\r\nStaticFileAuthorizationHandler : AuthorizationHandler\u003CStaticFileAuthorizationRequirement\u003E can be defined to parse against the ClaimsPrincipal or even an injected DB context (however you want to setup your handler) for authorizing the static file request.\r\n\r\nI further updated my customization to build this out based on entries my DB for ILibrary, thus I can define a LibraryServer with an endpoint of library, and it parses libraries and generates PhysicalFileProvider and serves the Path for the libraries exposed based on authentication and authorization.  Since this library treats each instance as a single path there\u0027s on need for that and would probably be best for this repo to instead utilize the authorization handler to treat the resource as the type of request being authorized, ie allow viewing the directory browser, or allow grabbing the static file.\r\n\r\nThen you can just allow the developer to add in the auth requirements as desired:\r\n\u0060\u0060\u0060c#\r\n            app.UseLibraryServer(new LibraryServerOptions\r\n            {\r\n                RequestPath = new PathString(\u0022/Library\u0022),\r\n                PathProvider = dbContextOrRepositoryOrServiceInheritingILibraryPathProvider,\r\n                AuthenticationSchemes = new List\u003Cstring\u003E { CookieAuthenticationDefaults.AuthenticationScheme },\r\n                AuthorizationRequirements = new List\u003CIAuthorizationRequirement\u003E { new LibraryAuthorizationRequirement() },\r\n                LibraryFileOptions =\r\n                {\r\n                    ServeUnknownFileTypes = true\r\n                }\r\n            });\r\n\u0060\u0060\u0060\r\nObviously in that example I\u0027m also providing a PathProvider for my db library entities that is out of scope of this post.  But you could pass AllowAnonymous = true, or pass in desired authentication schemes to target or against any defined, and any specific requirements.  Probably best to further expand it to allow just providing a policy name instead.\r\n\r\nI could probably put together a pull request if you like this direction without the dynamic sub path options.  Biggest question would be is it worth while to provide a base requirement class or just let the developer define their own.",
        "createdAt": "2018-01-01T21:41:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2457#issuecomment-354679178"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM2MzM1NzE1Mg==",
        "parentId": null,
        "author": "lumogox",
        "content": "Any updates on this? @aspnet-hello ",
        "createdAt": "2018-02-06T09:08:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2457#issuecomment-363357152"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3MDA5ODE0OQ==",
        "parentId": null,
        "author": "muratg",
        "content": "@blowdart What\u0027s your current thoughts on this?",
        "createdAt": "2018-03-03T00:38:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2457#issuecomment-370098149"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3MDEwNTc5OA==",
        "parentId": null,
        "author": "blowdart",
        "content": "How about the same way you handled razor pages, with paths in the config?",
        "createdAt": "2018-03-03T01:48:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2457#issuecomment-370105798"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3MDUxOTQ5Mg==",
        "parentId": null,
        "author": "muratg",
        "content": "Tentatively putting into the next milestone.",
        "createdAt": "2018-03-05T18:40:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2457#issuecomment-370519492"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3MDUyMTI5MQ==",
        "parentId": null,
        "author": "kyse",
        "content": "FYI, in the mean time.  You could make use of this to achieve auth on static files.\r\nhttps://github.com/kyse/Kyse.AspNetCore.StaticLibrary",
        "createdAt": "2018-03-05T18:46:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2457#issuecomment-370521291"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4MzE4NjU4MQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Here\u0027s a sample showing how to do AuthN and AuthZ for static files as a middleware on a pipeline branch: \r\nhttps://github.com/aspnet/AuthSamples/blob/c7bb6607307072f6e098d0e4a2c9fa7e6d017916/samples/StaticFilesAuth/Startup.cs#L120-L134\r\n\r\nThis isn\u0027t ideal, we should still figure out how to integrate this as a first class citizen.\r\n\r\nI also tried writing a sample using MVC\u0027s Authorize features, but MVC does not provide good handling for serving static files, directory browsing, default files, etc... See the discussion at https://github.com/aspnet/AuthSamples/pull/37.",
        "createdAt": "2018-04-20T18:41:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2457#issuecomment-383186581"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ1MzY3MDYwNg==",
        "parentId": null,
        "author": "shirhatti",
        "content": "@Tratcher In 3.0, should we rewrite static files as an end-ware? That should solve this problem",
        "createdAt": "2019-01-11T21:59:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2457#issuecomment-453670606"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ1MzY3MTE0Mg==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@shirhatti it\u0027s worth a try. You\u0027d still need a way to mark files as requiring authorization policies though.",
        "createdAt": "2019-01-11T22:01:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2457#issuecomment-453671142"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMTQ1NjIwNA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@rynowak are StaticFiles endpoints still on your list?",
        "createdAt": "2019-06-12T21:08:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2457#issuecomment-501456204"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY5OTk0Mzc5Nw==",
        "parentId": null,
        "author": "jotatoledo",
        "content": "Up, any updates related to this?",
        "createdAt": "2020-09-28T11:17:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2457#issuecomment-699943797"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcwMDExNjI2Nw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Only some updated guidance docs:\r\nhttps://docs.microsoft.com/en-us/aspnet/core/fundamentals/static-files?view=aspnetcore-3.1#static-file-authorization",
        "createdAt": "2020-09-28T15:45:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2457#issuecomment-700116267"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcwMDIwNjk2Ng==",
        "parentId": null,
        "author": "alrz",
        "content": "I made a custom endpoint pipeline with static file middleware. A few things to consider:\r\n\r\n- Make sure to reset endpoint to null\r\n- Pass an identical route to both RequestPath and Map\r\n\r\nThis has a tradeoff of matching the route twice (via endpoint and the middleware itself). You could manually set Path instead but it causes issues hard to diagnose.",
        "createdAt": "2020-09-28T18:30:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2457#issuecomment-700206966"
      },
      {
        "id": "IC_kwDOAQzde85LHCre",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-27T22:26:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2457#issuecomment-1260137182"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU1NzgyNjgzNjQ=",
    "title": "Use HttpClientFactory in Auth Providers",
    "url": "https://github.com/dotnet/aspnetcore/issues/19730",
    "createdAt": "2018-01-29T19:14:55Z",
    "lastUpdated": "2020-11-10T23:29:36Z",
    "body": "The Security repo has some of our only first party usage of HttpClient. We should try using HttpClientFactory there and see if it makes sense.\r\n\r\n@glennc ",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "severity-minor",
      "affected-medium"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM2MjQyMzUzNw==",
        "parentId": null,
        "author": "glennc",
        "content": "Is it extensible enough today that you could use the factory if you wanted to? Like giving security libraries a delegate or HTTPClient instance that they use instead of creating it themselves.",
        "createdAt": "2018-02-01T22:28:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/19730#issuecomment-362423537"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM2MjQyNTY4Nw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "You can give it a handler or client in the options at startup, not per request.",
        "createdAt": "2018-02-01T22:37:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/19730#issuecomment-362425687"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzOTU3MTQ2Mw==",
        "parentId": null,
        "author": "poke",
        "content": "Just saw this due to the transfer, I assume that we don\u2019t need any more prototyping for the HttpClientFactory now, given that it\u2019s already out for quite a while now.\r\n\r\nBut do we then want to attempt to migrate some of the client usages within the Security repo to use this?",
        "createdAt": "2018-11-17T00:49:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/19730#issuecomment-439571463"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzOTU4MzE2MQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "It would still be interesting to try using the client factory in the auth providers.",
        "createdAt": "2018-11-17T03:10:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/19730#issuecomment-439583161"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTA0NjY5NzE=",
    "title": "Back-channel logout support for OpenIdConnect?",
    "url": "https://github.com/dotnet/aspnetcore/issues/4659",
    "createdAt": "2018-04-01T00:20:07Z",
    "lastUpdated": "2023-09-11T17:07:13Z",
    "body": "There is a default endpoint for front-channel signout: signout-oidc\r\n\r\nIs there a plan to include a similar endpoint for back-channel signout in 2.1 release?\r\nSpec: http://openid.net/specs/openid-connect-backchannel-1_0.html\r\n\r\nThank you.",
    "upvotes": 8,
    "labels": [
      "enhancement",
      "area-auth",
      "affected-few",
      "severity-minor"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3NzczMzYxMA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "No plans for this at the moment, most 2.1 feature work is already done.\r\n\r\nThe middleware couldn\u0027t implement a back channel by itself. The front channel sign out removes the user\u0027s cookie. The back channel couldn\u0027t, it would have to track sessions and invalidate them so that next time the user presents the cookie it would be rejected. Identity has features like this but it requires plugging into the cookie auth handler to enforce them.",
        "createdAt": "2018-04-01T00:34:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4659#issuecomment-377733610"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3NzczNjkzNw==",
        "parentId": null,
        "author": "D3MaxT",
        "content": "Thank you for the response.",
        "createdAt": "2018-04-01T01:55:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4659#issuecomment-377736937"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3NzczNzM2Ng==",
        "parentId": null,
        "author": "brockallen",
        "content": "We have a super simple sample that shows mechanics here: https://github.com/IdentityServer/IdentityServer4.Samples/tree/release/Clients/src/MvcHybridBackChannel",
        "createdAt": "2018-04-01T02:05:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4659#issuecomment-377737366"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3NzczODMyNw==",
        "parentId": null,
        "author": "D3MaxT",
        "content": "Awesome!\r\nThank you Brock!",
        "createdAt": "2018-04-01T02:29:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4659#issuecomment-377738327"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3OTM5OTkzNg==",
        "parentId": null,
        "author": "Eilon",
        "content": "Parking in Backlog until we see sufficient interest in this. This would be a fairly costly feature for us to implement.",
        "createdAt": "2018-04-06T22:19:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4659#issuecomment-379399936"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyNzc2NjM5Mw==",
        "parentId": null,
        "author": "LindaLawton",
        "content": "@brockallen  this link is dead do you have an updated link?",
        "createdAt": "2019-09-04T06:45:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4659#issuecomment-527766393"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyNzc4MzUxNg==",
        "parentId": null,
        "author": "damienbod",
        "content": "@LindaLawton \r\n\r\nexample is here now\r\n\r\nhttps://github.com/IdentityServer/IdentityServer4/tree/master/samples/Clients/src/MvcHybridBackChannel\r\n",
        "createdAt": "2019-09-04T07:42:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4659#issuecomment-527783516"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgwODIwOTkxOA==",
        "parentId": null,
        "author": "daiplusplus",
        "content": "I feel this issue should be raised in priority and severity as recent - and still upcoming (as of Q1 2021) - changes to browser handling of third-party cookies will effectively break front-channel OIDC operations, e.g. https://leastprivilege.com/2020/03/31/spas-are-dead/ and https://auth0.com/blog/browser-behavior-changes-what-developers-need-to-know/ so there is a pressing need for built-in support for OIDC\u0027s back-channel - or at least to make it easier to implement (as well as documentation and guidance for how to handle OIDC back-channel in web-farm situations).\r\n\r\nThere are workarounds: Edge, Safari and Firefox both support [the Storage Access API](https://webkit.org/blog/11545/updates-to-the-storage-access-api/) which allow nested third-party iframes to access their own cookies - but only after user-interaction with the nested iframe (e.g. a \u0022click here to also log-out of RP website\u0022, so it isn\u0027t a graceful user-experience, but better than the user thinking they are logged-out of other websites) - curiously, Chrome doesn\u0027t support it. \r\n\r\n",
        "createdAt": "2021-03-26T13:21:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4659#issuecomment-808209918"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgwODMxNjk1Mg==",
        "parentId": null,
        "author": "brockallen",
        "content": "Coincidentally we made an announcement today about a new OSS library to address this scenario: https://blog.duendesoftware.com/posts/20210326_bff/",
        "createdAt": "2021-03-26T15:37:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4659#issuecomment-808316952"
      },
      {
        "id": "IC_kwDOAQzde85GPjeP",
        "parentId": null,
        "author": "jdaigle",
        "content": "Maybe the handler could simply handle and validate the backchannel logout request, but then raise an event to be implemented by the application in whatever way it needs?",
        "createdAt": "2022-07-08T02:50:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4659#issuecomment-1178482575"
      },
      {
        "id": "IC_kwDOAQzde85JpX1S",
        "parentId": null,
        "author": "raffaeler",
        "content": "I would really love to see this. The ability to forcibly logout a user is mandatory in many enterprise apps and a requirement in certain GDPR-related scenarios.\r\n\r\nBTW the current documentation is missing some details on what is exactly supported or not for the back-channel.\r\n",
        "createdAt": "2022-09-02T14:37:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4659#issuecomment-1235582290"
      },
      {
        "id": "IC_kwDOAQzde85QEHuU",
        "parentId": null,
        "author": "frederikprijck",
        "content": "With the spec having reached a final stage, are there any changes to what\u0027s been mentioned by @Eilon [before](https://github.com/dotnet/aspnetcore/issues/4659#issuecomment-379399936) regarding prioritisation?\r\n\r\nLooking at the issue here, I wouldn\u0027t say there\u0027s a significant increase in interest.\r\n\r\nHowever, with the spec having reached its final state, and IDP\u0027s starting to consider implementing this, it might be helpful to know if there are any short-term plans to have built-in support for back-channel logout in \u0060Microsoft.AspNetCore.Authentication.OpenIdConnect\u0060.",
        "createdAt": "2022-12-08T19:34:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4659#issuecomment-1343257492"
      },
      {
        "id": "IC_kwDOAQzde85Y08Au",
        "parentId": null,
        "author": "guillaume86",
        "content": "Any progress/timeline on this? ",
        "createdAt": "2023-03-30T13:06:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4659#issuecomment-1490272302"
      },
      {
        "id": "IC_kwDOAQzde85mLbee",
        "parentId": null,
        "author": "andi0b",
        "content": "\u003EParking in Backlog until we see sufficient interest in this. This would be a fairly costly feature for us to implement.\r\n\r\nIt surprising this is still missing. Backchannel log out is quite a basic OIDC feature, and it should not be a big effort implementing this.\r\n\r\nFront channel log out is already implemented, so all the required information is there. Instead of issuing a redirect to the IDP the same information just needs to be sent via a backchannel request. A method for backchannel communication is also already there for the token request. It just needs to be put together and tested.\r\n\r\nIt may even be possible to hack it into the \u0060options.Events.OnRemoteSignOut\u0060 callback in a few lines of code. Need to look into it once.",
        "createdAt": "2023-09-11T17:07:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4659#issuecomment-1714272158"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzODI1Mzg4Nzc=",
    "title": "Add a multitenant auth options sample",
    "url": "https://github.com/dotnet/aspnetcore/issues/4126",
    "createdAt": "2018-04-11T01:40:39Z",
    "lastUpdated": "2020-05-10T14:39:16Z",
    "body": "See https://github.com/aspnet/Security/issues/1718 for more context",
    "upvotes": 0,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM5MDA4Mzc1OQ==",
        "parentId": null,
        "author": "aagarwal10",
        "content": "hi @HaoK - I have scenario of multi-tenant auth, where I need to dynamically add OAuth2 Scheme based on tenant (each tenant has its own OAuth Options) and wire it with cookie scheme for my aspnet core web app (not implemented with any Javascript framework). Please suggest if this is possible with these auth samples. Thanks",
        "createdAt": "2018-05-18T03:29:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4126#issuecomment-390083759"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM5MDA5MTYzNg==",
        "parentId": null,
        "author": "HaoK",
        "content": "Try doing something like this sample https://github.com/aspnet/AuthSamples/pull/44",
        "createdAt": "2018-05-18T04:34:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4126#issuecomment-390091636"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM5MDg1MjMzNA==",
        "parentId": null,
        "author": "aagarwal10",
        "content": "@HaoK - Is it also possible to add Auth Handler dynamically, similar to adding/removing auth scheme from a controller?\r\n\r\nfor example in a controller action method, can we do something like?\r\n\r\n.AddScheme\u003CSimpleOptions, SimpleAuthHandler\u003E(\u0022fromAction\u0022, o =\u003E o.DisplayMessage = \u0022I am from controller action.\u0022) \r\n\r\nAlso, even if this possible, how can this whole dynamic auth handler registration via action method be done for application running in a web farm. \r\n\r\nActually I have a case where a tenant gets dynamically registered to the web application passing there OAuth Options on the fly. This is scenario of SMART on FHIR (HL7 Standard)",
        "createdAt": "2018-05-22T03:34:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4126#issuecomment-390852334"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM5MDg1NTMyNA==",
        "parentId": null,
        "author": "HaoK",
        "content": "Yes, you can just use the IAuthenticationSchemeProvider and call AddScheme, but you would probably have to have your implementation of this use some kind of shared data store backing the implementation to make them consistent across the web farm.",
        "createdAt": "2018-05-22T03:57:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4126#issuecomment-390855324"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM5MzcyMjIxNw==",
        "parentId": null,
        "author": "aagarwal10",
        "content": "@HaoK -- So I am trying to get PostConfigureOptions going my \u0022SimpleOptions\u0022 by registering like this;\r\n\r\n \u0060\u0060\u0060csharp\r\n  public void ConfigureServices(IServiceCollection services)\r\n        {\r\n             services.AddAuthentication();\r\n\r\n            services.AddSingleton\u003CIAuthenticationSchemeProvider, CustomAuthenticationSchemeProvider\u003E();\r\n            services.TryAddEnumerable(ServiceDescriptor.Singleton\u003CIPostConfigureOptions\u003CSimpleOptions\u003E, SimpleOptionsPostConfigureOptions\u003CSimpleOptions, SimpleAuthHandler\u003E());\r\n\r\n            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);\r\n        } \r\n\u0060\u0060\u0060\r\n\r\nBut the PostConfigure method in my SimpleOptionsPostConfigureOptions never hits ?\r\n\r\nhere is my SimpleOptionsPostConfigureOptions class, Please suggest whats missing;\r\n\r\n \u0060\u0060\u0060csharp\r\npublic class SimpleOptionsPostConfigureOptions\u003CSimpleOptions, SimpleAuthHandler\u003E : IPostConfigureOptions\u003CSimpleOptions\u003E\r\n        where SimpleOptions : AuthenticationSchemeOptions, new()\r\n        where SimpleAuthHandler : AuthenticationHandler\u003CSimpleOptions\u003E\r\n    {\r\n        public void PostConfigure(string name, SimpleOptions options)\r\n        {\r\n            throw new NotImplementedException();\r\n        }\r\n    }\r\n \u0060\u0060\u0060",
        "createdAt": "2018-06-01T00:21:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4126#issuecomment-393722217"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzMjczNDQyNg==",
        "parentId": null,
        "author": "muratg",
        "content": "@HaoK will this be in 2.2, or should we move this out?",
        "createdAt": "2018-10-24T16:41:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4126#issuecomment-432734426"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzMjc0ODg4MA==",
        "parentId": null,
        "author": "HaoK",
        "content": "You can move it out, there\u0027s some weird build flakiness that this sample introduces, I will merge it into master once its consistently passing on CI",
        "createdAt": "2018-10-24T17:17:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4126#issuecomment-432748880"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNjMxOTM1Mg==",
        "parentId": null,
        "author": "dasiths",
        "content": "Assuming we have some sort of middleware that sets the \u0060HttpContext.RequestServices\u0060 for the tenant, If we now resolve the \u0060IAuthenticationSchemeProvider\u0060 we get the correct options for the tenant. But the [\u0060AuthenticationMiddleware\u0060](https://github.com/dotnet/aspnetcore/blob/master/src/Security/Authentication/Core/src/AuthenticationMiddleware.cs) has this injected at construction as a singleton as you know.\r\n\r\n**Do you see any problems doing this custom AuthenticationMiddleware that has \u0060IAuthenticationSchemeProvider\u0060  injected per request? (In the Invoke() method)** Why is it a Singleton to begin with?\r\n\r\nNow we can easily have a \u0022container\u0022 per tenant with Authentication schemes/options defined there.\r\n\r\nExample from: \r\n1. https://michael-mckenna.com/multi-tenant-asp-dot-net-core-application-tenant-containers\r\n2. https://michael-mckenna.com/multi-tenant-asp-dot-net-core-application-tenant-specific-authentication\r\n\r\n\u0060\u0060\u0060\r\n/// \u003Csummary\u003E\r\n/// AuthenticationMiddleware.cs from framework with injection point moved\r\n/// \u003C/summary\u003E\r\npublic class TenantAuthMiddleware\r\n{\r\n    private readonly RequestDelegate _next;\r\n\r\n    public TenantAuthMiddleware(RequestDelegate next)\r\n    {\r\n        _next = next ?? throw new ArgumentNullException(nameof(next));\r\n    }\r\n    \r\n    public async Task Invoke(HttpContext context, IAuthenticationSchemeProvider Schemes)\r\n    {\r\n        context.Features.Set\u003CIAuthenticationFeature\u003E(new AuthenticationFeature\r\n        {\r\n            OriginalPath = context.Request.Path,\r\n            OriginalPathBase = context.Request.PathBase\r\n        });\r\n\r\n        // Give any IAuthenticationRequestHandler schemes a chance to handle the request\r\n        var handlers = context.RequestServices.GetRequiredService\u003CIAuthenticationHandlerProvider\u003E();\r\n        foreach (var scheme in await Schemes.GetRequestHandlerSchemesAsync())\r\n        {\r\n            var handler = await handlers.GetHandlerAsync(context, scheme.Name) \r\n                as IAuthenticationRequestHandler;\r\n            if (handler != null \u0026\u0026 await handler.HandleRequestAsync())\r\n            {\r\n                return;\r\n            }\r\n        }\r\n\r\n        var defaultAuthenticate = await Schemes.GetDefaultAuthenticateSchemeAsync();\r\n        if (defaultAuthenticate != null)\r\n        {\r\n            var result = await context.AuthenticateAsync(defaultAuthenticate.Name);\r\n            if (result?.Principal != null)\r\n            {\r\n                context.User = result.Principal;\r\n            }\r\n        }\r\n        \r\n        await _next(context);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n",
        "createdAt": "2020-05-10T12:17:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4126#issuecomment-626319352"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTA0NjY4NzQ=",
    "title": "Q: Is WebAuthn planned to be implemented by aspnet.security?",
    "url": "https://github.com/dotnet/aspnetcore/issues/4657",
    "createdAt": "2018-04-11T08:34:37Z",
    "lastUpdated": "2024-11-01T17:33:02Z",
    "body": "Hello,\r\n\r\nThe API should be available in Chrome and Firefox May release.\r\nStarting to look at it and be ready for it could be a good idea?\r\n\r\n[webauthn specs](https://www.w3.org/TR/webauthn/)",
    "upvotes": 4,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4MDQ4NzMyNQ==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "FIDO2/WebAuthn is definitely the future and I\u0027d personally love to see it adopted everywhere.\r\n\r\nThat said, it essentially dictates how things happen client-side, not server-side. The specification doesn\u0027t say how you\u0027re supposed to retrieve the challenge from the server or how you send the public key when creating an account or adding a new key to an existing account: all this stuff is necessarily implementation-specific (which gives you total flexibility).\r\n\r\nAs such, I\u0027m not sure aspnet/Security will ever have anything related to FIDO, just like there\u0027s nothing for \u0022password authentication\u0022 in this repo (on the other hand, membership frameworks like ASP.NET Core Identity will have to offer ways to store the public keys in the DB).",
        "createdAt": "2018-04-11T15:09:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4657#issuecomment-380487325"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4MDUxODI2NQ==",
        "parentId": null,
        "author": "Guymestef",
        "content": "About validating the client/user signature, I thought it would be considered as an external authentication provider.\r\nBut you are probably right about adding this as a whole feature into Identity.",
        "createdAt": "2018-04-11T16:41:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4657#issuecomment-380518265"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4MDUyMzI2MA==",
        "parentId": null,
        "author": "Eilon",
        "content": "Should we close the issue here then? A new Identity issue was just logged at https://github.com/aspnet/Identity/issues/1747.",
        "createdAt": "2018-04-11T16:57:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4657#issuecomment-380523260"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4MDUzMzEzMQ==",
        "parentId": null,
        "author": "blowdart",
        "content": "I think it belongs in both, because it\u0027s not just an identity issue.",
        "createdAt": "2018-04-11T17:30:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4657#issuecomment-380533131"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ3MTE4NzQ5Ng==",
        "parentId": null,
        "author": "tstojecki",
        "content": "I agree with @blowdart. Aspnet Identity could store and retrieve credentials but it seems that something like an authorization handler (or maybe a middleware?) to handle the challenge, registration and authentication requests, etc... would be helpful.\r\nThe login pages in aspnet templates would also have to be updated to accommodate this option for registering/logging-in. This might be what @Guymestef was referring to in the comment about external providers.\r\n\r\nAdding a link to the diagram and the code references below as it might be helpful for this discussion\r\nhttps://developers.yubico.com/FIDO2/Libraries/Using_a_library.html",
        "createdAt": "2019-03-09T15:07:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4657#issuecomment-471187496"
      },
      {
        "id": "IC_kwDOAQzde85NEP_1",
        "parentId": null,
        "author": "wsy",
        "content": "It has been many years since this issue has been created.\nFIDO2 is now being trending.\n- iOS 16 and iPadOS 16 is supporting FIDO2. (https://www.apple.com/ios/ios-16/features/ , \u0022Passkeys\u0022 section)\n- Android has been FIDO2 certified since 2019. (https://fidoalliance.org/android-now-fido2-certified-accelerating-global-migration-beyond-passwords/ )\n- GitHub already supports FIDO2 passkey login. (https://github.com/settings/two_factor_authentication/configure )\n- Microsoft Account also supports FIDO2 passkey. (https://support.microsoft.com/en-us/windows/sign-in-to-your-microsoft-account-with-windows-hello-or-a-security-key-800a8c01-6b61-49f5-0660-c2159bea4d84 )\n\nSo, I think it\u0027s time to move this issue out of Backlog and start to plan something about it.",
        "createdAt": "2022-10-27T04:30:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4657#issuecomment-1292959733"
      },
      {
        "id": "IC_kwDOAQzde85m6hda",
        "parentId": null,
        "author": "Bartmax",
        "content": "What\u0027s the status on this?",
        "createdAt": "2023-09-19T22:19:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4657#issuecomment-1726617434"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTA0NjY4MjY=",
    "title": "[ASPNET Core 2.0]Authorization Policy ignoring Authentication",
    "url": "https://github.com/dotnet/aspnetcore/issues/4656",
    "createdAt": "2018-04-11T17:49:52Z",
    "lastUpdated": "2021-08-26T07:32:59Z",
    "body": "_From @allevyMS on April 11, 2018 17:10_\n\nI am trying to set up authentication and authorization but I am seeing unexpected behavior.\r\nI am running an ASPNET Core 2.0 app on windows (tried this on windows 10 and in a docker container  with the following image 2.0.6-sdk-2.1.104-nanoserver-sac2016) and I have my authentication and authorization set up like this:\r\nusing Nuget package: Microsoft.AspNetCore.All 2.0.0 and also tried with 2.0.6\r\n\r\n        public void ConfigureServices(IServiceCollection services)\r\n        {\r\n            services.AddAuthorization(options =\u003E\r\n            {\r\n                options.AddPolicy(\u0022Test\u0022, policy =\u003E\r\n                {\r\n                    policy.Requirements.Add(new TestRequirement());\r\n                });\r\n            });\r\n\r\n            services.AddSingleton\u003CIAuthorizationHandler, TestAuthorizationHandler\u003E();\r\n\r\n            services.AddMvc();\r\n\r\n            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\r\n                .AddJwtBearer();\r\n\r\n            services.AddSingleton\u003CIConfigureOptions\u003CJwtBearerOptions\u003E\u003E(sp =\u003E\r\n            {\r\n                return new ConfigureNamedOptions\u003CJwtBearerOptions\u003E(\r\n                    JwtBearerDefaults.AuthenticationScheme,\r\n                    options =\u003E\r\n                    {\r\n                        options.TokenValidationParameters = new TokenValidationParameters\r\n                        {\r\n                            RequireSignedTokens = true,\r\n                            ValidateIssuer = false,\r\n                            ValidateAudience = false,\r\n                            ValidateLifetime = true,\r\n                            IssuerSigningKey = rsaSecurityKey\r\n                        };\r\n                    });\r\n            });\r\n        }\r\n\r\n        public void Configure(IServiceProvider sp, IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)\r\n        {\r\n            loggerFactory.AddConsole(Configuration.GetSection(\u0022Logging\u0022));\r\n\r\n            app.UseAuthentication();\r\n\r\n            app.UseMvc();\r\n        }\r\n\r\nMy requirement is empty and this is my authorization handler:\r\n\r\n    public class TestAuthorizationHandler : AuthorizationHandler\u003CTestRequirement\u003E\r\n    {\r\n        protected override Task HandleRequirementAsync(AuthorizationHandlerContext context,\r\n                                                       TestRequirement requirement)\r\n        {\r\n            context.Succeed(requirement);\r\n            return Task.CompletedTask;\r\n        }\r\n    }\r\n\r\nMy Controller get method:\r\n\r\n        [Authorize(Policy = \u0022Test\u0022)]\r\n        [HttpGet]\r\n        [Route(\u0022Data\u0022)]\r\n        public async Task\u003Cstring\u003E GetDataAsync()\r\n        {\r\n            return await Task.FromResult(\u0022data\u0022);\r\n        }\r\n\r\nThe unexpected behavior:\r\n\r\nAuthentication is always ignored for that controller method, my authorization handler and controller are always reached, even if I don\u0027t supply an Authentication header or supply an invalid token.\r\n\r\nExpected behavior:\r\n\r\nAuthorization should use the supplied default scheme in AddAuthentication to challenge the Authentication and not allow these calls through unless Authentication was successful.\r\n\r\nWorkaround:\r\n\r\nAdd the default scheme directly to the policy and require the user to be authenticated\r\n\r\npolicy.AuthenticationSchemes.Add(JwtBearerDefaults.AuthenticationScheme);\r\npolicy.RequireAuthenticatedUser();\r\n\r\nWhen these are added I see the behavior I expect.\r\n\r\nAm I misunderstanding the expected flow? Is this the expected behavior and RequireAuthenticatedUser is needed explicitly to block unauthenticated requests to go through authorization?\r\n\r\n\r\n\r\n\r\n\n\n_Copied from original issue: aspnet/Home#3046_",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "affected-few",
      "severity-minor"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4MDU0MTMxMQ==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E Am I misunderstanding the expected flow? Is this the expected behavior and RequireAuthenticatedUser is needed explicitly to block unauthenticated requests to go through authorization?\r\n\r\nWhile not super convenient, it\u0027s the expected behavior (and it\u0027s a quite frequent question: https://stackoverflow.com/questions/49545706/adding-a-policy-based-authorization-skips-jwt-bearer-token-authentication-check/49545923#49545923).\r\n\r\nIn a better world (and IMHO), \u0060DenyAnonymousAuthorizationRequirement\u0060 should always be added by default and \u0060RequireAuthenticatedUser()\u0060 should be replaced by \u0060AllowAnonymousUser()\u0060. But hem... it\u0027s probably a breaking change :sweat_smile: ",
        "createdAt": "2018-04-11T17:56:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-380541311"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4MDYwNzM4MQ==",
        "parentId": null,
        "author": "blowdart",
        "content": "Oh heck, I moved it and never replied. As @PinpointTownes says it\u0027s expected, and yes it\u0027d be a big breaking change, like major version number breaking change.",
        "createdAt": "2018-04-11T21:51:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-380607381"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4MTEzMjA2MQ==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "@blowdart do you mind re-opening this thread and putting it in the \u00603.0.0\u0060 milestone so it has a chance to be discussed for the next major version?",
        "createdAt": "2018-04-13T13:17:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-381132061"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4MTE1MzA3NQ==",
        "parentId": null,
        "author": "blowdart",
        "content": "I can, but as it\u0027s turning things on its head, it\u0027s going to be a hard sell :)",
        "createdAt": "2018-04-13T14:28:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-381153075"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ0Njk0NzM5MA==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "So, who can I bribe to make that happen? @DamianEdwards maybe? :trollface:\r\n\r\nThe fact \u0060DenyAnonymousAuthorizationRequirement\u0060 is not automatically added to new authorization policies (you have to explicitly call \u0060RequireAuthenticatedUser()\u0060) is a serious trap for too many people.\r\n\r\n@DamianEdwards would you be opposed to changing that to make the default behavior more secure in 3.0?",
        "createdAt": "2018-12-13T12:12:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-446947390"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ1OTczNjExNg==",
        "parentId": null,
        "author": "DamascenoRafael",
        "content": "Does anyone know if the workaround no longer works on .NET Core 2.2.0?\r\nI configured the policy as follows:\r\n\u0060\u0060\u0060c#\r\n        public void ConfigureServices(IServiceCollection services)\r\n        {\r\n            // ...\r\n            JWTExtension.AddJwtAuthentication(services, Configuration);\r\n            // ...\r\n            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);\r\n            // ...\r\n            {\r\n                options.AddPolicy(\u0022AdminRole\u0022, policy =\u003E\r\n                {\r\n                    policy.AuthenticationSchemes.Add(CookieAuthenticationDefaults.AuthenticationScheme);\r\n                    policy.RequireAuthenticatedUser();\r\n                    policy.Requirements.Add(new UserRoleRequirement(ProfileEnum.Admin));\r\n                });\r\n            });\r\n            // ...\r\n        }\r\n\u0060\u0060\u0060\r\nBut the policy is always called before checking the existence and validity of JWT. In my case the token is validated through the Cookie so I put the corresponding schema.\r\n\r\nMy \u0060Configure(IApplicationBuilder app, IHostingEnvironment env)\u0060 is as follows:\r\n\r\n\u003Cdetails\u003E\r\n\r\n\u0060\u0060\u0060c#\r\n        public void Configure(IApplicationBuilder app, IHostingEnvironment env)\r\n        {\r\n            RewriteOptions options = new RewriteOptions().AddRewrite(@\u0022^(?!(swagger|token|api|.\u002B[.])).*\u0022, \u0022/\u0022, skipRemainingRules: true);\r\n\r\n            app.UseRewriter(options);\r\n            \r\n            if (env.IsDevelopment())\r\n            {\r\n                app.UseDeveloperExceptionPage();\r\n            }\r\n            else\r\n            {\r\n                app.UseHsts();\r\n            }\r\n\r\n            string[] allowedAppUrls = Configuration[\u0022AllowedAppUrls\u0022].Split(\u0027,\u0027); \r\n            app.UseCorsAllow(allowedAppUrls);\r\n            app.UseMiddleware(typeof(ExceptionHandlerMiddleware));\r\n            app.UseAuthentication();\r\n            app.UseMiddleware(typeof(TokenExpirationMiddleware));\r\n            app.UseMvc(routes =\u003E\r\n            {\r\n                routes.MapRoute\r\n                (\r\n                    name: \u0022default\u0022,\r\n                    template: \u0022api/{controller=Home}/{action=Index}/{id?}\u0022 \r\n                );\r\n            });\r\n            app.UseDefaultFiles();\r\n            app.UseStaticFiles();\r\n\r\n            app.ConfigSwagger();\r\n\r\n            app.UseHttpsRedirection();\r\n        }\r\n\u0060\u0060\u0060\r\n\r\n\u003C/details\u003E",
        "createdAt": "2019-02-01T14:16:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-459736116"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ2MjQ2MzczOQ==",
        "parentId": null,
        "author": "MichaelHudgins",
        "content": "I too would like to know if this workaround is still supported.  I am having the same effect where my authorization policy is checked even when there is an invalid jwt.  I am working around by checking the user again in the authorization policy, but it would be better if the authorization policy was never called given the failure of the authentication. ",
        "createdAt": "2019-02-11T19:35:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-462463739"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ4MDE4OTY1Mg==",
        "parentId": null,
        "author": "dominicusmento",
        "content": "\u003E Does anyone know if the workaround no longer works on .NET Core 2.2.0?\r\n\u003E I configured the policy as follows:\r\n\u003E \r\n\u003E \u0060\u0060\u0060cs\r\n\u003E         public void ConfigureServices(IServiceCollection services)\r\n\u003E         {\r\n\u003E             // ...\r\n\u003E             JWTExtension.AddJwtAuthentication(services, Configuration);\r\n\u003E             // ...\r\n\u003E             services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);\r\n\u003E             // ...\r\n\u003E             {\r\n\u003E                 options.AddPolicy(\u0022AdminRole\u0022, policy =\u003E\r\n\u003E                 {\r\n\u003E                     policy.AuthenticationSchemes.Add(CookieAuthenticationDefaults.AuthenticationScheme);\r\n\u003E                     policy.RequireAuthenticatedUser();\r\n\u003E                     policy.Requirements.Add(new UserRoleRequirement(ProfileEnum.Admin));\r\n\u003E                 });\r\n\u003E             });\r\n\u003E             // ...\r\n\u003E         }\r\n\u003E \u0060\u0060\u0060\r\n\u003E \r\n\u003E But the policy is always called before checking the existence and validity of JWT. In my case the token is validated through the Cookie so I put the corresponding schema.\r\n\u003E \r\n\u003E My \u0060Configure(IApplicationBuilder app, IHostingEnvironment env)\u0060 is as follows:\r\n\r\nI\u0027ve had a same problem. My workaround was that I put controller under default [Authorize] attribute and then every action has it\u0027s own policy [Authorize(Policy = \u0022FullAccess\u0022)]. To me it wasn\u0027t such a big deal because I had only one controller which action\u0027s was under the same policy. RequireAuthenticatedUser and similar wasn\u0027t necessary.\r\n",
        "createdAt": "2019-04-05T08:18:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-480189652"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ4MDM3Mjk0MQ==",
        "parentId": null,
        "author": "HaoK",
        "content": "Can you guys share a simple repro app so we can take a closer look at the behavior changes you are seeing?\r\n\r\nIn regards to \u0022I am having the same effect where my authorization policy is checked even when there is an invalid jwt.\u0022.  This is by design, all of the authorization logic is run always, the presence or lack of the \u0060.RequireAuthenticatedUser()\u0060 requirement doesn\u0027t short circuit the rest of the authorization checks.  So if you want to hard block that, you do need to have logic inside of your handlers to no-op if there\u0027s no user",
        "createdAt": "2019-04-05T18:13:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-480372941"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMzM1NTYzMw==",
        "parentId": null,
        "author": "allevyMS",
        "content": "@HaoK I am experiencing the same regression mentioned above\r\n\r\n.RequireAuthenticatedUser() used to in fact short circuit the flow and block the authorization if the user was not authentication, now it no longer seems to do that.\r\n\r\nWhat is the function of \u0027RequireAuthenticatedUser()\u0027 if it doesn\u0027t enforce authentication?\r\n\r\n",
        "createdAt": "2019-06-19T00:04:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-503355633"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMzM2MzgyMA==",
        "parentId": null,
        "author": "allevyMS",
        "content": "This is a clear behavior change between the versions, you can use my sample app in the start of this thread as a repro",
        "createdAt": "2019-06-19T00:51:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-503363820"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMzM3OTU2Nw==",
        "parentId": null,
        "author": "HaoK",
        "content": "The likely behavior change you are seeing if its between 2.0 and 2.1/2.2/3.0 is most likely due to mvcOptions.AllowCombiningAuthorizeFilters, make sure that is false",
        "createdAt": "2019-06-19T02:20:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-503379567"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMzY2Mzk5OQ==",
        "parentId": null,
        "author": "allevyMS",
        "content": "I don\u0027t set that property and the documentation states that it is set to false by default",
        "createdAt": "2019-06-19T17:52:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-503663999"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMzY2NjMyOQ==",
        "parentId": null,
        "author": "allevyMS",
        "content": "To clarify, I am using version 2.2",
        "createdAt": "2019-06-19T17:58:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-503666329"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMzY3NDUwMg==",
        "parentId": null,
        "author": "HaoK",
        "content": "Can you upload your project to a github repo in a minimal state that reproduces what you are seeing?",
        "createdAt": "2019-06-19T18:21:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-503674502"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMzc4NTgyNg==",
        "parentId": null,
        "author": "allevyMS",
        "content": "Thanks @HaoK I created a minimal repro with a noop handler and requirement\r\n\r\nSo after trying it out end to end, I can confirm that \u0027RequireAuthenticatedUser()\u0027 is still respected correctly.\r\nThe only difference is that in 2.2 the handlers are called regardless of the authentication status.\r\nIn earlier versions (2.0) the handlers weren\u0027t called at all if the authentication failed.\r\nIn both cases the calls result in a 401 return status when the authentication fails.\r\n\r\nHere is the setup for my repro for posterity: \r\n\r\nStartup:\r\n\r\n    public class Startup\r\n    {\r\n        public Startup(IConfiguration configuration)\r\n        {\r\n            Configuration = configuration;\r\n        }\r\n\r\n        public IConfiguration Configuration { get; }\r\n\r\n        // This method gets called by the runtime. Use this method to add services to the container.\r\n        public void ConfigureServices(IServiceCollection services)\r\n        {\r\n            services.AddSingleton\u003CIAuthorizationHandler, TestAuthorizationHandler\u003E();\r\n\r\n            services.AddMvc();\r\n\r\n            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\r\n                .AddJwtBearer();\r\n\r\n            services.AddSingleton\u003CIConfigureOptions\u003CJwtBearerOptions\u003E\u003E(sp =\u003E\r\n            {\r\n                return new ConfigureNamedOptions\u003CJwtBearerOptions\u003E(\r\n                    JwtBearerDefaults.AuthenticationScheme,\r\n                    options =\u003E\r\n                    {\r\n                        options.TokenValidationParameters = new TokenValidationParameters\r\n                        {\r\n                            RequireSignedTokens = false,\r\n                            ValidateIssuer = false,\r\n                            ValidateAudience = false,\r\n                            ValidateLifetime = true,\r\n                        };\r\n                    });\r\n            });\r\n\r\n            services.AddAuthorization(options =\u003E\r\n            {\r\n                options.AddPolicy(\u0022Test\u0022, policy =\u003E\r\n                {\r\n                    policy.AuthenticationSchemes.Add(JwtBearerDefaults.AuthenticationScheme);\r\n                    policy.RequireAuthenticatedUser();\r\n                    policy.Requirements.Add(new TestRequirement());\r\n                });\r\n            });\r\n\r\n            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Latest);\r\n        }\r\n\r\n        public void Configure(IApplicationBuilder app, IHostingEnvironment env)\r\n        {\r\n            app.UseAuthentication();\r\n            app.UseMvc();\r\n        }\r\n    }\r\n\r\nMain:\r\n\r\n    public class Program\r\n    {\r\n        public static void Main(string[] args)\r\n        {\r\n            CreateWebHostBuilder(args).Build().Run();\r\n        }\r\n\r\n        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =\u003E\r\n            WebHost.CreateDefaultBuilder(args)\r\n                .UseStartup\u003CStartup\u003E();\r\n    }\r\n\r\nAuthZ Handler:\r\n\r\n    public class TestRequirement : IAuthorizationRequirement\r\n    {\r\n    }\r\n\r\n    public class TestAuthorizationHandler : AuthorizationHandler\u003CTestRequirement\u003E\r\n    {\r\n        protected override Task HandleRequirementAsync(AuthorizationHandlerContext context,\r\n                                                       TestRequirement requirement)\r\n        {\r\n            context.Succeed(requirement);\r\n            return Task.CompletedTask;\r\n        }\r\n    }\r\n\r\nController:\r\n\r\n    [ApiController]\r\n    public class TestController : ControllerBase\r\n    {\r\n        [Authorize(Policy = \u0022Test\u0022)]\r\n        [HttpGet]\r\n        [Route(\u0022data\u0022)]\r\n        public string Get()\r\n        {\r\n            return \u0022test\u0022;\r\n        }\r\n    }",
        "createdAt": "2019-06-19T23:43:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-503785826"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMzc4NjkzMQ==",
        "parentId": null,
        "author": "allevyMS",
        "content": "To be explicit:\r\n\r\nmaking a call with an invalid/missing token when specifying policy.RequireAuthenticatedUser(); will trigger the TestAuthorizationHandler.HandleRequirementAsync method  but  the request will still result in a 401 http status\r\n\r\nwithout the policy.RequireAuthenticatedUser(); it will go on to the controller",
        "createdAt": "2019-06-19T23:49:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-503786931"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyMzE0OTk0MQ==",
        "parentId": null,
        "author": "jrovny",
        "content": "Any update on this? Was this resolved in version 3.0?\r\n\r\nThanks,",
        "createdAt": "2019-08-20T18:56:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-523149941"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyMzE1MjYyNA==",
        "parentId": null,
        "author": "HaoK",
        "content": "There are intentional behavior changes between 2.0/2.1 and 3.0, the best thing to do is to try your app on 2.2 and 3.0 and see if it behaves in a way you expect, if not we can try and explain any behavior differences you see",
        "createdAt": "2019-08-20T19:04:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-523152624"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU5MjMzOTc3Ng==",
        "parentId": null,
        "author": "mingazhev",
        "content": "I can confirm  @allevyMS \u0027s answer, this flow works this way in .NET Core 3.1 too and this is not so obvious behavior.\r\n\r\nI\u0027ve expected that short circuiting (not walking till authorization policies with not authenticated user) could be done easily but it I couldn\u0027t find a perfect way.\r\nSo workaround for me was registering custom PolicyEvaluator wrapper to forbid requests manually:\r\n\r\n**Startup.cs**\r\n\u0060services.AddTransient\u003CIPolicyEvaluator, ForbidUnauthenticatedPolicyEvaluator\u003E();\r\n            services.AddTransient\u003CPolicyEvaluator\u003E();\u0060\r\n\r\n**ForbidUnauthenticatedPolicyEvaluator.cs**\r\n\r\n\u0060\u0060\u0060\r\npublic class ForbidUnauthenticatedPolicyEvaluator : IPolicyEvaluator\r\n    {\r\n        public ForbidUnauthenticatedPolicyEvaluator(PolicyEvaluator defaultEvaluator)\r\n        {\r\n            _defaultEvaluator = defaultEvaluator;\r\n        }\r\n\r\n\r\n        public Task\u003CAuthenticateResult\u003E AuthenticateAsync(AuthorizationPolicy policy, HttpContext context)\r\n            =\u003E _defaultEvaluator.AuthenticateAsync(policy, context);\r\n\r\n\r\n        public Task\u003CPolicyAuthorizationResult\u003E AuthorizeAsync(AuthorizationPolicy policy, AuthenticateResult authenticationResult, HttpContext context,\r\n            object resource)\r\n        {\r\n            if (!authenticationResult.Succeeded)\r\n                return Task.FromResult(PolicyAuthorizationResult.Forbid());\r\n\r\n            return _defaultEvaluator.AuthorizeAsync(policy, authenticationResult, context, resource);\r\n        }\r\n\r\n\r\n        private readonly PolicyEvaluator _defaultEvaluator;\r\n    }\r\n\u0060\u0060\u0060",
        "createdAt": "2020-02-28T06:39:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-592339776"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwNTAxMjAxNA==",
        "parentId": null,
        "author": "rosdi",
        "content": "Got bitten by this as well, I have a code like this:\r\n\r\n\u0060\u0060\u0060\r\nservices.AddAuthorization(options =\u003E\r\n  {\r\n     options.DefaultPolicy = new AuthorizationPolicyBuilder()\r\n        .RequireAuthenticatedUser()\r\n        .AddRequirements(new MustBeSuperAdminRequirement())\r\n        .Build();\r\n  })\r\n\u0060\u0060\u0060\r\n\r\nOne would be forgiven to think that \u0060MustBeSuperAdminRequirement\u0060 won\u0027t be called if user has not logged in... **but it is not so**!... it went straight in and I spent a few hours scratching my head...\r\n\r\nAs a workaround I did this in my requirement handler:\r\n\r\n\u0060\u0060\u0060\r\nprotected override async Task HandleRequirementAsync(\r\n            AuthorizationHandlerContext context,\r\n            MustBeSuperAdminRequirement requirement)\r\n{\r\n    var principal = context.User;\r\n    if (!principal.IsAuthenticated())\r\n    {\r\n        return;  //user not logged in\r\n    }\r\n\r\n   //the rest of the codes\r\n}\r\n\u0060\u0060\u0060\r\n\r\n.. and here...\r\n\u0060\u0060\u0060\r\napp.UseEndpoints(endpoints =\u003E \r\n{\r\n    endpoints.MapControllers().RequireAuthorization();\r\n});\r\n\u0060\u0060\u0060\r\n**UPDATE**\r\n\r\nI am **not** observing different behaviour between these two codes:\r\n\r\n\u0060\u0060\u0060\r\n//code 1\r\nservices.AddAuthorization(options =\u003E\r\n  {\r\n     options.DefaultPolicy = new AuthorizationPolicyBuilder()\r\n        .RequireAuthenticatedUser()\r\n        .AddRequirements(new MustBeSuperAdminRequirement())\r\n        .Build();\r\n  })\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060\r\n//code 2\r\nservices.AddAuthorization(options =\u003E\r\n  {\r\n     options.DefaultPolicy = new AuthorizationPolicyBuilder()\r\n        //.RequireAuthenticatedUser()  //\u003C-- this is intentionally removed\r\n        .AddRequirements(new MustBeSuperAdminRequirement())\r\n        .Build();\r\n  })\r\n\u0060\u0060\u0060\r\n\r\nBoth returning \u0060401\u0060, now I am more puzzled in what scenario would I need \u0060RequireAuthenticatedUser()\u0060 ?\r\n\r\nShouldn\u0027t we consider this a bug? I am on .NET Core 3.1 btw.\r\n",
        "createdAt": "2020-03-27T13:51:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-605012014"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY5NDkzOTY0MA==",
        "parentId": null,
        "author": "IngoVals",
        "content": "Just had this issue. Now we must write every Handler with the assumption that the user maybe isn\u0027t authenticated. So each handler is also a \u0060DenyAnonymousAuthorizationRequirement\u0060 handler in theory. This is counter intuitive, and strange considering that a failed authentication gives us a 401, but authorization a 403, so it seems asp.net core is at least ensuring that authentication prevails anyways.",
        "createdAt": "2020-09-18T15:38:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-694939640"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY5NTc3NzgzMw==",
        "parentId": null,
        "author": "mingazhev",
        "content": "\u003E \r\n\u003E \r\n\u003E Just had this issue. Now we must write every Handler with the assumption that the user maybe isn\u0027t authenticated. So each handler is also a \u0060DenyAnonymousAuthorizationRequirement\u0060 handler in theory. This is counter intuitive, and strange considering that a failed authentication gives us a 401, but authorization a 403, so it seems asp.net core is at least ensuring that authentication prevails anyways.\r\n\r\nJust to update a workaround I\u0027ve written before:\r\nNow we return \u0060PolicyAuthorizationResult.Challenge()\u0060 instead of \u0060PolicyAuthorizationResult.Forbid()\u0060 and that returns 401 as expected for unauthenticated users.",
        "createdAt": "2020-09-20T11:46:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-695777833"
      },
      {
        "id": "IC_kwDOAQzde842AwJQ",
        "parentId": null,
        "author": "sushilb21",
        "content": "\u003E Got bitten by this as well, I have a code like this:\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E services.AddAuthorization(options =\u003E\r\n\u003E   {\r\n\u003E      options.DefaultPolicy = new AuthorizationPolicyBuilder()\r\n\u003E         .RequireAuthenticatedUser()\r\n\u003E         .AddRequirements(new MustBeSuperAdminRequirement())\r\n\u003E         .Build();\r\n\u003E   })\r\n\u003E \u0060\u0060\u0060\r\n\u003E \r\n\u003E One would be forgiven to think that \u0060MustBeSuperAdminRequirement\u0060 won\u0027t be called if user has not logged in... **but it is not so**!... it went straight in and I spent a few hours scratching my head...\r\n\u003E \r\n\u003E As a workaround I did this in my requirement handler:\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E protected override async Task HandleRequirementAsync(\r\n\u003E             AuthorizationHandlerContext context,\r\n\u003E             MustBeSuperAdminRequirement requirement)\r\n\u003E {\r\n\u003E     var principal = context.User;\r\n\u003E     if (!principal.IsAuthenticated())\r\n\u003E     {\r\n\u003E         return;  //user not logged in\r\n\u003E     }\r\n\u003E \r\n\u003E    //the rest of the codes\r\n\u003E }\r\n\u003E \u0060\u0060\u0060\r\n\u003E \r\n\u003E .. and here...\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E app.UseEndpoints(endpoints =\u003E \r\n\u003E {\r\n\u003E     endpoints.MapControllers().RequireAuthorization();\r\n\u003E });\r\n\u003E \u0060\u0060\u0060\r\n\u003E \r\n\u003E **UPDATE**\r\n\u003E \r\n\u003E I am **not** observing different behaviour between these two codes:\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E //code 1\r\n\u003E services.AddAuthorization(options =\u003E\r\n\u003E   {\r\n\u003E      options.DefaultPolicy = new AuthorizationPolicyBuilder()\r\n\u003E         .RequireAuthenticatedUser()\r\n\u003E         .AddRequirements(new MustBeSuperAdminRequirement())\r\n\u003E         .Build();\r\n\u003E   })\r\n\u003E \u0060\u0060\u0060\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E //code 2\r\n\u003E services.AddAuthorization(options =\u003E\r\n\u003E   {\r\n\u003E      options.DefaultPolicy = new AuthorizationPolicyBuilder()\r\n\u003E         //.RequireAuthenticatedUser()  //\u003C-- this is intentionally removed\r\n\u003E         .AddRequirements(new MustBeSuperAdminRequirement())\r\n\u003E         .Build();\r\n\u003E   })\r\n\u003E \u0060\u0060\u0060\r\n\u003E \r\n\u003E Both returning \u0060401\u0060, now I am more puzzled in what scenario would I need \u0060RequireAuthenticatedUser()\u0060 ?\r\n\u003E \r\n\u003E Shouldn\u0027t we consider this a bug? I am on .NET Core 3.1 btw.\r\n\r\nIndeed it is a bug. RequireAuthenticatedUser() does not work at all. I am also using .net core 3.1\r\n\r\nYour workaround worked for me, thanks! I just made the slight changes as below:\r\n\r\n\u0060 var principal = context.User;\r\n            if (!principal.Identity.IsAuthenticated)\r\n            {\r\n                return Task.FromResult(0);  //user not logged in\r\n            }\u0060",
        "createdAt": "2021-08-26T07:32:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-906166864"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTE4NDAzMzU=",
    "title": "Refreshing auth tokens for SignalR",
    "url": "https://github.com/dotnet/aspnetcore/issues/5297",
    "createdAt": "2018-04-26T20:10:16Z",
    "lastUpdated": "2025-01-21T19:00:48Z",
    "body": "Below is one option we\u0027ve considered, but I\u0027m re-framing this issue to build *some* story for refreshing auth tokens.\r\n\r\nTo improve the ability to \u0022refresh\u0022 expired tokens, we should consider caching the access token provided by the factory. Then, when an HTTP request gets a \u0060401\u0060, we call the factory again before re-issuing the request. That way the user can configure a process to \u0022refresh\u0022 the token without forcing the connection to be reestablished\r\n\r\n* For the WebSockets transport, this has no effect. There is only ever a single request. This logic would **not** cover reconnecting in the event of something like #1159 (where the WebSocket is terminated when the token expires)\r\n* For the SSE transport, this only affects \u0060POST\u0060 (send) requests. We would call the token factory again and re-issue the send. The unsent data would stay buffered in the pipe\r\n* For Long Polling, this affects \u0060POST\u0060 requests like SSE, and the \u0060GET\u0060 (poll) requests. The client would assume that a \u0060401\u0060 error indicates that the data is **still in the pipe** for them to read. The server would be expected to keep data in the pipe in the case of a \u0060401\u0060",
    "upvotes": 22,
    "labels": [
      "Needs: Design",
      "enhancement",
      "area-auth",
      "area-signalr",
      "Blazor \u2665 SignalR",
      "severity-major",
      "affected-medium",
      "Priority:2"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4NDc5NTI5Mw==",
        "parentId": null,
        "author": "analogrelay",
        "content": "We need to make sure that if two requests are outstanding simultaneously, the access token factory is only called once. So we should use a shared component and lock properly",
        "createdAt": "2018-04-26T21:31:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-384795293"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM4NDgwMTc1Nw==",
        "parentId": null,
        "author": "JamesNK",
        "content": "Also need to make sure any new new requests that need to get sent wait while the access token is refreshed.\r\n\r\nThe same behavior should happen while starting a connection. Requests that need to get sent with an access token should wait while a single call to the factory is made, and then get sent out once the token is ready.\r\n\r\nI\u0027m assuming the behavior between C# and TS should be the same.",
        "createdAt": "2018-04-26T21:57:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-384801757"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxODg1NzcxMA==",
        "parentId": null,
        "author": "analogrelay",
        "content": "@SteveSandersonMS @rynowak FYI, just something that popped up in our backlog grooming and @BrennanConroy mentioned this was something you cared about. So we put our special happy label on it.",
        "createdAt": "2019-08-06T21:51:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-518857710"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNzIzNTY0NA==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Expanding this to also cover the possibility of in-band refresh of the token. We may want to build a way to refresh the user principal **without** terminating the connection.",
        "createdAt": "2019-10-01T21:20:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-537235644"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc2Mzk0MjQyMw==",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\nWe\u0027re moving this issue to the \u0060Next sprint planning\u0060 milestone for future evaluation / consideration. We will evaluate the request when we are planning the work for the next milestone. To learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-01-20T21:00:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-763942423"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc2NDAwOTA3Mw==",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "We should author a doc about handling auth expiration correctly. See https://github.com/dotnet/aspnetcore/issues/5283#issuecomment-368864944 for a code example.\r\n\r\n@bradygaster asked me to add @IEvangelist ",
        "createdAt": "2021-01-20T23:00:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-764009073"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgyMzY0NTA3OQ==",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "Notes:\r\nAdd an option to enable automatic refresh of connection on token expiration (note: this closes the connection)\r\n* Store some sort of auth information that has expiration on it on the transport\r\n* Use IConnectionLifetimeNotificationFeature from heartbeat on expiration to tell SignalR to abort connection (with retry allowed)\r\n* If expiration of token happens, can we first run auth again to check if the token hasn\u0027t had its expiry updated?",
        "createdAt": "2021-04-20T22:43:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-823645079"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg1NDU1MTc3OA==",
        "parentId": null,
        "author": "SebastianKunz",
        "content": "Not checking the expiration of the access token in SignalR is a huge security risk. And it adds some work for the appilcation developer to make sure the access token is always fresh. I think it makes sense to add it to the SignalR library where the developer can opt in the feature #14578\r\nI don\u0027t like the approach of closing the connection to then refresh the access token and then connect with the new access token. It does the job, but it\u0027s slow and hacky. There is also the possibility that the backend gets confused because of a completely new connectionId.\r\n\r\nFurthermore I see a second problem arising, which is not solved by keeping the access token fresh. And that is changing roles within the access token.\r\nFor that let me give an example.\r\n\r\nYou have a priviliged user that manages other users in your application. The priviliged user then removes a role from one of the users he manages (e.g. removes the role of adding comment to you blogpost). Assuming this communication is via SignalR and the access token is always valid (not expired) then the user is still authorized to the the tasks (comment on your blogpost) he just was removed from. In the worst case, the access token was just refreshed and the user can abuse his roles up to EXPIRATION_TIME (e.g. 4 minutes).\r\n\r\nThis is a more complex problem to solve then just making sure that the token is always valid, because the Identity Provider needs to inform you that the roles of a user were updated.\r\n\r\nTo sum this up. \r\nI see two problems with signalR and authorization. The first is that the access token is never looked at after the inital connection and second updating roles while a connection is live.\r\nI think we should focus on the first one (keeping the access token fresh). I think it would already help a lot of developers when SignalR with websockets support this feature.",
        "createdAt": "2021-06-04T10:07:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-854551778"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg1NDU3ODIwMA==",
        "parentId": null,
        "author": "JoFrMueller",
        "content": "@BrennanConroy killing the connection in case of an expired refresh token sounds like a blunt hack to be honest. Everything that relates to the connection would be thrown away, while what we actually want to achieve is a \u0022cache invalidation\u0022 on the side of the hub with the support of the client. Couldn\u0027t we think about it from the \u0022bi-directional communication feature\u0022 perspective of SignalR itself?\r\n\r\n1. Hub informs clients some seconds (configurable) before the access token will become invalid. Either because of a timer or because of the heartbeat mechanism. The hub has to know about it, because it persists/caches the initial access token and relates it to the connection itself.\r\n2. Clients can react to this event, that is triggered by the hub to then re-send their access token (which should be refreshed by their local access token handling mechanism anyways) to allow the hub to update the authorization properties related to the client.\r\n3. The hub receives the updated token from the client and overwrites all related ClaimsPrincipal properties for the sending client and therefore updates its internally cached/connectation related state to reflect the latest acces token content.\r\n4. Because of this update, if we remove a role from a client (like described by @SebastianKunz f.e.), this change will be reflected with the next access token refresh cycle, which usually should take 5 minutes maximum.",
        "createdAt": "2021-06-04T10:19:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-854578200"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg1OTkyODcwMQ==",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "Apologies, I realize I left out some critical information when jotting down notes. Closing the connection after token expiration is one part of what we plan on implementing. We do want to have a nicer experience where the token can be refreshed without closing the connection. That does require a lot more thought and care and will be additive with the expiration check.\r\n\r\nThe current plan is to add just the expiration part in 6.0 (opt in) and then build on top of that and design the experience for refresh for a future release.",
        "createdAt": "2021-06-11T21:54:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-859928701"
      },
      {
        "id": "IC_kwDOAQzde840jXw9",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "6.0 work is done, there is a new option to close connections on auth expiration. See https://github.com/dotnet/aspnetcore/pull/32431 for info.\r\n\r\nBacklogging for future work in 7.0",
        "createdAt": "2021-07-16T20:04:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-881687613"
      },
      {
        "id": "IC_kwDOAQzde840jXxz",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-07-16T20:04:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-881687667"
      },
      {
        "id": "IC_kwDOAQzde8489eP8",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 7 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-01-27T01:03:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1022747644"
      },
      {
        "id": "IC_kwDOAQzde849TJyq",
        "parentId": null,
        "author": "gregoriusus",
        "content": "In addition to the security flaw mentioned before, there is also another problem. In high loaded signalr system disconnecting and reconnecting can lead to a lot of messages being lost. Disconnecting and reconnecting are expensive operations that should be avoided.\r\n\r\nThis issue is somehow addressed in many places. I guess that a lot of solutions, that are based on nsignalr, are with jwt authentication with refresh token.",
        "createdAt": "2022-02-02T22:49:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1028431018"
      },
      {
        "id": "IC_kwDOAQzde849TO1b",
        "parentId": null,
        "author": "gregoriusus",
        "content": "I am testing CloseOnAuthenticationExpiration feature. It works. On my development machine with all resources free it takes 1 second to process all operations:\r\n[2022-02-02T23:19:24.859Z] Information: Connection disconnected.\r\n[2022-02-02T23:19:25.904Z] Information: WebSocket connected to....\r\n\r\nA lot can happen in 1 second and on a high load system with a lot of users and messages can lead to messages lost.",
        "createdAt": "2022-02-02T23:23:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1028451675"
      },
      {
        "id": "IC_kwDOAQzde85HcRCi",
        "parentId": null,
        "author": "rafikiassumani-msft",
        "content": "Below are individual items to consider for refreshing auth tokens for SignalR: \r\n\r\n- [ ] Fix error message on client side for OnClose (.NET7):\r\n- Add info to CloseMessage that auth is expired and make it easy for clients to see that (strongly typed exception) and request a new token if required. This should include the error message and status code (401 for example). \r\n\r\n- [ ] Immediate easy \u2122 win for (.NET7):\r\n- Change AccessTokenFactory to only be called on startup and on 401/403 and retry the request, not for every single http request\r\n\r\n- [ ] Doc improvement (.NET7):\r\n- Add doc on how users can setup an endpoint to refresh their token on the server\r\n\r\n- [ ] Protocol change (.NET8):\r\n- Add new hub message type for \u0022pre-close\u0022 that\u0027s effectively an auth challenge and has a grace period for a response before killing connection\r\n- Could make use of Hub message headers to flow auth info to server instead.",
        "createdAt": "2022-07-28T20:19:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1198592162"
      },
      {
        "id": "IC_kwDOAQzde85NbXe4",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-11-01T19:37:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1299019704"
      },
      {
        "id": "IC_kwDOAQzde85QMPd_",
        "parentId": null,
        "author": "davidfowl",
        "content": "This is a popular issue, so I figured I\u0027d shared some updates. The team is looking at ways to keep the make sure there\u0027s a new auth token that represents the updated user information. Since SignalR isn\u0027t a simple request-response based system, it\u0027s challenging and anything we do here will require protocol changes (that means new client and server changes). \r\n\r\nThere are 2 approaches being considered:\r\n\r\n1. A way to renew user information using [the transport protocol](https://github.com/dotnet/aspnetcore/blob/f543e3552514c5c420eeddd55c505bbc131f10a6/src/SignalR/docs/specs/TransportProtocols.md) (HTTP in the common case) \r\n2. A way to renew the user information in [the hub protocol](https://github.com/dotnet/aspnetcore/blob/f543e3552514c5c420eeddd55c505bbc131f10a6/src/SignalR/docs/specs/HubProtocol.md) \r\n\r\nDoing auth at the transport layer lets us reuse all of the ASP.NET Core based authentication handlers so it\u0027s attractive. Doing it over the transport means we need to encode the auth representation in the hub protocol and then have code on the server side that understands how to \u0022unpack\u0022 the token (the equivalent of auth handlers but for SignalR specifically).\r\n\r\nThese are the forms of auth being looked at:\r\n\r\n- Cookie \r\n- JWT (generally bearer tokens)\r\n- Cert\r\n- API-Key\r\n",
        "createdAt": "2022-12-10T21:18:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1345386367"
      },
      {
        "id": "IC_kwDOAQzde85R0yNR",
        "parentId": null,
        "author": "Gruski",
        "content": "I\u0027d be happy if we could control when the accessTokenFactory is called to retrieve new access token. For custom authentication I would like to send a new auth token on every hub method call for reasons too elaborate to go into detail here. Sure I could do it though method parameters but that\u0027s ugly especially when there is an elegant way to do it on initial connection. Then on the back end we could develop more unified ways to custom handle those tokens, update identity, and so on.",
        "createdAt": "2023-01-05T21:21:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1372791633"
      },
      {
        "id": "IC_kwDOAQzde85SBCVs",
        "parentId": null,
        "author": "davidfowl",
        "content": "@Gruski SignalR can\u0027t get a new token, the issue is about how to force the accessTokenFactory to run more than once per connection establishment for long running connections.",
        "createdAt": "2023-01-09T17:37:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1376003436"
      },
      {
        "id": "IC_kwDOAQzde85aHd5U",
        "parentId": null,
        "author": "gregoriusus",
        "content": "Has been this addressed in. NET8?  At the moment, when getting a new token with refresh token, I can only disconnect an connect with a new token to trigger all auth procedure in Signalr backend. Isn\u0027t this a big issue? Can\u0027t just implement client side function who will send some magic word with token and reauthenticate connection or change URL param? ",
        "createdAt": "2023-04-17T18:48:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1511906900"
      },
      {
        "id": "IC_kwDOAQzde85by4fa",
        "parentId": null,
        "author": "DeepWorksStudios",
        "content": "\u003E Has been this addressed in. NET8? At the moment, when getting a new token with refresh token, I can only disconnect an connect with a new token to trigger all auth procedure in Signalr backend. Isn\u0027t this a big issue? Can\u0027t just implement client side function who will send some magic word with token and reauthenticate connection or change URL param?\r\n\r\nI agree this would be required to implement in net8 i\u0027m having the same issues",
        "createdAt": "2023-05-09T12:52:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1540065242"
      },
      {
        "id": "IC_kwDOAQzde85ksvF7",
        "parentId": null,
        "author": "gregoriusus",
        "content": "There are at least 3 issues ( opened on this issue. Any movement on this directions or at least feedback?",
        "createdAt": "2023-08-23T07:41:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1689448827"
      },
      {
        "id": "IC_kwDOAQzde85oOpa3",
        "parentId": null,
        "author": "Misiu",
        "content": "This issue should be moved to .NET 9 Planning as .NET 8 will be released soon. Hopefully, it will get addressed in .NET 9",
        "createdAt": "2023-10-05T11:07:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1748670135"
      },
      {
        "id": "IC_kwDOAQzde85pSFrJ",
        "parentId": null,
        "author": "Skyppid",
        "content": "\u003E This issue should be moved to .NET 9 Planning as .NET 8 will be released soon. Hopefully, it will get addressed in .NET 9\r\n\r\nAs often as it was moved to the next iteration without **any** visible update on it makes me doubt that .NET 9 will be our saviour. It\u0027s been two years almost since I last used it and had to work around this issue. Now again, I really thought they might have fixed it by now. But looks like even ASPNET.Core and SignalR aren\u0027t important enough projects for MS to fix critical issues. Not to mention how you can overlook this issue in the first place. Sad.",
        "createdAt": "2023-10-17T12:47:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1766349513"
      },
      {
        "id": "IC_kwDOAQzde85pS8lg",
        "parentId": null,
        "author": "gregoriusus",
        "content": "As I am aware, there is even no clue how to solve this from architecture point of view ",
        "createdAt": "2023-10-17T14:47:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1766574432"
      },
      {
        "id": "IC_kwDOAQzde85q5ROq",
        "parentId": null,
        "author": "gregoriusus",
        "content": "Is this issue\u0027s milestone moved to NET8 planning? ",
        "createdAt": "2023-11-04T09:46:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1793397674"
      },
      {
        "id": "IC_kwDOAQzde85q_gW3",
        "parentId": null,
        "author": "DeepWorksStudios",
        "content": "It\u0027s just to sad that signalR suffer from that issue and since months I hoped that they fix it but I guess it will never be fixed my impression is that all those Microsoft\u0027s projects are suffering from the same issues that the team behind it has not the resources to tackle all the bleeding wounds in their project and they just try to fix it but it\u0027s simply to much work for those people. That\u0027s my opinion based on the experience working at multiple .net Maui and asp.net core projects. Reported over 12 issues and followed a lot more of already reported issues that I as well encountered in those projects. And still a lot of the issues are still remaining present in the latest versions.",
        "createdAt": "2023-11-06T15:02:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1795032503"
      },
      {
        "id": "IC_kwDOAQzde85rFyHb",
        "parentId": null,
        "author": "gregoriusus",
        "content": "@mkArtakMSFT, guess you have some insider information. Are you going to tackle this issue?",
        "createdAt": "2023-11-06T21:51:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1796678107"
      },
      {
        "id": "IC_kwDOAQzde85rGDYQ",
        "parentId": null,
        "author": "davidfowl",
        "content": "Hopefully in .NET 9",
        "createdAt": "2023-11-06T21:56:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1796748816"
      },
      {
        "id": "IC_kwDOAQzde85rGaF3",
        "parentId": null,
        "author": "gregoriusus",
        "content": "@davidfowl , are there any new information regarding 2 approaches, have you talked about it?",
        "createdAt": "2023-11-06T22:11:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1796841847"
      },
      {
        "id": "IC_kwDOAQzde85rLt6E",
        "parentId": null,
        "author": "Skyppid",
        "content": "\u003E Hopefully in .NET 9\r\n\r\nThat\u0027d be great. SignalR itself is a great tool and usually works really well. But that issue is a huge deal breaker and always was. Is about time that this will be fixed.\r\n\r\nMaybe the community can help with that.",
        "createdAt": "2023-11-07T10:30:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1798233732"
      },
      {
        "id": "IC_kwDOAQzde85zX-gV",
        "parentId": null,
        "author": "yuvi-pc",
        "content": "Came across this [stackoverflow ](https://stackoverflow.com/a/70871191/4060087) workaround. It is working for us for our self hosted service. Is this a viable solution for now? ",
        "createdAt": "2024-02-09T10:20:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1935665173"
      },
      {
        "id": "IC_kwDOAQzde85zZgzS",
        "parentId": null,
        "author": "gregoriusus",
        "content": "\u003E Came across this [stackoverflow ](https://stackoverflow.com/a/70871191/4060087) workaround. It is working for us for our self hosted service. Is this a viable solution for now?\r\n\r\nWell, this implies to stop and reconnect... this is only solution for now....",
        "createdAt": "2024-02-09T14:50:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1936067794"
      },
      {
        "id": "IC_kwDOAQzde85zbnzY",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E @davidfowl , are there any new information regarding 2 approaches, have you talked about it?\r\n\r\nYes, we would go with an \u0022over the transport\u0022 approach. Which means protocol changes to accommodate doing auth without a reconnect. ",
        "createdAt": "2024-02-09T21:22:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1936620760"
      },
      {
        "id": "IC_kwDOAQzde85zbrKW",
        "parentId": null,
        "author": "gregoriusus",
        "content": "That\u0027s great. Is it already on road map?",
        "createdAt": "2024-02-09T21:34:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-1936634518"
      },
      {
        "id": "IC_kwDOAQzde86HE9a9",
        "parentId": null,
        "author": "gregoriusus",
        "content": "Any news on this topic?",
        "createdAt": "2024-08-02T22:40:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2266224317"
      },
      {
        "id": "IC_kwDOAQzde86Kx6g1",
        "parentId": null,
        "author": "Misiu",
        "content": "So maybe .NET 10? ",
        "createdAt": "2024-09-04T09:16:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2328340533"
      },
      {
        "id": "IC_kwDOAQzde86K1d3G",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E So maybe .NET 10?\r\n\r\nAt a minimum",
        "createdAt": "2024-09-04T14:47:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2329271750"
      },
      {
        "id": "IC_kwDOAQzde86K3pVD",
        "parentId": null,
        "author": "Skyppid",
        "content": "Wow that\u0027s crazy... too bad there\u0027s not much good alternatives to SignalR as of now...",
        "createdAt": "2024-09-04T19:45:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2329843011"
      },
      {
        "id": "IC_kwDOAQzde86K4eVq",
        "parentId": null,
        "author": "reduckted",
        "content": "\u003E At a minimum\r\n\r\nThe earliest we\u0027ll see it is in the next version? How about a maximum? \uD83D\uDE06 ",
        "createdAt": "2024-09-04T20:57:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2330060138"
      },
      {
        "id": "IC_kwDOAQzde86K4tOY",
        "parentId": null,
        "author": "DeepWorksStudios",
        "content": "\u003E \u003E At a minimum\n\u003E \n\u003E \n\u003E \n\u003E The earliest we\u0027ll see it is in the next version? How about a maximum? \uD83D\uDE06 \n\nIt\u0027s sadly the fact that Microsoft does not invest enough in the development department in comparison to how many technologies they are invented and maintaining. \n\nBest course is to build the solution yourself or even better try to avoid such incompleted frameworks.",
        "createdAt": "2024-09-04T21:07:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2330121112"
      },
      {
        "id": "IC_kwDOAQzde86bLl6Z",
        "parentId": null,
        "author": "thirstyape",
        "content": "6 years and 9 months and not even close to any real progress, just a bunch of classic MS bureaucracy.\n\nWhy is there not at least a manual way to refresh tokens or even just the stored value?",
        "createdAt": "2025-01-21T02:38:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2603507353"
      },
      {
        "id": "IC_kwDOAQzde86bOC_X",
        "parentId": null,
        "author": "Skyppid",
        "content": "\u003E 6 years and 9 months and not even close to any real progress, just a bunch of classic MS bureaucracy.\n\u003E \n\u003E Why is there not at least a manual way to refresh tokens or even just the stored value?\n\nFrom what I understand by using the \u0060accessTokenFactory\u0060 you always fetch a fresh token when a request is being sended. To optimize it, you can cache it until expiry and request a new one only if expired.\n\n\u0060\u0060\u0060ts\n    const hubConnectionBuilder = new HubConnectionBuilder().withUrl(this.SERVER_HUB_URL, {\n      transport: HttpTransportType.None,\n      logger: LogLevel.Debug,\n      accessTokenFactory: () =\u003E this.identityService.getToken()\n    });\n\u0060\u0060\u0060",
        "createdAt": "2025-01-21T09:28:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2604150743"
      },
      {
        "id": "IC_kwDOAQzde86bOP02",
        "parentId": null,
        "author": "DeepWorksStudios",
        "content": "\u003E \u003E 6 years and 9 months and not even close to any real progress, just a bunch of classic MS bureaucracy.\n\u003E \u003E \n\u003E \u003E Why is there not at least a manual way to refresh tokens or even just the stored value?\n\u003E \n\u003E From what I understand by using the \u0060accessTokenFactory\u0060 you always fetch a fresh token when a request is being sended. To optimize it, you can cache it until expiry and request a new one only if expired.\n\u003E \n\u003E \u0060\u0060\u0060ts\n\u003E     const hubConnectionBuilder = new HubConnectionBuilder().withUrl(this.SERVER_HUB_URL, {\n\u003E       transport: HttpTransportType.None,\n\u003E       logger: LogLevel.Debug,\n\u003E       accessTokenFactory: () =\u003E this.identityService.getToken()\n\u003E     });\n\u003E \u0060\u0060\u0060\n\nThis does not solve the original issue. The issue is that a reconnect is required to revaildet the token if its expired and that requires a full reconnect and if a client is connected without any connection loss even the token is invalid he can still accces protected hub methods etc . And some other issues that\u0027d come with the whole auth system of signalR just read the thread  ",
        "createdAt": "2025-01-21T09:50:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2604203318"
      },
      {
        "id": "IC_kwDOAQzde86bRVVs",
        "parentId": null,
        "author": "gregoriusus",
        "content": "Interesting that this is not some major issue. No one is refreshing token until logout/login?",
        "createdAt": "2025-01-21T15:16:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605012332"
      },
      {
        "id": "IC_kwDOAQzde86bRWim",
        "parentId": null,
        "author": "Skyppid",
        "content": "Is it? I remember in a previous company we used it and had the problem that after the expiry all requests failed. Back then we had to actually reconnect. But using the factory it requests a token on each request, so if the token is outdated it should still fail?\n\nOr do you mean backend-side? Honestly, we haven\u0027t been using SignalR that much so far, as those features were just UX convenience and there were more pressing things to build. It works for us, but maybe I\u0027m overlooking something here as I\u0027m not that deep into it anymore.\n\nJust wanted to hint that this helps at least with some common issues in low-frequency / non-critical scenarios.",
        "createdAt": "2025-01-21T15:17:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605017254"
      },
      {
        "id": "IC_kwDOAQzde86bReeC",
        "parentId": null,
        "author": "thirstyape",
        "content": "\u003E Interesting that this is not some major issue. No one is refreshing token until logout/login?\n\nBy default this is pretty much the issue, the token request does not happen until an HTTP request goes out, which doesn\u0027t happen often as most communication is facilitated via WebSocket. \n\nMaybe the thought process here is that since the connection remains open it doesn\u0027t require re-validation? Not sure I agree with this.\n\nJust seems wrong when I\u0027m adding methods on the hub for them to not check for a valid token on each request. And when an invalid token is found just abort the connection. My current workaround is two-fold: on the hub add a method that informs whether the token is valid; on the client check with the hub each request whether the token is valid and reconnect when it is not. Additionally, the hub will do a single retry if the request failed due to closure from the hub.",
        "createdAt": "2025-01-21T15:29:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605049730"
      },
      {
        "id": "IC_kwDOAQzde86bRfKM",
        "parentId": null,
        "author": "gregoriusus",
        "content": "Yes, we are solving now, on client side, to pool all request to signalr when we are refreshing token and then we disconnect and reconnect. But on high volume of calls to/from signalr this will pose a problem of messages being lost or invest on some kind of retry mechanism. ",
        "createdAt": "2025-01-21T15:31:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605052556"
      },
      {
        "id": "IC_kwDOAQzde86bRh8C",
        "parentId": null,
        "author": "thirstyape",
        "content": "\u003E Yes, we are solving now, on client side, to pool all request to signalr when we are refreshing token and then we disconnect and reconnect. But on high volume of calls to/from signalr this will pose a problem of messages being lost or invest on some kind of retry mechanism.\n\nExactly!\n\nOnly dealing with maybe 100 low traffic connections at a time right now, but this is going to be a scaling nightmare. ",
        "createdAt": "2025-01-21T15:35:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605063938"
      },
      {
        "id": "IC_kwDOAQzde86bRj0I",
        "parentId": null,
        "author": "DeepWorksStudios",
        "content": "\u003E Yes, we are solving now, on client side, to pool all request to signalr when we are refreshing token and then we disconnect and reconnect. But on high volume of calls to/from signalr this will pose a problem of messages being lost or invest on some kind of retry mechanism. \n\nIt\u0027s more about the actual backend issue that we can have the case an invalid token or a user that changed permissions on runtime can still access protected methods since the validation just happens on the initial handshake of the websocket connection afterwards if the connection persists than we got the issue with unauthorized users can still access protected resources. The only workaround is to attach to the signalR heartbeat and validate it yourself but on client side we got the reconnect issue it\u0027s a slight different issue but still all is kinda sharing the same issue that authentication is rather fragile in signalR \n\nThe workaround works but ain\u0027t optimal and causes scaling issues if the demand increases so yeah total conclusion is rather bad since it\u0027s a issue known for nearly 7 years ",
        "createdAt": "2025-01-21T15:38:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605071624"
      },
      {
        "id": "IC_kwDOAQzde86bRlGj",
        "parentId": null,
        "author": "DeepWorksStudios",
        "content": "\u003E \u003E Yes, we are solving now, on client side, to pool all request to signalr when we are refreshing token and then we disconnect and reconnect. But on high volume of calls to/from signalr this will pose a problem of messages being lost or invest on some kind of retry mechanism.\n\u003E \n\u003E Exactly!\n\u003E \n\u003E Only dealing with maybe 100 low traffic connections at a time right now, but this is going to be a scaling nightmare. \n\nSadly we already experienced issues  at our company in therms of scaling and there is no real solution sadly since it\u0027s a concept issue in signalR and can\u0027t be changed that easily that\u0027s why I wonder what did Microsoft all the 6 years. That would be sufficient time to fix such a major flaw ",
        "createdAt": "2025-01-21T15:40:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605076899"
      },
      {
        "id": "IC_kwDOAQzde86bRpTW",
        "parentId": null,
        "author": "thirstyape",
        "content": "\u003E It\u0027s more about the actual backend issue that we can have the case an invalid token or a user that changed permissions on runtime can still access protected methods since the validation just happens on the initial handshake of the websocket connection afterwards if the connection persists than we got the issue with unauthorized users can still access protected resources. The only workaround is to attach to the signalR heartbeat and validate it yourself but on client side we got the reconnect issue it\u0027s a slight different issue but still all is kinda sharing the same issue that authentication is rather fragile in signalR\n\u003E \n\u003E The workaround works but ain\u0027t optimal and causes scaling issues if the demand increases so yeah total conclusion is rather bad since it\u0027s a issue known for nearly 7 years\n\nWow! I hadn\u0027t even thought of token invalidation or permission changes, that\u0027s huge.",
        "createdAt": "2025-01-21T15:47:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605094102"
      },
      {
        "id": "IC_kwDOAQzde86bRqI6",
        "parentId": null,
        "author": "gregoriusus",
        "content": "Me niether regarding permission changes, this is additional issue :-(\n\nAt the time when they architect this, refresh token was not a big issue. We have one solution on old Signalr (NET framework) and we are using cookie based authentication. It works flawless. Anyone knows, if it is possible to mix and for signalr send cookie based authneticaton with some custom validation on server and for API calls token based?",
        "createdAt": "2025-01-21T15:48:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605097530"
      },
      {
        "id": "IC_kwDOAQzde86bRsaK",
        "parentId": null,
        "author": "DeepWorksStudios",
        "content": "\u003E \u003E It\u0027s more about the actual backend issue that we can have the case an invalid token or a user that changed permissions on runtime can still access protected methods since the validation just happens on the initial handshake of the websocket connection afterwards if the connection persists than we got the issue with unauthorized users can still access protected resources. The only workaround is to attach to the signalR heartbeat and validate it yourself but on client side we got the reconnect issue it\u0027s a slight different issue but still all is kinda sharing the same issue that authentication is rather fragile in signalR\n\u003E \u003E \n\u003E \u003E The workaround works but ain\u0027t optimal and causes scaling issues if the demand increases so yeah total conclusion is rather bad since it\u0027s a issue known for nearly 7 years\n\u003E \n\u003E Wow! I hadn\u0027t even thought of token invalidation or permission changes, that\u0027s huge.\n\nIt\u0027s a huge issue and no real solution wich would solve the root issue \n\nI mean that\u0027s why nobody srs uses Microsoft tech because their them self don\u0027t use it in the extend their should to prove it\u0027s viable for production and sadly this case if you require high security that\u0027s a no no \n\nIt\u0027s a killer issue out of my perspective I wonder why nobody points that out as what it is \n\nI mean I follow this issue since 4 years and still no progress at all only more people find out about the surface issue but only a small handful of people understands the overall impact on therms of auth security and I am no expert in that terms and still even I saw the issues that comes with this type of of implementation ",
        "createdAt": "2025-01-21T15:52:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605106826"
      },
      {
        "id": "IC_kwDOAQzde86bRxrD",
        "parentId": null,
        "author": "gregoriusus",
        "content": "Do you think that token authentication for api calls and cookie based for signalr would help in this issue? Just a thought...",
        "createdAt": "2025-01-21T16:00:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605128387"
      },
      {
        "id": "IC_kwDOAQzde86bR7T_",
        "parentId": null,
        "author": "thirstyape",
        "content": "\u003E Do you think that token authentication for api calls and cookie based for signalr would help in this issue? Just a thought...\n\nFrom what I can tell this would be subject to the same issue. \n\nThe documentation, and examples I googled, seem to suggest that the cookie would only be provided on the initial HTTP request, and subsequent requests over the WebSocket would be doing the same thing as token based requests. ",
        "createdAt": "2025-01-21T16:14:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605167871"
      },
      {
        "id": "IC_kwDOAQzde86bSQGb",
        "parentId": null,
        "author": "channeladam",
        "content": "It has been a while since I have looked at the SignalR code in my project, but I think I mitigate the many SignalR issues/concerns with the following approach:\n\n1. My  SignalR access token is a very short-lived token just for the hubs - no other endpoints will accept them - they are different from my normal api endpoint access tokens.\n\n2. I never send data to the hub via the SignalR connection!  When calling the backend, I always use a normal api endpoint with the normal session security mechanism.\n\n3. As you can guess, data is only sent from the backend to the frontend, for the specified user guid that was part of the original access token when initially connecting to SignalR.  The backend can check the current role of the user (e.g. against the database) before sending the data if necessary or if concerned about a role change.\nI believe that makes it okay for the SignalR connection to remain open as long as the user is on that web page.\nIf the user\u0027s web session times out, they are redirected to the login page, so their connection is closed from the frontend at that point.\n\n4. Due to the javascript library having issues reconnecting server-sent events or long-polling (more specifically not bothering to properly inspect the response status code), I use a custom HttpClient that extends DefaultHttpClient and overrides send()  in order to catch any error and and return a specific HttpResponse to address those issues to allow them to reconnect.\n\nHaving said all that, if I recall correctly (please be kind - I could be wrong!), the backend Hub Context keeps the initial connection request details - so the user\u0027s guid that was in the SignalR access token is always accessible via a claim via the Hub.Context.GetHttpContext().  I believe, if I wanted to, I could add other custom claims such as a session expiry timestamp if I wanted to check that later in a hub method, and then call Abort() if it had expired - or something similar if there was a role change and it had to be invalidated. Could be wrong!  \nEither way, given my approach, I don\u0027t need that.\n\nHope this helps someone.",
        "createdAt": "2025-01-21T16:50:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605253019"
      },
      {
        "id": "IC_kwDOAQzde86bSdNq",
        "parentId": null,
        "author": "DeepWorksStudios",
        "content": "\u003E It has been a while since I have looked at the SignalR code in my project, but I think I mitigate the many SignalR issues/concerns with the following approach:\n\u003E \n\u003E 1. My  SignalR access token is a very short-lived token just for the hubs - no other endpoints will accept them - they are different from my normal api endpoint access tokens.\n\u003E \n\u003E 2. I never send data to the hub via the SignalR connection!  When calling the backend, I always use a normal api endpoint with the normal session security mechanism.\n\u003E \n\u003E 3. As you can guess, data is only sent from the backend to the frontend, for the specified user guid that was part of the original access token when initially connecting to SignalR.  The backend can check the current role of the user (e.g. against the database) before sending the data if necessary or if concerned about a role change.\n\u003E I believe that makes it okay for the SignalR connection to remain open as long as the user is on that web page.\n\u003E If the user\u0027s web session times out, they are redirected to the login page, so their connection is closed from the frontend at that point.\n\u003E \n\u003E 4. Due to the javascript library having issues reconnecting server-sent events or long-polling (more specifically not bothering to properly inspect the response status code), I use a custom HttpClient that extends DefaultHttpClient and overrides send()  in order to catch any error and and return a specific HttpResponse to address those issues to allow them to reconnect.\n\u003E \n\u003E Having said all that, if I recall correctly (please be kind - I could be wrong!), the backend Hub Context keeps the initial connection request details - so the user\u0027s guid that was in the SignalR access token is always accessible via a claim via the Hub.Context.GetHttpContext().  I believe, if I wanted to, I could add other custom claims such as a session expiry timestamp if I wanted to check that later in a hub method, and then call Abort() if it had expired - or something similar if there was a role change and it had to be invalidated. Could be wrong!  \n\u003E Either way, given my approach, I don\u0027t need that.\n\u003E \n\u003E Hope this helps someone.\n\nSadly it won\u0027t work for my use case but I see how it can minimize the issues for many use cases but still they are just a workaround out of my perspective ",
        "createdAt": "2025-01-21T17:13:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605306730"
      },
      {
        "id": "IC_kwDOAQzde86bSvRH",
        "parentId": null,
        "author": "Gruski",
        "content": "I need this a few years ago too but since there was nothing being done I ended up changing my auth from token based to where info was actually stored in token, to database based so now token never needs to be updated because I can just update the auth info of the static client token on the server side in DB user\u0027s record. That also helped with heterogeneous systems that could not share auth which I also needed and sliding expiration which I believe none of the other workarounds address. Then use filters in the hub to auth against DB on every SignalR request.",
        "createdAt": "2025-01-21T17:47:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605380679"
      },
      {
        "id": "IC_kwDOAQzde86bTHh3",
        "parentId": null,
        "author": "DeepWorksStudios",
        "content": "https://www.youtube.com/watch?v=kAGlATRcgY4\nSecurity \u0026 Auth .NET 10 planning discussion\n\nThats currently live on going maybe it will tackel this issue in .net 10\nAt least i hope so ",
        "createdAt": "2025-01-21T18:40:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605480055"
      },
      {
        "id": "IC_kwDOAQzde86bTQv2",
        "parentId": null,
        "author": "DeepWorksStudios",
        "content": "They mentioned that it will be worked on this issue in .Net 10 \n\nGladly \uD83C\uDF89",
        "createdAt": "2025-01-21T19:00:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5297#issuecomment-2605517814"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzODI1Mzg1ODc=",
    "title": "Consider adding overview/listing of all samples in root README",
    "url": "https://github.com/dotnet/aspnetcore/issues/4121",
    "createdAt": "2018-05-01T22:48:49Z",
    "lastUpdated": "2020-11-10T23:24:54Z",
    "body": "Might be useful to give an brief overview of what each sample does consolidated in one place at the root of the repo",
    "upvotes": 0,
    "labels": [
      "task",
      "area-auth",
      "Samples",
      "severity-nice-to-have",
      "affected-few"
    ],
    "comments": []
  },
  {
    "id": "MDU6SXNzdWUzOTA0NjY2Mzk=",
    "title": "Empty body responses can violate content security policy",
    "url": "https://github.com/dotnet/aspnetcore/issues/4652",
    "createdAt": "2018-05-29T16:36:32Z",
    "lastUpdated": "2023-10-28T14:09:41Z",
    "body": "# Overview\r\n\r\nI have a basic MVC website utilizing OIDC with authorization code flow for authentication. After implementing a content security policy, remote sign out will no longer function.\r\n\r\nOn remote signout the OpenIdConnectHandler will respond with a response of code 200 but with no body. As a result, browsers will interpret the response by improvising the text/html content. This can result in a content security policy violation based on the browser\u0027s improvisation.\r\n\r\n# Reproduction\r\n\r\n[I have a repository with the most basic configuration.](https://github.com/null-d3v/OidcCsp)\r\nUsing Chrome, navigate directly to the \u0060RemoteSignOutPath\u0060 (/signout-oidc)\r\nChrome will report a content security policy violation from the pre element\u0027s inline style:\r\n\u0060\u0060\u0060\r\n\u003Chtml\u003E\r\n    \u003Chead\u003E\u003C/head\u003E\r\n    \u003Cbody\u003E\r\n        \u003Cpre style=\u0022word-wrap: break-word; white-space: pre-wrap;\u0022\u003E\u003C/pre\u003E\r\n    \u003C/body\u003E\r\n\u003C/html\u003E\r\n\u0060\u0060\u0060\r\n\r\nCurrently there is limited recourse. I understand I have several options: using \u0027unsafe-inline\u0027, overriding the remote sign out implementation via the \u0060OnRemoteSignOut\u0060 event, or add middleware to change the content security policy for the \u0060RemoteSignOutPath\u0060 specifically. These options are somewhat contrived and not what I would think ideal. However, if there is a better solution that I am overlooking I would appreciate any insight.\r\n\r\nI would request consideration for the text/html status code 200 HTTP responses include a body to avoid this browser improvisation.",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM5Mjg1NjM4MQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Additional mitigation: UseStatusCodePages\r\nhttps://github.com/aspnet/Diagnostics/blob/2f297de23215f981d6ed521868e4f235ee8afa48/samples/StatusCodePagesSample/Startup.cs",
        "createdAt": "2018-05-29T17:04:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4652#issuecomment-392856381"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwMTE4MDU3Ng==",
        "parentId": null,
        "author": "Eilon",
        "content": "It seems worth considering placing a simple text response in the body.",
        "createdAt": "2018-06-28T21:34:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4652#issuecomment-401180576"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTA0NjYxNTc=",
    "title": "Log decryption failures",
    "url": "https://github.com/dotnet/aspnetcore/issues/4651",
    "createdAt": "2018-06-01T17:54:50Z",
    "lastUpdated": "2023-10-28T14:09:40Z",
    "body": "\u0022Correlation failed\u0022 is one of the most common failures in OIDC or OAuth flows. Many of the things that can go wrong here happen on the client and can\u0027t be traced from the server. However there\u0027s one scenario where everything does flow back to the server and the server fails to decrypt the values. This can happen in a multi-node environment with misconfigured dataprotection (RE: https://github.com/aspnet/Security/issues/1755). We can highlight this by logging decryption failures in OAuth, OIDC, and CookieAuth.",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "severity-minor",
      "affected-medium",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwMTE3OTY0MQ==",
        "parentId": null,
        "author": "Eilon",
        "content": "Marking as up-for-grabs in Backlog.",
        "createdAt": "2018-06-28T21:30:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4651#issuecomment-401179641"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQyOTIyMjgwMA==",
        "parentId": null,
        "author": "SanderDeclerck",
        "content": "Would it perhaps be possible to have a more specific Exception type for this as well? Then it would be easier to handle this kind of issue in an application.\r\n\r\nI am investigating a \u0022correlation failed\u0022 issue in one of my applications, and in order to add extra logging when this exception occurs, I needed to add a check on the Exception message. Wouldn\u0027t it be nicer if we could check for a specific Exception type instead?\r\n\r\nThis might be especially the case as:\r\n\r\n\u003E \u0022Correlation failed\u0022 is one of the most common failures in OIDC or OAuth flows.",
        "createdAt": "2018-10-12T06:49:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4651#issuecomment-429222800"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTA0NjYwOTg=",
    "title": "Encrypted userinfo jwt not working",
    "url": "https://github.com/dotnet/aspnetcore/issues/4650",
    "createdAt": "2018-07-11T12:29:14Z",
    "lastUpdated": "2021-12-07T22:08:15Z",
    "body": "I\u0027m integrating with an identity provider who uses OpenId connect with userinfo in an encrypted jwt.\r\n\r\nUnfortunately, OpenIdConnectHandler is unable to handle this specific case. Crashes at: https://github.com/aspnet/Security/blob/beaa2b443d46ef8adaf5c2a89eb475e1893037c2/src/Microsoft.AspNetCore.Authentication.OpenIdConnect/OpenIdConnectHandler.cs#L815-L819 because userInfoEndpointJwt.Payload is null in this case\r\n\r\nSee also https://github.com/aspnet/Security/pull/517#discussion_r42279158 where @PinpointTownes suggests it will possibly crash but he can\u0027t test it versus a server with this behavior.\r\n\r\nSince it\u0027s allowed in the openid connect spec, the handler should probably be able to handle it.\r\n\r\nI managed to make it work by replacing the code above with this:\r\n\r\n\r\n    else if (contentType.MediaType.Equals(\u0022application/jwt\u0022, StringComparison.OrdinalIgnoreCase))\r\n            {\r\n                var validationParameters = Options.TokenValidationParameters.Clone();\r\n                validationParameters.RequireSignedTokens = false;\r\n                validationParameters.ValidateLifetime = false;\r\n                if (_configuration != null)\r\n                {\r\n                    var issuer = new[] { _configuration.Issuer };\r\n                    validationParameters.ValidIssuers = validationParameters.ValidIssuers?.Concat(issuer) ?? issuer;\r\n                    validationParameters.IssuerSigningKeys = validationParameters.IssuerSigningKeys?.Concat(_configuration.SigningKeys)\r\n                                                             ?? _configuration.SigningKeys;\r\n                }\r\n\r\n                var princip = Options.SecurityTokenValidator.ValidateToken(userInfoResponse, validationParameters, out SecurityToken validatedToken);\r\n                var userInfoJwt = validatedToken as JwtSecurityToken;\r\n                user = JObject.FromObject(userInfoJwt.Payload);\r\n                userInfoResponse = new JwtSecurityTokenHandler().WriteToken(userInfoJwt.InnerToken);\r\n    }\r\n\r\nBut this is just an ugly workaround for this specific provider, I\u0027m sure someone can come up with a more generic implementation which fixes both cases. (The reason I\u0027m replacing the userInfoResponse is because later in the method the userInfoResponse is being validated and this method ALSO assumes it\u0027s unencrypted)",
    "upvotes": 1,
    "labels": [
      "enhancement",
      "area-auth",
      "affected-few",
      "severity-major"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwNDE2MzMxNQ==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E See also #517 (comment) where @PinpointTownes suggests it will possibly crash but he can\u0027t test it versus a server with this behavior.\r\n\r\nGlad to know I was right :rofl: \r\n\r\nMore seriously: another workaround may consist in disabling the built-in userinfo retrieval support and doing it yourself using the \u0060TokenValidated\u0060 event.",
        "createdAt": "2018-07-11T13:11:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-404163315"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwNDE2NDk2Ng==",
        "parentId": null,
        "author": "jgoyvaerts",
        "content": "Should I really be writing workarounds when integrating with a party who follows the specification? :wink: \r\n\r\nMy goal is to improve the current implementation so it supports more variants of openid connect out of the box, and hopefully this issue can help with that.",
        "createdAt": "2018-07-11T13:16:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-404164966"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwNDE2NTc4MQ==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E Should I really be writing workarounds when integrating with a party who follows the specification?\r\n\r\nWorkarounds are not long-term fixes, they\u0027re just meant to unblock you until a proper fix is released :smile: \r\n\r\nFixing the OIDC handler is certainly the right thing to do, but you\u0027ll have to wait for 2.2 to ship to benefit from your fix :smile: ",
        "createdAt": "2018-07-11T13:19:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-404165781"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwNTc0NzUwNw==",
        "parentId": null,
        "author": "Eilon",
        "content": "@brentschmaltz - do  you have a tracking item for supporting this in IdentityModel?",
        "createdAt": "2018-07-17T22:22:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-405747507"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwNjAzMjcxNg==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@Eilon IdentityModel supports JWE. \r\nThe problem is as @PinpointTownes points out the OIDC handle doesn\u0027t recognize or support JWE.\r\nWe have the pieces in place that would allow us to put a solution together. I believe it would involve changes to ASP.Net.",
        "createdAt": "2018-07-18T18:38:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-406032716"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwNjAzMzkzMQ==",
        "parentId": null,
        "author": "jgoyvaerts",
        "content": "The problem exists in 2 places, the following 2 parts assume that the token is unencrypted:\r\nhttps://github.com/aspnet/Security/blob/beaa2b443d46ef8adaf5c2a89eb475e1893037c2/src/Microsoft.AspNetCore.Authentication.OpenIdConnect/OpenIdConnectHandler.cs#L815-L819\r\nhttps://github.com/aspnet/Security/blob/beaa2b443d46ef8adaf5c2a89eb475e1893037c2/src/Microsoft.AspNetCore.Authentication.OpenIdConnect/OpenIdConnectHandler.cs#L834-L838\r\n\r\nChanges in the validator could be avoided by decrypting the token and then reassigning the unencrypted inner token to the userInfoResponse variable (similar to Id_token, the validator doesn\u0027t do decryption, it only validates unencrypted tokens). However, the resulting code wouldn\u0027t be very pretty...",
        "createdAt": "2018-07-18T18:42:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-406033931"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwNjA2NDU3OQ==",
        "parentId": null,
        "author": "Eilon",
        "content": "Got it; we\u0027ll evaluate what\u0027s needed in ASP.NET Core.",
        "createdAt": "2018-07-18T20:32:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-406064579"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwNjA3MzYwNw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "What identity servers provide encrypted tokens that we can test against?",
        "createdAt": "2018-07-18T21:03:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-406073607"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwNjA3NjMzNg==",
        "parentId": null,
        "author": "jgoyvaerts",
        "content": "I\u0027m afraid the one I encountered is private and I\u0027m unable to share it for\r\ntesting.\r\n\r\nMaybe someone can setup a IdentityServer4 repo PoC which encrypts userinfo\r\ntokens?",
        "createdAt": "2018-07-18T21:13:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-406076336"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwNjM3OTgzOA==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@Tratcher http://testingsts.azurewebsites.net/ has a discovery endpoint and can return jwe.",
        "createdAt": "2018-07-19T18:57:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-406379838"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwODU1MjIwMA==",
        "parentId": null,
        "author": "Eilon",
        "content": "Thanks for the info, everyone. We will consider this in the 3.0 release.",
        "createdAt": "2018-07-27T22:16:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-408552200"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQxMDA0MzY0OQ==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@Eilon when is 3.0 planned for release?",
        "createdAt": "2018-08-02T19:38:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-410043649"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQxMDEwMjQzNg==",
        "parentId": null,
        "author": "Eilon",
        "content": "@brentschmaltz looks like next year (definitely not this year).",
        "createdAt": "2018-08-02T23:52:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-410102436"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzODA5ODczNw==",
        "parentId": null,
        "author": "blowdart",
        "content": "@brentschmaltz Is JWE now supported from your side? If so we can look at this for 5.0",
        "createdAt": "2019-10-03T19:45:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-538098737"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzODEwNTQ2Ng==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "IdentityModel already supports JWE, as @brentschmaltz said last year:\r\n\r\n\u003E @Eilon IdentityModel supports JWE.\r\nThe problem is as @PinpointTownes points out the OIDC handle doesn\u0027t recognize or support JWE.\r\nWe have the pieces in place that would allow us to put a solution together. I believe it would involve changes to ASP.Net.\r\n\r\nIt\u0027s a bit surprising to see at least two reports related to this missing **optional** feature, since the OIDC spec is pretty clear about the fact signed and/or encrypted userinfo responses are things the client itself must opt-in for during registration (which is frankly a super marginal case):\r\n\r\n\u003E The UserInfo Claims MUST be returned as the members of a JSON object unless a signed or encrypted response was requested during Client Registration.",
        "createdAt": "2019-10-03T20:02:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-538105466"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzODEwNjM5Mw==",
        "parentId": null,
        "author": "blowdart",
        "content": "Expecting client registration to be correct in a lot of handlers is probably a pipe dream. Anyway, moving this to 5.0 planning then",
        "createdAt": "2019-10-03T20:05:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-538106393"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU0MDgzNjAyNg==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@blowdart we have had support for JWE for a while. One issue is IdentityModel 5.5.0 is needed for tokens that use \u0027deflate\u0027.",
        "createdAt": "2019-10-10T23:14:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-540836026"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU0MTA2NTM4MQ==",
        "parentId": null,
        "author": "blowdart",
        "content": "Cool, we\u0027ll get this done in 5.0 then :) Expect a bunch of questions in the new year",
        "createdAt": "2019-10-11T13:30:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-541065381"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU0MzA1NTM5Mw==",
        "parentId": null,
        "author": "sliekens",
        "content": "\u003E It\u0027s a bit surprising to see at least two reports related to this missing **optional** feature, since the OIDC spec is pretty clear about the fact signed and/or encrypted userinfo responses are things the client itself must opt-in for during registration (which is frankly a super marginal case):\r\n\r\nOne of those reports was mine and in my particular case it was not opt-in. In fact there isn\u0027t even an opt-out.  I guess that means that my identity provider doesn\u0027t follow the spec. Sending \u0060Accept: application/json\u0060 to the user info endpoint results in a 400 Bad Request.  \r\nEither way I\u0027m glad to see this will get fixed. \uD83D\uDE04 ",
        "createdAt": "2019-10-17T07:59:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-543055393"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU0MzA3Njg1Mw==",
        "parentId": null,
        "author": "jgoyvaerts",
        "content": "\u003E One of those reports was mine and in my particular case it was not opt-in. In fact there isn\u0027t even an opt-out. I guess that means that my identity provider doesn\u0027t follow the spec. Sending Accept: application/json to the user info endpoint results in a 400 Bad Request.\r\n\r\nSeeing as we\u0027re from the same country we\u0027re probably talking about the same identity provider (itsme) \uD83D\uDE09",
        "createdAt": "2019-10-17T08:55:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-543076853"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU0MzA4OTU5MQ==",
        "parentId": null,
        "author": "sliekens",
        "content": "Yep that\u0027s the one... I guess I\u0027ll file a bug report with them and link to this issue...",
        "createdAt": "2019-10-17T09:28:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-543089591"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2NjY5ODk3NQ==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-07-30T21:04:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-666698975"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2ODEzMzExOQ==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "The issue here is how do the decryption keys needed for the Jwt.",
        "createdAt": "2020-08-03T17:01:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-668133119"
      },
      {
        "id": "IC_kwDOAQzde8466DYF",
        "parentId": null,
        "author": "ytqsl",
        "content": "We have an userinfo encryption policy in place with our organization OIDC provider, so decrypting the returned JWE from the endpoint is a must. Will this issue be prioritized any time soon, or this is going to be a \u0027known issue\u0027 for the foreseeable future?\r\n",
        "createdAt": "2021-12-07T22:08:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4650#issuecomment-988296709"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTA0NjYwNDg=",
    "title": "Consider resolving IAuthenticationSchemeProvider from DI in Invoke in AuthenticationMiddleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/4649",
    "createdAt": "2018-07-26T03:16:14Z",
    "lastUpdated": "2020-10-19T17:07:21Z",
    "body": "In short, accepting the IAuthenticationSchemeProvider as a ctor to the AuthenticationMiddleware forces it to be a singleton. I know the default is deigned that way and put in DI that way, but if someone wants to replace it (say with something that hits a DB) then it\u0027s difficult.",
    "upvotes": 2,
    "labels": [
      "area-auth",
      "multi-tenancy"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwODE0MzY4OA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Interesting. You wouldn\u0027t be able to use most of the AddFacebook/OIDC extensions with that pattern as they all rely on the singleton. It would be a pretty sharp one-or-the-other divergence.\r\n\r\nYou may be better off replacing the IAuthenticationService with something that doesn\u0027t use IAuthenticationSchemeProvider at all, and IAuthenticationService is already scoped.",
        "createdAt": "2018-07-26T15:49:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4649#issuecomment-408143688"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwODUwMTYzOA==",
        "parentId": null,
        "author": "brockallen",
        "content": "I think whatever larger multi-tenant solution is finally presented (assuming it\u0027s eventually done as what Damian said here: https://github.com/aspnet/Security/issues/1718), that would prolly address my issue and provide me a workaround. \r\n\r\nIn the short term, I\u0027ll see if hooking in at the authN service gets me what I need.",
        "createdAt": "2018-07-27T18:27:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4649#issuecomment-408501638"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwODU1MTIzMw==",
        "parentId": null,
        "author": "Eilon",
        "content": "Parking in backlog. We will look into this again when we eventually embark on proper multi-tenant support.",
        "createdAt": "2018-07-27T22:10:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4649#issuecomment-408551233"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNjMxOTcyOQ==",
        "parentId": null,
        "author": "dasiths",
        "content": "I gave an example about how this could be useful in #4126. ",
        "createdAt": "2020-05-10T12:21:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4649#issuecomment-626319729"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNjMyMTE5Ng==",
        "parentId": null,
        "author": "dasiths",
        "content": "@Eilon any updates on this?",
        "createdAt": "2020-05-10T12:32:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/4649#issuecomment-626321196"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTEyNjQzNTg=",
    "title": "OIDC should verify response_mode",
    "url": "https://github.com/dotnet/aspnetcore/issues/5113",
    "createdAt": "2018-12-14T20:14:17Z",
    "lastUpdated": "2020-11-10T00:24:38Z",
    "body": "\u0022Only if supported_response_modes is present in the discovery doc and form_post is listed there, should the RP ever try to use it.  If our RP code is sending response_mode=form_post when the IdP doesn\u2019t support that, that\u2019s a bug in our RP code, and needs to be fixed.\u0022 ~Mike Jones, OIDC spec master\r\n\r\nWarn or fail if the OIDCOptions.ResponseMode value isn\u0027t listed in the discovery doc. Note we default to \u0027form_post\u0027 which isn\u0027t required to be supported in the spec. The spec default is \u0027query\u0027.\r\n\r\nhttps://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#ResponseModes\r\n\r\n@blowdart ",
    "upvotes": 0,
    "labels": [
      "bug",
      "breaking-change",
      "area-auth",
      "severity-nice-to-have",
      "affected-few"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ0NzU2NjA2NQ==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "It\u0027s worth noting that the OIDC middleware uses \u0060response_type=id_token\u0060 by default, which **forces** using \u0060response_type=form_post\u0060 as neither \u0060query\u0060 (forbidden) nor \u0060fragment\u0060 (not applicable to server-side components) are usable in this case.\r\n\r\nThis kind of check would only make sense with the authorization code flow (\u0060response_type=code\u0060), not with implicit or hybrid.",
        "createdAt": "2018-12-15T12:46:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5113#issuecomment-447566065"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ0NzU4MzI4Mw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "That\u0027s why the suggested behavior is to warn or fail, not to downgrade.  This came up when we found a server that didn\u0027t support form_post and resulted in some very odd behavior.",
        "createdAt": "2018-12-15T17:13:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5113#issuecomment-447583283"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ0NzU4NDAxNg==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "My point is that failing sounds dangerous for a default (and de facto almost mandatory) option like \u0060response_mode=form_post\u0060, as an OAuth2/OIDC server doesn\u0027t have to return the list of response modes it supports.\r\n\r\nIf \u0060response_modes_supported\u0060 is missing, a server is assumed to support both \u0060query\u0060 and \u0060fragment\u0060 and nothing else. If you decide to throw, then you may break implementations that support \u0060form_post\u0060 but don\u0027t explicitly disclose it as part of their discovery document or clients that manually create the \u0060OpenIdConnectConfiguration\u0060 instance.",
        "createdAt": "2018-12-15T17:24:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5113#issuecomment-447584016"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ0NzU4NDU3Mg==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E That\u0027s why the suggested behavior is to warn or fail, not to downgrade.\r\n\r\nEven if you wanted to, you couldn\u0027t, as all/most OIDC servers would reject your request if it used an invalid \u0060response_mode\u0060/\u0060response_type\u0060 combination.\r\n\r\n\u003E This came up when we found a server that didn\u0027t support form_post and resulted in some very odd behavior.\r\n\r\nOut of curiosity, what did it do? If an OAuth2/OIDC server doesn\u0027t support the \u0060response_mode\u0060 specified by the client, it should very likely return an explicit error stating a parameter is invalid or not supported.",
        "createdAt": "2018-12-15T17:32:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5113#issuecomment-447584572"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ1MTMwMDY0Mw==",
        "parentId": null,
        "author": "Eilon",
        "content": "Here\u0027s the proposal:\r\n- [ ] We verify the response mode and fail if it is a downgrade\r\n- [ ] The failure message will link to a new doc saying what to do (for example, change the expected mode to the lower mode, or set the flag to restore the old behavior)\r\n- [ ] We add a new option to say to allow downgrades anyway\r\n- [ ] Post an announcement about this breaking change",
        "createdAt": "2019-01-03T22:40:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5113#issuecomment-451300643"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ4MjMyODA2OQ==",
        "parentId": null,
        "author": "Eilon",
        "content": "Moving to backlog because we can\u0027t get this breaking change into preview5.",
        "createdAt": "2019-04-11T21:28:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5113#issuecomment-482328069"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0MDIyMDUzMDY=",
    "title": "ITicketStore from DI",
    "url": "https://github.com/dotnet/aspnetcore/issues/6946",
    "createdAt": "2019-01-23T11:57:54Z",
    "lastUpdated": "2023-10-28T14:09:02Z",
    "body": "Wouldn\u0027t it make sense to resolve the ITicketStore for the cookie handler from DI in the future?",
    "upvotes": 7,
    "labels": [
      "enhancement",
      "area-auth",
      "affected-few",
      "severity-minor",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ1NjgxNTUzMA==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "FYI, it\u0027s been discussed here: https://github.com/aspnet/Security/pull/1719.",
        "createdAt": "2019-01-23T14:12:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6946#issuecomment-456815530"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ1NzgxMjU1OQ==",
        "parentId": null,
        "author": "leastprivilege",
        "content": "I am glad you have the time to search the archives ;)",
        "createdAt": "2019-01-26T08:14:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6946#issuecomment-457812559"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ1NzgzMDk3OA==",
        "parentId": null,
        "author": "brockallen",
        "content": "It would nice to add this. ",
        "createdAt": "2019-01-26T13:26:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6946#issuecomment-457830978"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ2MTYxNTAyNQ==",
        "parentId": null,
        "author": "Eilon",
        "content": "Marking as up-for-grabs in case someone wants to take a crack at this. We don\u0027t currently plan to implement this ourselves, but we\u0027d be open to a collaboration/contribution for this.",
        "createdAt": "2019-02-07T22:14:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6946#issuecomment-461615025"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ2MTY3Mjk3Ng==",
        "parentId": null,
        "author": "crozone",
        "content": "We\u0027re currently implementing a \u0060DbContext\u0060 based implementation of \u0060ITicketStore\u0060, and this requires \u0060ITicketStore\u0060 to be accessible via DI in a \u0060Scoped\u0060 context.\r\n\r\nThe solution should be very similar to the implementation for \u0060services.AddDataProtection().PersistKeysToDbContext\u003CApplicationDbContext\u003E();\u0060, however the \u0060AddCookie()\u0060 extension provides no access to the DI container.\r\n\r\nThe current solution is to use \u0060services.AddOptions\u003CCookieAuthenticationOptions\u003E(CookieAuthenticationDefaults.AuthenticationScheme).Configure\u003CITicketStore\u003E((o, t) =\u003E o.SessionStore = t);\u0060, but we cannot make guarantees about \u0060DbContext\u0060 lifetime. If we discover a cleaner way to do this, I\u0027ll look into submitting a PR.\r\n\r\nEDIT: Our workaround for the \u0060DbContext\u0060 lifetime issue is to have \u0060IServiceProvider\u0060 injected into our implementation of \u0060ITicketStore\u0060, and it creates and manages the necessary scopes internally to safely use \u0060DbContext\u0060. In this way, the lifetime of \u0060ITicketStore\u0060 becomes a non-issue. It\u0027s not pretty, but it works for now. We\u0027ll continue to look into creating a more elegant solution.",
        "createdAt": "2019-02-08T02:49:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6946#issuecomment-461672976"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU0MjE0Nzk0NA==",
        "parentId": null,
        "author": "niklasholm",
        "content": "Also, it would be neat to have some default implementation(s) for \u0060ITicketStore\u0060 available, for example one using \u0060ISession\u0060 to store the data.",
        "createdAt": "2019-10-15T10:30:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6946#issuecomment-542147944"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxMDA0OTI5OQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "FYI this is much improved by https://github.com/dotnet/aspnetcore/pull/19268.\r\n\u0060.AddCookie\u003CMemoryCacheTicketStore\u003E((o, ticketStore) =\u003E o.SessionStore = ticketStore);\u0060",
        "createdAt": "2020-04-06T21:34:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6946#issuecomment-610049299"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxMDA1NjMwNw==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "@Tratcher it only works with singleton services, right?",
        "createdAt": "2020-04-06T21:52:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6946#issuecomment-610056307"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxMDA2ODc1Mw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Correct, but a singleton can inject the IServiceProvider and create its own scope.",
        "createdAt": "2020-04-06T22:24:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6946#issuecomment-610068753"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxMDA3MTg1OA==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "Interesting. Why not adding a \u0060SessionStoreType\u0060 property like what we did for \u0060EventsType\u0060? It works amazingly well.",
        "createdAt": "2020-04-06T22:33:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6946#issuecomment-610071858"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxMDA3NzM0OQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "We can, but it\u0027s never become a priority. The new extensions are a general feature for a general problem.",
        "createdAt": "2020-04-06T22:51:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6946#issuecomment-610077349"
      },
      {
        "id": "IC_kwDOAQzde840yvFS",
        "parentId": null,
        "author": "AnthonyMastrean",
        "content": "\u003E FYI this is much improved by #19268.\r\n\u003E \u0060.AddCookie\u003CMemoryCacheTicketStore\u003E((o, ticketStore) =\u003E o.SessionStore = ticketStore);\u0060\r\n\r\nThese are greatly improved signatures... but don\u0027t these services get resolved from the root service provider? Doesn\u0027t that mean we can\u0027t resolve scoped dependencies in the \u0060ITicketStore\u0060 implementation type? There doesn\u0027t seem to be any way to use the request scope or to create short-lived scopes... is our only option to inject a scope factory and create a instance scope that lives for the lifetime of the store?\r\n\r\n---\r\nUpdate: Oh, I could grab the \u0060IHttpContextAccessor\u0060 and use its service provider.\r\n\r\n\u0060\u0060\u0060csharp\r\nthis.httpContextAccessor.HttpContext.RequestServices.GetRequiredService\u003CWhatever\u003E();\r\n\u0060\u0060\u0060",
        "createdAt": "2021-07-23T15:22:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6946#issuecomment-885715282"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0MDY5OTg5NzY=",
    "title": "Some samples do not work out of box",
    "url": "https://github.com/dotnet/aspnetcore/issues/7288",
    "createdAt": "2019-02-05T22:16:37Z",
    "lastUpdated": "2020-11-10T23:29:04Z",
    "body": "At least the following samples do not work if you do \u0060.\\build.cmd\u0060 move into their directory and do \u0060dotnet run\u0060.\r\n\r\n- [OpenIdConnect.AzureAdSample](https://github.com/aspnet/AspNetCore/tree/master/src/Security/Authentication/OpenIdConnect/samples/OpenIdConnect.AzureAdSample)\r\n- [WsFederation](https://github.com/aspnet/AspNetCore/tree/master/src/Security/Authentication/WsFederation/samples/WsFedSample)\r\n- [OpenIdConnectSample](https://github.com/aspnet/AspNetCore/tree/master/src/Security/Authentication/OpenIdConnect/samples/OpenIdConnectSample)\r\n\r\nThese samples should either be fixed so that an outside user can run them without modification (or if modification is required for config or some such, it should be explicitly called out in the error message), or removed entirely if they no longer serve a purpose.\r\n\r\nMore generally it would be a good idea for us build and test basic functionality of all our samples (IE, index page returns 200) so we can ensure that they are up to date and not misleading to customers.",
    "upvotes": 0,
    "labels": [
      "task",
      "area-auth",
      "affected-few",
      "severity-minor"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ2MDg1MjA5Mg==",
        "parentId": null,
        "author": "Tratcher",
        "content": "I just fixed one issue with the missing launchsettings in https://github.com/aspnet/AspNetCore/pull/7105.\r\n\r\nThe other blocker here is that these scenarios require client secrets, it\u0027s a very bad practice to check those into source control. That also prevents automated testing.\r\n\r\nSome of these samples have explicit config instructions such as https://github.com/aspnet/AspNetCore/blob/b21c09665e868526057dd3785f1d4518359b9a25/src/Security/Authentication/samples/SocialSample/Startup.cs#L51-L56",
        "createdAt": "2019-02-05T23:55:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/7288#issuecomment-460852092"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ2MDg1MzI4Nw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Also, these samples should stay as they make for very good manual verification of the various providers.",
        "createdAt": "2019-02-06T00:01:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/7288#issuecomment-460853287"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ2MTA5NDMxMg==",
        "parentId": null,
        "author": "ryanbrandenburg",
        "content": "Yeah, if you have uses for these by all means keep them. The error message you linked is pretty good, but maybe it could call out specifically where to set that config, or link to docs on the subject?",
        "createdAt": "2019-02-06T16:43:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/7288#issuecomment-461094312"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0MTY5MzU0MDk=",
    "title": "OAuth 2 refresh token support",
    "url": "https://github.com/dotnet/aspnetcore/issues/8175",
    "createdAt": "2019-03-04T18:32:49Z",
    "lastUpdated": "2024-12-16T13:19:39Z",
    "body": "The OAuthHandler class does not provide any option to expire the underlying Cookie ticket upon expiry of the Bearer Token, also it does not have any support for Refresh tokens other than storing the value in AuthenticationProperties.\r\n\r\nI Suggest the following:\r\nAdd a property: bool ExpireUponTokenExpiry to RemoteAuthenticationOptions\r\n\r\nOn authenticating ticket, check this property \r\nif false just return AuthenticateResult.Success upon validating the ticket\r\nif true and bearer token is not expired return AuthenticateResult.Success\r\nif true and bearer token is expired\r\n-\u003E if refresh_token isSet in AuthenticationProperties, Exhange the refresh token for new bearer token through http backchannel,\r\n-\u003E if no refresh_token is set, start a new OAuth authentication flow, with RedirectResult",
    "upvotes": 9,
    "labels": [
      "enhancement",
      "area-auth",
      "severity-major",
      "affected-medium"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ2OTQ3NjgzMA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "The [UseTokenLifetime](https://github.com/aspnet/AspNetCore/blob/39e52578d354a6a7abb3f6169d5ac2174ffe4551/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectOptions.cs#L272) OIDC option already does part of this, tying the cookie lifetime to the token lifetime, though most people don\u0027t like it and have turned it off.\r\n\r\nThe biggest gap in the suggested design is that RemoteAuth.AuthenticateAsync doesn\u0027t run every request, it only runs during sign-in. After sign-in it\u0027s CookieAuth.AuthenticateAsync that runs every request and it doesn\u0027t know about the upstream details.\r\n\r\nThe other big gap is that refresh is not a well standardized behavior for OAuth. I tried it with a few of our common providers and only two out of five were able to share any of their logic. This was my last experiment at refresh: https://github.com/aspnet/AspNetCore/blob/39e52578d354a6a7abb3f6169d5ac2174ffe4551/src/Security/Authentication/samples/SocialSample/Startup.cs\r\n\r\nWe do need to provide better refresh support, but I doubt it would ever be completely automatic. A big reason is concurrency. If you have any parallel requests from the same user they would all start attempting the refresh as soon as the token expired. A better pattern I\u0027ve seen is to only refresh the token when you go to use it. That cuts down the concurrency as you only use that token on a small subset of requests.",
        "createdAt": "2019-03-04T23:58:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/8175#issuecomment-469476830"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ3Njg2Mjc4Mg==",
        "parentId": null,
        "author": "Eilon",
        "content": "Placing in backlog so we can consider in a future version.",
        "createdAt": "2019-03-26T21:37:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/8175#issuecomment-476862782"
      },
      {
        "id": "IC_kwDOAQzde86NFTVn",
        "parentId": null,
        "author": "AdamWyzgol",
        "content": "really still in backlog? since 2019?",
        "createdAt": "2024-09-22T21:41:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/8175#issuecomment-2366977383"
      },
      {
        "id": "IC_kwDOAQzde86N3sg0",
        "parentId": null,
        "author": "halter73",
        "content": "Moving out of backlog for consideration in .NET 10. We could look at [CookieOidcRefresher](https://github.com/dotnet/blazor-samples/blob/dd2f19f5b81e0eba66321eb6ec103d1fdcdbd995/8.0/BlazorWebAppOidcBff/BlazorWebAppOidc/CookieOidcRefresher.cs) for inspiration although that\u0027s specifically for the \u0060OpenIdConnectHandler\u0060 rather than the \u0060OAuthHandler\u0060. It would be nice to add refresh support to both.\r\n\r\nhttps://github.com/dotnet/aspnetcore/issues/55213 is related but even tricker because in the case of Blazor Server interactivity it\u0027s harder to store the refreshed tokens in an updated cookie",
        "createdAt": "2024-09-27T22:09:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/8175#issuecomment-2380187700"
      },
      {
        "id": "IC_kwDOAQzde86S63-j",
        "parentId": null,
        "author": "Fronix",
        "content": "For anyone who keeps returning here hoping for some type of revelation:\n\nhttps://github.com/DuendeSoftware/Duende.AccessTokenManagement has created something that seems to work and has working examples...",
        "createdAt": "2024-11-08T14:30:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/8175#issuecomment-2464907171"
      },
      {
        "id": "IC_kwDOAQzde86S8c5D",
        "parentId": null,
        "author": "josephdecock",
        "content": "Thanks for the shoutout @Fronix! I\u0027m one of the maintainers of Duende.AccessTokenManagement, so I thought I\u0027d chime in. We\u0027re an apache licensed library sponsored by Duende Software for automatically managing access tokens.\n\nIn addition to simple token management, we also have support for DPoP (sender constrained tokens). And we have an extensibility point for storing tokens outside of cookies (especially helpful for [Blazor Server](https://docs.duendesoftware.com/foss/accesstokenmanagement/blazor_server/)).\n\n- Documentation: https://docs.duendesoftware.com/foss/accesstokenmanagement/\n- Sample: https://docs.duendesoftware.com/identityserver/v7/samples/basics/#mvc-client-with-automatic-access-token-management",
        "createdAt": "2024-11-08T17:18:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/8175#issuecomment-2465320515"
      },
      {
        "id": "IC_kwDOAQzde86XtON-",
        "parentId": null,
        "author": "developer9969",
        "content": "@josephdecock  Hi come across this thread and also used in a pluralsight course I have just watched, my question is , is the accesstokenManagment nuget free to use in commercial application?\n",
        "createdAt": "2024-12-16T10:36:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/8175#issuecomment-2545214334"
      },
      {
        "id": "IC_kwDOAQzde86XuwR4",
        "parentId": null,
        "author": "brockallen",
        "content": "\u003E Hi come across this thread and also used in a pluralsight course I have just watched, my question is , is the accesstokenManagment nuget free to use in commercial application?\n\nYes, Apache2.\n\nhttps://www.nuget.org/packages/Duende.AccessTokenManagement\n",
        "createdAt": "2024-12-16T13:19:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/8175#issuecomment-2545615992"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0Mjg5MjIyNjI=",
    "title": "ApiController redirects to login page",
    "url": "https://github.com/dotnet/aspnetcore/issues/9039",
    "createdAt": "2019-04-03T18:53:17Z",
    "lastUpdated": "2025-01-22T18:08:38Z",
    "body": "### Describe the bug\r\nWhen using ASP.NET Identity cookie authentication to protect a API controller that is decorated with the \u0060ApiController\u0060 attribute and performing an unauthorized HTTP request, ASP.NET redirects to /Identity/Account/Login?ReturnUrl=%2Fapi%2FFoo instead of just returning a 401 Unauthorized status code and problem details in JSON format.\r\n\r\n### To Reproduce\r\nSteps to reproduce the behavior:\r\n1. Configure ASP.NET Core to use ASP.NET Identity with default identity and default UI which uses cookies.\r\n2. Create a API controller that you decorate with the \u0060ApiController\u0060 attribute.\r\n3. Perform a HTTP request (Content-Type can even be application/json) against the controller.\r\n\r\nUsing ASP.NET Core 6.0.\r\n\u0060\u0060\u0060cs\r\n[ApiController] // \u003C-- I want this controller to behave like an API. \r\n[Authorize]     // \u003C-- Authenticate using cookies.\r\n[Route(\u0022api/[controller]\u0022)]\r\npublic class FooController : ControllerBase\r\n{\r\n    [HttpGet]\r\n    public string Get()\r\n    {\r\n        return \u0022string\u0022;\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060cs\r\n// Add services to the container.\r\n/// ...\r\nbuilder.Services.AddDefaultIdentity\u003CIdentityUser\u003E(options =\u003E options.SignIn.RequireConfirmedAccount = true)\r\n    .AddEntityFrameworkStores\u003CApplicationDbContext\u003E();\r\n// ...\r\n\r\n// Configure the HTTP request pipeline.\r\n// ...\r\napp.UseAuthentication();\r\n// ...\r\n\u0060\u0060\u0060\r\n\r\n### Expected behavior\r\nI expected the API to behave as an API since I explicitly decorated the controller with the \u0060ApiController\u0060 attribute.\r\nI expected it to return the status code 401 Unauthorized.\r\nMaybe with a link to: https://httpstatuses.com/401\r\n\r\n### Additional context\r\nMy SPA authenticates using cookie authentication then uses \u0060fetch()\u0060 to do HTTP requests against the API. The fetch call sets the \u0060credentials\u0060 option to include cookies with the request.",
    "upvotes": 86,
    "labels": [
      "enhancement",
      "area-auth",
      "severity-major",
      "affected-medium"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ3OTY2NzI5Nw==",
        "parentId": null,
        "author": "blowdart",
        "content": "Override the cookie authentication events.\r\n\r\nAs you\u0027re also using identity, it\u0027d be something like\r\n\r\n\u0060\u0060\u0060c#\r\nservices.ConfigureApplicationCookie(o =\u003E\r\n        {\r\n            o.Events = new CookieAuthenticationEvents()\r\n            {\r\n                OnRedirectToLogin = (ctx) =\u003E\r\n                {\r\n                    if (ctx.Request.Path.StartsWithSegments(\u0022/api\u0022) \u0026\u0026 ctx.Response.StatusCode == 200)\r\n                    {\r\n                        ctx.Response.StatusCode = 401;\r\n                    }\r\n\r\n                    return Task.CompletedTask;\r\n                },\r\n                OnRedirectToAccessDenied = (ctx) =\u003E\r\n                {\r\n                    if (ctx.Request.Path.StartsWithSegments(\u0022/api\u0022) \u0026\u0026 ctx.Response.StatusCode == 200)\r\n                    {\r\n                        ctx.Response.StatusCode = 403;\r\n                    }\r\n\r\n                    return Task.CompletedTask;\r\n                }\r\n            };\r\n        });\r\n\u0060\u0060\u0060",
        "createdAt": "2019-04-03T21:33:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-479667297"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ3OTc0NzI1Mg==",
        "parentId": null,
        "author": "pranavkm",
        "content": "cc @DamianEdwards and @davidfowl since this is similar to the diagnostics \\ error handling that you recently investigated.",
        "createdAt": "2019-04-04T04:40:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-479747252"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ3OTgxMzE5Ng==",
        "parentId": null,
        "author": "vanillajonathan",
        "content": "Thank you @blowdart for the workaround.\r\n\r\nI still think that controllers intended for use as APIs and explicitly decorated with the \u0060ApiController\u0060 should return a status code (possibly along with JSON) instead of redirecting though.",
        "createdAt": "2019-04-04T09:00:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-479813196"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ3OTk4MTI0MQ==",
        "parentId": null,
        "author": "blowdart",
        "content": "That\u0027s an interesting idea @vanillajonathan. That responsibility lies outside of the authentication pieces, and in MVC, so I\u0027ll demure to @rynowak  et al for that.",
        "createdAt": "2019-04-04T17:01:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-479981241"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ4MTc3MjA2MQ==",
        "parentId": null,
        "author": "danroth27",
        "content": "@glennc ",
        "createdAt": "2019-04-10T16:51:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-481772061"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ4NDM3OTY5OQ==",
        "parentId": null,
        "author": "TanvirArjel",
        "content": "@vanillajonathan Actually this is happening due to a complete miss-design of introducing Razor Page Identity in the MVC application. And they are sticking to this miss-design and trying to fit this in everywhere. **In Angular application they are providing login page from Razor Page Identity. How comical is this! :)** What will happen if my Client App and API are in two different apps? \r\n\r\nThis hodgepodge would not have happened if they didn\u0027t introduce Razor Page Identity in the MVC application. By the way, I completely hate this Razor Page Identity in an MVC application and I am fully irritated with this.",
        "createdAt": "2019-04-18T06:56:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-484379699"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ4OTMxODU1MA==",
        "parentId": null,
        "author": "huysentruitw",
        "content": "\u002B1 Would be great if we could stop using that workaround suggested by @blowdart. I lost the count in how many applications I\u0027ve added that piece of code.",
        "createdAt": "2019-05-04T11:26:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-489318550"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMTY2NDQwMQ==",
        "parentId": null,
        "author": "RemiBou",
        "content": "If you send the head \u0022X-Requested-With: XMLHttpRequest\u0022 the redirection is not done and only 401 is send cf https://github.com/aspnet/AspNetCore/blob/master/src/Security/Authentication/Cookies/src/CookieAuthenticationEvents.cs.\r\n\r\nI tried it with a Blazor client-side app and it is working",
        "createdAt": "2019-06-13T11:31:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-501664401"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMTY3NjYyMw==",
        "parentId": null,
        "author": "vanillajonathan",
        "content": "Thank you @RemiBou, I was not aware of that. I just did a plain fetch request without setting any additional HTTP headers.\r\n\r\nA thing to take into consideration is that ASP.NET Core MVC no longer have the \u0060IsAjaxRequest\u0060 method that was present in the old ASP.NET MVC 5, so arguably have been moving away from the \u0060X-Requested-With\u0060 header which is a non-standard (but de facto standard) used by jQuery (and some other JavaScript frameworks and libraries).\r\n\r\nAnother thing to note is that I believe including the \u0060X-Requested-With\u0060 header would or could trigger an additional CORS preflight request.",
        "createdAt": "2019-06-13T12:13:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-501676623"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMTY3OTA4Mw==",
        "parentId": null,
        "author": "RemiBou",
        "content": "Why do you think the headers won\u0027t change the CORS preflight ? ",
        "createdAt": "2019-06-13T12:21:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-501679083"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMTcyMDYyMA==",
        "parentId": null,
        "author": "vanillajonathan",
        "content": "My understanding is that adding non-standard HTTP headers to a fetch causes it perform a CORS preflight request.\r\n\r\n\u003E Why do you think the headers won\u0027t change the CORS preflight ?\r\n\r\nSee:\r\nhttps://developers.google.com/web/ilt/pwa/working-with-the-fetch-api#example_post_requests\r\n\u003E The server in this example would need to be configured to accept the X-Custom-Header header in order for the fetch to succeed. When a custom header is set, the browser performs a preflight check. This means that the browser first sends an OPTIONS request to the server to determine what HTTP methods and headers are allowed by the server. \r\n",
        "createdAt": "2019-06-13T14:13:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-501720620"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxNzI0NDE0NA==",
        "parentId": null,
        "author": "Bernoulli-IT",
        "content": "@blowdart solution doesn\u0027t work in .NET Core 3.x (preview) anymore. I tried a ton of different approaches but can\u0027t seem to find a working solution. Annoying. A Web API project redirecting \u0022automagically\u0022 (huge design mistake) to a login page which does not exist and therefore ends up in returning a 404 (Not Found) whilst actually the request was UnAuthenticated (which should be the real name of 401 UnAuthorized. Authentication -\u003E Who are you? And do you have a valid login with password? Authorization -\u003E Hey we know you, welcome! But do you have the right to perform this request? Well let\u0027s see which you roles / claims you own.\r\n\r\nConcerning the flaw in design I agree with @TanvirArjel completely.",
        "createdAt": "2019-08-01T11:29:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-517244144"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxNzI1MzI4Mw==",
        "parentId": null,
        "author": "Bernoulli-IT",
        "content": "I just found a solution and described it [here](https://stackoverflow.com/a/57308458/468910) it was this [SO answer](https://stackoverflow.com/a/46979590/468910) which brought light.",
        "createdAt": "2019-08-01T11:55:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-517253283"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU0MjI0OTg2MQ==",
        "parentId": null,
        "author": "voroninp",
        "content": "@Bernoulli-IT, well, I have this issue even for Bearer auth in ASP.NET Core 3\r\n\r\n\u0060\u0060\u0060CSharp\r\nservices\r\n    .AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\r\n    .AddJwtBearer(opt =\u003E\r\n    {\r\n        opt.TokenValidationParameters = new TokenValidationParameters\r\n        {\r\n            ClockSkew = TimeSpan.FromMinutes(5),\r\n            RequireSignedTokens = true,\r\n            RequireExpirationTime = true,\r\n            ValidateLifetime = true,\r\n            ValidateAudience = false,\r\n            ValidIssuer = issuer,\r\n            IssuerSigningKey = new X509SecurityKey(certificate),\r\n            ValidateIssuerSigningKey = true,\r\n            NameClaimType = \u0022sub\u0022\r\n        };\r\n        opt.IncludeErrorDetails = true;\r\n    });\r\n\u0060\u0060\u0060\r\nAnd I saw a redirect instead of 401 for the controller marked as \u0060ApiController\u0060 \r\n\r\n\u003E icrosoft.AspNetCore.Hosting.Diagnostics: Information: Request starting HTTP/1.1 GET http://localhost:53775/identity/api/claims/158f6e60-cab9-47a2-9e91-7b124c45945b  \r\nMicrosoft.AspNetCore.HostFiltering.HostFilteringMiddleware: Trace: All hosts are allowed.\r\nMicrosoft.AspNetCore.StaticFiles.StaticFileMiddleware: Debug: The request path  does not match the path filter\r\nMicrosoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler: Debug: AuthenticationScheme: __idsrv was not authenticated.__\r\nMicrosoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler: Debug: AuthenticationScheme: __idsrv was not authenticated.__\r\nIdentityServer4.Hosting.EndpointRouter: Trace: No endpoint entry found for request path: /api/claims/158f6e60-cab9-47a2-9e91-7b124c45945b\r\nMicrosoft.AspNetCore.Routing.Matching.DfaMatcher: Debug: 1 candidate(s) found for the request path \u0027/api/claims/158f6e60-cab9-47a2-9e91-7b124c45945b\u0027\r\nMicrosoft.AspNetCore.Routing.Matching.DfaMatcher: Debug: Endpoint \u0027Luscii.Identity.Service.Controllers.ClaimController.Get (Luscii.Identity.Service)\u0027 with route pattern \u0027api/claims/{connectId}\u0027 is valid for the request path \u0027/api/claims/158f6e60-cab9-47a2-9e91-7b124c45945b\u0027\r\nMicrosoft.AspNetCore.Routing.EndpointRoutingMiddleware: Debug: Request matched endpoint \u0027Luscii.Identity.Service.Controllers.ClaimController.Get (Luscii.Identity.Service)\u0027\r\nMicrosoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler: Debug: AuthenticationScheme: __idsrv was not authenticated.__\r\nMicrosoft.AspNetCore.Authorization.DefaultAuthorizationService: Information: Authorization failed.\r\nMicrosoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler: Information: AuthenticationScheme: __idsrv was challenged.__\r\nMicrosoft.AspNetCore.Hosting.Diagnostics: Information: Request finished in 440.71200000000005ms 302 \r\nMicrosoft.AspNetCore.Server.IIS.Core.IISHttpServer: Debug: Connection ID \u002218230571301796315137\u0022 disconnecting.\r\nMicrosoft.AspNetCore.Hosting.Diagnostics: Information: Request starting HTTP/1.1 GET http://localhost:53775/identity/Account/Login?ReturnUrl=%2Fidentity%2Fapi%2Fclaims%2F158f6e60-cab9-47a2-9e91-7b124c45945b  \r\nMicrosoft.AspNetCore.HostFiltering.HostFilteringMiddleware: Trace: All hosts are allowed.\r\nMicrosoft.AspNetCore.StaticFiles.StaticFileMiddleware: Debug: The request path  does not match the path filter\r\nMicrosoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler: Debug: AuthenticationScheme: __idsrv was not authenticated.__\r\nMicrosoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler: Debug: AuthenticationScheme: __idsrv was not authenticated.__\r\nIdentityServer4.Hosting.EndpointRouter: Trace: No endpoint entry found for request path: /Account/Login\r\nMicrosoft.AspNetCore.Routing.Matching.DfaMatcher: Debug: No candidates found for the request path \u0027/Account/Login\u0027\r\nMicrosoft.AspNetCore.Routing.EndpointRoutingMiddleware: Debug: Request did not match any endpoints\r\nMicrosoft.AspNetCore.Authentication.Cookies.CookieAuthenticationHandler: Debug: AuthenticationScheme: __idsrv was not authenticated.__\r\nMicrosoft.AspNetCore.Hosting.Diagnostics: Information: Request finished in 117.48580000000001ms 404 \r\n\r\n\r\nBut what was really suspicious is \u0060idsrv\u0060 scheme. It appeared, that I was adding (!!!) bearer as default auth scheme (I use \u0060[Authorize]\u0060 without specifying scheme), and only then I was adding \u0060IdentityServer\u0060 services where default auth scheme gets silently overridden.\r\n\r\nWhen I changed the order of services registration, 401 was returned instead of redirect.\r\n\r\nRedirect happens.\r\n\u0060\u0060\u0060CSharp\r\nAddJwtAuthentication(services);\r\nAddIdentityServer(services);\r\n\u0060\u0060\u0060\r\n\r\n401 is returned\r\n\u0060\u0060\u0060CSharp\r\nAddIdentityServer(services);\r\nAddJwtAuthentication(services);\r\n\u0060\u0060\u0060\r\n\r\n__I would like to see warnings, if default scheme changes multiple times.__\r\n\r\nMaybe @leastprivilege and @brockallen are willing to comment on this as well.",
        "createdAt": "2019-10-15T14:46:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-542249861"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2Njc4Mjc0Mg==",
        "parentId": null,
        "author": "altretya-microsoft",
        "content": "I don\u0027t need to use IdentityServer.\r\nThis is what worked for me:\r\n\u0060\u0060\u0060\r\nservices\r\n.AddAuthentication()\r\n.AddOpenIdConnect()\r\n.AddJwtBearer()\r\n.AddCookie(options =\u003E\r\n   {\r\n           options.Events.OnRedirectToAccessDenied =\r\n           options.Events.OnRedirectToLogin = c =\u003E\r\n                {\r\n                   c.Response.StatusCode = StatusCodes.Status401Unauthorized;\r\n                   return Task.FromResult\u003Cobject\u003E(null);\r\n                };\r\n    });\r\n\u0060\u0060\u0060",
        "createdAt": "2019-12-17T22:43:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-566782742"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU3NzM5NzE5MQ==",
        "parentId": null,
        "author": "baselbj",
        "content": "The framework is great but when I start working with security it is a total miss this is what make me avoid asp .net for many years ... you need so much workarounds to accomplish your work. \r\n\r\nI think specially the Security part in asp .net should be re designed is there any alternative to it?",
        "createdAt": "2020-01-22T21:36:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-577397191"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU5MDkxODM2OA==",
        "parentId": null,
        "author": "raspyweather",
        "content": "Hi there!\r\nI just wasted way too much time on this issue. In my case, depending on which the configuration of the project, Authentification is necessary or not etc., and I don\u0027t use IdentityServer etc.\r\n\r\n#### I was using netcore3.1 \r\n\r\n\u0060\u0060\u0060\r\n// you have to assign any scheme, not assigning a scheme doesn\u0027t throw but also doesn\u0027t work\r\napp.AddAuthentication(options =\u003E\r\n                {\r\n                    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\r\n                    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\r\n                })\r\n// necessary, even if you don\u0027t use BearerAuth.\r\n.AddJwtBearer();\r\n\u0060\u0060\u0060\r\n\r\n\r\n\u0060\u0060\u0060\r\n           app.UseRouting();\r\n\r\n            // UseAuthentification \u0026 UseAuthorization must be called after Routing and before Endpoints!\r\n            app.UseAuthentication();\r\n            app.UseAuthorization();\r\n\r\n            app.UseEndpoints(...);\r\n\u0060\u0060\u0060\r\n\r\nFor standalone operation without Authentification, you need to write a class and implement \u0060\u0060\u0060IAuthorizationService\u0060\u0060\u0060 and return \u0060\u0060\u0060AuthorizationResult.Success()\u0060\u0060\u0060 in every case.\r\nOf course, you need to add the service manually to services (e.g. with AddTransient).\r\n\r\nEither way, it took way too long to get my backend working. To me, there\u0027s a huge usability problem for developers because the default behavior isn\u0027t really expectable and there\u0027s not really much helpful documentation out there. Due to AspNetCore being OpenSource at least, I was able to somewhat try and guess how to get it working.",
        "createdAt": "2020-02-25T15:17:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-590918368"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyOTYxNzAyNQ==",
        "parentId": null,
        "author": "iamNCJ",
        "content": "\u003E I don\u0027t need to use IdentityServer.\r\n\u003E This is what worked for me:\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E services\r\n\u003E .AddAuthentication()\r\n\u003E .AddOpenIdConnect()\r\n\u003E .AddJwtBearer()\r\n\u003E .AddCookie(options =\u003E\r\n\u003E    {\r\n\u003E            options.Events.OnRedirectToAccessDenied =\r\n\u003E            options.Events.OnRedirectToLogin = c =\u003E\r\n\u003E                 {\r\n\u003E                    c.Response.StatusCode = StatusCodes.Status401Unauthorized;\r\n\u003E                    return Task.FromResult\u003Cobject\u003E(null);\r\n\u003E                 };\r\n\u003E     });\r\n\u003E \u0060\u0060\u0060\r\n\r\n\uD83D\uDC4DSuppressed redirecting using this method. Nice!",
        "createdAt": "2020-05-16T09:32:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-629617025"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyOTc4MDYzMw==",
        "parentId": null,
        "author": "Trolldemorted",
        "content": "@RemiBou unfortunately I cannot reproduce that setting the \u0060X-Requested-With: XMLHttpRequest\u0060 header causes a 401. I have created a fresh \u0022ASP.NET Core Web Application\u0022 project (the \u0022ASP.NET Core Web API\u0022 template) and applied this diff:\r\n\r\n\u0060\u0060\u0060diff\r\nindex 0e4d663..f7dade8 100644\r\n--- a/NoRedirectForXHRTest/Controllers/WeatherForecastController.cs\r\n\u002B\u002B\u002B b/NoRedirectForXHRTest/Controllers/WeatherForecastController.cs\r\n@@ -1,4 \u002B1,5 @@\r\n-\u003CEF\u003E\u003CBB\u003E\u003CBF\u003Eusing Microsoft.AspNetCore.Mvc;\r\n\u002B\u003CEF\u003E\u003CBB\u003E\u003CBF\u003Eusing Microsoft.AspNetCore.Authorization;^M\r\n\u002Busing Microsoft.AspNetCore.Mvc;^M\r\n using Microsoft.Extensions.Logging;\r\n using System;\r\n using System.Collections.Generic;\r\n@@ -7,6 \u002B8,7 @@ using System.Threading.Tasks;\r\n\r\n namespace NoRedirectForXHRTest.Controllers\r\n {\r\n\u002B    [Authorize]^M\r\n     [ApiController]\r\n     [Route(\u0022[controller]\u0022)]\r\n     public class WeatherForecastController : ControllerBase\r\ndiff --git a/NoRedirectForXHRTest/Startup.cs b/NoRedirectForXHRTest/Startup.cs\r\nindex e1960f1..16ffd18 100644\r\n--- a/NoRedirectForXHRTest/Startup.cs\r\n\u002B\u002B\u002B b/NoRedirectForXHRTest/Startup.cs\r\n@@ -1,3 \u002B1,4 @@\r\n\u002Busing Microsoft.AspNetCore.Authentication.Cookies;^M\r\n using Microsoft.AspNetCore.Builder;\r\n using Microsoft.AspNetCore.Hosting;\r\n using Microsoft.AspNetCore.Mvc;\r\n@@ -24,7 \u002B25,9 @@ namespace NoRedirectForXHRTest\r\n         // This method gets called by the runtime. Use this method to add services to the container.\r\n         public void ConfigureServices(IServiceCollection services)\r\n         {\r\n-\r\n\u002B            services.AddAuthentication(options =\u003E^M\r\n\u002B                options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme)^M\r\n\u002B                .AddCookie();^M\r\n             services.AddControllers();\r\n         }\r\n\u0060\u0060\u0060\r\n\r\nWhen I query the forecast controller with curl and the header set, I get redirected to the (not existing) loginpage:\r\n\u0060\u0060\u0060\r\n~$ curl -X GET \u0022http://localhost:5000/weatherforecast\u0022  -v -H \u0022X-Requested-With: XMLHttpRequest\u0022\r\nNote: Unnecessary use of -X or --request, GET is already inferred.\r\n*   Trying 127.0.0.1:5000...\r\n* TCP_NODELAY set\r\n* Connected to localhost (127.0.0.1) port 5000 (#0)\r\n\u003E GET /weatherforecast HTTP/1.1\r\n\u003E Host: localhost:5000\r\n\u003E User-Agent: curl/7.68.0\r\n\u003E Accept: */*\r\n\u003E X-Requested-With: XMLHttpRequest\r\n\u003E\r\n* Mark bundle as not supporting multiuse\r\n\u003C HTTP/1.1 401 Unauthorized\r\n\u003C Date: Wed, 18 Nov 2020 16:02:06 GMT\r\n\u003C Server: Kestrel\r\n\u003C Content-Length: 0\r\n\u003C Location: http://localhost:5000/Account/Login?ReturnUrl=%2Fweatherforecast\r\n\u003C\r\n* Connection #0 to host localhost left intact\r\n\u0060\u0060\u0060\r\n\r\nAm I missing something obvious? The header is parsed correctly, a test controller like this echos \u0022foobar true\u0022:\r\n\u0060\u0060\u0060\r\n[HttpGet]\r\npublic ActionResult Test()\r\n{\r\n    var foo = string.Equals(HttpContext.Request.Query[HeaderNames.XRequestedWith], \u0022XMLHttpRequest\u0022, StringComparison.Ordinal) ||\r\n        string.Equals(HttpContext.Request.Headers[HeaderNames.XRequestedWith], \u0022XMLHttpRequest\u0022, StringComparison.Ordinal);\r\n    return Ok($\u0022foobar {foo}\u0022);\r\n}\r\n\u0060\u0060\u0060",
        "createdAt": "2020-11-18T16:06:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-729780633"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczMDM5ODUzMg==",
        "parentId": null,
        "author": "vanillajonathan",
        "content": "Maybe if we patch the file [\u0060CookieAuthenticationEvents.cs\u0060](https://github.com/dotnet/aspnetcore/blob/master/src/Security/Authentication/Cookies/src/CookieAuthenticationEvents.cs#L41) file:\r\n\r\nChecking if the \u0060Accept\u0060 request header contains \u0022application/json\u0022.\r\n\u0060\u0060\u0060diff\r\n        /// \u003Csummary\u003E\r\n        /// Invoked when the client needs to be redirected to the sign in url.\r\n        /// \u003C/summary\u003E\r\n        public Func\u003CRedirectContext\u003CCookieAuthenticationOptions\u003E, Task\u003E OnRedirectToLogin { get; set; } = context =\u003E\r\n        {\r\n\u002B           if (context.Request.Headers.TryGetValue(HeaderNames.Accept, out StringValues accept) \u0026\u0026 accept.Any(x =\u003E x.Contains(\u0022application/json\u0022)))\r\n\u002B           {\r\n\u002B               context.Response.StatusCode = 401;\r\n\u002B               return Task.CompletedTask;\r\n\u002B           }\r\n            if (IsAjaxRequest(context.Request))\r\n            {\r\n                context.Response.Headers[HeaderNames.Location] = context.RedirectUri;\r\n                context.Response.StatusCode = 401;\r\n            }\r\n            else\r\n            {\r\n                context.Response.Redirect(context.RedirectUri);\r\n            }\r\n            return Task.CompletedTask;\r\n        };\r\n\u0060\u0060\u0060\r\n\r\nOr by checking if the path starts with \u0060/api/\u0060:\r\n\r\n\u0060\u0060\u0060diff\r\n        /// \u003Csummary\u003E\r\n        /// Invoked when the client needs to be redirected to the sign in url.\r\n        /// \u003C/summary\u003E\r\n        public Func\u003CRedirectContext\u003CCookieAuthenticationOptions\u003E, Task\u003E OnRedirectToLogin { get; set; } = context =\u003E\r\n        {\r\n\u002B           if (context.Request.Path.StartsWithSegments(\u0022/api\u0022))\r\n\u002B           {\r\n\u002B               context.Response.StatusCode = 401;\r\n\u002B               return Task.CompletedTask;\r\n\u002B           }\r\n            if (IsAjaxRequest(context.Request))\r\n            {\r\n                context.Response.Headers[HeaderNames.Location] = context.RedirectUri;\r\n                context.Response.StatusCode = 401;\r\n            }\r\n            else\r\n            {\r\n                context.Response.Redirect(context.RedirectUri);\r\n            }\r\n            return Task.CompletedTask;\r\n        };\r\n\u0060\u0060\u0060\r\n\r\n@blowdart, @rynowak, @DamianEdwards, @davidfowl, @glennc, @pranavkm, @mkArtakMSFT ",
        "createdAt": "2020-11-19T14:06:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-730398532"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczNTY5NDM2MA==",
        "parentId": null,
        "author": "vanillajonathan",
        "content": "Hey @blowdart, @rynowak, @DamianEdwards, @davidfowl, @glennc, @pranavkm, @mkArtakMSFT\r\nWhat do you think of the patch above? Does it look reasonable? Can this be a way forward?",
        "createdAt": "2020-11-30T10:20:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-735694360"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczNTc2NTQ5Ng==",
        "parentId": null,
        "author": "huysentruitw",
        "content": "In my opinion, both proposals are too application specific.\r\n\r\n1. What if it\u0027s a static translation json file or static sensitive json data that needs a redirect to login?\r\n2. I can imagine not everyone uses the \u0060/api\u0060 prefix, it would be too much magic.\r\n\r\nI wonder why the \u0060IsAjaxRequest\u0060 check isn\u0027t sufficient for your application?",
        "createdAt": "2020-11-30T12:47:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-735765496"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczNTc3Mjg2NQ==",
        "parentId": null,
        "author": "vanillajonathan",
        "content": "Good points.\r\n\r\nI use \u0060fetch\u0060 in JavaScript and by default it does not include the non-standard \u0060X-Requested-With\u0060 header. See also: https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-501720620",
        "createdAt": "2020-11-30T13:03:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-735772865"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczOTEzODA0MA==",
        "parentId": null,
        "author": "huysentruitw",
        "content": "At some point you\u0027ll need to wrap the calls to \u0060fetch\u0060 in your own method where you would also handle the 401 that comes back. Otherwise, you\u0027ll have to handle the 401 at all places, am I correct?\r\n\r\nOnce you have that wrapping method, it\u0027s easy to include the de-facto \u0060X-Requested-With\u0060 which isn\u0027t going away anytime soon IMO. \uD83D\uDE42",
        "createdAt": "2020-12-05T07:13:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-739138040"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc0NTIxNTYyNA==",
        "parentId": null,
        "author": "whSwitching",
        "content": "yes I want RedirectToLogin on View Controller and 401 on Api Controller",
        "createdAt": "2020-12-15T11:00:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-745215624"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc0NjQxNzE5NA==",
        "parentId": null,
        "author": "gobyn",
        "content": "You can also specify the AuthenticationScheme on the controller attribute like this:\r\n\r\n\u0060[Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]\u0060",
        "createdAt": "2020-12-16T14:52:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-746417194"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc0NzM3NTczMg==",
        "parentId": null,
        "author": "vanillajonathan",
        "content": "It would make sense for the \u0060ApiController\u0060 attribute to adjust this behavior, but looking at [\u0060CookieAuthenticationHandler.cs\u0060](/dotnet/aspnetcore/blob/master/src/Security/Authentication/Cookies/src/CookieAuthenticationHandler.cs), [\u0060SignInAuthenticationHandler.cs\u0060](/dotnet/aspnetcore/blob/master/src/Security/Authentication/Core/src/SignInAuthenticationHandler.cs), and [\u0060AuthenticationHandler.cs\u0060](/dotnet/aspnetcore/blob/master/src/Security/Authentication/Core/src/AuthenticationHandler.cs) I have found no obvious way of doing so, I was looking for references to \u0022controller\u0022 so I could determine if it was decorated with the \u0060ApiController\u0060 attribute.",
        "createdAt": "2020-12-17T11:13:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-747375732"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc0NzM5MTM4NQ==",
        "parentId": null,
        "author": "whSwitching",
        "content": "allright, I just did it by myself,  I just want a simple different authorize on webapi\r\n\r\n\u0060\u0060\u0060\r\n[AllowAnonymous]\r\n[Route(\u0022connect/token\u0022)]\r\n[ApiController]\r\npublic class TokenController: ControllerBase\r\n{\r\n    // issue access_token, asymmetric encryption, or save something in db\r\n}\r\n\r\n[ApiAuthorize]\r\n[Route(\u0022api/[controller]\u0022)]\r\n[ApiController]\r\npublic class ValuesController: ControllerBase\r\n{\r\n    // protected api controller\r\n}\r\n\r\npublic class ApiAuthorizeAttribute : Attribute, IAuthorizationFilter, IFilterFactory\r\n{\r\n    private AppDbContext _db;\r\n    public bool IsReusable =\u003E false;\r\n    public string AuthenticationSchemes { get; set; }\r\n    public string Policy { get; set; }\r\n    public string Roles { get; set; }\r\n\r\n    public IFilterMetadata CreateInstance(IServiceProvider serviceProvider)\r\n    {\r\n        return new ApiAuthorizeAttribute()\r\n        {\r\n            _db = (AppDbContext)serviceProvider.GetService(typeof(AppDbContext));\r\n        };\r\n    }\r\n\r\n    public void OnAuthorization(AuthorizationFilterContext context)\r\n    {\r\n        // check Authorization header\r\n        if (context.HttpContext.Request.Headers.ContainsKey(\u0022Authorization\u0022))\r\n        {\r\n            var authHeader = context.HttpContext.Request.Headers[\u0022Authorization\u0022][0];\r\n            // validate access_token you just issued\r\n            // check token expiration\r\n            // check token identity valid\r\n            // check AuthenticationSchemes\r\n            // check Policy\r\n            // check Roles\r\n            if ( all pass )\r\n                return;\r\n        }\r\n        context.Result = new Microsoft.AspNetCore.Mvc.UnauthorizedResult();\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "createdAt": "2020-12-17T11:47:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-747391385"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1Njk5NDYxMw==",
        "parentId": null,
        "author": "RoySalisbury",
        "content": "It was not mentioned, but you can also use the ForbidResult and specify the authentication scheme.  So if your API is using Bearer tokens, just use Forbid(\u0022Bearer\u0022);  You wont get redirected.  \r\n\r\n\u0060\u0060\u0060\r\n[ApiController, Authorize(\u0022Bearer\u0022)]\r\npublic class MyApiController : ControllerBase\r\n{\r\n  public IActionResult TestMethod()\r\n  {\r\n     if (DoSpecialPermissionCheckAfterAuthentication() == false)\r\n    {\r\n      return Forbid(\u0022Bearer\u0022);\r\n    }\r\n\r\n    return Ok;\r\n  }\r\n}\r\n\r\n\u0060\u0060\u0060\r\nIt does not return the same json object as StatusCode(403), but it does not redirect to the cookies login page.\r\n\r\nRoy",
        "createdAt": "2021-01-08T20:57:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-756994613"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3MzQwODc3Mg==",
        "parentId": null,
        "author": "benm-eras",
        "content": "I found that @raspyweather\u0027s [suggestion ](https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-590918368) above worked for me in .NET 5 hosted Blazor Web Assembly (without identity server). Specifically setting the default auth and challenge schemes:\r\n\r\n\u0060\u0060\u0060\r\nservices\r\n    .AddAuthentication(o =\u003E {\r\n        o.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\r\n        o.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\r\n    })\r\n    .AddJwtBearer(o =\u003E o.TokenValidationParameters = new TokenValidationParameters() {\r\n        ValidateIssuer = true,\r\n        ValidateAudience = true,\r\n        ValidateLifetime = true,\r\n        ValidateIssuerSigningKey = true,\r\n        ValidIssuer = this.configuration[\u0022JWT:Issuer\u0022],\r\n        ValidAudience = this.configuration[\u0022JWT:Audience\u0022],\r\n        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(this.configuration[\u0022JWT:Key\u0022])),\r\n    })\r\n\u0060\u0060\u0060\r\nPreviously I simply had \u0060services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(//jwt sfuff)\u0060 which resulted in a 302 redirect to a non-existent login page, but changing to the above means I now get the desired 401.\r\n\r\nIf any one stumbling upon this needs a guide to API auth with hosted Blazor WASM without the rather confusing identity server implementation in the standard template I can\u0027t recommend this enough: \r\n\r\nhttps://chrissainty.com/securing-your-blazor-apps-authentication-with-clientside-blazor-using-webapi-aspnet-core-identity/ ",
        "createdAt": "2021-02-04T15:50:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-773408772"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3OTE3NTkyNg==",
        "parentId": null,
        "author": "deinok",
        "content": "Adding my fix:\r\n\r\n\u0060\u0060\u0060\r\napplicationBuilder.UseRouting();\r\n\r\napplicationBuilder.Use(async (httpContext, func) =\u003E {\r\n    var apiMode = httpContext.Request.Path.StartsWithSegments(\u0022/api\u0022) ||\r\n\t    httpContext.Request.Path.StartsWithSegments(\u0022/odata\u0022);\r\n    if (apiMode)\r\n    {\r\n        httpContext.Request.Headers[HeaderNames.XRequestedWith] = \u0022XMLHttpRequest\u0022;\r\n    }\r\n    await func();\r\n});\r\n\r\napplicationBuilder.UseAuthentication();\r\n\r\napplicationBuilder.UseAuthorization();\r\n\u0060\u0060\u0060",
        "createdAt": "2021-02-15T12:00:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-779175926"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc4MDIwOTU1MQ==",
        "parentId": null,
        "author": "GeorgeTsiokos",
        "content": "Just ran in to this bug. Easy fix, correct the \u0060IsAjaxRequest\u0060 method:\r\n\u0060\u0060\u0060c#\r\nprivate static bool IsAjaxRequest(HttpRequest request)\r\n            =\u003E string.Equals(request.Headers[\u0022Sec-Fetch-Mode\u0022], \u0022cors\u0022, StringComparison.Ordinal) || \r\n               // legacy\r\n               string.Equals(request.Query[HeaderNames.XRequestedWith], \u0022XMLHttpRequest\u0022, StringComparison.Ordinal) ||\r\n               string.Equals(request.Headers[HeaderNames.XRequestedWith], \u0022XMLHttpRequest\u0022, StringComparison.Ordinal);\r\n        }\r\n\u0060\u0060\u0060",
        "createdAt": "2021-02-17T00:35:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-780209551"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0NDQ4MzEzOQ==",
        "parentId": null,
        "author": "yoyos",
        "content": "This problem is still here on .NET 5.0.203.\r\nNone of these solutions have worked except @gobyn to put everywhere [Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)] \r\n\r\nIf you have a better solution somewhere ?",
        "createdAt": "2021-05-19T21:21:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-844483139"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0NDUzNDg3MQ==",
        "parentId": null,
        "author": "GeorgeTsiokos",
        "content": "Another option is to add the header .net is expecting on the client side, as described here: https://stackoverflow.com/a/12533473\n\n",
        "createdAt": "2021-05-19T22:17:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-844534871"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0NjI3ODY4MQ==",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "I think we should fix this for .NET 6. The cookie auth already has its own logic to look for old-school Ajax requests via the jQuery header and we can now update that to look for endpoint metadata too.\r\n\r\nMVC could add new metadata to \u0060[ApiController]\u0060 endpoints that signals the desired behavior. If we want it to default to returning a problem details response in these cases (that\u0027d be ideal I think) then we\u0027d need to implement a piece of extensibility that allows MVC to set a callback to be invoked when this metadata is present.\r\n\r\nActually given that \u0060CookieAuthenticationEvents\u0060 already exists as the extensibility point in the authentication middleware, should we just make MVC add a custom one of those that contains all this logic? Although that wouldn\u0027t work for the new Minimal APIs feature so perhaps this needs to be its own callback type (similar to the developer exception page like @pranavkm said).\r\n\r\n@davidfowl ",
        "createdAt": "2021-05-21T21:45:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-846278681"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0NzI5NTMwMg==",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "I started an exploration of this over at https://github.com/DamianEdwards/UnauthorizedApis\r\n\r\nRight now it basically introduces an extensibility point that the cookie auth would look for to delegate redirect behavior to, and MVC and Minimal APIs can hook that point to customize the behavior. This might possibly be over-engineering though.\r\n\r\nSome other ideas worth exploring:\r\n- have the endpoints add a non-dependent metadata like \u0022IPreferJsonResponses\u0022 or \u0022IPreferNoRedirection\u0022 or similar and have the cookie auth behavior use that (along with the existing jQuery Ajax header check) to decide when not to redirect\r\n- wait until the new metadata to drive Swagger/OpenAPI experiences is added to MVC and Minimal APIs and see if that is a better set of markers to have the cookie auth behavior pivot on, e.g. the metadata just existing on an endpoint should indicate it\u0027s an \u0022API\u0022 and thus don\u0027t redirect, or perhaps the return content-type not being HTML, etc.\r\n- ignore the endpoint/resource completely and instead extend the existing logic which is based on what the client is sending and see if that covers the scenarios here, e.g. Accept header not containing HTML or putting JSON before HTML, etc.",
        "createdAt": "2021-05-24T19:55:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-847295302"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg2OTEzNjkxMQ==",
        "parentId": null,
        "author": "2mik",
        "content": "The solution below works correctly with Ajax and seems flexible:\r\n\u0060\u0060\u0060\r\npublic class CustomCookieAuthenticationEvents : CookieAuthenticationEvents\r\n{\r\n    public override Task RedirectToLogin(RedirectContext\u003CCookieAuthenticationOptions\u003E context)\r\n    {\r\n        if (context.Request.Path.StartsWithSegments(\u0022/api\u0022) \u0026\u0026\r\n            context.Response.StatusCode == StatusCodes.Status200OK)\r\n        {\r\n            context.Response.StatusCode = StatusCodes.Status401Unauthorized;\r\n            return Task.CompletedTask;\r\n        }\r\n        else\r\n        {\r\n            return base.RedirectToLogin(context);\r\n        }\r\n    }\r\n\r\n    public override Task RedirectToAccessDenied(RedirectContext\u003CCookieAuthenticationOptions\u003E context)\r\n    {\r\n        if (context.Request.Path.StartsWithSegments(\u0022/api\u0022) \u0026\u0026\r\n            context.Response.StatusCode == StatusCodes.Status200OK)\r\n        {\r\n            context.Response.StatusCode = StatusCodes.Status403Forbidden;\r\n            return Task.CompletedTask;\r\n        }\r\n        else\r\n        {\r\n            return base.RedirectToAccessDenied(context);\r\n        }\r\n    }\r\n}\r\n\r\n\u0060\u0060\u0060\r\n\r\nIn Startup.cs\r\n\u0060\u0060\u0060\r\nservices\r\n    .AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)\r\n    .AddCookie(options =\u003E\r\n    {\r\n        options.Events = new CustomCookieAuthenticationEvents();\r\n    });\r\n\r\n\u0060\u0060\u0060",
        "createdAt": "2021-06-27T10:10:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-869136911"
      },
      {
        "id": "IC_kwDOAQzde843Pkyn",
        "parentId": null,
        "author": "tanveerbadar",
        "content": "This was properly answered by @andrew-vdb in [this](https://github.com/dotnet/aspnetcore/issues/18013#issuecomment-568703715) reply.",
        "createdAt": "2021-09-24T18:14:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-926829735"
      },
      {
        "id": "IC_kwDOAQzde8483cnj",
        "parentId": null,
        "author": "devopg",
        "content": "rly patch this ....\r\namazing magic things. If i ceate webApi use like api, and api recomentate my to go LoginPage? :D \r\n\r\n\u0060\u0060\u0060\r\nbuilder.Services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)\r\n.AddCookie(options =\u003E\r\n    {\r\n        options.Redirect = false;\r\n    });\r\n\u0060\u0060\u0060",
        "createdAt": "2022-01-25T13:10:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1021168099"
      },
      {
        "id": "IC_kwDOAQzde849Ke__",
        "parentId": null,
        "author": "johnwc",
        "content": "For those using Microsoft identity platform.\r\n\r\n\u0060\u0060\u0060CSharp\r\nservices.AddAuthentication(OpenIdConnectDefaults.AuthenticationScheme)\r\n    .AddMicrosoftIdentityWebApp(\r\n    idOptions =\u003E\r\n    {\r\n       ...\r\n    },\r\n    cOptions =\u003E\r\n    {\r\n        #region force api calls to return 401/403 instead of login redirect\r\n        var redirectToLoginHandler = cOptions.Events.OnRedirectToLogin;\r\n        cOptions.Events.OnRedirectToLogin = async (ctx) =\u003E\r\n            {\r\n                if (ctx.Request.Path.StartsWithSegments(\u0022/api\u0022) \u0026\u0026 ctx.Response.StatusCode == StatusCodes.Status200OK)\r\n                {\r\n                    ctx.Response.StatusCode = StatusCodes.Status401Unauthorized;\r\n                    return;\r\n                }\r\n\r\n                await redirectToLoginHandler(ctx).ConfigureAwait(false);\r\n            };\r\n        var redirectToAccessDeniedHandler = cOptions.Events.OnRedirectToAccessDenied;\r\n        cOptions.Events.OnRedirectToAccessDenied = async (ctx) =\u003E\r\n            {\r\n                if (ctx.Request.Path.StartsWithSegments(\u0022/api\u0022) \u0026\u0026 ctx.Response.StatusCode == StatusCodes.Status200OK)\r\n                {\r\n                    ctx.Response.StatusCode = StatusCodes.Status403Forbidden;\r\n                    return;\r\n                }\r\n\r\n                await redirectToAccessDeniedHandler(ctx).ConfigureAwait(false);\r\n            };\r\n        #endregion\r\n    });\r\n\u0060\u0060\u0060",
        "createdAt": "2022-01-31T20:04:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1026158591"
      },
      {
        "id": "IC_kwDOAQzde849MkJN",
        "parentId": null,
        "author": "kieranbenton",
        "content": "Has anyone found a way to do the equivalent for AddIdentityServerAuthentication?\r\n\r\nI\u0027m doing:\r\n\r\n\u0060\u0060\u0060\r\noptions.JwtBearerEvents.OnChallenge = (context) =\u003E\r\n\t\t\t\t{\r\n\t\t\t\t\t// TODO: this gets hit, but does nothing\r\n\t\t\t\t\tcontext.Response.StatusCode = 401;\r\n\t\t\t\t\treturn Task.CompletedTask;\r\n\t\t\t\t};\r\n\u0060\u0060\u0060\r\n\r\nBut as per the TODO - this gets hit and then must get reset later in the pipeline back to a 302 which I\u0027ve not been able to track down.",
        "createdAt": "2022-02-01T10:42:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1026703949"
      },
      {
        "id": "IC_kwDOAQzde84-Bi62",
        "parentId": null,
        "author": "IronSean",
        "content": "I\u0027m disappointed this is still an issue with .Net 6.\r\n\r\nUsing \u0060AddCookie()\u0060 with a custom event handler did not help, I suspect because calling \u0060AddControllers()\u0060 already configures the Authorization internally. From [the source](https://github.com/dotnet/aspnetcore/blob/c85baf8db0c72ae8e68643029d514b2e737c9fae/src/Mvc/Mvc/src/MvcServiceCollectionExtensions.cs#L143) AddControllers is implemented as:\r\n\u0060\u0060\u0060csharp\r\nvar builder = services\r\n            .AddMvcCore()\r\n            .AddApiExplorer()\r\n            .AddAuthorization()\r\n            .AddCors()\r\n            .AddDataAnnotations()\r\n            .AddFormatterMappings();\r\n\r\n        if (MetadataUpdater.IsSupported)\r\n        {\r\n            services.TryAddEnumerable(\r\n                ServiceDescriptor.Singleton\u003CIActionDescriptorChangeProvider, HotReloadService\u003E());\r\n        }\r\n\r\n        return builder;\r\n\u0060\u0060\u0060        \r\n\r\nSo I was going to inline that and customize the Authortization cookie config except HotReloadService is an internal class so I would lose that functionality as well.",
        "createdAt": "2022-02-15T17:51:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1040592566"
      },
      {
        "id": "IC_kwDOAQzde84-B7vL",
        "parentId": null,
        "author": "IronSean",
        "content": "Using \r\n\r\n\u0060\u0060\u0060csharp\r\nbuilder.Services.ConfigureApplicationCookie(o =\u003E\r\n{\r\n    o.Events = new CustomCookieAuthenticationEvents();\r\n});\r\n\u0060\u0060\u0060\r\n\r\nAllows @2mik \u0027s solution (or inlining one of the other workarounds) to work in .Net 6 without needing to inline library methods like I suggested in the last comment.",
        "createdAt": "2022-02-15T19:21:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1040694219"
      },
      {
        "id": "IC_kwDOAQzde84-CF6Y",
        "parentId": null,
        "author": "johnwc",
        "content": "@IronSean you do not want to replace the existing events handler with your own. You would then loose any other events that where registered to it. You need to just register your own event handler for the few things you need to fire on.\r\n\r\n\u0060\u0060\u0060CSharp\r\nbuilder.Services.ConfigureApplicationCookie(o =\u003E\r\n{\r\n    o.Events.OnRedirectToLogin = async (ctx) =\u003E\r\n    {\r\n        if (ctx.Request.Path.StartsWithSegments(\u0022/api\u0022) \u0026\u0026 ctx.Response.StatusCode == StatusCodes.Status200OK)\r\n        {\r\n            ctx.Response.StatusCode = StatusCodes.Status401Unauthorized;\r\n            return;\r\n        }\r\n\r\n        await redirectToLoginHandler(ctx).ConfigureAwait(false);\r\n    };\r\n    var redirectToAccessDeniedHandler = cOptions.Events.OnRedirectToAccessDenied;\r\n    o.Events.OnRedirectToAccessDenied = async (ctx) =\u003E\r\n    {\r\n        if (ctx.Request.Path.StartsWithSegments(\u0022/api\u0022) \u0026\u0026 ctx.Response.StatusCode == StatusCodes.Status200OK)\r\n        {\r\n            ctx.Response.StatusCode = StatusCodes.Status403Forbidden;\r\n            return;\r\n        }\r\n\r\n        await redirectToAccessDeniedHandler(ctx).ConfigureAwait(false);\r\n    };\r\n});\r\n\u0060\u0060\u0060",
        "createdAt": "2022-02-15T20:02:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1040735896"
      },
      {
        "id": "IC_kwDOAQzde85BwicM",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 7 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-04-19T22:59:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1103243020"
      },
      {
        "id": "IC_kwDOAQzde85Dv6PG",
        "parentId": null,
        "author": "michaeljunkin",
        "content": "This is so painful, I hope the msft will not close this.  Redirect should be an opt in for API\u0027s not the default.",
        "createdAt": "2022-05-25T02:05:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1136632774"
      },
      {
        "id": "IC_kwDOAQzde85FhYXI",
        "parentId": null,
        "author": "amarmechai",
        "content": "\u003E The solution below works correctly with .Net 6.0:\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E public class CustomCookieAuthenticationEvents : CookieAuthenticationEvents\r\n\u003E {\r\n\u003E     public override Task RedirectToLogin(RedirectContext\u003CCookieAuthenticationOptions\u003E context)\r\n\u003E     {\r\n\u003E         if (context.Request.Path.StartsWithSegments(\u0022/api\u0022) \u0026\u0026\r\n\u003E             context.Response.StatusCode == StatusCodes.Status200OK)\r\n\u003E         {\r\n\u003E             context.Response.StatusCode = StatusCodes.Status401Unauthorized;\r\n\u003E             return Task.CompletedTask;\r\n\u003E         }\r\n\u003E         else\r\n\u003E         {\r\n\u003E             return base.RedirectToLogin(context);\r\n\u003E         }\r\n\u003E     }\r\n\u003E \r\n\u003E     public override Task RedirectToAccessDenied(RedirectContext\u003CCookieAuthenticationOptions\u003E context)\r\n\u003E     {\r\n\u003E         if (context.Request.Path.StartsWithSegments(\u0022/api\u0022) \u0026\u0026\r\n\u003E             context.Response.StatusCode == StatusCodes.Status200OK)\r\n\u003E         {\r\n\u003E             context.Response.StatusCode = StatusCodes.Status403Forbidden;\r\n\u003E             return Task.CompletedTask;\r\n\u003E         }\r\n\u003E         else\r\n\u003E         {\r\n\u003E             return base.RedirectToAccessDenied(context);\r\n\u003E         }\r\n\u003E     }\r\n\u003E }\r\n\u003E \u0060\u0060\u0060\r\n\u003E \r\n\u003E In Startup.cs\r\n\r\n\u0060services\r\n        .ConfigureApplicationCookie(o =\u003E\r\n         {\r\n             o.Events = new CustomCookieAuthenticationEvents();\r\n         });\u0060",
        "createdAt": "2022-06-25T23:31:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1166378440"
      },
      {
        "id": "IC_kwDOAQzde85MAY22",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-10-11T19:25:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1275170230"
      },
      {
        "id": "IC_kwDOAQzde85P_gHf",
        "parentId": null,
        "author": "digitalhameed",
        "content": "I have also the same problem, still not solved in net 6",
        "createdAt": "2022-12-08T05:03:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1342046687"
      },
      {
        "id": "IC_kwDOAQzde85VDKBQ",
        "parentId": null,
        "author": "jeffputz",
        "content": "This obviously didn\u0027t make net7.0. It\u0027s my opinion is that it\u0027s well past time to admit that the redirect is a bad idea and introduce the breaking change. I think it\u0027s presumptuous to believe that the framework knows better than the developer who wants to send a 401 or 403, regardless of it being an API, MVC app or Razor page. The default behavior should be to do nothing, and a redirect only happens if you code it to happen.",
        "createdAt": "2023-02-11T22:40:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1426890832"
      },
      {
        "id": "IC_kwDOAQzde85VddqY",
        "parentId": null,
        "author": "tfishr",
        "content": "Keeping this issue around is useful in one way though--as an indicator that not many people are using ASP.NET for building REST APIs. (Or else they are all coming here and reading this entire thread to find a workaround, but not leaving much feedback.)",
        "createdAt": "2023-02-16T22:13:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1433787032"
      },
      {
        "id": "IC_kwDOAQzde85Vde08",
        "parentId": null,
        "author": "jeffputz",
        "content": "@tfishr that sounds like an anecdote to me. I mean, it\u0027s an extra line of configuration in \u0060Program\u0060. It\u0027s not a big deal, it just shouldn\u0027t be the _default_ behavior.",
        "createdAt": "2023-02-16T22:18:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1433791804"
      },
      {
        "id": "IC_kwDOAQzde85Vd-yF",
        "parentId": null,
        "author": "tfishr",
        "content": "It\u0027s not an obvious solution, and the only place it\u0027s documented is in this thread. If the solution was anywhere on learn.microsoft.com this issue could be closed now. I believe the default behavior is the way it is because of Razor and Blazor, and so this issue will not be fixed. And that\u0027s fine, as long as people using Angular or React as their front-end with ASP.NET as their REST API have this solution documented in the proper location, instead of spending all day searching for this well-buried page.",
        "createdAt": "2023-02-17T00:24:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1433922693"
      },
      {
        "id": "IC_kwDOAQzde85VeAUa",
        "parentId": null,
        "author": "jeffputz",
        "content": "I mean, I Googled \u0022aspnet prevent 401 redirect access denied api\u0022 and got this as my first result, which explains overriding the \u0060OnRedirectToLogin\u0060 event: https://stackoverflow.com/questions/32863080/how-to-remove-the-redirect-from-an-asp-net-core-webapi-and-return-http-401\r\n\r\nI think we agree it\u0027s suboptimal default behavior, but I don\u0027t agree that it\u0027s any indication that no one is using web API\u0027s in aspnet.",
        "createdAt": "2023-02-17T00:33:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1433928986"
      },
      {
        "id": "IC_kwDOAQzde85YcrRP",
        "parentId": null,
        "author": "ProTip",
        "content": "Since others mentioned the original solution not working in later versions of ASP.NET, I wanted to report that I\u0027m using a variant of blowdart\u0027s solution in v7 that appears to be working for my needs:\r\n\r\n\u0060\u0060\u0060\r\nbuilder.Services.ConfigureApplicationCookie(options =\u003E{\r\n    options.Events.OnRedirectToAccessDenied = context =\u003E {\r\n             context.Response.StatusCode = 403;\r\n             return Task.CompletedTask;\r\n    };\r\n\r\n    options.Events.OnRedirectToLogin = context =\u003E {\r\n             context.Response.StatusCode = 401;\r\n             return Task.CompletedTask;\r\n    };\r\n});\r\n\u0060\u0060\u0060\r\n\r\n_As an aside I took this opportunity to patch into the signin/signout to add my non-http-only cookie so the client has access to session status info._\r\n\r\n### Feedback and thoughts\r\n\r\nI must say it\u0027s very unexpected for an API to be behaving the default way by default. I felt like I followed the recommended path for setting up an API and adding Identity.\r\n\r\nI\u0027m not sure I would have arrived at this solution based on the documentation. With the solution in hand I have yet to find documentation for \u0060OnRedirectToAccessDenied\u0060 on \u0060learn.microsoft.com\u0060 outside of the entry in the library docs.\r\n\r\nI have been hitting number of snags where I feel like things aren\u0027t working as expected and I haven\u0027t been taught to fish(or not for lack of trying have been unable to learn to fish through the fishing manual). For those not all-in on Dotnet(maybe other platforms are on the table like Elixir, Python, NodeJs, etc) I can imagine the accumulation of these events turning people away from asp.net during evaluation.",
        "createdAt": "2023-03-25T20:11:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1483912271"
      },
      {
        "id": "IC_kwDOAQzde85qHE4H",
        "parentId": null,
        "author": "otto-gebb",
        "content": "I am using the library Microsoft.Identity.Web, and none of the workarounds in this thread work for me, so I am posting my own:\r\n\u0060\u0060\u0060cs\r\nservices.Configure\u003COpenIdConnectOptions\u003E(\r\n    OpenIdConnectDefaults.AuthenticationScheme,\r\n    options =\u003E\r\n    {\r\n        options.Events = new OpenIdConnectEvents\r\n        {\r\n            OnRedirectToIdentityProvider = ctx =\u003E\r\n            {\r\n                if (ctx.Request.Path.StartsWithSegments(\u0022/api\u0022))\r\n                {\r\n                    if (ctx.Response.StatusCode == StatusCodes.Status200OK)\r\n                    {\r\n                        // Remove cookies set by OpenIdConnectHandler (e.g. .AspNetCore.OpenIdConnect.Nonce).\r\n                        ctx.Response.Clear();\r\n                        ctx.Response.StatusCode = StatusCodes.Status401Unauthorized;\r\n                    }\r\n\r\n                    ctx.HandleResponse();\r\n                }\r\n\r\n                return Task.CompletedTask;\r\n            }\r\n        };\r\n    });\r\n\u0060\u0060\u0060\r\n\r\nNB. This workaround violates [RFC9110](https://www.rfc-editor.org/rfc/rfc9110#status.401) (as do all others in this thread):\r\n\r\n\u003E A server generating a 401 (Unauthorized) response MUST send a WWW-Authenticate header\r\n\u003E field containing at least one challenge.\r\n\r\nBut this has long been the default behavior of ASP.Net cookies authentication\r\nfor AJAX requests, see [CookieAuthenticationEvents](https://github.com/dotnet/aspnetcore/blob/ffa0a028464e13d46aaec0c5ad8de0725a4d5aa5/src/Security/Authentication/Cookies/src/CookieAuthenticationEvents.cs#L47),\r\nwhere the status code is set to 401, but the WWW-Authenticate header is not set.\r\n\r\n\u0060\u0060\u0060console\r\n\u276F curl -i \u0027https://localhost:5151/home/\u0027 \\  \r\n  -X \u0027POST\u0027 --http1.1 -H \u0027X-Requested-With: XMLHttpRequest\u0027 \\\r\n  --insecure\r\nHTTP/1.1 401 Unauthorized\r\nContent-Length: 0\r\nDate: Thu, 26 Oct 2023 00:31:18 GMT\r\nServer: Kestrel\r\nLocation: https://localhost:5151/Account/Login?ReturnUrl=%2Fhome%2F\r\n\u0060\u0060\u0060\r\n\r\nMaybe it\u0027s not too bad, practical considerations may outweigh following the specification in this case.",
        "createdAt": "2023-10-26T00:34:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1780239879"
      },
      {
        "id": "IC_kwDOAQzde85qHrky",
        "parentId": null,
        "author": "johnwc",
        "content": "\u003E I am using the library Microsoft.Identity.Web, and none of the workarounds in this thread work for me, so I am posting my own:\r\n\u003E \r\n\u003E \u0060\u0060\u0060cs\r\n\u003E services.Configure\u003COpenIdConnectOptions\u003E(\r\n\u003E     OpenIdConnectDefaults.AuthenticationScheme,\r\n\u003E     options =\u003E\r\n\u003E     {\r\n\u003E         options.Events = new OpenIdConnectEvents\r\n\u003E         {\r\n\u003E             OnRedirectToIdentityProvider = ctx =\u003E\r\n\u003E             {\r\n\u003E                 if (ctx.Request.Path.StartsWithSegments(\u0022/api\u0022))\r\n\u003E                 {\r\n\u003E                     if (ctx.Response.StatusCode == StatusCodes.Status200OK)\r\n\u003E                     {\r\n\u003E                         // Remove cookies set by OpenIdConnectHandler (e.g. .AspNetCore.OpenIdConnect.Nonce).\r\n\u003E                         ctx.Response.Clear();\r\n\u003E                         ctx.Response.StatusCode = StatusCodes.Status401Unauthorized;\r\n\u003E                     }\r\n\u003E \r\n\u003E                     ctx.HandleResponse();\r\n\u003E                 }\r\n\u003E \r\n\u003E                 return Task.CompletedTask;\r\n\u003E             }\r\n\u003E         };\r\n\u003E     });\r\n\u003E \u0060\u0060\u0060\r\n\u003E \r\n\u003E NB. This workaround violates [RFC9110](https://www.rfc-editor.org/rfc/rfc9110#status.401) (as do all others in this thread):\r\n\u003E \r\n\u003E \u003E A server generating a 401 (Unauthorized) response MUST send a WWW-Authenticate header\r\n\u003E \u003E field containing at least one challenge.\r\n\u003E \r\n\u003E But this has long been the default behavior of ASP.Net cookies authentication for AJAX requests, see [CookieAuthenticationEvents](https://github.com/dotnet/aspnetcore/blob/ffa0a028464e13d46aaec0c5ad8de0725a4d5aa5/src/Security/Authentication/Cookies/src/CookieAuthenticationEvents.cs#L47), where the status code is set to 401, but the WWW-Authenticate header is not set.\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E \u276F curl -i \u0027https://localhost:5151/home/\u0027 \\  \r\n\u003E   -X \u0027POST\u0027 --http1.1 -H \u0027X-Requested-With: XMLHttpRequest\u0027 \\\r\n\u003E   --insecure\r\n\u003E HTTP/1.1 401 Unauthorized\r\n\u003E Content-Length: 0\r\n\u003E Date: Thu, 26 Oct 2023 00:31:18 GMT\r\n\u003E Server: Kestrel\r\n\u003E Location: https://localhost:5151/Account/Login?ReturnUrl=%2Fhome%2F\r\n\u003E \u0060\u0060\u0060\r\n\u003E \r\n\u003E Maybe it\u0027s not too bad, practical considerations may outweigh following the specification in this case.\r\n\r\nYou must of missed my comment then. https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1026158591",
        "createdAt": "2023-10-26T04:31:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1780398386"
      },
      {
        "id": "IC_kwDOAQzde85r_E73",
        "parentId": null,
        "author": "XiaoFaye",
        "content": "Just to confirm this is still an issue in .NET 8.",
        "createdAt": "2023-11-15T02:19:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1811697399"
      },
      {
        "id": "IC_kwDOAQzde85sFJIz",
        "parentId": null,
        "author": "JeremyLikness",
        "content": "I realize the bigger issue here is the default behavior, which is on the backlog to consider but changing that could end up being a major breaking change. Meanwhile in .NET 8, does this work for you?\r\n\r\nAssume the \u0060AppDbContext\u0060 is defined and registered.\r\n\r\n\u0060\u0060\u0060csharp\r\nbuilder.Services.AddIdentityCore\u003CIdentityUser\u003E(opt =\u003E\r\n{\r\n    opt.SignIn.RequireConfirmedEmail = true;\r\n})\r\n    .AddSignInManager()\r\n    .AddEntityFrameworkStores\u003CAppDbContext\u003E();\r\n\r\nbuilder.Services.AddAuthentication(o =\u003E\r\n{\r\n    o.DefaultScheme = IdentityConstants.ApplicationScheme;\r\n    o.DefaultSignInScheme = IdentityConstants.ExternalScheme;    \r\n})\r\n    .AddIdentityCookies(cookieOpts =\u003E\r\n    {       \r\n        cookieOpts.ApplicationCookie!.Configure(cfg =\u003E\r\n        {            \r\n            cfg.Events.OnRedirectToLogin = ctx =\u003E\r\n            {\r\n                ctx.Response.StatusCode = 401;\r\n                return Task.CompletedTask;\r\n            };\r\n        });\r\n    });\r\n\u0060\u0060\u0060",
        "createdAt": "2023-11-15T21:29:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1813287475"
      },
      {
        "id": "IC_kwDOAQzde85sFQJ_",
        "parentId": null,
        "author": "jacobvisick",
        "content": "@JeremyLikness I\u0027ve found that this breaks the normal redirect behavior, e.g. in a Blazor Web App accessing a page that requires login. A very small change to that solution that I\u0027m currently using to return 401 from my API controllers and still allow my UI to redirect to the login page:\r\n\r\n\u0060\u0060\u0060cs\r\n    .AddIdentityCookies(cookieOpts =\u003E\r\n    {\r\n        cookieOpts.ApplicationCookie!.Configure(cfg =\u003E\r\n        {\r\n            cfg.Events.OnRedirectToLogin \u002B= ctx =\u003E\r\n            {\r\n                if (ctx.Request.Path.StartsWithSegments(\u0022/api\u0022))\r\n                {\r\n                    ctx.Response.StatusCode = 401;\r\n                }\r\n\r\n                return Task.CompletedTask;\r\n            };\r\n        });\r\n    });\r\n\u0060\u0060\u0060\r\n\r\nThe caveat here is that your API controllers all need their route to begin with \u0060/api\u0060, but I personally find that a good idea anyways. The same logic can be applied to return \u0060403\u0060 on \u0060OnRedirectToAccessDenied\u0060, if you need it.",
        "createdAt": "2023-11-15T21:50:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1813316223"
      },
      {
        "id": "IC_kwDOAQzde85uOHwb",
        "parentId": null,
        "author": "Varin6",
        "content": "How is this still not resolved since it\u0027s been reported in 2019? This is insane. I Just spent hours on this from trying to clear all cache everywhere, restarting everything, trying different approaches (as it should work fine) to uninstalling IDE and all my SDKs because I ran out of ideas. \r\n\r\nIf you want Blazor and .NET APIs to ever become a valid and not nonsensical competition for other established and working stacks - maybe you should not leave jarring issues unresolved FOR 5 YEARS?\r\n\r\nJust an observation.\r\n\r\n\r\n---- \r\nThis is the comment with the code that fixes it in .NET 8 btw:\r\nKudos @ProTip \r\n\r\nhttps://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1483912271",
        "createdAt": "2023-12-11T01:41:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1849195547"
      },
      {
        "id": "IC_kwDOAQzde85vGXvP",
        "parentId": null,
        "author": "ANRCorleone",
        "content": "My current project is web api in one project and a spa frontend in a separate project. This is a fresh one using basic cookie auth, I was able to test the auth from swagger. I\u0027m still to test from the actual UI, hopeful I won\u0027t get many roadblocks like this. Here\u0027s what I did in .NET 8.0\r\n\r\n\u0060\u0060\u0060\r\n        // Entity Framework deps\r\n        builder.Services.AddDbContext\u003CAppDbContext\u003E();\r\n\r\n\r\n        // Authentication \u0026 Authorization\r\n        builder.Services.AddIdentityApiEndpoints\u003CEmployee\u003E(options =\u003E\r\n            {\r\n                // your options\r\n            })\r\n            .AddRoles\u003CIdentityRole\u003E()\r\n            .AddRoleManager\u003CRoleManager\u003CIdentityRole\u003E\u003E()\r\n            .AddRoleValidator\u003CRoleValidator\u003CIdentityRole\u003E\u003E()\r\n            .AddEntityFrameworkStores\u003CAppDbContext\u003E();\r\n\r\n        builder.Services.AddControllers();\r\n\u0060\u0060\u0060\r\ndecompiled from Rider, AddIdentityApiEndpoints does this - it adds bearer and cookie auth\r\n\u0060\u0060\u0060\r\n    public static IdentityBuilder AddIdentityApiEndpoints\u003CTUser\u003E(\r\n      this IServiceCollection services,\r\n      Action\u003CIdentityOptions\u003E configure)\r\n      where TUser : class, new()\r\n    {\r\n      ArgumentNullException.ThrowIfNull((object) services, nameof (services));\r\n      ArgumentNullException.ThrowIfNull((object) configure, nameof (configure));\r\n      services.AddAuthentication(\u0022Identity.BearerAndApplication\u0022).AddScheme\u003CAuthenticationSchemeOptions, IdentityServiceCollectionExtensions.CompositeIdentityHandler\u003E(\u0022Identity.BearerAndApplication\u0022, (string) null, (Action\u003CAuthenticationSchemeOptions\u003E) (compositeOptions =\u003E\r\n      {\r\n        compositeOptions.ForwardDefault = IdentityConstants.BearerScheme;\r\n        compositeOptions.ForwardAuthenticate = \u0022Identity.BearerAndApplication\u0022;\r\n      })).AddBearerToken(IdentityConstants.BearerScheme).AddIdentityCookies();\r\n      return services.AddIdentityCore\u003CTUser\u003E(configure).AddApiEndpoints();\r\n    }\r\n\u0060\u0060\u0060\r\nBecause it calls AddIdentityCore, you gotta manually add the services you need that are by default included when you call AddIdentity, which can be a downside or an upside if you don\u0027t want to do the stated workarounds.\r\n\r\n",
        "createdAt": "2023-12-20T06:50:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1863941071"
      },
      {
        "id": "IC_kwDOAQzde85yULus",
        "parentId": null,
        "author": "victorvartan",
        "content": "I had the same issue with the redirect in .NET 8 because I was doing AddAuthentication before AddIdentity... after switching the order (see correct order in code snippet below) it worked.\r\n\r\n\u0060\u0060\u0060\r\nbuilder.Services.AddIdentity\u003CUser, Role\u003E(options =\u003E\r\n{\r\n    options.User.RequireUniqueEmail = true;\r\n    options.Password.RequireDigit = false;\r\n    options.Password.RequireLowercase = false;\r\n    options.Password.RequireUppercase = false;\r\n    options.Password.RequireNonAlphanumeric = false;\r\n    options.Password.RequiredLength = 6;\r\n})\r\n                .AddEntityFrameworkStores\u003CSqlContext\u003E()\r\n                .AddDefaultTokenProviders();\r\n\r\nvar tokenValidationParameters = new TokenValidationParameters\r\n{\r\n    ValidateIssuer = true,\r\n    ValidateAudience = false,\r\n    ValidateLifetime = true,\r\n    ValidateIssuerSigningKey = true,\r\n    ClockSkew = TimeSpan.Zero,\r\n    ValidIssuer = Constants.Authentication.Tokens.ISSUER,\r\n    IssuerSigningKey = new SymmetricSecurityKey(Convert.FromBase64String(builder.Configuration.GetValue\u003Cstring\u003E(\u0022JWT:IssuerSigningKey\u0022)!))\r\n};\r\n\r\nbuilder.Services.AddScoped(s =\u003E tokenValidationParameters);\r\n\r\nbuilder.Services.AddAuthentication(options =\u003E\r\n{\r\n    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\r\n    options.DefaultSignInScheme = JwtBearerDefaults.AuthenticationScheme;\r\n    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\r\n})\r\n                .AddJwtBearer(options =\u003E\r\n                {\r\n                    options.TokenValidationParameters = tokenValidationParameters;\r\n                });\r\n\u0060\u0060\u0060",
        "createdAt": "2024-01-30T21:06:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1917893548"
      },
      {
        "id": "IC_kwDOAQzde85y64py",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 9 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2024-02-05T20:27:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-1928039026"
      },
      {
        "id": "IC_kwDOAQzde855dq-J",
        "parentId": null,
        "author": "halter73",
        "content": "@javiercn suggested we could check for the absence of [Sec-Fetch-Dest](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Dest) request header with a value of \u0060document\u0060, \u0060frame\u0060 or \u0060iframe\u0060. And if there __isn\u0027t__ one, assume that a 401 would be better than a login redirect, because the request must not be from a modern browser expecting HTML.\r\n\r\nI do worry that this might break things like Blazor\u0027s enhanced navigation that use \u0060fetch\u0060 but still respect redirects. I know we did a lot to make that work in .NET 8 with #50551, so I wouldn\u0027t want to break it, but I don\u0027t want to rely on a Blazor-specific workaround like checking for the \u0060Accept: text/html;blazor-enhanced-nav=on\u0060 request header. Maybe @SteveSandersonMS has some ideas.\r\n\r\nWe already have similar logic for detecting the presence of the \u0060X-Requested-With: XMLHttpRequest\u0060 header and assuming it\u0027s an API request if it\u0027s there. The \u0060Sec-Fetch-Dest\u0060 check could replace that. We could also consider looking at other headers like the \u0060Accept\u0060 header. But considering \u0060fetch\u0060 uses \u0060*/*\u0060 as the default, I\u0027m not sure that\u0027d work.\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/f4c2f14b3fff61f3e98cac2e3e6c4807dc111861/src/Security/Authentication/Cookies/src/CookieAuthenticationEvents.cs#L42-L54\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/f4c2f14b3fff61f3e98cac2e3e6c4807dc111861/src/Security/Authentication/Cookies/src/CookieAuthenticationEvents.cs#L105-L109\r\n\r\nThis kind of change would probably need to be opt-in, since it\u0027s likely to break older applications and browsers even though they\u0027re unsupported. And there\u0027s probably a lot of other scenarios like Blazor enhanced navigation where client-side frameworks use \u0060fetch\u0060 even though they expect HTML and would follow redirect. An example of this may be [HTMX\u0027s \u0060hx-get\u0060](https://htmx.org/reference/), although that seems to expect you to use the \u0060HX-Redirect\u0060 header to force a full-page redirect, so maybe people using HTMX would have had to customize \u0060OnRedirectToLogin\u0060 already.\r\n\r\nI think the right thing to do would be to examine endpoint metadata to determine if the endpoint is expected to return HTML vs something else like JSON. The problem with that is that I don\u0027t think most endpoints have enough metadata to determine that reliably. However, we could be conservative. For endpoints without sufficient metadata, we\u0027d still redirect. And for things like \u0060[ApiController]\u0060 actions, we\u0027d return a 401.",
        "createdAt": "2024-04-04T17:45:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-2037821321"
      },
      {
        "id": "IC_kwDOAQzde855duAb",
        "parentId": null,
        "author": "johnwc",
        "content": "@halter73 I think the presence of \u0060[ApiController]\u0060 attribute would probably cover most situations.",
        "createdAt": "2024-04-04T17:51:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9039#issuecomment-2037833755"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0MzAxNDgzMDY=",
    "title": "Consider adding OIDC event to handle identity token validation for hybrid flow",
    "url": "https://github.com/dotnet/aspnetcore/issues/9154",
    "createdAt": "2019-04-07T13:53:10Z",
    "lastUpdated": "2020-07-24T23:24:00Z",
    "body": "I am trying to handle JWE identity tokens returned from an OpenID Provider. Since \u0060OpenIdConnectProtocolValidator\u0060 is meant for JWS, I must ensure that the token sent for validation is the inner token of the decrypted JWE.\r\n\r\nA JWE identity token returned from the authorization endpoint (implicit flow) or token endpoint (authorization code flow) can be handled using the token validated event.\r\n\r\nHowever, when using the hybrid flow and receiving a JWE identity token from both the authorization endpoint and token endpoint (e.g. response type of \u0060code id_token\u0060), I am not given the opportunity to handle the identity token: https://github.com/aspnet/AspNetCore/blob/v2.2.3/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectHandler.cs#L614.\r\n\r\nMy current workaround is to override the protocol validator to handle JWS extraction, however according to [this issue](https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/pull/841), the protocol validator is not the place to do this.\r\n\r\nPlease consider adding an event that would allow the identity token to be modified in this scenario.",
    "upvotes": 2,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ4MDU5Nzc4Nw==",
        "parentId": null,
        "author": "blowdart",
        "content": "Also https://github.com/aspnet/AspNetCore/issues/9092",
        "createdAt": "2019-04-07T15:01:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9154#issuecomment-480597787"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ4MjMyNDEwNA==",
        "parentId": null,
        "author": "Eilon",
        "content": "We\u0027ve moved this issue is in the Backlog milestone. This means that it is not going to happen for the coming release. We will re-assess the backlog following the current release and consider this item at that time. However, keep in mind that there are many other high priority features with which it will be competing for resources.",
        "createdAt": "2019-04-11T21:21:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9154#issuecomment-482324104"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2Mzc3MTM5MQ==",
        "parentId": null,
        "author": "thesuavehog",
        "content": "I\u0027ve been looking for a (ideally simple) way to access the \u0060id_token\u0060 after a successful OIDC login in my Blazor WebAssembly project.\r\nMy use case is that I am trying to leverage the AWS Cognito Identity Pool to provide a scoped AWS Role for my users to use to access AWS resources once they have logged in. This is done via the AWS CognitoAWSCredentials class in their .NET SDK (which you pass to the various \u0060IAmazonServiceClient\u0060s), however in order to initialize a CognitoAWSCredentials instance with a JWT token after an OpenID Connect login, I need to pass it the \u0060id_token\u0060.\r\n\r\nOn a .NET Core 3.1 WebApi (running as a Lambda function) the OpenID Connect can be used to authenticate the user if I directly access the API in my browser (it redirects to the Cognito hosted login page, and back once I successfully login). Within my HttpContext I can then access the \u0060id_token\u0060 as it is automatically added there (\u0060Microsoft.AspNetCore.Authentication.AuthenticationHttpContextExtensions.GetTokenAsync\u0060).\r\n\r\nIn a Blazor WebAssembly project, the \u0060access_token\u0060 is available via \u0060Microsoft.AspNetCore.Components.WebAssembly.Authentication.Internal.IAccessTokenProviderAccessor.TokenProvider.RequestAccessToken\u0060 however there is no equivalent \u0060IIdTokenProviderAccessor\u0060 ... why? The ID, Access and Refresh tokens should all be available to be used by the application - in this case so I can leverage the AWS client libraries to access AWS resources directly in the Blazor WebAssembly - but I\u0027m sure there are other use cases for people as well.",
        "createdAt": "2020-07-24T23:24:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9154#issuecomment-663771391"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0NDExODc2NTM=",
    "title": "MicrosoftAccount should use OIDC (was: AddMicrosoftAccount  \u0026 Azure Active Directory - App registrations signin/signout problems)",
    "url": "https://github.com/dotnet/aspnetcore/issues/10037",
    "createdAt": "2019-05-07T11:46:05Z",
    "lastUpdated": "2021-05-27T20:42:08Z",
    "body": "## Problem Description:\r\n\r\nIf a user logs in from an ASP.NET Core application using the AddMicrosoftAccount extension method, it is impossible to change user on the aad, because the app does an auto login if only one aad account is logged in.\r\n\r\nIf 2 aad accounts are logged in, then it waits, and I can choose. This is correct.\r\n\r\nIf only 1 aad user is logged in, and if I click the popup window to change an account, I then get a Correlation failed exception (If I\u2019m fast enough to complete the login) in the ASP.NET Core application. \r\n\r\nThe auto login breaks everything.\r\n\r\na)\tHow can you turn this off?\r\nb)\tHow can you logout from the ASP.NET Core application?  The signout is not sent to the aad APP Registration.  This is possible in the Azure Portal. Maybe I want to logout in the aad using the application.\r\n\r\n## Code to reproduce:\r\n\r\nhttps://github.com/damienbod/AspNetCoreID4External/blob/master/src/IdentityServerWithAspNetIdentity/Startup.cs#L61-L67\r\n\r\nAzure Portal\r\n\r\nUsed Azure Active Directory / App registrations to configure the client.",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "severity-minor",
      "affected-medium"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MDIzODc3NA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "For AAD you should be using OpenIdConnect rather than Microsoft Account. OIDC has the remote signout capability.",
        "createdAt": "2019-05-07T20:15:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-490238774"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MDM0ODU1Ng==",
        "parentId": null,
        "author": "damienbod",
        "content": "@Tratcher I use https://apps.dev.microsoft.com which now recommends you do this in the portal as a application personal account. It\u0027s not in the aad, but this is how you navigate to it in the portal. A bit confusing I think.\r\n\r\nHere\u0027s the existing docs which probably should be updated.\r\n\r\nhttps://docs.microsoft.com/en-us/aspnet/core/security/authentication/social/microsoft-logins?view=aspnetcore-2.2\r\n",
        "createdAt": "2019-05-08T05:04:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-490348556"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MTA2OTIyMg==",
        "parentId": null,
        "author": "Eilon",
        "content": "It seems like the best path forward is to add a new API, such as \u0060.AddMicrosoftAccountOidc(...)\u0060 that uses OIDC (instead of OAuth) to connect Microsoft Account for auth. \r\n\r\nUsing OIDC will help gain newer features such as what\u0027s being discussed in this issue. However, it\u0027s a behavioral breaking change, so we should add this via a new API, rather than changing the existing APIs.",
        "createdAt": "2019-05-09T21:15:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-491069222"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MTA3MDIxNQ==",
        "parentId": null,
        "author": "Eilon",
        "content": "The above is for part (b).\r\n\r\nFor part (a), you can handle the [\u0060OnRedirectToAuthorizationEndpoint\u0060](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.oauth.oauthevents.onredirecttoauthorizationendpoint?view=aspnetcore-2.0#Microsoft_AspNetCore_Authentication_OAuth_OAuthEvents_OnRedirectToAuthorizationEndpoint) event and add a \u0060prompt=login\u0060 query string parameter to the [\u0060RedirectUri\u0060](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.redirectcontext-1.redirecturi?view=aspnetcore-2.0#Microsoft_AspNetCore_Authentication_RedirectContext_1_RedirectUri) to force prompting for accounts.",
        "createdAt": "2019-05-09T21:19:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-491070215"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MTM4ODIyNg==",
        "parentId": null,
        "author": "damienbod",
        "content": "Thanks for your replies\r\n\r\nI have switched from MS Account extension to OpenID Connect. By using OpenID connect I can send a prompt=login using the property, and this prevents the auto login. I could also do it the way @Eilon suggested, but @Tratcher recommended OIDC as does the Azure docs for this type on APP. \r\n\r\nSecondly, I had many problems with Correlation cookie (also for single instance), we solved this by customizing the creation of the cookie and the correlation ID. The default values did not work.  The multiple instance was solved by moving the data protection to a cache.\r\n\r\nI think the AddMicrosoftAccount should be made obsolete. Maybe the new API is not required, but an OIDC recommendation should be made in the Obsolete text. \r\n\r\nStill have problems with one deployment, the user always receives a correlation exception, cookie not found. No idea why this is happening here yet.\r\n",
        "createdAt": "2019-05-10T18:30:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-491388226"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MTM5MDAxOQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E customizing the creation of the cookie and the correlation ID\r\n\r\nYou shouldn\u0027t need to do that. See https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/web-farm?view=aspnetcore-2.2#required-configuration for hosting multiple instances of your site.",
        "createdAt": "2019-05-10T18:36:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-491390019"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MTU5Nzc4NA==",
        "parentId": null,
        "author": "damienbod",
        "content": "@Tratcher thanks for you answer. I had/ have no problems with the multiple instance. The correlation exceptions was caused by time outs, SameSite and cookie not found. The timeouts and the same site cookie problems are fixed. \r\n\r\n\u0060\u0060\u0060\r\noptions.RemoteAuthenticationTimeout = TimeSpan.FromSeconds(30);\r\noptions.CorrelationCookie = new Microsoft.AspNetCore.Http.CookieBuilder()\r\n{\r\n\tExpiration = new TimeSpan(0, 0, 30),\r\n\tSameSite = Microsoft.AspNetCore.Http.SameSiteMode.None,\r\n\tIsEssential = true\r\n};\r\n\u0060\u0060\u0060\r\nStill have correlation Cookie not Found exceptions by some clients and no idea what causes this. \r\n\r\nGreetings Damien",
        "createdAt": "2019-05-12T13:52:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-491597784"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MTYwMjA1MA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@damienbod Don\u0027t change the cookie builder.\r\nSameSite and IsEssential are the default values.\r\nhttps://github.com/aspnet/AspNetCore/blob/208299aa31ef78de7da8d7bf2b96e8b8d5a98786/src/Security/Authentication/Core/src/RemoteAuthenticationOptions.cs#L26-L33\r\nRemoteAuthenticationTimeout and Expiration do the same thing.\r\nhttps://github.com/aspnet/AspNetCore/blob/d7a7c65b2b40a97bb0ba78c07380c46bc5920400/src/Security/Authentication/Core/src/RemoteAuthenticationOptions.cs#L160-L163",
        "createdAt": "2019-05-12T14:47:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-491602050"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MTgzNzI0Mg==",
        "parentId": null,
        "author": "damienbod",
        "content": "The correlation Cookie not found exceptions were caused by an anti-virus, firewall setting on the client PCs. Now the external provider is working stable. \r\n\r\nI think making AddMicrosoftAccount  obsolete would be good. I also think AddOpenIdConnect is enough, and the .AddMicrosoftAccountOidc is not required. This needs documentation.\r\n\r\nThanks for you feedback and answers.",
        "createdAt": "2019-05-13T14:07:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-491837242"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzMyODMxNw==",
        "parentId": null,
        "author": "damienbod",
        "content": "I made some docs for this, and how I could fix this for me, maybe it will help others.\r\n\r\nhttps://damienbod.com/2019/05/17/updating-microsoft-account-logins-in-asp-net-core-with-openid-connect-and-azure-active-directory/\r\n",
        "createdAt": "2019-05-17T05:47:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-493328317"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3ODM1ODk1Mg==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Update: For 6.0 we should obsolete AddMicrosoftAccount and AddGoogle and rewrite the docs to use AddOpenIdConnect.",
        "createdAt": "2020-08-21T15:44:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-678358952"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0OTcwNjM1NA==",
        "parentId": null,
        "author": "ericsampson",
        "content": "@Tratcher just bumping this as 6.0 is almost upon us.\r\n\r\nThis issue that got autoclosed/locked still looks valid to me, but I can\u0027t comment on it as it\u0027s locked for externals:\r\nhttps://github.com/dotnet/aspnetcore/issues/26919",
        "createdAt": "2021-05-27T14:58:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-849706354"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0OTc1MDYxNw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "#26919 was a rather complicated proposal for something that should already be possible with named options. We didn\u0027t have any plans to pursue it.\r\n\r\n@blowdart looks like this got stuck in backlog. Any ambition to address it for 6.0?",
        "createdAt": "2021-05-27T15:57:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-849750617"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0OTc1Nzc2OA==",
        "parentId": null,
        "author": "blowdart",
        "content": "We aren\u0027t going to deprecate in an LTS unfortunately, because that\u0027s now a principal. So it\u0027ll be 7",
        "createdAt": "2021-05-27T16:07:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-849757768"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0OTc2MDM4MA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Should we at least re-write the docs to recommend OIDC?",
        "createdAt": "2021-05-27T16:10:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-849760380"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0OTc2NDQ5OA==",
        "parentId": null,
        "author": "ericsampson",
        "content": "Thanks Chris.",
        "createdAt": "2021-05-27T16:16:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-849764498"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0OTkyNzc2OQ==",
        "parentId": null,
        "author": "blowdart",
        "content": "We should, or IdentityWeb which should work with MSAs",
        "createdAt": "2021-05-27T20:42:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10037#issuecomment-849927769"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0NDU1NTc0MDg=",
    "title": "Enable Certificate authentication option in API template",
    "url": "https://github.com/dotnet/aspnetcore/issues/10336",
    "createdAt": "2019-05-17T18:07:18Z",
    "lastUpdated": "2023-04-27T19:14:45Z",
    "body": "This is listed in the Templating epic with questionmark, so not sure what exactly needs to happen here or how important it is to get it done in 3.0.\r\n\r\nThere is also tooling impact here. There is no such option in the New Project Dialog UI",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "Docs",
      "area-auth",
      "Needs: Spec",
      "affected-few",
      "severity-minor",
      "feature-templates"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzU0NjkxOQ==",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "This depends on https://github.com/aspnet/AspNetCore/issues/4663",
        "createdAt": "2019-05-17T18:07:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10336#issuecomment-493546919"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzU1OTEzMA==",
        "parentId": null,
        "author": "blowdart",
        "content": "Given the desire to drive templates to be smaller, this is probably a rare enough want that it doesn\u0027t need template integration, but documentation will suffice.",
        "createdAt": "2019-05-17T18:47:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10336#issuecomment-493559130"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzU5MDQ3NQ==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Agreed. I don\u0027t think we should overload the template with samples. We just finished scaling it back :)",
        "createdAt": "2019-05-17T20:32:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10336#issuecomment-493590475"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0NDU1NTg5ODg=",
    "title": "Enable Kerberos authentication option in API template",
    "url": "https://github.com/dotnet/aspnetcore/issues/10337",
    "createdAt": "2019-05-17T18:11:51Z",
    "lastUpdated": "2023-04-27T19:14:35Z",
    "body": "This is listed in the Templating epic with questionmark, so not sure what exactly needs to happen here or how important it is to get it done in 3.0.\r\n\r\nThere is also tooling impact here. There is no such option in the New Project Dialog UI\r\n\r\nThis work depends on https://github.com/aspnet/AspNetCore/issues/8897",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "Docs",
      "area-auth",
      "Needs: Spec",
      "severity-nice-to-have",
      "affected-few",
      "feature-templates"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NzAyNTM0MQ==",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "Talked to @blowdart regarding this. We aren\u0027t going to load templates with this. Rather there will be just docs covering enabling this.",
        "createdAt": "2019-05-29T17:07:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10337#issuecomment-497025341"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NzA4NTU5OQ==",
        "parentId": null,
        "author": "brockallen",
        "content": "Don\u0027t forget to enable anti-forgery for the API calls.",
        "createdAt": "2019-05-29T19:54:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10337#issuecomment-497085599"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0NDg1MzE2MzA=",
    "title": "Use IHttpClientFactory in RemoteAuthenticationOptions",
    "url": "https://github.com/dotnet/aspnetcore/issues/10542",
    "createdAt": "2019-05-26T05:52:16Z",
    "lastUpdated": "2024-12-16T15:46:02Z",
    "body": "### Is your feature request related to a problem? Please describe.\r\nASP.NET Core 2.1 introduced IHttpClientFactory to solve the [problems with creating and disposing HttpClient with every call](https://aspnetmonsters.com/2016/08/2016-08-27-httpclientwrong/), and the [problems with creating a long-lived HttpClient](https://github.com/dotnet/corefx/issues/11224).\r\n\r\nHowever, long-lived HttpClient is still created within the framework. Specifically, in [RemoteAuthenticationOptions.Backchannel](https://github.com/aspnet/AspNetCore/blob/master/src/Security/Authentication/Core/src/RemoteAuthenticationOptions.cs#L79) and [RemoteAuthenticationOptions.BackchannelHttpHandler](https://github.com/aspnet/AspNetCore/blob/master/src/Security/Authentication/Core/src/RemoteAuthenticationOptions.cs#L74), these have effectively application lifetime because instances of AuthenticationOptions are cached in the singleton IOptionsMonitorCache.\r\n\r\n### Describe the solution you\u0027d like\r\nReplace RemoteAuthenticationOptions.Backchannel and RemoteAuthenticationOptions.BackchannelHttpHandler with RemoteAuthenticationOptions.BackchannelFactory, so that whenever an HttpClient is needed, it is created from the BackchannelFactory and disposed.\r\n\r\nThis would also require a new [HttpDocumentRetriever](https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/master/src/Microsoft.IdentityModel.Protocols/Configuration/HttpDocumentRetriever.cs) constructor that takes an IHttpClientFactory, because [JwtBearerPostConfigureOptions](https://github.com/aspnet/AspNetCore/blob/master/src/Security/Authentication/JwtBearer/src/JwtBearerPostConfigureOptions.cs#L58), [WsFederationPostConfigureOptions](https://github.com/aspnet/AspNetCore/blob/master/src/Security/Authentication/WsFederation/src/WsFederationPostConfigureOptions.cs#L84) and [OpenIdConnectPostConfigureOptions](https://github.com/aspnet/AspNetCore/blob/master/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectPostConfigureOptions.cs#L96) initializes a long-lived ConfigurationManager.\r\n\r\n### Describe alternatives you\u0027ve considered\r\n- Do not store AuthenticationOptions in IOptionsMonitorCache and make it scoped per request. However, it means that JwtBearer, OpenIdConnect and WsFederation (or 3rd party Saml2 protocol handler) would require fetching metadata on every request, which would slow down every request.\r\n\r\n- Roll my own ConfigurationManager and HttpDocumentRetriever, which would bypass any kind of niceities that \u0060.AddJwtBearer\u0060, \u0060.AddOpenIdConnect\u0060 extension methods provide.\r\n\r\n### Additional context\r\n[The Grand Auth Redesign of 2017](https://github.com/aspnet/Security/issues/1179) in Core 2.0 predates IHttpClientFactory in Core 2.1.\r\n\r\nIn Core 2.0, the new [SocketsHttpHandler does not solve DNS problem](https://github.com/aspnet/HttpClientFactory/issues/10#issuecomment-398511183)\r\n\r\n[Exploring DNS issue](https://github.com/aspnet/HttpClientFactory/wiki/Exploring-DNS-issues)",
    "upvotes": 4,
    "labels": [
      "enhancement",
      "area-auth",
      "severity-minor",
      "affected-medium"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NjMwMTM1OQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "This would be easy enough for OAuth, but for the IdentityModel based providers (OIDC, WsFed) we\u0027d need updated, refactored dependencies. @brentschmaltz  ",
        "createdAt": "2019-05-27T20:37:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10542#issuecomment-496301359"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NzE2MTc4OA==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@Tratcher see: https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/1197\r\n\r\nHow do you prioritize this for this 3.0?\r\nOther users have asked for this.",
        "createdAt": "2019-05-30T01:02:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10542#issuecomment-497161788"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NzIwMDg3MQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "- It\u0027s a bit late for new 3.0 features, more likely it will be a future release.\r\n- You\u0027d need to do IdentityModel first\r\n- We\u0027d want to add it in a non-breaking way (new properties \u0026 overloads)",
        "createdAt": "2019-05-30T04:47:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10542#issuecomment-497200871"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NzIwMTY0NQ==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@Tratcher OK, we will add this and make sure you know when it is available.",
        "createdAt": "2019-05-30T04:52:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10542#issuecomment-497201645"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU5MjQ4OTg4Ng==",
        "parentId": null,
        "author": "damianh",
        "content": "Also in \u0060JwtBearerOptions\u0060:\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/ce0579255104f6ea1902b62c1e21195a7b93f828/src/Security/Authentication/JwtBearer/src/JwtBearerOptions.cs#L65 \r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/62351067ff4c1401556725b401478e648b66acdc/src/Security/Authentication/JwtBearer/src/JwtBearerPostConfigureOptions.cs#L53\r\n\r\n...and probably several other places.",
        "createdAt": "2020-02-28T12:21:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10542#issuecomment-592489886"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU5MjU3NTAzNg==",
        "parentId": null,
        "author": "Tratcher",
        "content": "It\u0027s the expectation that it would resolve the client per request or only at startup? Per request would be challenging for OIDC and JwtBearer due to their use of ConfigManager.",
        "createdAt": "2020-02-28T15:54:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10542#issuecomment-592575036"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU5MjU5NjcxNA==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@Tratcher our focus is on a 6.4.2 public release.\r\nPOR is weekly as we find issues.\r\nOnce 6.4.2 is released, we can address this and other issues.",
        "createdAt": "2020-02-28T16:43:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10542#issuecomment-592596714"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU5NTE1MDYwNA==",
        "parentId": null,
        "author": "damianh",
        "content": "\u003E It\u0027s the expectation that it would resolve the client per request or only at startup? Per request would be challenging for OIDC and JwtBearer due to their use of ConfigManager.\r\n\r\nSorry, I\u0027m not confident enough on this topic to make an assertion.",
        "createdAt": "2020-03-05T10:23:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10542#issuecomment-595150604"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMzA4NTY3MA==",
        "parentId": null,
        "author": "jeffreyrivor",
        "content": ".NET Core 2.1 introduced \u0060SocketsHttpHandler\u0060 as the default handler, which is designed to be used in a long-lived singleton-like way and can be made to work. In the [documentation for alternatives to IHttpClientFactory](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-3.1#alternatives-to-ihttpclientfactory), it says that setting a finite \u0060SocketsHttpHandler.PooledConnectionLifetime\u0060 solves the stale DNS problem of long-lived handlers while keeping the performance benefits of pooled resource management. The default value for \u0060SocketsHttpHandler.PooledConnectionLifetime\u0060 is \u0060Timeout.InfiniteTimeSpan\u0060, so default construction of \u0060HttpClient\u0060 or \u0060SocketsHttpHandler\u0060 won\u0027t have the behavior and it has to be manually set.\r\n\r\nThis should allow us to use an application-lifetime (non-disposed) \u0060HttpClient\u0060 for the \u0060Backchannel\u0060 (or \u0060BackchannelHttpHandler\u0060) as a workaround.\r\n\r\n\u0060\u0060\u0060 csharp\r\nservices.AddAuthentication().AddOpenIdConnect(options =\u003E\r\n{\r\n    // use the handler config\r\n    options.BackchannelHttpHandler = new SocketsHttpHandler\r\n    {\r\n        // recycle pooled sockets every 5 minutes\r\n        PooledConnectionLifetime = TimeSpan.FromMinutes(5),\r\n    };\r\n\r\n    // or use the client config\r\n    options.Backchannel = new HttpClient(new SocketsHttpHandler\r\n    {\r\n        PooledConnectionLifetime = TimeSpan.FromMinutes(5),\r\n    }, disposeHandler: false);\r\n});\r\n\u0060\u0060\u0060\r\n\r\nIf you still want to use \u0060IHttpClientFactory\u0060 (it\u0027s got really good delegating handler building overloads) and can work within the fact that the \u0060Backchannel\u0060 will be application-lifetime, you could get fancy with [using DI services to configure options](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-3.1#use-di-services-to-configure-options).\r\n\r\n\u0060\u0060\u0060 csharp\r\n// configure a named HttpClient for use as the backchannel, use SocketsHttpHandler\r\n// configure delegating handler pipeline like Polly here as usual\r\nservices.AddHttpClient(\u0022backchannel\u0022)\r\n    .ConfigurePrimaryHttpMessageHandler(() =\u003E new SocketsHttpHandler\r\n    {\r\n        PooledConnectionLifetime = TimeSpan.FromMinutes(5),\r\n    });\r\n\r\n// configure the options (match the authentication scheme name used in AddOpenIdConnect)\r\nservices.AddOptions\u003COpenIdConnectOptions\u003E(OpenIdConnectDefaults.AuthenticationScheme)\r\n    .Bind(Configuration.GetSection(\u0022AzureAD\u0022)) // similar trick to AADv2 tutorials for using settings from appsettings.json\r\n    .Configure\u003CIHttpClientFactory\u003E((options, httpClientFactory) =\u003E\r\n    {\r\n        // use the injected IHttpClientFactory to get the named client\r\n        // note: this only happens once (the options are still bound in singleton fashion)\r\n        options.Backchannel = httpClientFactory.CreateClient(\u0022backchannel\u0022);\r\n\r\n        // configure other options here or in the normal AddOpenIdConnect options lambda\r\n    });\r\n\r\n// match the authentication scheme used for the options name\r\nservices.AddAuthentication()\r\n    .AddOpenIdConnect(OpenIdConnectDefaults.AuthenticationScheme, options =\u003E { /* configure options here or above with backchannel config */ });\r\n\u0060\u0060\u0060",
        "createdAt": "2020-03-24T07:57:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10542#issuecomment-603085670"
      },
      {
        "id": "IC_kwDOAQzde86XwIs1",
        "parentId": null,
        "author": "wdnijdam",
        "content": "Will there be any progress on this item. Having a BackChannelFactory would be convenient here.",
        "createdAt": "2024-12-16T15:46:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10542#issuecomment-2545978165"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0NDkwMjg2MTk=",
    "title": "OpenIdConnectHandler - Design for override",
    "url": "https://github.com/dotnet/aspnetcore/issues/10564",
    "createdAt": "2019-05-28T01:43:10Z",
    "lastUpdated": "2021-08-11T11:51:57Z",
    "body": "### Is your feature request related to a problem? Please describe.\r\nI\u0027m trying to augment the standard OpenId/Connect handler to configure additional information in the OIDC challenge and expose additional events for specific Auth failure reasons.\r\n\r\nI want to subclass the existing OpenIdConnect handler but I\u0027m have issues with getting access to some private variables, getting hooks for configuring the OpenIdConnect protocol message prior to raising events, and the hardcoding of the Options type into the base RemoteAuthenticationHandler class.\r\n\r\n### Describe the solution you\u0027d like\r\nCreate an open generic OpenIdConnectHandler that has an OpenIdConnectOptions type constraint.\r\nRefactor the current OpenIdConnectHandler to close the new generic over the existing OpenIdConnectOptions.\r\n\r\nExpose the OpenIdConnectConfiguration private variable to protected scope\r\n\r\nAdd virtual methods to allow configuring/creation of the OpenIdConnect protocol messages BEFORE invoking the RedirectToIdentityProvider event \r\n\r\nAllow setting of the JSON parsing settings ( JObject or JsonDocument ) instead of calling the overload of Parse without settings\r\n\r\nAllow a way of Removing default claim actions added in the OpenIdConnectOptions constructor, we have to clear and duplicate the actions just because I want some of the OpenId claims ( specifically AMR ) to be available to the OpenId client\u0027s system.\r\n\r\n### Describe alternatives you\u0027ve considered\r\nI created a new set of classes inheriting from RemoteAuthenticationHandler\u003CT\u003E, but creating an internal OpenIdConnect handler and routing the HandleChallengeAsync, HandleRemoteAuthenticateAsync, and SignOutAsync from the outer handler to the inner OpenIdConnect handler.\r\nI\u0027m getting significant friction with the way the Events property is created (InitializeEventsAsync) to coordinate the Events instance between the 2 handlers\r\n\r\n\r\n### Additional context\r\nAdd any other context or screenshots about the feature request here.\r\n",
    "upvotes": 0,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NjMzNTQxMw==",
        "parentId": null,
        "author": "brockallen",
        "content": "\u003E specifically AMR\r\n\r\nI have a feeling \u0060amr\u0060 will be automatically available in a upcoming release, and other claims easier to make available.",
        "createdAt": "2019-05-28T01:45:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10564#issuecomment-496335413"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NjYwMjIxOA==",
        "parentId": null,
        "author": "blowdart",
        "content": "As this would be a rather large, and potentially break change, it could only take place ion a major release, so moving to the backlog until we plan the next major release",
        "createdAt": "2019-05-28T17:00:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10564#issuecomment-496602218"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NzE2NjYxNA==",
        "parentId": null,
        "author": "slaneyrw",
        "content": "Just an additional note that to get my Options subclass into the Events context I need to inherit from each context type, override the Options property and EACH Handle method.  A lot of work when doing from the outside, and trying to navigate the mire of private and protected scopes.\r\n\r\n",
        "createdAt": "2019-05-30T01:29:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10564#issuecomment-497166614"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NzE2NzQzNQ==",
        "parentId": null,
        "author": "slaneyrw",
        "content": "\u003E \u003E specifically AMR\r\n\u003E \r\n\u003E I have a feeling \u0060amr\u0060 will be automatically available in a upcoming release, and other claims easier to make available.\r\n\r\nNot really my sticking point... getting my Options subclass into the _entire_ Handler/Events object structure means I have to wrap most of them and forward method calls.",
        "createdAt": "2019-05-30T01:34:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10564#issuecomment-497167435"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg2MTU1NjU1Mg==",
        "parentId": null,
        "author": "DumboJet",
        "content": "I have the same requirement, because our authentication provider (Signicat) seems to be trying to make the token endpoint to require the client ID and secret passed as a basic auth header. They have only enabled this behavior in a test environment of theirs and created a mess for us.\r\nFrom what I have seen, this is now recommended practice:\r\n\r\nhttps://datatracker.ietf.org/doc/html/rfc6749#section-2.3.1\r\n\r\n\u003E    Including the client credentials in the request-body using the two\r\n   parameters is NOT RECOMMENDED and SHOULD be limited to clients unable\r\n   to directly utilize the HTTP Basic authentication scheme (or other\r\n   password-based HTTP authentication schemes).  The parameters can only\r\n   be transmitted in the request-body and MUST NOT be included in the\r\n   request URI.\r\n\r\nThe only way to support this, seems to be overriding the \u0060OpenIdConnectHandler\u0060 (the \u0060RedeemAuthorizationCodeAsync\u0060 method [here](https://github.com/aspnet/Security/blob/master/src/Microsoft.AspNetCore.Authentication.OpenIdConnect/OpenIdConnectHandler.cs#L746)) but, unlike @slaneyrw, I am still struggling on how to do this...\r\nI mostly have a problem making the framework use my handler, not overriding its methods (although, getting the TokenEndpoint URL in there might be a challenge too...), so if someone can help on this it would be nice.\r\n\r\nI am trying things like:\r\n\r\n\u0060\u0060\u0060\r\n            services.AddSingleton\u003CAuthenticationHandler\u003COpenIdConnectOptions\u003E, CustomOpenIdConnectHandler\u003E();\r\n\u0060\u0060\u0060\r\n\r\n..but they don\u0027t work.\r\n\r\n----\r\n**UPDATE:**\r\nOK, I think this is how you replace the handler:\r\n\r\n\u0060\u0060\u0060\r\nservices.Replace(ServiceDescriptor.Transient\u003COpenIdConnectHandler, CustomOpenIdConnectHandler\u003E());\r\n\u0060\u0060\u0060\r\n\r\nBut turns out there is an easier way to do what I want:\r\nhttps://github.com/signicat/Quick-start-guide-Authentication-.NET-Core\r\n\r\n\u0060\u0060\u0060\r\n options.Events.OnAuthorizationCodeReceived = RedeemAuthorizationCodeAsync;\r\n\r\n....\r\nprotected virtual async Task RedeemAuthorizationCodeAsync(AuthorizationCodeReceivedContext context)\r\n{\r\n    var configuration = await context.Options.ConfigurationManager.GetConfigurationAsync(CancellationToken.None);\r\n    var requestMessage = new HttpRequestMessage(HttpMethod.Post, configuration.TokenEndpoint);\r\n    string authInfo = context.TokenEndpointRequest.ClientId \u002B \u0022:\u0022 \u002B context.TokenEndpointRequest.ClientSecret;\r\n    authInfo = Convert.ToBase64String(Encoding.Default.GetBytes(authInfo));\r\n    requestMessage.Headers.Authorization = new AuthenticationHeaderValue(\u0022Basic\u0022, authInfo);\r\n    var msg = context.TokenEndpointRequest.Clone();\r\n    msg.ClientSecret = null;\r\n    requestMessage.Content = new FormUrlEncodedContent(msg.Parameters);\r\n\r\n\r\n    var responseMessage = await context.Backchannel.SendAsync(requestMessage);\r\n    if (!responseMessage.IsSuccessStatusCode)\r\n    {\r\n        Console.WriteLine(await responseMessage.Content.ReadAsStringAsync());\r\n        return;\r\n    }\r\n\r\n    try\r\n    {\r\n        var responseContent = await responseMessage.Content.ReadAsStringAsync();\r\n        var message = new OpenIdConnectMessage(responseContent);\r\n        context.HandleCodeRedemption(message);\r\n    }\r\n    catch (Exception)\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "createdAt": "2021-06-15T14:38:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10564#issuecomment-861556552"
      },
      {
        "id": "IC_kwDOAQzde841c3zw",
        "parentId": null,
        "author": "slaneyrw",
        "content": "@DumboJet Handling an existing Event callback is how it was designed to work.  But I wanted to add new events and add additional properties to the options.  That is where my \u0022fun\u0022 started.",
        "createdAt": "2021-08-11T11:51:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10564#issuecomment-896761072"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0NDk5MDc2MDk=",
    "title": "Supporting basic authentication Token exchange in both the OAuth2 and OIDC handlers ",
    "url": "https://github.com/dotnet/aspnetcore/issues/10615",
    "createdAt": "2019-05-29T16:31:56Z",
    "lastUpdated": "2024-01-29T20:36:47Z",
    "body": "https://github.com/aspnet/AspNetCore/pull/9448#issuecomment-484298711\r\n\r\nOAuth and OIDC have a standard flow of sending the clientid and secret to the token endpoint using a custom basic auth format. 4 of the auth handlers in aspnet-contrib require this flow and have to implement it manually. We expect many other providers also support this format since it\u0027s the one required in the spec.\r\n\r\nNote the encoding is customized in the OAuth spec. (I don\u0027t think the FitBit handler is following that).\r\nhttps://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/blob/aad5420654c65b5fb9908ddf298dbab17076338c/src/AspNet.Security.OAuth.Fitbit/FitbitAuthenticationHandler.cs#L66-L70\r\n\r\n@PinpointTownes ",
    "upvotes": 4,
    "labels": [
      "enhancement",
      "area-auth",
      "severity-minor",
      "affected-very-few"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NzAxNDk4NQ==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E I don\u0027t think the FitBit handler is following that\r\n\r\nYeah, the logic is not standard-compliant. Not sure whether it\u0027s an oversight or not (I guess it is), but here\u0027s an example of a valid basic header construction: https://github.com/aspnet-contrib/AspNet.Security.OAuth.Extensions/blob/378348bb4efb1d277020e2a55f41a546368f7a31/src/AspNet.Security.OAuth.Introspection/OAuthIntrospectionHandler.cs#L414-L429\r\n\r\n/cc @martincostello ",
        "createdAt": "2019-05-29T16:39:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10615#issuecomment-497014985"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NzAzNTczNQ==",
        "parentId": null,
        "author": "martincostello",
        "content": "@PinpointTownes I\u0027ll look at updating that in https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/pull/280 based on the above sample.",
        "createdAt": "2019-05-29T17:35:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10615#issuecomment-497035735"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxMTkyOTY1MQ==",
        "parentId": null,
        "author": "prochnowc",
        "content": "@Tratcher Is there any plans to implement this in the \u0060OAuthHandler\u0060 ? I need to add federation for some authority which only supports credentials via authorization header.",
        "createdAt": "2020-10-19T09:37:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10615#issuecomment-711929651"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxMjEzMTYwNw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@prochnowc no plans at present. Only a few providers have required it, and even they don\u0027t use standard implementations.\r\n\r\nYou can handle this today the same way they did for FitBit.\r\nhttps://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/blob/aad5420654c65b5fb9908ddf298dbab17076338c/src/AspNet.Security.OAuth.Fitbit/FitbitAuthenticationHandler.cs#L66-L70",
        "createdAt": "2020-10-19T12:45:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10615#issuecomment-712131607"
      },
      {
        "id": "IC_kwDOAQzde843f2Sq",
        "parentId": null,
        "author": "MrSmoke",
        "content": "Just throwing my two cents on this ticket as I\u0027ve also ran into this recently (also ended up using a similar method to the FitBit handler so no biggie).\r\n\r\nSince its defined in the [RFC](https://datatracker.ietf.org/doc/html/rfc6749#section-2.3.1) it would be nice to have it as an option for those very few providers who do implement it as per the spec.",
        "createdAt": "2021-09-30T09:05:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10615#issuecomment-931095722"
      },
      {
        "id": "IC_kwDOAQzde85Iu8t5",
        "parentId": null,
        "author": "dylantack",
        "content": "Curiously, the documentation contains a description of [TokenEndpointAuthMethodsSupported](https://docs.microsoft.com/en-us/dotnet/api/microsoft.identitymodel.protocols.openidconnect.openidconnectconfiguration.tokenendpointauthmethodssupported?view=azure-dotnet#microsoft-identitymodel-protocols-openidconnect-openidconnectconfiguration-tokenendpointauthmethodssupported), but it appears to be unimplemented.\r\n\r\nAt least for me, this has no effect:\r\n\r\n\u0060\u0060\u0060\r\n       options.Configuration = new OpenIdConnectConfiguration\r\n       {\r\n           TokenEndpointAuthMethodsSupported = { \u0022client_secret_basic\u0022 },\r\n       };\r\n\u0060\u0060\u0060",
        "createdAt": "2022-08-19T05:26:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10615#issuecomment-1220266873"
      },
      {
        "id": "IC_kwDOAQzde85rv9At",
        "parentId": null,
        "author": "lausitzer",
        "content": "@Tratcher a whole rewrite of ExchangeCodeAsync() to support client_secret_basic is a bad idea (at least in my opinion) because you decouple from further improvements in the development and run the risk of incompatibilities. The linked FitBit code is a good example for that, it doesn\u0027t support PKCE verifier_code like the original implementation does. That results in trouble if your identity provider relies on PKCE (like ADFS) or expects verifier_code in the token request if you sent code_challenge in the authorization request (like GitLab).\r\n\r\nIf I may wish for something, implement client_secret_basic or split ExchangeCodeAsync() in one part for content creation and another one for transmission. That gives us a chance to adjust content in dedicated points before transmission without the need to generate it from scratch.",
        "createdAt": "2023-11-13T09:11:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10615#issuecomment-1807732781"
      },
      {
        "id": "IC_kwDOAQzde85ryud_",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E The linked FitBit code is a good example for that, it doesn\u0027t support PKCE verifier_code like the original implementation does.\r\n\r\nIt\u0027s worth noting that the permalink present in the OP points to an old commit: the implementation has since been updated to optionally support PKCE (which isn\u0027t too terrible as it requires just 5 lines of code, braces included: https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/blob/dev/src/AspNet.Security.OAuth.Fitbit/FitbitAuthenticationHandler.cs)\r\n\r\nAs part of the [OpenIddict web providers development](https://kevinchalet.com/2022/12/16/getting-started-with-the-openiddict-web-providers/), I had to implement and test ~60 integrations (including a lot of providers we already support via aspnet-contrib), so I can shed some - fresh - light for those who are interested:\r\n\r\n  - Some providers - e.g Dropbox, LinkedIn, PayPal or Salesforce - have started offering OpenID Connect support (either by updating their existing OAuth 2.0 implementation or by providing new endpoints).\r\n\r\n  - Most of the providers that implemented OpenID Connect also implemented the optional discovery specification (which is a great thing). Sadly, I didn\u0027t see much appetite for the OAuth 2.0 equivalent/backport - \u0060OAuth 2.0 Authorization Server Metadata\u0060 - that wasn\u0027t adopted by any major service.\r\n\r\n  - PKCE is slowly being implemented in popular services: ArcGIS, Discord, Facebook, Fitbit, Lichess, Twitter and Zoom now officially support it.\r\n\r\n  - There are still providers that only support \u0060client_secret_basic\u0060: Fitbit, Kroger, Notion, Reddit, ServiceChannel and Twitter. Reddit is still the weirdest one in that list as it requires sending the \u0060client_id\u0060 using basic authentication even when there\u0027s no \u0060client_secret\u0060 (in this case, the standard approach would be to send \u0060client_id\u0060 in the form).\r\n\r\n  - The fact a provider offers a recent implementation doesn\u0027t mean it\u0027s standard-compliant, even if it implements OIDC. For instance:\r\n      - The new OIDC-based LinkedIn implementation doesn\u0027t return a \u0060token_endpoint_auth_methods_supported\u0060 node in its discovery document, so a standard client would have to use \u0060client_secret_basic\u0060 (since it\u0027s the default client authentication method)... but LinkedIn doesn\u0027t support basic authentication AT ALL \uD83E\uDD23\r\n      - The quite recent EpicGames service (OIDC-based too) doesn\u0027t implement the standard \u0060client_secret_basic\u0060 encoding method as it doesn\u0027t support formURL-encoding AND returns chars that need to be escaped in its tokens...\r\n\r\nConclusion: it\u0027s sadly still a hot mess.",
        "createdAt": "2023-11-13T16:04:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10615#issuecomment-1808459647"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0NTc5NzAwMjg=",
    "title": "Cannot handle error if host is not reachable for JwtBearer",
    "url": "https://github.com/dotnet/aspnetcore/issues/11368",
    "createdAt": "2019-06-19T11:56:48Z",
    "lastUpdated": "2021-03-01T23:36:11Z",
    "body": "### Describe the bug\r\n\r\nif you have more then one authentication server (JWT or OpenID) that you trust if one of them is down we are getting error: \r\n\r\n\u0060\u0060\u0060\r\n IDX20803: Unable to obtain configuration from: \u0027[PII is hidden by default. Set the \u0027ShowPII\u0027 flag in IdentityModelEventSource.cs to true to reveal it.]\u0027.\r\n\u0060\u0060\u0060\r\n\r\nWe should have a way to make this check optional\r\n\r\n### To Reproduce\r\nSteps to reproduce the behavior:\r\n1. Add two authentication schemas with two Authority URLs\r\n2. Turn off one of the authorities\r\n3. See error when try to navigate to endpoint supporting both authorities\r\n\r\nSample configuration of two JWT bearer can be found here\r\nhttps://stackoverflow.com/questions/49694383/use-multiple-jwt-bearer-authentication\r\n\r\n### Expected behavior\r\n\r\nIgnore authentication service if not available. Return 401 if it is the only trusted source.\r\n\r\n",
    "upvotes": 1,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwNDI2MjA5NA==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Can you clarify your scenario? Are these just alternate ways clients can be configured and if one isn\u0027t functional, then you want to continue to allow clients configured with the other token source to be authenticated? That doesn\u0027t seem unreasonable but it\u0027s not something we\u0027ve had significant demand for. I\u0027m putting this on the backlog for now, but I don\u0027t expect it\u0027s something we\u0027ll have the resources to look at in our upcoming releases.",
        "createdAt": "2019-06-21T02:09:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11368#issuecomment-504262094"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwNDI4ODc2Ng==",
        "parentId": null,
        "author": "vasicvuk",
        "content": "Scenario is next. I have two authentication servers that i trust. One is issuing tokens to general users on the single environment and the second one is admin authority (authentication server) which is trusted by multiple environments. If the admin authentication server is down i still want users to be able to access environment. Currently if i have some downtime on admin authentication server all the environments are unaccessible by users.\r\n\r\n",
        "createdAt": "2019-06-21T04:55:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11368#issuecomment-504288766"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc4ODM0OTY5NQ==",
        "parentId": null,
        "author": "jayeshkv",
        "content": "@vasicvuk were you able to find a workaround for this specific issue ?",
        "createdAt": "2021-03-01T22:29:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11368#issuecomment-788349695"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc4ODQwMDQ3Ng==",
        "parentId": null,
        "author": "LukeStephen",
        "content": "\u003E Can you clarify your scenario? Are these just alternate ways clients can be configured and if one isn\u0027t functional, then you want to continue to allow clients configured with the other token source to be authenticated? That doesn\u0027t seem unreasonable but it\u0027s not something we\u0027ve had significant demand for. I\u0027m putting this on the backlog for now, but I don\u0027t expect it\u0027s something we\u0027ll have the resources to look at in our upcoming releases.\r\n\r\nWe\u0027re in this situation right now, one identity server authentication server went down at a 3rd party company we had integrated SSO with and then no one could log in on the Azure AD instance that was configured for all other users.",
        "createdAt": "2021-03-01T23:36:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11368#issuecomment-788400476"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0NjkwNzU5MDA=",
    "title": "JwtBearer and OpenIdConnect handlers should have support for JWT type validation",
    "url": "https://github.com/dotnet/aspnetcore/issues/12269",
    "createdAt": "2019-07-17T09:09:45Z",
    "lastUpdated": "2020-11-10T23:27:25Z",
    "body": "This is really more an issue for the underlying JWT handler\r\n\r\nhttps://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/1220\r\n\r\nBut I thought it might be interesting to bring this to your attention. @blowdart ",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "affected-few",
      "severity-minor"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxMjk4NzMwOA==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Triage: Yep, we will probably need to react to this. Backlogging since we don\u0027t have a timeline on the AAD changes yet.",
        "createdAt": "2019-07-18T21:05:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12269#issuecomment-512987308"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0Nzc4NzM2MTA=",
    "title": "UseExceptionHandler middleware can\u0027t handle exceptions from UseAuthentication middleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/12939",
    "createdAt": "2019-08-07T11:35:10Z",
    "lastUpdated": "2023-02-03T16:18:59Z",
    "body": "### Describe the bug\r\nWhen an exception is thrown from the \u0060UseAuthentication\u0060 middleware it propagates back up the pipeline until caught by the \u0060UseExceptionHandler\u0060 middleware which then re-executes the pipeline using the error path which then gets to the \u0060UseAuthentication\u0060 middleware a second time but because the cached \u0060Task\u0060 from the first call to \u0060UseAuthentication\u0060 is returned the second time around the initial exception on the \u0060Task\u0060 is returned as soon as it is awaited causing \u0060UseExceptionHandler\u0060 to catch it as a secondary exception and then throw the original exception it caught.\r\n\r\n### To Reproduce\r\nSteps to reproduce the behavior:\r\nVersion 2.2.6 of ASP.NET Core\r\nMinimal reproduction https://github.com/AquilaSands/AspNetCoreCookieErrorHandlerBug based on https://github.com/aspnet/AspNetCore.Docs/tree/master/aspnetcore/security/authentication/cookie/samples/2.x/CookieSample\r\n\r\n1. Run the minimal repro\r\n2. Sign in\r\n3. Follow the \u0027Contact (Authentication Required)\u0027 link\r\n4. This will cause a \u0060CustomException\u0060 to be thrown from the custom \u0060ValidatePrincipal()\u0060 method\r\n5. The custom error page is not shown and you get the generic browser 500 error page\r\n\r\n### Expected behavior\r\nExpect the custom error page to be shown.\r\n\r\n### Sample log output\r\nhttps://github.com/AquilaSands/AspNetCoreCookieErrorHandlerBug/blob/dc50eda4b1dfc0bbc926f00109d57b6f2193499d/log-output.txt\r\n\r\n### Additional context\r\nThe behaviour of the authentication middleware is clearly by design but I think it either needs a way to clear the cached \u0060Task\u0060 or it should avoid caching a faulted \u0060Task\u0060.\r\n\r\n### Output of \u0060dotnet --info\u0060\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   2.2.301\r\n Commit:    70d6be0814\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.17763\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.2.301\\\r\n\r\nHost (useful for support):\r\n  Version: 2.2.6\r\n  Commit:  7dac9b1b51\r\n\r\n.NET Core SDKs installed:\r\n  2.1.700 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.701 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.300 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.301 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.2.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.2.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.2.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.2.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.1.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.2.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.2.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n",
    "upvotes": 1,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxOTE5MzQ0MA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Your repro app makes sense, but could you please describe the original exception scenario where you encountered this? Were you able to work around it? That will help us prioritize this.",
        "createdAt": "2019-08-07T17:26:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12939#issuecomment-519193440"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxOTIyMzM5NA==",
        "parentId": null,
        "author": "AquilaSands",
        "content": "Hi, the original scenario uses social authentication providers along with the cookie auth scheme but it is essentially the same as the repro, once a user is authenticated they are signed in with the cookie scheme. The app is multi tenant database per customer so it provides an implementation of the ValidatePrincipal() event to get additional claims for authorization from a tenant db I had a bug in my implementation which caused an exception which triggered this issue.\r\n\r\nI haven\u0027t found a workaround for this issue other than writing my own code a bit better so it doesn\u0027t cause exceptions in the first place \uD83D\uDE04. ",
        "createdAt": "2019-08-07T18:48:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12939#issuecomment-519223394"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxOTI0MzIwMw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Indeed, not throwing in the first place is your best option \uD83D\uDE01.  \u0060UseExceptionHandler\u0060 is a best effort to show a friendly error, but it will never be able to handle all errors. We\u0027ll see if there\u0027s something we can do to address this specific scenario.",
        "createdAt": "2019-08-07T19:47:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12939#issuecomment-519243203"
      },
      {
        "id": "IC_kwDOAQzde85UV-ns",
        "parentId": null,
        "author": "michael-freidgeim-webjet",
        "content": "Is any workaround available since 2019? ",
        "createdAt": "2023-02-03T05:49:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12939#issuecomment-1415047660"
      },
      {
        "id": "IC_kwDOAQzde85UZ93h",
        "parentId": null,
        "author": "Tratcher",
        "content": "You can use the other overload of UseExceptionHandler to provide a response without re-executing the middleware pipeline.\r\nhttps://github.com/dotnet/aspnetcore/blob/6a547f269de700cfe333946e1fd744e4332a904a/src/Middleware/Diagnostics/src/ExceptionHandler/ExceptionHandlerExtensions.cs#L56",
        "createdAt": "2023-02-03T16:18:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12939#issuecomment-1416093153"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0NzkxMTU2NDM=",
    "title": "React to corefx negotiate linux error reporting changes",
    "url": "https://github.com/dotnet/aspnetcore/issues/13011",
    "createdAt": "2019-08-09T18:35:26Z",
    "lastUpdated": "2021-07-22T22:36:37Z",
    "body": "In https://github.com/aspnet/AspNetCore/issues/12566 we had to work around some corefx linux limitations. These were fixed in https://github.com/dotnet/corefx/pull/40105. Remove the workarounds.\r\n\r\nMainly these parts:\r\nhttps://github.com/aspnet/AspNetCore/blob/6e25a9fc53dd5fb8332c685e0c92f10c70bc225f/src/Security/Authentication/Negotiate/src/Internal/ReflectedNegotiateState.cs#L52-L58\r\nhttps://github.com/aspnet/AspNetCore/blob/6e25a9fc53dd5fb8332c685e0c92f10c70bc225f/src/Security/Authentication/Negotiate/src/Internal/ReflectedNegotiateState.cs#L111-L127\r\n\r\nThis is only cleanup, it can happen in master/5.x.",
    "upvotes": 0,
    "labels": [
      "task",
      "area-auth",
      "severity-nice-to-have",
      "affected-very-few"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NDY3Njk1Mw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Removing my assignment here. We need to get someone else ramped up on this scenario.",
        "createdAt": "2019-12-11T18:38:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13011#issuecomment-564676953"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg4MDI2OTQ2MQ==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-07-14T23:12:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13011#issuecomment-880269461"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0Nzk1NTA4Mzk=",
    "title": "multiple JwtBearer authentication schemes continually refresh metadata",
    "url": "https://github.com/dotnet/aspnetcore/issues/13046",
    "createdAt": "2019-08-12T09:34:52Z",
    "lastUpdated": "2021-12-09T00:11:54Z",
    "body": "### Describe the bug\r\nWe require accepting multiple JwtBearer audience/authority pairs for our api. \r\n\r\nWhen we setup multiple JwtBearer authentication for our api, we notice that aspnetcore middleware is continually calling the \u0060.well-known/openid-configuration\u0060 at the minimum refresh interval of 30 seconds instead of the desired AutomaticRefreshInterval of 1 day.\r\n\r\n### To Reproduce\r\nSteps to reproduce the behavior:\r\n1. Using ASP.NET Core Version 2.2\r\n2. Configure to use multiple Jwt Bearers (see code below)\r\n3. Get a valid authorization token (note - invalid tokens have the same result)\r\n4. Run any endpoint that engages the middleware e.g. \u0060[Authorize]\u0060 and pass the token correctly\r\n3. Observe that the \u0060.well-known/openid-configuration\u0060 for all configured JwtBearer\u0027s will be called every 30 seconds (or every \u0060RefreshInterval\u0060) instead of once a day (or every \u0060AutomaticRefreshInterval\u0060).\r\n\r\n### Expected behavior\r\nExpect the default Refresh Interval of 30 seconds, and AutomaticRefreshInterval of 1 day to be sufficient, and the \u0060.well-known/openid-configuration\u0060 to be called at most once per day per scheme.\r\n\r\nNote that I did perform a test of a single Jwt Bearer registered as the default, and it did perform as expected only calling at the AutomaticRefreshInterval \r\n\r\n### Additional context\r\n- using the http interceptor isn\u0027t required if you can monitor with Application Insights\r\n- it makes no difference if the audience strings are the same or different\r\n\r\nInclude the output of \u0060dotnet --info\u0060\r\n\r\n\u0060\u0060\u0060\r\nC:\\repos\\test\u003Edotnet --info\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   2.2.401\r\n Commit:    729b316c13\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.17763\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\2.2.401\\\r\n\r\nHost (useful for support):\r\n  Version: 2.2.6\r\n  Commit:  7dac9b1b51\r\n\r\n.NET Core SDKs installed:\r\n  1.0.2 [C:\\Program Files\\dotnet\\sdk]\r\n  1.0.3 [C:\\Program Files\\dotnet\\sdk]\r\n  1.0.4 [C:\\Program Files\\dotnet\\sdk]\r\n  1.1.0 [C:\\Program Files\\dotnet\\sdk]\r\n  2.0.2 [C:\\Program Files\\dotnet\\sdk]\r\n  2.0.3 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.2 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.4 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.101 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.102 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.103 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.104 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.200 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.201 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.202 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.302 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.400 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.401 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.402 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.403 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.500 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.502 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.503 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.504 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.505 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.507 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.700 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.701 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.801 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.102 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.300 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.301 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.401 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.2.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.2.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.2.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.2.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.2.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.2.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 1.0.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.1.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 1.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.3-servicing-26724-03 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.2.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.2.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.2.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n\u0060\u0060\u0060\r\n\r\nCode to reproduce. I used the VS2019 template for a webapi and modified it slightly.\r\n\r\n\u0060\u0060\u0060c#\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Threading.Tasks;\r\nusing Microsoft.AspNetCore.Authentication;\r\nusing Microsoft.AspNetCore.Authorization;\r\nusing Microsoft.AspNetCore.Builder;\r\nusing Microsoft.AspNetCore.Hosting;\r\nusing Microsoft.AspNetCore.HttpsPolicy;\r\nusing Microsoft.AspNetCore.Mvc;\r\nusing Microsoft.Extensions.Configuration;\r\nusing Microsoft.Extensions.DependencyInjection;\r\nusing Microsoft.Extensions.Logging;\r\nusing Microsoft.Extensions.Options;\r\n\r\nnamespace WebApplicationAuthTest\r\n{\r\n    public class Startup\r\n    {\r\n        public Startup(IConfiguration configuration)\r\n        {\r\n            Configuration = configuration;\r\n        }\r\n\r\n        public IConfiguration Configuration { get; }\r\n\r\n        // This method gets called by the runtime. Use this method to add services to the container.\r\n        public void ConfigureServices(IServiceCollection services)\r\n        {\r\n            // this example uses 2 different auth0 tenants, but this shouldn\u0027t matter\r\n            const string audience_one = \u0022https://api1.example.com\u0022;\r\n            const string authority_one = \u0022https://test-tenant-a.au.auth0.com/\u0022;\r\n            const string audience_two = \u0022https://api2.example.com\u0022;\r\n            const string authority_two = \u0022https://test-tenant-b.au.auth0.com/\u0022;\r\n\r\n            var auth = services\r\n                .AddAuthentication()\r\n#if true\r\n                .AddJwtBearerWithHttpIntercept(\u0022Auth-A\u0022, audience_one, authority_one)\r\n                .AddJwtBearerWithHttpIntercept(\u0022Auth-B\u0022, audience_two, authority_two)\r\n#else\r\n                // AddJwtBearerWithHttpIntercept is equivalent to these. All it adds is http client interception for request/response logging.\r\n                .AddJwtBearer(\u0022Auth-A\u0022, options =\u003E\r\n                {\r\n                    options.Audience = audience_one;\r\n                    options.Authority = authority_one;\r\n\r\n                    options.Validate();\r\n                })\r\n                .AddJwtBearer(\u0022Auth-B\u0022, options =\u003E\r\n                {\r\n                    options.Audience = audience_two;\r\n                    options.Authority = authority_two;\r\n\r\n                    options.Validate();\r\n                })\r\n#endif\r\n                ;\r\n\r\n\r\n            services.AddAuthorization(options =\u003E\r\n            {\r\n                options.DefaultPolicy = new AuthorizationPolicyBuilder()\r\n                    .RequireAuthenticatedUser()\r\n                    .AddAuthenticationSchemes(\u0022Auth-A\u0022, \u0022Auth-B\u0022)\r\n                    .Build();\r\n            });\r\n\r\n            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);\r\n        }\r\n\r\n        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\r\n        public void Configure(IApplicationBuilder app, IHostingEnvironment env)\r\n        {\r\n            if (env.IsDevelopment())\r\n            {\r\n                app.UseDeveloperExceptionPage();\r\n            }\r\n            else\r\n            {\r\n                // The default HSTS value is 30 days. You may want to change this for production scenarios, see https://aka.ms/aspnetcore-hsts.\r\n                app.UseHsts();\r\n            }\r\n\r\n            app.UseHttpsRedirection();\r\n            app.UseMvc();\r\n        }\r\n    }\r\n\r\n\r\n    public static class JwtConfiguration\r\n    {\r\n        public static AuthenticationBuilder AddJwtBearerWithHttpIntercept(this AuthenticationBuilder authenticationBuilder, string schemeIdentifier, string audience, string authority)\r\n        {\r\n            return authenticationBuilder\r\n                 .AddJwtBearer(schemeIdentifier, options =\u003E\r\n                 {\r\n                     options.Audience = audience;\r\n                     options.Authority = authority;\r\n\r\n\r\n                     // Except for this - we added it ourselves. Technically all we should need to set is this unless we want to modify configurationManager.\r\n                     options.BackchannelHttpHandler = new LoggingHandler(new System.Net.Http.HttpClientHandler());\r\n\r\n#if false\r\n\r\n                     // this is as-is defaults from https://github.com/aspnet/AspNetCore/blob/v2.2.6/src/Security/Authentication/JwtBearer/src/JwtBearerPostConfigureOptions.cs\r\n                     if (string.IsNullOrEmpty(options.MetadataAddress) \u0026\u0026 !string.IsNullOrEmpty(options.Authority))\r\n                     {\r\n                         options.MetadataAddress = options.Authority;\r\n                         if (!options.MetadataAddress.EndsWith(\u0022/\u0022, StringComparison.Ordinal))\r\n                         {\r\n                             options.MetadataAddress \u002B= \u0022/\u0022;\r\n                         }\r\n\r\n                         options.MetadataAddress \u002B= \u0022.well-known/openid-configuration\u0022;\r\n                     }\r\n\r\n                     var httpClient = new System.Net.Http.HttpClient(options.BackchannelHttpHandler ?? new System.Net.Http.HttpClientHandler());\r\n                     httpClient.Timeout = options.BackchannelTimeout;\r\n                     httpClient.MaxResponseContentBufferSize = 1024 * 1024 * 10; // 10 MB\r\n\r\n                     var configurationManager = new Microsoft.IdentityModel.Protocols.ConfigurationManager\u003CMicrosoft.IdentityModel.Protocols.OpenIdConnect.OpenIdConnectConfiguration\u003E(\r\n                         options.MetadataAddress, new Microsoft.IdentityModel.Protocols.OpenIdConnect.OpenIdConnectConfigurationRetriever(),\r\n                         new Microsoft.IdentityModel.Protocols.HttpDocumentRetriever(httpClient) { RequireHttps = options.RequireHttpsMetadata });\r\n                     options.ConfigurationManager = configurationManager;\r\n\r\n\r\n                     // Except here - we manually increase the RefreshInterval to prove it\u0027s the RefreshInterval\r\n                     configurationManager.RefreshInterval = TimeSpan.FromMinutes(5);\r\n                     // configurationManager.AutomaticRefreshInterval = \r\n#endif\r\n\r\n\r\n                     options.Validate();\r\n                     Console.WriteLine($\u0022Added {schemeIdentifier} for authority {authority} and audience {audience}\u0022);\r\n\r\n                 });\r\n        }\r\n    }\r\n\r\n    public class LoggingHandler : System.Net.Http.DelegatingHandler\r\n    {\r\n        public LoggingHandler(System.Net.Http.HttpMessageHandler innerHandler)\r\n            : base(innerHandler)\r\n        {\r\n        }\r\n\r\n        protected override async Task\u003CSystem.Net.Http.HttpResponseMessage\u003E SendAsync(System.Net.Http.HttpRequestMessage request, System.Threading.CancellationToken cancellationToken)\r\n        {\r\n            Console.WriteLine(\u0022Request:\u0022);\r\n            Console.WriteLine(request.ToString());\r\n            if (request.Content != null)\r\n            {\r\n                Console.WriteLine(await request.Content.ReadAsStringAsync());\r\n            }\r\n            Console.WriteLine();\r\n\r\n            System.Net.Http.HttpResponseMessage response = await base.SendAsync(request, cancellationToken);\r\n\r\n            Console.WriteLine(\u0022Response:\u0022);\r\n            Console.WriteLine(response.ToString());\r\n            if (response.Content != null)\r\n            {\r\n                Console.WriteLine(await response.Content.ReadAsStringAsync());\r\n            }\r\n            Console.WriteLine();\r\n\r\n            return response;\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n",
    "upvotes": 7,
    "labels": [
      "bug",
      "area-auth",
      "severity-major",
      "affected-medium",
      "multi-tenancy"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzMDU2MjI2Mg==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Does it hit this code path?\r\nhttps://github.com/aspnet/AspNetCore/blob/71c5c66b211c7ab9d44751e39cef27c525124bb7/src/Security/Authentication/JwtBearer/src/JwtBearerHandler.cs#L112-L121\r\nA) Token arrives for Auth-B.\r\nB) Authenticate runs for Auth-A, fails with SecurityTokenSignatureKeyNotFoundException (?), requests a rate limited refresh of metadata\r\nC) Authenticate runs for Auth-B and succeeds.\r\n\r\nIf this is what\u0027s happening then you should only see refreshes for A, not B. Disabling RefreshOnIssuerKeyNotFound would prevent it.",
        "createdAt": "2019-09-11T20:56:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13046#issuecomment-530562262"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzMzY0MjYwMg==",
        "parentId": null,
        "author": "HudsonAkridge",
        "content": "We\u0027re having the exact same problem where \u0060RefreshOnIssuerKeyNotFound\u0060 is firing on either Bearer Scheme failing. One of the two will always fail for us, while the other succeeds.",
        "createdAt": "2019-09-20T17:28:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13046#issuecomment-533642602"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzMzcyMTIxOQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@HudsonAkridge it should only ever fire for the first provider. Can you confirm?",
        "createdAt": "2019-09-20T21:51:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13046#issuecomment-533721219"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNDc2MjA1NQ==",
        "parentId": null,
        "author": "eliaslopezgt",
        "content": "@Tratcher If I add 4 JWTBearerHandlers and only one can validate the token, it reloads the configuration on the other 3.  Hope that helps. https://github.com/aspnet/AspNetCore/issues/14397",
        "createdAt": "2019-09-24T21:47:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13046#issuecomment-534762055"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNDc2ODgzMw==",
        "parentId": null,
        "author": "blowdart",
        "content": "Does it happen every time? Every so often isn\u0027t unsurprising as it will go through the handlers in order and refresh to see if there\u0027s a new key.",
        "createdAt": "2019-09-24T22:10:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13046#issuecomment-534768833"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNDgzOTU4NQ==",
        "parentId": null,
        "author": "eliaslopezgt",
        "content": "Maybe this section from the issue I created helps.\r\n\r\n### Expected behavior\r\nThis behavior is acceptable as long as there\u0027s only one \u0060JWTBearerHandler\u0060.\r\nHaving multiple \u0060JWTBearerHandlers\u0060 results in unwanted traffic to the configuration endpoints.\r\nThis can be currently mitigated by:\r\n\r\n1. Setting the \u0060RefreshInterval\u0060 to something different than its default (30 seconds)\r\n2. Setting \u0060RefreshOnIssuerKeyNotFound\u0060 to false in all the \u0060JWTBearerHandlers\u0060\r\n\r\nMy proposed solution is to create an additional \u0060OnSignatureValidationFailed\u0060 event that can be triggered before \u0060Options.ConfigurationManager.RequestRefresh();\u0060 in \u0060JwtBearerHandler.cs\u0060 \r\nhttps://github.com/aspnet/AspNetCore/blob/master/src/Security/Authentication/JwtBearer/src/JwtBearerHandler.cs\r\n\r\nThis with the purpose of allowing the caller to intercept the \u0060RequestRefresh\u0060 and in this case, inject logic that can compare the \u0060invalid token\u0060 audience and authority, with the audience and authority of \u0060the handler\u0060, if they are the same, then trigger the refresh otherwise it means we are trying to validate a token that is going to fail the validation no matter if we refresh.\r\n\r\nThe only change to the JWTBearerHandler is the addition of the \u0060OnSignatureValidationFailed\u0060 event. I have a PR ready but wanted to discuss if this could bring any value or not.",
        "createdAt": "2019-09-25T03:52:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13046#issuecomment-534839585"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNTEwNDQyNA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@blowdart this is functioning as intended, and the mitigations listed above are effective:\r\n1. Setting the RefreshInterval to something different than its default (30 seconds)\r\n1. Setting RefreshOnIssuerKeyNotFound to false in all the JWTBearerHandlers\r\n\r\nOne way to redesign this would be to build one JwtAuthHandler that could contain multiple configurations. It would loop through all of them before triggering this kind of failure. Similar logic already exists when there are multiple token validators configured.\r\n\r\nhttps://github.com/aspnet/AspNetCore/blob/752d99ca531f587fae92da63c1120f95c453e72a/src/Security/Authentication/JwtBearer/src/JwtBearerHandler.cs#L103-L105\r\n\r\nRecommend backlog.",
        "createdAt": "2019-09-25T16:31:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13046#issuecomment-535104424"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNTE4MTEyMg==",
        "parentId": null,
        "author": "eliaslopezgt",
        "content": "@blowdart can I help with it?",
        "createdAt": "2019-09-25T19:43:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13046#issuecomment-535181122"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNzIzMDUwNQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@eliaslopezgt feel free to make some proposals, but for a refactor this large we want to agree on a design before starting any PRs.",
        "createdAt": "2019-10-01T21:06:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13046#issuecomment-537230505"
      },
      {
        "id": "IC_kwDOAQzde8469_wi",
        "parentId": null,
        "author": "Tiberriver256",
        "content": "If anyone else is struggling with this, I stumbled across a workaround for this issue here:\r\nhttps://oliviervaillancourt.com/posts/Fixing-IDX10501-MultipleAuthScheme\r\n\r\nBasically, the issue seems to be that when running multiple auth schemes every auth scheme will attempt to validate the token. For the correct auth scheme everything happens as expected. For the other auth schemes, signature validation will fail with \u0060SecurityTokenSignatureKeyNotFoundException: IDX10501: Signature validation failed. Unable to match key\u0060 since the jwt token was issued by a different Idp. This marks the auth scheme with the \u0060RefreshOnIssuerKeyNotFound\u0060 and the metadata is forced to reload.\r\n\r\nThe solution from the blog is basically to only attempt token validation if the issuer on the token matches the authority issuer:\r\n\r\n\u0060\u0060\u0060cs\r\nvar token = jwtHandler.ReadJwtToken(jwtToken);\r\nif (string.Equals(token.Issuer, authorityIssuer, StringComparison.OrdinalIgnoreCase))\r\n{\r\n    // means the token was issued by this authority, we make sure full validation runs as normal\r\n    return await base.HandleAuthenticateAsync();\r\n}\r\nelse\r\n{\r\n    // Skip validation since the token as issued by a an issuer that this instance doesn\u0027t know about\r\n    // That has zero of success, so we will not issue a \u0022fail\u0022 since it crowds the logs with failures of type IDX10501 \r\n    // which are not really true and certainly not useful.\r\n    this.Logger.LogDebug($\u0022Skipping jwt token validation because token issuer was {token.Issuer} but the authority issuer is: {authorityIssuer}\u0022);\r\n    return AuthenticateResult.NoResult();\r\n}\r\n\u0060\u0060\u0060\r\n\r\nAs a side note, it also gets rid of the problem in #18940",
        "createdAt": "2021-12-09T00:11:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13046#issuecomment-989330466"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0OTY5NDkxMzc=",
    "title": "Changing authentication providers at runtime",
    "url": "https://github.com/dotnet/aspnetcore/issues/14250",
    "createdAt": "2019-09-23T08:05:19Z",
    "lastUpdated": "2022-09-28T15:32:58Z",
    "body": "Hi,\r\n\r\nI want to support (re)configuring authentication providers at runtime. There are many authentication types supported in the application: cookie authentication, a custom AuthenticationHandler and external providers (such as Google).\r\n\r\nIs it possible to enable/disable and reconfigure authentication providers at runtime, even for external providers provided out of the box, such as Google? Additionally, it is possible to use the same external provider multiple times, but with different configurations?\r\n\r\nI saw the example for dynamic schemes (https://github.com/aspnet/AspNetCore/blob/5a6b6c90b6e32ecab4975c546228cc63199f168b/src/AuthSamples/samples/DynamicSchemes/Controllers/AuthController.cs), but I was wondering how to do this with external providers that are supported out of the box. Since this is abstracted behind the \u0060AddGoogle\u0060 extension on the AuthenticationBuilder, will I need to implement this myself?\r\n\r\nI\u0027m using ASP.NET Core 2.2.\r\n",
    "upvotes": 1,
    "labels": [
      "Docs",
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNDA3NDUxMQ==",
        "parentId": null,
        "author": "blowdart",
        "content": "@Tratcher do you have a suitable sample?",
        "createdAt": "2019-09-23T12:20:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-534074511"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNTY4NjMwMg==",
        "parentId": null,
        "author": "analogrelay",
        "content": "We don\u0027t have a concrete sample for using the existing auth providers.\r\n\r\n\u003E Since this is abstracted behind the \u0060AddGoogle\u0060 extension on the AuthenticationBuilder, will I need to implement this myself?\r\n\r\nYes, you\u0027d have to unpack the \u0060AddGoogle\u0060 method (look at the implementation) and adapt it to the patterns shown in the sample you referenced above.",
        "createdAt": "2019-09-26T21:06:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-535686302"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNTkyNDY4Mw==",
        "parentId": null,
        "author": "Aaronmsv",
        "content": "@blowdart @anurse Okay thanks, will do it that way then.",
        "createdAt": "2019-09-27T12:47:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-535924683"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNjE2MDAyNw==",
        "parentId": null,
        "author": "leastprivilege",
        "content": "well - maybe it is finally time to once and for all produce that sample. It\u0027s your auth and config system.\r\n\r\nAnd with sample, I mean something that is actually working. ",
        "createdAt": "2019-09-28T06:52:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-536160027"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNzUyNDA4MQ==",
        "parentId": null,
        "author": "Aaronmsv",
        "content": "I am trying to implement this now, but I\u0027m stuck at the \u0060GoogleOptions\u0060 not being updated. Causing the following exception: \u0060ArgumentException: The \u0027ClientId\u0027 must be provided\u0060.\r\n\r\nAt startup (in the \u0060ConfigureServices\u0060) I added \u0060services.AddTransient\u003CGoogleHandler\u003E();\u0060 to register the Google handler.\r\n\r\nThen at runtime, when Google authentication is enabled or modified, I add the scheme:\r\n\r\n\u0060\u0060\u0060\r\n_schemeProvider.AddScheme(new AuthenticationScheme(name, name, typeof(GoogleHandler)));\r\n\r\n_optionsCache.TryRemove(name);\r\n\r\n_optionsCache.TryAdd(name, new GoogleOptions()\r\n{\r\n\tClientId = clientId,\r\n\tClientSecret = clientSecret\r\n});\r\n\u0060\u0060\u0060",
        "createdAt": "2019-10-02T14:38:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-537524081"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNzkxOTUyOQ==",
        "parentId": null,
        "author": "ptrefall",
        "content": "I discovered that some authentication handlers require a post configure options step. With Jwt Bearer, I had to add the following before trying to add to options cache (validate is probably optional):\r\n\u0060options.Validate();\r\npostConfigureOptions.PostConfigure(provider.Schemes, options);\r\noptionsCache.TryAdd(provider.Schemes, options);\u0060\r\n\r\nwhere\r\n\u0060IPostConfigureOptions\u003CJwtBearerOptions\u003E postConfigureOptions\u0060\r\nand\r\n\u0060services.TryAddEnumerable(ServiceDescriptor.Singleton\u003C\r\nIPostConfigureOptions\u003CJwtBearerOptions\u003E,\r\nJwtBearerPostConfigureOptions\u003E());\u0060\r\n\r\nBefore I added this (and just implemented the Dynamic Schemes sample), I was getting the following error message:\r\n\r\n\u003E Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler: Information: Failed to validate the token.\r\n\r\n\u003E Microsoft.IdentityModel.Tokens.SecurityTokenSignatureKeyNotFoundException: IDX10501: Signature validation failed. Unable to match keys:",
        "createdAt": "2019-10-03T12:16:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-537919529"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNzk2ODUxMg==",
        "parentId": null,
        "author": "Aaronmsv",
        "content": "Hi, @ptrefall \r\n\r\nThanks for the tip! Unfortunately, I think the Google authentication does not have a post configurator, so it must be something else. (https://github.com/aspnet/AspNetCore/tree/release/2.2/src/Security/Authentication/Google/src)",
        "createdAt": "2019-10-03T14:24:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-537968512"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzODAxMjM5NA==",
        "parentId": null,
        "author": "Aaronmsv",
        "content": "Hi @ptrefall,\r\n\r\nIt seems I was too quick to reply. I don\u0027t remember what exactly changed, but I started getting the following exception: \r\n\r\n\u0060NullReferenceException: Object reference not set to an instance of an object.\u0060 at \u0060Microsoft.AspNetCore.Authentication.Google.GoogleHandler.BuildChallengeUrl(AuthenticationProperties properties, string redirectUri)\u0060.\r\n\r\nUpon further investigation in the [GoogleHandler:67](https://github.com/aspnet/AspNetCore/blob/release/2.2/src/Security/Authentication/Google/src/GoogleHandler.cs#L67), this line \u0060var state = Options.StateDataFormat.Protect(properties);\u0060 was causing the exception because \u0060Options.StateDataFormat\u0060 was \u0060null\u0060.\r\n\r\nIt is indeed required that a post configurator needs to run. Since \u0060GoogleHandler\u0060 derives from \u0060OAuthHandler\u0060, the following post configurator needs to be registered: \u0060OAuthPostConfigureOptions\u003CGoogleOptions, GoogleHandler\u003E\u0060.\r\n\r\nThis seems to make the Google authentication work :) I will implement more providers and see how it goes.\r\n\r\n",
        "createdAt": "2019-10-03T16:07:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-538012394"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzODAzMDg3Ng==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@Aaronmsv thanks for piecing this together. If you share your working sample we can update the DynamicSchemes sample and even add some docs to this effect.",
        "createdAt": "2019-10-03T16:53:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-538030876"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzODMwNzcxMQ==",
        "parentId": null,
        "author": "Aaronmsv",
        "content": "@Tratcher Sure, when I get it working with all the providers I need, I\u0027ll try to make a PR to update the sample, with additional docs ;)",
        "createdAt": "2019-10-04T08:43:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-538307711"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY5MTE1NjE0OA==",
        "parentId": null,
        "author": "maulik-modi",
        "content": "I am also into the same boat.\r\n@Aaronmsv and @Tratcher , can you please update PR and additional docs so it can be taken further? \r\n",
        "createdAt": "2020-09-11T15:16:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-691156148"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyNTkwOTMxNA==",
        "parentId": null,
        "author": "??",
        "content": "Thank you for contacting us. Due to a lack of activity on this discussion issue we\u0027re closing it in an effort to keep our backlog clean. If you believe there is a concern related to the ASP.NET Core framework, which hasn\u0027t been addressed yet, please file a new issue.\n\nThis issue will be locked after 30 more days of inactivity. If you still wish to discuss this subject after then, please create a new issue!",
        "createdAt": "2020-11-12T08:01:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-725909314"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyNTk0MDA1Nw==",
        "parentId": null,
        "author": "schmitch",
        "content": "please reopen.",
        "createdAt": "2020-11-12T08:58:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-725940057"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyNTk0MjU1MA==",
        "parentId": null,
        "author": "maulik-modi",
        "content": "@Tratcher  and @blowdart , Please reopen",
        "createdAt": "2020-11-12T09:02:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-725942550"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyNjk1ODMyNQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Re-opening to consider for docs. @blowdart ",
        "createdAt": "2020-11-13T18:40:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-726958325"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyNjk4NDk2Nw==",
        "parentId": null,
        "author": "blowdart",
        "content": "Well you\u0027d be on point for the docs @tratcher so if you want it, self assign :)",
        "createdAt": "2020-11-13T19:18:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-726984967"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg2Nzk0NzEyMA==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-06-24T20:58:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/14250#issuecomment-867947120"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU1MTQyMzU1OTE=",
    "title": "Provide correct warning for incorrectly configured Auth middleware in chained method calls",
    "url": "https://github.com/dotnet/aspnetcore/issues/16648",
    "createdAt": "2019-10-29T21:27:22Z",
    "lastUpdated": "2021-03-02T00:21:29Z",
    "body": "Context: https://github.com/aspnet/AspNetCore/issues/15203, https://github.com/aspnet/AspNetCore/pull/16639#issuecomment-547522901",
    "upvotes": 0,
    "labels": [
      "area-auth",
      "analyzer"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU1MTI5MTQ2NA==",
        "parentId": null,
        "author": "analogrelay",
        "content": "There should already be a runtime check if the endpoint has Auth metadata but the middleware didn\u0027t run, right? What\u0027s the request here?",
        "createdAt": "2019-11-07T22:15:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/16648#issuecomment-551291464"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU1MTcxMzkzMQ==",
        "parentId": null,
        "author": "pranavkm",
        "content": "@anurse we have an analyzer that does a build-time check for this. It works for the most use cases, but chained calls ended up producing false positives. For 3.1, the analyzer no-ops when it thinks it\u0027s seeing chained calls. The suggestion was to fix this in 5.0.\r\n\r\nAFAIK, I\u0027m fairly neutral about this issue. Startup analyzers are meant to work in the most common scenarios and aren\u0027t meant to be a panacea. We additionally have runtime checks that detect this behavior. Unless we get a ton of feedback, I\u0027d consider putting this in backlog \\ closing.",
        "createdAt": "2019-11-08T12:32:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/16648#issuecomment-551713931"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU1MTk3ODMyMg==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Ah, so fix the analyzer in 5.0? We can consider it for 5.0. I\u0027ll backlog it and label it as a candidate.",
        "createdAt": "2019-11-08T20:27:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/16648#issuecomment-551978322"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU1Mjk3MTgzOTY=",
    "title": "SignInAsync sets Location header",
    "url": "https://github.com/dotnet/aspnetcore/issues/17475",
    "createdAt": "2019-11-28T06:28:24Z",
    "lastUpdated": "2020-10-22T22:05:50Z",
    "body": "When calling SignInAsync on the login page, the Location header gets set to the value of the returnUrl query string parameter.\r\n\r\nhttps://github.com/aspnet/AspNetCore/blob/master/src/Security/Authentication/Cookies/src/CookieAuthenticationHandler.cs#L334-L335\r\n\r\nBesides I am unclear why this would be ever useful, this is a non-obvious side effect of calling SignIn and interferes with other logic on the login page. You might not always want to do a redirect - but maybe show a view. Calling \u0060return View(...);\u0060 will not work because the response has already been modified to be a redirect.",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "affected-few",
      "severity-minor"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MjM0NDgwMw==",
        "parentId": null,
        "author": "analogrelay",
        "content": "This is in order to do a redirect to the \u0060returnUrl\u0060, no? The status code should also be updated to \u006030x\u0060 in order to redirect back to the page that issued the original challenge.\r\n\r\n\u003E Calling \u0060return View(...);\u0060 will not work because the response has already been modified to be a redirect.\r\n\r\nAre you not able to reset the status-code and remove the header here? Does that not work?",
        "createdAt": "2019-12-05T22:20:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17475#issuecomment-562344803"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MjQ0ODUxMQ==",
        "parentId": null,
        "author": "brockallen",
        "content": "The question is why is this implicit? Especially in MVC where a subsequent call to a ViewResult does not take effect.",
        "createdAt": "2019-12-06T06:20:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17475#issuecomment-562448511"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2Mzg5NDgxNQ==",
        "parentId": null,
        "author": "??",
        "content": "This issue has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **4 days**. It will be closed if no further activity occurs **within 3 days of this comment**. If it *is* closed, feel free to comment when you are able to provide the additional information and we will re-investigate.\n\nSee [our Issue Management Policies](https://aka.ms/aspnet/issue-policies) for more information.",
        "createdAt": "2019-12-10T07:00:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17475#issuecomment-563894815"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NDQwNTA3NQ==",
        "parentId": null,
        "author": "leastprivilege",
        "content": "this is certainly one way to deal with the problem ;)",
        "createdAt": "2019-12-11T06:49:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17475#issuecomment-564405075"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NDQwNTM0OQ==",
        "parentId": null,
        "author": "leastprivilege",
        "content": "\u003E Are you not able to reset the status-code and remove the header here? Does that not work?\r\n\r\nThat does work - yes that\u0027s the workaround.",
        "createdAt": "2019-12-11T06:51:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17475#issuecomment-564405349"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NDcxMTkxOQ==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Ok, so this is about having a first-class way to suppress the behavior when you intend to do something different?",
        "createdAt": "2019-12-11T20:09:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17475#issuecomment-564711919"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NDcxNjk1Ng==",
        "parentId": null,
        "author": "brockallen",
        "content": "Well, it\u0027s more around is the implicit behavior well understood/used/expected by the general developer and is it something to keep going forward. In my experience, I don\u0027t know the scenarios where the implicit behavior is commonly used.",
        "createdAt": "2019-12-11T20:23:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17475#issuecomment-564716956"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NDg3NDQwOQ==",
        "parentId": null,
        "author": "leastprivilege",
        "content": "yep - single responsibility principle.\r\n\r\nI think I spend quite some time with the authN APIs in ASP.NET - but this behavior was new to me, and I needed to check the source code first to understand it.\r\n\r\nSigning in and deciding what to do afterwards are two distinct steps.\r\n",
        "createdAt": "2019-12-12T06:47:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17475#issuecomment-564874409"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NDg3NDg1MA==",
        "parentId": null,
        "author": "leastprivilege",
        "content": "..and we are explicitly talking about the low-level ASP.NET Core SignIn/SignOut APIs - the MVC SignInResult/SignOutResult can add additional behavior of course.",
        "createdAt": "2019-12-12T06:49:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17475#issuecomment-564874850"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NTA4NjU1OQ==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Thanks for the context, we\u0027ll review this in triage (@blowdart is off for the holidays so there may be some lag, but it\u0027s in our queue \uD83D\uDE04).",
        "createdAt": "2019-12-12T16:42:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17475#issuecomment-565086559"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NTIxMTA5NA==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Initial triage notes (with no @blowdart ;)): We certainly can\u0027t just change this behavior, it\u0027s been present since Katana and would significantly break. If we did something here we\u0027d have to do it via a setting to opt-out of the default redirect behavior. We\u0027ll chat again when Barry\u0027s back.",
        "createdAt": "2019-12-12T22:14:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17475#issuecomment-565211094"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NTI3MDE2MA==",
        "parentId": null,
        "author": "brockallen",
        "content": "Understood. But perhaps in 5.0 it\u0027s worth considering a diff/new behavior.",
        "createdAt": "2019-12-13T02:10:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17475#issuecomment-565270160"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU4ODI5MzY3Mg==",
        "parentId": null,
        "author": "brockallen",
        "content": "Yea, I just ran into this for another customer. This breaks the ability to render SSO properly.",
        "createdAt": "2020-02-19T15:59:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17475#issuecomment-588293672"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxNDc4ODM1OQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Re-triage:\r\nThe check here to only do this if you\u0027re on the configured \u0060LoginPath\u0060 is the most confusing magic of all, we get lots of questions asking what this property is for.\r\nhttps://github.com/dotnet/aspnetcore/blob/63199b40afd17586ee25d4ab29a42af5058edac9/src/Security/Authentication/Cookies/src/CookieAuthenticationHandler.cs#L357\r\nNote there\u0027s a separate issue about that: https://github.com/dotnet/aspnetcore/issues/4667\r\n\r\nAs called out in that issue, you can override the query\u0027s redirectUri with one from the AuthenticaitonProperties (if you\u0027re on the LoginPath). However, you can\u0027t outright prevent the redirect without hooking into the RedirectToReturnUrl event.\r\nhttps://github.com/dotnet/aspnetcore/blob/63199b40afd17586ee25d4ab29a42af5058edac9/src/Security/Authentication/Cookies/src/CookieAuthenticationHandler.cs#L413-L421\r\n\r\nSpecifying the redirect always should have been the responsibility of the caller, not implicit behavior of SignInAsync.\r\n\r\nProposal:\r\n- Fix #4667 to honor the AuthenticationProperties.RedirectUri passed to SignInAsync even if you\u0027re not on the LoginPath to address the related scenario in minimally breaking way.\r\n- We\u0027d probably need a new option to suppress the auto redirect for cases when the AuthenticationProperties.RedirectUri was not specified but the returnUrl was. Consider it an obsolete feature and update the identity templates to pass in the expected redirect on sign-in (depends on the #4667 fix). If we always pass in the redirect value then we might not even need to set the new option in the template scenarios.",
        "createdAt": "2020-10-22T22:05:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17475#issuecomment-714788359"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU1MzMzMzk4NzA=",
    "title": "Authentication Handler as an Endpoint",
    "url": "https://github.com/dotnet/aspnetcore/issues/17615",
    "createdAt": "2019-12-05T13:06:16Z",
    "lastUpdated": "2023-02-23T19:29:51Z",
    "body": "Now that almost everything (Controller, RazorPage, SignalR Hub, HealthCheck, Grpc) in ASP.NET Core is becoming an Endpoint, I\u0027m curious is there a plan to make [authentication handlers](https://github.com/aspnet/AspNetCore/blob/62351067ff4c1401556725b401478e648b66acdc/src/Security/Authentication/Core/src/AuthenticationMiddleware.cs#L45) into endpoints?",
    "upvotes": 0,
    "labels": [
      "Needs: Design",
      "enhancement",
      "Perf",
      "area-auth",
      "severity-minor",
      "affected-medium"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MjEyNDcwMw==",
        "parentId": null,
        "author": "khellang",
        "content": "It can\u0027t, as authentication needs to happen *before* the endpoint is executed. Endpoints are... endpoints, not middleware pipelines \uD83D\uDE0A",
        "createdAt": "2019-12-05T13:17:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562124703"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MjEyOTQzNw==",
        "parentId": null,
        "author": "Kahbazi",
        "content": "I think I should have explain my point more. I\u0027m not talking about the authentication process itself. I\u0027m talking about the endpoints which I\u0027m redirecting to from Identity Providers like \u0060/signin-microsoft\u0060 or \u0060/signin-google\u0060 . I believe these are endpoints which can be separated from authentication middleware.",
        "createdAt": "2019-12-05T13:31:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562129437"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MjEzOTU5Mg==",
        "parentId": null,
        "author": "blowdart",
        "content": "No there\u0027s not. Those aren\u0027t really endpoints, but ephemeral locations authentication intercepts, which, as Kristian points out needs to happen before normal endpoint code would execute. \r\n\r\nWhat do you think would be gained by making them endpoints?",
        "createdAt": "2019-12-05T13:58:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562139592"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MjE1Mzg5MQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "This is something I\u0027ve briefly discussed with @rynowak. No, you couldn\u0027t convert all of an auth handler to endpoints, but moving some of the callbacks like \u0060/signin-microsoft\u0060 to endpoints might be possible. That said, it would involve breaking up the auth handlers into several pieces and it\u0027s not clear what would be gained by doing so.\r\n\r\nThis part might scale better if you had a lot of auth handlers, routing is much more optimized for this scenario. The current code allocates every auth handler on every request (the schemes are singletons but the handlers are scoped).\r\nhttps://github.com/aspnet/AspNetCore/blob/62351067ff4c1401556725b401478e648b66acdc/src/Security/Authentication/Core/src/AuthenticationMiddleware.cs#L42-L49",
        "createdAt": "2019-12-05T14:32:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562153891"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MjE2MTI3MA==",
        "parentId": null,
        "author": "brockallen",
        "content": "\u002B1 -- we discussed this somewhat already, but auth handlers are middleware for most requests, but endpoints for some specific requests (signouts and challenge callbacks). The signouts and challenge callbacks would benefit from being endpoints, I think -- mainly for the scale issue once you need 100\u002B OIDC/Ws-Fed/SAML handlers in your pipeline.",
        "createdAt": "2019-12-05T14:49:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562161270"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MjE3MjQ4OA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "The transition might even be able to be done in a non-breaking way.\r\n- Add a UseEndpoints option on the auth scheme options.\r\n- The GetHandlerAsync allocation above would be skipped if UseEndpoints was enabled.\r\n- _something_ would give each scheme a chance to register endpoints if UseEndpoints were set.\r\n- Since endpoints are largely stateless, they would probably allocate the handler when selected and call into their existing HandleRequestAsync logic.\r\n- We\u0027d have to ensure the dynamic add and remove scenarios still worked.",
        "createdAt": "2019-12-05T15:13:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562172488"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MjE3NjA3Ng==",
        "parentId": null,
        "author": "khellang",
        "content": "This also sounds semi-related to https://github.com/aspnet/AspNetCore/issues/6993?",
        "createdAt": "2019-12-05T15:21:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562176076"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MjE4ODMyMA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@khellang distantly. Once you have endpoints then you can use them for url generation. However, most of the endpoint addresses in auth handlers are self-referential, generating them hasn\u0027t been much of an issue. The cookie auth urls called out in #6993 are more of an exception.",
        "createdAt": "2019-12-05T15:48:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562188320"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MjE5NDI3OA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "On a related perf note, this code even allocates handlers that don\u0027t implement IAuthenticationRequestHandler such as JwtBearer. We could probably add a scheme option to suppress that too.\r\nhttps://github.com/aspnet/AspNetCore/blob/62351067ff4c1401556725b401478e648b66acdc/src/Security/Authentication/Core/src/AuthenticationMiddleware.cs#L42-L45",
        "createdAt": "2019-12-05T16:02:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562194278"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MjE5OTk2MQ==",
        "parentId": null,
        "author": "Kahbazi",
        "content": "\u003E  you couldn\u0027t convert all of an auth handler to endpoints, but moving some of the callbacks like /signin-microsoft to endpoints might be possible.\r\n\r\nYes this was my intention. I should have specify better.\r\nI would like to work on this if possible. Would you accept PR for this?",
        "createdAt": "2019-12-05T16:15:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562199961"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MjIwODI2MQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E Would you accept PR for this?\r\n\r\nCould you start by outlining a detailed design proposal? This has several moving parts that we need to make sure are accounted for before starting on a PR.",
        "createdAt": "2019-12-05T16:35:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562208261"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MjM0NTIxNw==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Triage: Seems reasonable, but definitely needs a bunch of design.",
        "createdAt": "2019-12-05T22:22:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562345217"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MjU0OTMwNw==",
        "parentId": null,
        "author": "Kahbazi",
        "content": "Here\u0027s what I thought.\r\n\r\nWe can add a \u0060UseEndpoints\u0060 option to \u0060AuthenticationOptions\u0060 and use it to enable endpoints for all authentication handlers.\r\n\r\n\u0060\u0060\u0060csharp\r\npublic class AuthenticationOptions\r\n{\r\n    public bool UseEndpoints { get; set; }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nAdding and removing endpoints could happen in \u0060IAuthenticationSchemeProvider\u0060 in \u0060AddSchema(AuthenticationScheme scheme)\u0060 and \u0060RemoveScheme(string name)\u0060. And \u0060IAuthenticationSchemeProvider\u0060 should expose a \u0060EndpointDataSource\u0060 via method or a property\r\n \r\n\u0060\u0060\u0060csharp\r\npublic interface IAuthenticationSchemeProvider\r\n{\r\n    EndpointDataSource GetEndpointDataSource();\r\n    //OR\r\n    EndpointDataSource EndpointDataSource { get; }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n I have two thought on how to get endpoints for one scheme\r\n1. We could add a  \u0060IEnumerable\u003CEndpoint\u003E\u0060 property to \u0060AuthenticationScheme\u0060 and fill it in AuthenticationBuilder extenstion methods. Here we can easily add the Endpoints to the data source, but I don\u0027t like the idea of having endpoints in extension methods. \r\n\r\n\u0060\u0060\u0060csharp\r\npublic class AuthenticationScheme\r\n{\r\n    public IEnumerable\u003CEndpoint\u003E Endpoints { get; set; }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n2. Add a ConfigureEndpoints() method to \u0060IAuthenticationRequestHandler\u0060 so each handler can register their endpoints and deprecate \u0060HandleRequestAsync\u0060. In this way Endpoints are bind to \u0060IAuthenticationRequestHandler\u0060 which is good but we need to do some Reflection or use ActivatorUtility in order to create a \u0060IAuthenticationRequestHandler\u0060 from \u0060AuthenticationScheme .HandlerType\u0060.\r\n\r\n\u0060\u0060\u0060csharp\r\npublic interface IAuthenticationRequestHandler\r\n{\r\n    void ConfigureEndpoints(IEndpointRouteBuilder endpointRouteBuilder);\r\n\r\n    [Obsolete]\r\n    Task\u003Cbool\u003E HandleRequestAsync();\r\n}\r\n\u0060\u0060\u0060\r\n\r\nSince we have to cover adding and removing scheme in runtime a dynamic EndpointDataSource is needed. Well I found one in unit tests and with some change it fits our needs.\r\n\r\n\u0060\u0060\u0060csharp\r\npublic class DynamicEndpointDataSource : EndpointDataSource\r\n{\r\n    private readonly ConcurrentDictionary\u003Cstring, IEnumerable\u003CEndpoint\u003E\u003E _endpoints;\r\n    private CancellationTokenSource _cts;\r\n    private CancellationChangeToken _changeToken;\r\n\r\n    public DynamicEndpointDataSource()\r\n    {\r\n        _endpoints = new ConcurrentDictionary\u003Cstring, IEnumerable\u003CEndpoint\u003E\u003E();\r\n\r\n        CreateChangeToken();\r\n    }\r\n\r\n    public override IChangeToken GetChangeToken() =\u003E _changeToken;\r\n\r\n    public override IReadOnlyList\u003CEndpoint\u003E Endpoints =\u003E _endpoints.SelectMany(pair =\u003E pair.Value).ToArray();\r\n\r\n    public void AddEndpoint(string schema, IEnumerable\u003CEndpoint\u003E endpoint)\r\n    {\r\n        _endpoints.TryAdd(schema, endpoint);\r\n\r\n        TriggerChange();\r\n    }\r\n\r\n    public void RemoveEndpoint(string schema)\r\n    {\r\n        _endpoints.TryRemove(schema, out _);\r\n\r\n        TriggerChange();\r\n    }\r\n\r\n    private void TriggerChange()\r\n    {\r\n        // Capture the old tokens so that we can raise the callbacks on them. This is important so that\r\n        // consumers do not register callbacks on an inflight event causing a stackoverflow.\r\n        var oldTokenSource = _cts;\r\n        var oldToken = _changeToken;\r\n\r\n        CreateChangeToken();\r\n\r\n        // Raise consumer callbacks. Any new callback registration would happen on the new token\r\n        // created in earlier step.\r\n        oldTokenSource.Cancel();\r\n    }\r\n\r\n    private void CreateChangeToken()\r\n    {\r\n        _cts = new CancellationTokenSource();\r\n        _changeToken = new CancellationChangeToken(_cts.Token);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\nAnd add an extension method for adding the \u0060EndpointDataSource\u0060 to \u0060IEndpointRouteBuilder\u0060\r\n\u0060\u0060\u0060csharp\r\npublic static class EndpointRouteBuilderExtensions\r\n{\r\n    public static void MapAuthenticationEndpoints(this IEndpointRouteBuilder endpoints)\r\n    {\r\n        var authenticationSchemeProvider = endpoints.ServiceProvider.GetService\u003CIAuthenticationSchemeProvider\u003E();\r\n        var endpointDataSource = authenticationSchemeProvider.GetEndpointDataSource();\r\n\r\n        endpoints.DataSources.Add(endpointDataSource);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\u0060AuthenticationMiddleware\u0060 can check \u0060AuthenticationOptions.UseEndpoints\u0060 for handling the request itself.\r\n\u0060\u0060\u0060csharp\r\npublic class AuthenticationMiddleware\r\n{\r\n    public async Task Invoke(HttpContext context)\r\n    {\r\n        context.Features.Set\u003CIAuthenticationFeature\u003E(new AuthenticationFeature\r\n        {\r\n            ...\r\n\r\n            if (!options.UseEndpoints)\r\n            {\r\n                // Give any IAuthenticationRequestHandler schemes a chance to handle the request\r\n                var handlers = context.RequestServices.GetRequiredService\u003CIAuthenticationHandlerProvider\u003E();\r\n                foreach (var scheme in await Schemes.GetRequestHandlerSchemesAsync())\r\n                {\r\n                    var handler = await handlers.GetHandlerAsync(context, scheme.Name) as IAuthenticationRequestHandler;\r\n                    if (handler != null \u0026\u0026 await handler.HandleRequestAsync())\r\n                    {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n        ...\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nLet me know what do you think? :relaxed:",
        "createdAt": "2019-12-06T12:14:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562549307"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MjgzOTQ4Nw==",
        "parentId": null,
        "author": "Kahbazi",
        "content": "One breaking behavior in switching to endpoint is that \u0060HandleRequestResult.SkipHandler()\u0060 makes no sence for an Endpoint. \r\n\r\nhttps://github.com/aspnet/AspNetCore/blob/d8381656429addead2e5eb22ba1356abfb419d86/src/Security/Authentication/Core/src/RemoteAuthenticationHandler.cs#L65-L68 \r\n\r\nAlso I\u0027m not quite familiar with Negotiate Handler, does it also need to break into an endpoint? I feel like its business should move to \u0060HandleAuthenticateAsync\u0060, but I don\u0027t know if it\u0027s possible or not. :thinking:",
        "createdAt": "2019-12-07T10:50:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562839487"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2Mjg2MTQ4Mw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "No, Negotaite, CertAuth, and JwtBearer do not have any dedicated endpoints. NegotiateAuth\u0027s HandleRequestAsync need to stay due to mutli-stage handshakes that could happen on any url path.",
        "createdAt": "2019-12-07T15:39:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562861483"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2Mjg2MTU5NA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E One breaking behavior in switching to endpoint is that \u0060HandleRequestResult.SkipHandler()\u0060 makes no sence for an Endpoint.\r\n\r\nTrue, you\u0027d have to opt-out of endpoints if you wanted to use dynamic fallback logic. Most scenarios don\u0027t require this by default.",
        "createdAt": "2019-12-07T15:40:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562861594"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2Mjg3ODA2MA==",
        "parentId": null,
        "author": "Kahbazi",
        "content": "\u003E NegotiateAuth\u0027s HandleRequestAsync need to stay\r\n\r\nI was thinking of deprecating and eventually removing \u0060HandleRequestAsync\u0060. Is it possible to move all Netotiate process to \u0060HandleAuthenticateAsync\u0060? \r\nBeside aspnet docs, where can I learn more on how negotiate works?\r\n\r\nAlso I would like to know your thoughts on my comment on how to move to Endpoint. Should I add more details? Is there something that I missed?\r\n",
        "createdAt": "2019-12-07T19:09:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562878060"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2Mjg3OTY1Nw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "For compat reasons HandleRequestAsync is going to have to stay.  Besides NegotiateAuth, there are also WsFed scenarios that require it. Not all WsFed providers use dedicated endpoints, many of them redirect you back to the site root. Thus you need to be able to have multiple components on a path and sometimes skip one in favor of the other. That scenario\u0027s disabled by default, but still needs to be possible.\r\n\r\nI\u0027m also less concerned about NegotiateAuth because that\u0027s not a component that makes sense to have multiple of (unlike OAuth or OIDC). If we can get the OAuth and OIDC providers moved to endpoints by default then that should be a good start here.",
        "createdAt": "2019-12-07T19:31:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-562879657"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzA3MDkxMQ==",
        "parentId": null,
        "author": "davidfowl",
        "content": "cc @rynowak ",
        "createdAt": "2019-12-09T05:33:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563070911"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzI0OTQ3NQ==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E One breaking behavior in switching to endpoint is that HandleRequestResult.SkipHandler() makes no sence for an Endpoint.\r\n\r\nI hope \u0060SkipHandler()\u0060 will still be supported in 5.0 as I use it... quite massively \uD83D\uDE05 ",
        "createdAt": "2019-12-09T13:56:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563249475"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzI2MTY1OA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@PinpointTownes where do you use it? The idea is that callback paths like \u0060/sigin-oidc\u0060 would use endpoints by default and SkipHandler would no longer work there. You should be able to opt out of using endpoints though, and get the SkipHandler behavior back.",
        "createdAt": "2019-12-09T14:24:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563261658"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzI2OTQyMQ==",
        "parentId": null,
        "author": "Kahbazi",
        "content": "\u003E You should be able to opt out of using endpoints \r\n\r\n@Tratcher are you thinking about opting out for all schemes or per scheme?",
        "createdAt": "2019-12-09T14:42:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563269421"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzI3MDUyMQ==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E @PinpointTownes where do you use it?\r\n\r\nIn OpenIddict, pretty much everywhere, as it\u0027s what we use to enable pass-through. Once this mode is enabled, OpenIddict validates requests for you but eventually calls \u0060context.SkipHandler()\u0060 so that you can handle the rest of the request outside OpenIddict: in a MVC controller, in a custom middleware, in a Carter module (e.g to render a consent page for the authorization endpoint or to return some JSON profile data from the userinfo endpoint).",
        "createdAt": "2019-12-09T14:44:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563270521"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzI3NDQyNQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E @Tratcher are you thinking about opting out for all schemes or per scheme?\r\n\r\nPer scheme. E.g. someone might need to opt out for WsFed but not for OIDC.",
        "createdAt": "2019-12-09T14:53:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563274425"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzI3NTM2OA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E In OpenIddict, pretty much everywhere, as it\u0027s what we use to enable pass-through. Once this mode is enabled, OpenIddict validates requests for you but eventually calls \u0060context.SkipHandler()\u0060 so that you can handle the rest of the request outside OpenIddict: in a MVC controller, in a custom middleware, in a Carter module (e.g to render a consent page for the authorization endpoint or to return some JSON profile data from the userinfo endpoint).\r\n\r\nIs it used on callback paths? Or only on normally pass through components like JWT validation?",
        "createdAt": "2019-12-09T14:55:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563275368"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzI3NzEwMQ==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E Is it used on callback paths?\r\n\r\nIf by \u0022callback paths\u0022, you mean things handled from \u0060IAuthenticationRequestHandler.HandleRequestAsync()\u0060, then yep, it\u0027s used a lot.",
        "createdAt": "2019-12-09T14:59:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563277101"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzI3ODk4NA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E If by \u0022callback paths\u0022, you mean things handled from \u0060IAuthenticationRequestHandler.HandleRequestAsync()\u0060, then yep, it\u0027s used a lot.\r\n\r\nI mean operations that have dedicated urls like \u0060/signin-oidc\u0060. Not all HandleRequestAsync\u0027s are checking for specific paths.",
        "createdAt": "2019-12-09T15:03:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563278984"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzI3OTgwMA==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "It does check for specific paths by default for all OpenIddict-managed endpoints, but users are free to add their own logic to override that using the events model.",
        "createdAt": "2019-12-09T15:04:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563279800"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzI4MDg4NA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Ok, so it could use endpoints by default but the user could opt out as needed.",
        "createdAt": "2019-12-09T15:06:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563280884"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzI4MzcxOQ==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "It\u0027s not clear to me whether endpoints are flexible enough for that - they don\u0027t seem to be designed with composability in mind - but I don\u0027t mind giving the new design a try \uD83D\uDE04 \r\n\r\nWould the opt-out be per-endpoint or per-handler (i.e all the endpoints exposed by a handler)?",
        "createdAt": "2019-12-09T15:11:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563283719"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzI5OTkxNQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E Would the opt-out be per-endpoint or per-handler (i.e all the endpoints exposed by a handler)?\r\n\r\nProbably per handler. Really what you\u0027re opting into/out-of is running HandleRequestAsync for that handler on every request. Once you\u0027re running it, the endpoints don\u0027t help you anymore.",
        "createdAt": "2019-12-09T15:46:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563299915"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzM1NjcyOA==",
        "parentId": null,
        "author": "HaoK",
        "content": "Should we consider a new top level abstraction, i.e. \u0060IAuthenticationEndpointHandler\u0060 so it can coexist with \u0060IAuthenticationRequestHandler\u0060.  Then we could introduce a new base EndpointAuthenticationHandler that does the right thing and add new handler types (with overloads that allow back compat). Basically instead of a UseEndpoints option, it\u0027d be \u0060AddAuthentication().AddGoogleEndpoints()\u0060 where \u0060AddGoogle()\u0060 is unchanged.  \r\n\r\n\r\n\r\n",
        "createdAt": "2019-12-09T17:58:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563356728"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzM1OTI4NQ==",
        "parentId": null,
        "author": "Kahbazi",
        "content": "Does \u0060AddAuthentication().AddGoogleEndpoints()\u0060 would be enough to add the Endpoint to the \u0060IEndpointRouteBuilder\u0060,  or do you think a \u0060MapAuthenticationEndpoints(this IEndpointRouteBuilder endpoints)\u0060 is needed?",
        "createdAt": "2019-12-09T18:05:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563359285"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzM2MDUxMw==",
        "parentId": null,
        "author": "HaoK",
        "content": "I think we should make it smart enough to automatically register any authentication endpoints if any were registered without any additional calls.  The extension methods should do that magic underneath the covers.",
        "createdAt": "2019-12-09T18:08:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563360513"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzM2MDU0OQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@HaoK that seems overkill, it forks the ecosystem. Moving people over to endpoints by default should be good for the vast majority of cases. It\u0027s only some corner cases that need to opt-out.",
        "createdAt": "2019-12-09T18:08:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563360549"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzM2NTc3NA==",
        "parentId": null,
        "author": "HaoK",
        "content": "I don\u0027t know, we\u0027ve already had lots of behavior changes with endpoint routing to auth already.  So I can\u0027t imagine we won\u0027t run into more.  Forking the handlers would better guarantee there\u0027s at least a workaround in case/when we accidentally break something.  Opting into the new endpoint enabled handlers would only require them changing their implementation to derive from the new Endpoint aware base class.  Seems like this is something auth handlers should be aware of and opt into.  We can still make endpoints the default for our auth handlers since we control the extension methods.",
        "createdAt": "2019-12-09T18:20:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563365774"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzM2ODAxMQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Adding a base class is maximally disruptive since we already have a class hierarchy (AuthenticationHandler, RemoteAuthenticationHandler, OAuthHandler), you\u0027d have to fork the entire hierarchy. Maintaining two copies of every auth handler and base class is not sustainable.\r\n\r\nYes there\u0027s risk with this change, but we should be able to manage that with opt-out options and avoid mass duplication.",
        "createdAt": "2019-12-09T18:26:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563368011"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzM3NDAyMQ==",
        "parentId": null,
        "author": "HaoK",
        "content": "Yeah if there wasn\u0027t an easy way to refactor things to reuse most of the logic in both hierarchies, that would be no good. My main point is the handler implementation code has been mostly unchanged since katana, we know how hard it is to extend/customize, as we\u0027ve never spent the time to make that easy. Seems like this is an opportunity to see if we can finally make things nicer since endpoint support is a big change",
        "createdAt": "2019-12-09T18:41:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563374021"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzM3Nzk4MA==",
        "parentId": null,
        "author": "HaoK",
        "content": "I guess lets just see how the PR goes, given that there\u0027s already stuff like HandleEndpointPost/GetAsync showing up, seems like we are going to have resolve some of these questions anyways",
        "createdAt": "2019-12-09T18:51:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563377980"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzM3ODYzMQ==",
        "parentId": null,
        "author": "blowdart",
        "content": "I\u0027d rather try and think it through design wise rather than go code first. This is a major enough change that we need a consistent approach.\r\n",
        "createdAt": "2019-12-09T18:53:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563378631"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzM3OTQ1Nw==",
        "parentId": null,
        "author": "HaoK",
        "content": "Yeah I agree, but the prototype PR might be good to flush out some of the design issues we need to discuss.",
        "createdAt": "2019-12-09T18:54:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563379457"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzUwNDg1Mg==",
        "parentId": null,
        "author": "rynowak",
        "content": "\u003E This is something I\u0027ve briefly discussed with @rynowak. No, you couldn\u0027t convert all of an auth handler to endpoints, but moving some of the callbacks like /signin-microsoft to endpoints might be possible. That said, it would involve breaking up the auth handlers into several pieces and it\u0027s not clear **what would be gained by doing so** \r\n\r\nI\u0027m catching up to this discussion a little bit late, but I\u0027m wondering what kinds of concrete answers have cropped out to this question (emphasis mine).\r\n\r\n----\r\n\r\nIn general endpoints are useful because.... \r\n\r\n- The app developer needs to configure cross-cutting concerns (auth/cors)\r\n- Middleware need to collaborate \r\n- You want to make a deferred decision \r\n\r\nAre any of these things true for this case?",
        "createdAt": "2019-12-10T00:35:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563504852"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MzUxMTQxNw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@rynowak the one scenario I\u0027ve identified above is a perf optimization to avoid allocating and looping through every auth handler on every request. This would be covered more by routing than endpoints. https://github.com/aspnet/AspNetCore/issues/17615#issuecomment-562153891",
        "createdAt": "2019-12-10T01:01:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563511417"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2Mzk1MTc2MQ==",
        "parentId": null,
        "author": "khellang",
        "content": "Another benefit is simply having the callback endpoints be part of the endpoint collection for other middleware to discover, like OpenAPI can read its metadata and include it in the document. ",
        "createdAt": "2019-12-10T09:44:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563951761"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2Mzk1Nzk2MQ==",
        "parentId": null,
        "author": "Kahbazi",
        "content": "It also could be useful for throttling or logging callback endpoints.",
        "createdAt": "2019-12-10T09:59:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-563957961"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NDEzNDE2MA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E like OpenAPI can read its metadata and include it in the document.\r\n\r\nNot that anything should be calling these endpoints directly, an initial challenge is required in almost all cases.",
        "createdAt": "2019-12-10T17:09:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-564134160"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NDE2MTkwMw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "I went over this again with @rynowak and came to the conclusion that what we want for these callback paths is routing, not endpoints. We haven\u0027t identified any other concrete scenarios that need endpoints.\r\n\r\nThe theory is that the auth middleware or service would build their own internal route table mapping callback paths to auth schemes \u0026 handlers (not Endpoints). This would re-use existing routing code internally rather than participate in the larger route table. The middleware would then run that handler\u0027s HandleRequestAsync method. Schemes would opt-in/out via options, and be given some way to register and unregister their callbacks. (@PinpointTownes) Skip would still mostly work by allowing you to keep executing after the new routing component and still run the rest of the auth middleware logic (AuthenticateAsync for the default scheme, etc.) and the request pipeline. The loop through schemes to run HandleRequestAsync would still happen if no route was found, but schemes that had registered callbacks would opt out of that part.",
        "createdAt": "2019-12-10T18:13:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-564161903"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NDE2MjU3Mg==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "@Tratcher perfect, thanks! \uD83D\uDC4F ",
        "createdAt": "2019-12-10T18:14:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-564162572"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NDU4MjExMQ==",
        "parentId": null,
        "author": "Kahbazi",
        "content": "\u003E We haven\u0027t identified any other concrete scenarios that need endpoints.\r\n\r\nI don\u0027t know if these would count as good scenarios:\r\n\r\n- Analysis for endpoints including callback and remote signout endpoints.\r\n\r\n- Eventually \u0060ConcurrencyMiddleware\u0060 will be able to have different queue for different \u0060Endpoint\u0060. User could add \u0060ConcurrencyMiddleware\u0060 for callbacks or remote signout endpoints.\r\n\r\n- User could add a middleware which has a IP white list or black list for these endpoints.",
        "createdAt": "2019-12-11T14:55:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-564582111"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NDYwMTQ1NQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@Kahbazi I don\u0027t see why you\u0027d do any of those things specifically for these auth endpoints and not for the reset of your app.",
        "createdAt": "2019-12-11T15:39:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-564601455"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NDYwNjUyNA==",
        "parentId": null,
        "author": "Kahbazi",
        "content": "I\u0027m thinking all my app has these things but maybe I wan\u0027t different settings for these endpoints. For example I have \u0060ConcurrencyMiddleware\u0060 and it will choose a queue based on some attribute in Endpoint Metadata. Now there\u0027s no way for me to have \u0060ConcurrencyMiddleware\u0060 for auth callbacks.\r\n\r\nAlso I could write a analysis middleware based on Endpoint which generate report for all endpoints and the callbacks would be included in the report automatically.",
        "createdAt": "2019-12-11T15:50:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-564606524"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NjY4NjM0Mw==",
        "parentId": null,
        "author": "Kahbazi",
        "content": "\u003E we want for these callback paths is routing, not endpoints\r\n\r\n@Tratcher Is this decision final? I think by having just routing for authentication callbacks, there would be some limitations. I\u0027m just expanding my previous example here.\r\n\r\nLet\u0027s say I have a \u0060ConcurrencyMiddleware\u0060 which has different queues for different kind of Endpoints. I can mark my Endpoints with some attribute to assign them to a specific queue. This would be my pipeline.\r\n\r\n\u0060\u0060\u0060csharp\r\napp.UseRouting();\r\napp.ConcurrencyMiddleware();\r\napp.UseAuthentication();\r\napp.UseAuthorization();\r\napp.UseEndpoints();\r\n\u0060\u0060\u0060\r\n\r\nNow I can\u0027t assign a specific  queue for callbacks. The only option for them could be a default fallback queue which I might only wanna use it for when there\u0027s no Endpoint found at routing.\r\nI even may want to assign different authentication callbacks to different queue which I can\u0027t with this design.\r\n\r\nI promise this is my last attempt to apply Endpoints for authentication callbacks :sweat_smile:\r\nI would like to know your thoughts.",
        "createdAt": "2019-12-17T18:21:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-566686343"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NjY4ODI0Ng==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Nothing\u0027s final, but the case for endpoints has not been compelling. The use of endpoints also has tradeoffs with fallback patterns currently supported by several of the auth handlers.\r\n\r\nHow would you add metadata/attributes to the callback endpoints when they\u0027re created and registered by the auth service?",
        "createdAt": "2019-12-17T18:25:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-566688246"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NjY5MjczOA==",
        "parentId": null,
        "author": "Kahbazi",
        "content": "\u003E The use of endpoints also has tradeoffs with fallback patterns\r\n\r\nAs you said, there could be an opt out option.\r\n\r\n\u003E How would you add metadata/attributes to the callback endpoints\r\n\r\nBy adding a Metadata on \u0060AuthenticationOptions\u0060 like \u0060MicrosoftAccountOptions\u0060.\r\nOr even changing \u0060CallBackPath\u0060 from \u0060PathString\u0060 to a class with \u0060PathString\u0060 and Metadata, since some handlers have multiple callback path :thinking:",
        "createdAt": "2019-12-17T18:37:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-566692738"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NjY5NjM3MA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E \u003E How would you add metadata/attributes to the callback endpoints\r\n\u003E \r\n\u003E By adding a Metadata on \u0060AuthenticationOptions\u0060 like \u0060MicrosoftAccountOptions\u0060.\r\n\u003E Or even changing \u0060CallBackPath\u0060 from \u0060PathString\u0060 to a class with \u0060PathString\u0060 and Metadata, since some handlers have multiple callback path \uD83E\uDD14\r\n\r\nNeeds some more thought. There\u0027s a strong preference for not having API breaks required for this change, only additions.",
        "createdAt": "2019-12-17T18:47:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-566696370"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2NjcwMDI2Mg==",
        "parentId": null,
        "author": "Kahbazi",
        "content": "We could add the new class (let\u0027s call it \u0060CallBackEndpoint\u0060) and keep the \u0060CallBackPath\u0060 (maybe with an ObsoleteAttribute) and if \u0060CallBackEndpoint\u0060 has been set, we ignore \u0060CallBackPath\u0060 and if \u0060CallBackEndpoint\u0060 is null, we could set it from \u0060CallBackPath\u0060 with default metadata.\r\nDefault metadata could specify the scheme, handler type, etc",
        "createdAt": "2019-12-17T18:57:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/17615#issuecomment-566700262"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU1NDI5MDM2MTc=",
    "title": "AuthorizationOptions does not allow to query list of available policies",
    "url": "https://github.com/dotnet/aspnetcore/issues/18047",
    "createdAt": "2019-12-27T15:07:39Z",
    "lastUpdated": "2020-01-08T16:32:53Z",
    "body": "Due to the dictionary of policies being private there is currently no way to get all the available policies. Getting all the available policies is very useful when building Administration dashboards where you want to control and check what permissions a given user has.\r\n\r\nMultiple users seem to have the same [requirement.](https://stackoverflow.com/questions/45014894/how-to-get-all-authorize-policies-that-i-added-in-the-startup-configureservices)",
    "upvotes": 1,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU3MDM3MzM1Mw==",
        "parentId": null,
        "author": "analogrelay",
        "content": "What kind of information would you want to get here? We can provide the names and a list of the \u0060IAuthorizationRequirement\u0060 instances but those have no descriptive metadata associated with them.\r\n\r\nCan you provide an example of what you\u0027d want to *do* with this information. A code sample would be best, or a description of a specific use case (more detailed that just \u0022administration dashboards\u0022, for example: what would those dashboards show?)",
        "createdAt": "2020-01-02T22:13:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18047#issuecomment-570373353"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU3MTUxMjg4MQ==",
        "parentId": null,
        "author": "ptsneves",
        "content": "Hello @anurse \r\n\r\nWhat I want is to take a user and check all the policies that he/she complies with. Imagine I only have a policy called \u0022IsAdmin\u0022 registered. Also consider that i have 2 users User1 and User2.\r\n\r\nMy dashboard would be\r\n\u0060\u0060\u0060\r\n| Name  | Complied Policies |\r\n| User1 |     IsAdmin       |\r\n| User2 |                   |\r\n| UserN |       ....        |\r\n\u0060\u0060\u0060",
        "createdAt": "2020-01-07T09:45:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18047#issuecomment-571512881"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU3MTgzODYzOA==",
        "parentId": null,
        "author": "analogrelay",
        "content": "That\u0027s not really something you can do with the Auth system though. @Tratcher and @HaoK can correct me if I\u0027m wrong but in order to evaluate a requirement you have to have an **authenticated user**. You can\u0027t just take a list of users from a database or other source and test policies against them. You need a fully-authenticated \u0060ClaimsPrincipal\u0060.",
        "createdAt": "2020-01-08T00:40:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18047#issuecomment-571838638"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU3MTkxMTc1OQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "AuthZ is pretty decoupled, it should be possible to run specific policies against users enumerated from the database. Enumerating those users in a form that AuthZ would recognize might take a bit of work, but the information is all there in the Identity database. @HaoK would know better how to go about it.",
        "createdAt": "2020-01-08T06:36:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18047#issuecomment-571911759"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU3MTkxNjYzMA==",
        "parentId": null,
        "author": "HaoK",
        "content": "We don\u0027t have any build in way to enumerate all the policies, but that is something you could probably add yourself.  You could use \u0060UserManager.Users\u0060 to iterate over all the users and call \u0060IUserClaimsPrincipalFactory.CreateAsync(user)\u0060 to get the ClaimsPrincipal and then call \u0060IAuthorizationService.AuthorizeAsync\u0060 against every policy.\r\n\r\n\r\n",
        "createdAt": "2020-01-08T06:55:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18047#issuecomment-571916630"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU3MjA5ODAyMQ==",
        "parentId": null,
        "author": "ptsneves",
        "content": "@HaoK So i still need a way to enumerate/query the list of all available policies. Am i correct in this analysis? If so @anurse does this mean my issue got a bit more legitimate, and the removal of the private or the addition of an accessor seems a viable way.\r\n\r\nGrateful for the support\r\nptsneves",
        "createdAt": "2020-01-08T14:45:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18047#issuecomment-572098021"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU3MjE1MDM3OQ==",
        "parentId": null,
        "author": "analogrelay",
        "content": "The request was certainly always legitimate :). Just trying to understand prioritization. Making any API public is costly (as it has a high support burden for the future because we can\u0027t break/change it) so it\u0027s important to understand the specific usefulness of the change so we can use that to evaluate the priority.",
        "createdAt": "2020-01-08T16:32:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18047#issuecomment-572150379"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU1NjI4MDY3MTg=",
    "title": "Change OIDC default to Code \u002B PKCE",
    "url": "https://github.com/dotnet/aspnetcore/issues/18932",
    "createdAt": "2020-02-10T20:24:58Z",
    "lastUpdated": "2020-11-10T00:23:28Z",
    "body": "Code \u002B PKCE is as secure as FormPost and avoids many of the issues with SameSite=None.\r\n\r\nChange the nonce cookie SameSite default to lax? What about the correlation cookie?",
    "upvotes": 1,
    "labels": [
      "enhancement",
      "breaking-change",
      "area-auth",
      "severity-minor",
      "affected-medium"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU4NDQxMDg4MQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Note this will also require the templates to provision a client secret. That\u0027s going to require tooling work to populate.",
        "createdAt": "2020-02-10T23:33:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18932#issuecomment-584410881"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYzOTEyOTM5Mg==",
        "parentId": null,
        "author": "blowdart",
        "content": "As these templates are getting replaced, this would fall under the new templates, so closing.",
        "createdAt": "2020-06-04T21:29:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18932#issuecomment-639129392"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYzOTEyOTk5MQ==",
        "parentId": null,
        "author": "blowdart",
        "content": "Auth handlers will need to switch too, based on the templates/tooling. Need to coordinate with @jmprieur",
        "createdAt": "2020-06-04T21:30:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18932#issuecomment-639129991"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzIzOTIwNg==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-07-23T21:22:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18932#issuecomment-663239206"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzIzOTY3NQ==",
        "parentId": null,
        "author": "blowdart",
        "content": "@jmprieur in your tooling discussion don\u0027t you need this for IdentityWeb as you were needing a client secret to switch?",
        "createdAt": "2020-07-23T21:23:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18932#issuecomment-663239675"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzI1ODM0NA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "TODO: Test in chrome incognito mode which has started blocking SameSite cookies. We may have to change the cookie SameSite defaults to Unspecified.",
        "createdAt": "2020-07-23T22:14:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18932#issuecomment-663258344"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2NDkyOTQ5OQ==",
        "parentId": null,
        "author": "jmprieur",
        "content": "Well @blowdart @Tratcher: MSAL.NET does not support Auth Code PKCE in confidential client apps. So if it\u0027s default, it needs to be disable-able when using AAD.\r\n\r\ncc: @henrik-me FYI (and prioritization discussion)",
        "createdAt": "2020-07-28T09:41:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18932#issuecomment-664929499"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3NTc0MzI3Ng==",
        "parentId": null,
        "author": "Tratcher",
        "content": "We met with the Identity.Web team and decided to have them change the default in their library \u0026 templates first. In 6.0 we\u0027ll reconsider changing the default in OIDC. ",
        "createdAt": "2020-08-18T22:05:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18932#issuecomment-675743276"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3NTc0MzM0NA==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-08-18T22:05:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18932#issuecomment-675743344"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3NTc0MzcwOA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "I was finally able to test chrome by downloading Chromium. I enabled every current and future restriction available and the SameSite=none cookies continued to work. That makes this change safer because we can leave the cookies as is, but it also makes this change less necessary.",
        "createdAt": "2020-08-18T22:06:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18932#issuecomment-675743708"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU1ODM3MzM3MTg=",
    "title": "OIDC PKCE should be allowed with hybrid flow",
    "url": "https://github.com/dotnet/aspnetcore/issues/19954",
    "createdAt": "2020-03-18T13:36:55Z",
    "lastUpdated": "2020-05-24T19:40:22Z",
    "body": "This line only allows the use of PKCE with code flow:\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/master/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectHandler.cs#L369\r\n\r\nBut PKCE can also be used with hybrid flow. Please allow that as well.",
    "upvotes": 0,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMDY0MDcxMg==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "By \u0060hybrid\u0060, I suppose you mean \u0060code id_token\u0060 only and not \u0060code id_token token\u0060 or \u0060code token\u0060?\r\n\r\nSome implementations are known for blocking \u0060code id_token token\u0060 or \u0060code token\u0060 when using PKCE (it doesn\u0027t make much sense to force apps to use PKCE if an access token is returned straight from the authorization endpoint). Since \u0060UsePkce\u0060 is set to \u0060true\u0060 by default, it could be potentially breaking.",
        "createdAt": "2020-03-18T14:01:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/19954#issuecomment-600640712"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYzMzI4NDc4Nw==",
        "parentId": null,
        "author": "scottbrady91",
        "content": "Damn it, Brock: https://github.com/dotnet/aspnetcore/pull/10928#issuecomment-499284407",
        "createdAt": "2020-05-24T19:40:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/19954#issuecomment-633284787"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU1ODU4OTM0ODc=",
    "title": "Security Authentication handlers should not reference JwtSecurityToken",
    "url": "https://github.com/dotnet/aspnetcore/issues/20066",
    "createdAt": "2020-03-23T03:00:06Z",
    "lastUpdated": "2020-10-22T21:31:53Z",
    "body": "\u003C!--\r\n\r\nMore information on our issue management policies can be found here: https://aka.ms/aspnet/issue-policies\r\n\r\n--\u003E\r\n\r\n### Is your feature request related to a problem? Please describe.\r\nA clear and concise description of what the problem is.\r\nExample: I am trying to do [...] but [...]\r\n\r\n### Describe the solution you\u0027d like\r\n\r\nAsp.net uses ISecurityTokenValidator.ValidateToken which has an out parameter of type SecurityToken. asp.net assumes a JwtSecurityToken.\r\nIf a user plugs in a different ISecurityTokenValidator that returns a different valid token that represents a JWT, this will fail.\r\n\r\n[Here for OIDC](https://github.com/dotnet/aspnetcore/blob/62351067ff4c1401556725b401478e648b66acdc/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectHandler.cs#L1178)\r\n\r\n[also here (there are others)](https://github.com/dotnet/aspnetcore/blob/62351067ff4c1401556725b401478e648b66acdc/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectHandler.cs#L545)\r\n\r\nasp.net and IdentityModel will need to work together to develop the correct JWT abstractions so new token validators, handlers and tokens can be used.\r\n\r\n\r\nsee: IdentityModel https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/1349\r\n\r\n### Additional context\r\nAdd any other context or screenshots about the feature request here.\r\n",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "severity-major",
      "affected-medium"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMjg2MTc3Ng==",
        "parentId": null,
        "author": "blowdart",
        "content": "@Tratcher for your consideration.\r\n\r\nHowever as we only support JWT (and WSFED) I don\u0027t know if I\u0027m too concerned right now.\r\n\r\n@brentschmaltz What other tokens are you expecting? JWE?",
        "createdAt": "2020-03-23T21:19:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-602861776"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMjg2NTA1OQ==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@blowdart We have invested in JsonWebToken / JsonWebTokenHandler where we have the following improvements.\r\n1. Performance ~10%\r\n2. No mapping of claimtypes\r\n3. No reference to Newtonsoft\r\n\r\nWe are thinking an abstraction for JWT\u0027s, so that a JwtTokenHandler will return an IJwtToken or JwtToken (abstract).\r\nRight now we are linked to a specific implementation that we are not investing in anymore.\r\n\r\nIn addition, CBOR is a variation of JWT\u0027s that are helpful in the IOT environment as the size is minimized.\r\n\r\nHope this helps.",
        "createdAt": "2020-03-23T21:26:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-602865059"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMjg2NzY1MQ==",
        "parentId": null,
        "author": "blowdart",
        "content": "You know we\u0027re adding CBOR to the framework right?",
        "createdAt": "2020-03-23T21:31:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-602867651"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMjg2ODc3NQ==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@blowdart I did not know that, we have started a handler similar to JsonWebTokenHandler.\r\nWhere is this work taking place, we probably don\u0027t need two.",
        "createdAt": "2020-03-23T21:34:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-602868775"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMjg2ODkzNg==",
        "parentId": null,
        "author": "blowdart",
        "content": "Now, @bartonjs is doing it.",
        "createdAt": "2020-03-23T21:34:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-602868936"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMjg3MDE3MA==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@bartonjs @blowdart cbor is essentially an encoded json token.\r\nWhere are you planning on shipping it?",
        "createdAt": "2020-03-23T21:37:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-602870170"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMjg3NDkxMg==",
        "parentId": null,
        "author": "blowdart",
        "content": "In 5. We need it for passwordless/FIDO2 support",
        "createdAt": "2020-03-23T21:49:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-602874912"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMjg4MDQwMw==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@blowdart I guess we will have two then, we need it to seamlessly plug into our authz/authn model.",
        "createdAt": "2020-03-23T22:02:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-602880403"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMjkwMTkwNg==",
        "parentId": null,
        "author": "bartonjs",
        "content": "@brentschmaltz I\u0027m expecting that we\u0027ll ship it as a netstandard2.0 NuGet package, though there are a few political hurdles (that are easier if you would be a consumer of that package).",
        "createdAt": "2020-03-23T22:57:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-602901906"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMzA0MjA2Ng==",
        "parentId": null,
        "author": "leastprivilege",
        "content": "* I have never seen anyone use the OIDC handler with an alternative JWT validator\r\n* If you want to decouple them, then the OIDC handler should own the validation parameters type as well as the interface - the validator would return \u0060ClaimsPrincipal\u0060.\r\n\r\nI never thought this \u0022abstraction\u0022 with the interface was useful.",
        "createdAt": "2020-03-24T06:25:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-603042066"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMzI3MDk1OA==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@bartonjs for IdentityModel to use any token type it must fit into our model of Token / TokenHandler / ClaimsIdentity trio. We have SecurityToken and TokenHandler are the base class for those.\r\n\r\n@leastprivilege OIDC is special in that the specification defines that a JWT is the token type. I am exactly sure what \u0022abstraction\u0022 you are referring to, but there are multiple options.\r\n\r\nMoving to a SecurityToken or JToken abstraction will allow us to do things like remove dependency on System.IdentityModel.Tokens.Jwt which has issues of dependency on Newtonsoft, performs claim-type mapping, is slower than JsonWebToken.\r\n\r\nWe need to continue to support numerious runtimes, with out a proper abstraction it is difficult to include improvements such as system.text.json and take advantage the new string features with out cluttering up the code with #if defs and multiple targets.",
        "createdAt": "2020-03-24T14:27:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-603270958"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMzMxNzIwMA==",
        "parentId": null,
        "author": "bartonjs",
        "content": "\u003E @bartonjs for IdentityModel to use any token type it must fit into our model of Token / TokenHandler / ClaimsIdentity trio\r\n\r\nAll we\u0027re providing is a CBOR reader/writer.  Understanding what a token means is at too high a level for us :smile:.",
        "createdAt": "2020-03-24T15:43:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-603317200"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMzMyMzQxNA==",
        "parentId": null,
        "author": "leastprivilege",
        "content": "\u003E I am exactly sure what \u0022abstraction\u0022 you are referring to\r\n\r\nI am saying - I see no value in the OIDC handler using \u0060ISecurityTokenValidator.ValidateToken\u0060.",
        "createdAt": "2020-03-24T15:52:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-603323414"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMzMzMzYyNQ==",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@leastprivilege oh I agree, in fact ISecurityTokenValidator.ValidateToken is broken for asnyc as it has an out param. We want to move away from that model.\r\n\r\nThat\u0027s not what we are thinking. We are thinking more of adding to the current abstractions SecurityToken, SecurityTokenHandler and have asp.net use those instead of a specific implementation such as JwtSecurityToken or JsonWebToken.\r\n\r\n@bartonjs we should talk.",
        "createdAt": "2020-03-24T16:07:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-603333625"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzIzODE4OA==",
        "parentId": null,
        "author": "blowdart",
        "content": "@brentschmaltz As this is still in \u0022thinking\u0022 mode from both sides this is going to get bumped to 6.0",
        "createdAt": "2020-07-23T21:19:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-663238188"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzIzODI1Ng==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-07-23T21:20:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-663238256"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3NTk3ODg5Ng==",
        "parentId": null,
        "author": "IshamMohamed",
        "content": "\u003E You know we\u0027re adding CBOR to the framework right?\r\n\r\nare you? Please share more information on this please?",
        "createdAt": "2020-08-19T08:56:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20066#issuecomment-675978896"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU1OTM5ODgxMjE=",
    "title": "Windows Authentication Error using Kestrel for .NET Core Web API, when accessed remotely.",
    "url": "https://github.com/dotnet/aspnetcore/issues/20540",
    "createdAt": "2020-04-04T18:28:25Z",
    "lastUpdated": "2020-11-13T21:11:44Z",
    "body": "Error in Windows Authentication using Kestrel still reproduce (package  Microsoft.AspNetCore.Authentication.Negotiate, guide https://docs.microsoft.com/ru-ru/aspnet/core/security/authentication/windowsauth?view=aspnetcore-3.1\u0026tabs=visual-studio#kestrel).\r\nSame error in related issue. But i collected logs and prepare example to reproduce bug.\r\n\r\nExample in branch: https://github.com/Yustos/AspNetCoreSubdomain/commits/auth_trouble\r\nReproduce steps:\r\n\r\n- Compile AspNetCoreSubdomain.Samples.csproj\r\n- Place bin folder to remote server (example.com)\r\n- Run on remote server AspNetCoreSubdomain.Samples.exe in console\r\n- On local computer open http://example.com:5000 in chrome browser\r\n\r\nYou can see error 404 in browser and this topic error in log.\r\nOr you can try postman get query with NTLM auth - there will be 401 error and same error in server log.\r\n\r\nIn the fiddler all three negotiate requests exists, bug without success:\r\n\u2116\tResult\tProtocol\tHost\tURL\tBody\tCaching\tContent-Type\tProcess\tComments\tCustom\t\r\n7\t401\tHTTP\texample.com:5000\t/\t0\t\t\tpostman:119596\t\t\t\r\n8\t401\tHTTP\texample.com:5000\t/\t0\t\t\tpostman:119596\t\t\t\r\n9\t401\tHTTP\texample.com:5000\t/\t0\t\t\tpostman:119596\t\r\n\r\nThere is connection log, as you ask:\t\t\r\n[auth_log.txt](https://github.com/dotnet/aspnetcore/files/4432216/auth_log.txt)\r\n\r\nRemark: i replaced server name to \u0060\u0060\u0060example.com\u0060\u0060\u0060 and username from domain to Yustos in attached log.\r\n\r\nAt last, i was tried HTTP.SYS auth (see commented code in example branch https://github.com/Yustos/AspNetCoreSubdomain/commit/d39dd1f729c34d7ea36f4e807303b1c7687c34a2) - it work fine.\r\n\r\nI followed auth example prepare by this guide on windows (client and server): https://docs.microsoft.com/ru-ru/aspnet/core/security/authentication/windowsauth?view=aspnetcore-3.1\u0026tabs=visual-studio#kestrel\r\nExcept setspn command: https://docs.microsoft.com/ru-ru/aspnet/core/security/authentication/windowsauth?view=aspnetcore-3.1\u0026tabs=visual-studio#windows-environment-configuration",
    "upvotes": 0,
    "labels": [
      "External",
      "task",
      "blocked",
      "area-auth",
      "affected-few",
      "severity-minor"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwOTEzMTY0MQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "The 404 is the exception handler trying to redirect to \u0060/Home/Error\u0060 which doesn\u0027t seem to exist in this app.\r\n\r\nThe actual exception reported in the logs is:\r\n\u0060\u0060\u0060\r\nSystem.InvalidOperationException: An anonymous request was received in between authentication handshake requests.\r\n   at Microsoft.AspNetCore.Authentication.Negotiate.NegotiateHandler.HandleRequestAsync()\r\n   at Microsoft.AspNetCore.Authentication.Negotiate.NegotiateHandler.HandleRequestAsync()\r\n   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)\r\n   at Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware.\u003CInvoke\u003Eg__Awaited|6_0(ExceptionHandlerMiddleware middleware, HttpContext context, Task task)\r\n\u0060\u0060\u0060\r\nWhich matches https://github.com/dotnet/aspnetcore/issues/20100 (closed as stale). There wasn\u0027t enough information before to debug it, but it looks like we have more now...\r\n\r\nWhen you\u0027re doing this authentication are you using the machine\u0027s fully qualified active directory name? Using an alternate name isn\u0027t going to work unless you\u0027ve set up proper SPNs.\r\n\r\nFrom the logs:\r\nRequest 1) Anonymous, authorization failed, Challenge 401 Negotiate\r\nRequest 2) Authorization: Negotiate (kerberos(?) blob), incomplete handshake, 401 Negotiate (blob)\r\nRequest 3) Authorization: Negotiate (blob), incomplete handshake, 401 Negotiate (blob)\r\nRequest 4) Anonymous, exception as shown above.\r\n\r\nSo the main issue seems to be that the server thinks auth is still in progress but the client has given up. This is likely a misconfiguration related to SPNs or similar. It\u0027s odd that the client would send another anonymous request after three consecutive 401s.\r\n\r\n@blowdart any idea how to get the associated schannel events to get a more specific explanation here?\r\n\r\nNote Http.Sys may have worked because it uses kernel mode authentication which means SPNs are configured on the machine account. With Kestrel it\u0027s using user mode which means the SPNs must be configured on the user account instead.",
        "createdAt": "2020-04-05T02:21:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20540#issuecomment-609131641"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwOTM2ODM4MA==",
        "parentId": null,
        "author": "Yustos",
        "content": "Hi, Chris!\r\n\u0022When you\u0027re doing this authentication are you using the machine\u0027s fully qualified active directory name?\u0022 - yes. In client browser i used full server name http://example.com:5000/ and have auth error.\r\nWhen i use browser on server - all urls variants works fine: http://localhost:5000, http://example:5000 and http://example.com:5000.\r\n\r\nFor clear - 404 is strange, but not a root trouble. Problem is authentication.\r\n\r\nPostman failed on auth without any additional potential requests (like js, css, favico and other).\r\n\r\nTo reduce any browser specific network activity i tried powershell:\r\n\u0060\u0060\u0060powershell\r\nPS C:\\Users\\Yustos\u003E $url = \u0022http://example.com:5000\u0022\r\nPS C:\\Users\\Yustos\u003E $wc = New-Object System.Net.WebClient\r\nPS C:\\Users\\Yustos\u003E $wc.UseDefaultCredentials = $true\r\nPS C:\\Users\\Yustos\u003E $response = $wc.DownloadString($url)\r\nException calling \u0022DownloadString\u0022 with \u00221\u0022 argument(s): \u0022The remote server returned an error: (401) Unauthorized.\u0022\r\nAt line:1 char:1\r\n\u002B $response = $wc.DownloadString($url)\r\n\u002B ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    \u002B CategoryInfo          : NotSpecified: (:) [], MethodInvocationException\r\n    \u002B FullyQualifiedErrorId : WebException\r\n\u0060\u0060\u0060\r\nAnd here is server log: \r\n[auth_log_by_powershell.txt](https://github.com/dotnet/aspnetcore/files/4433060/auth_log_by_powershell.txt)\r\n\r\nWill fiddler logs help you?\r\nThank you for advice!\r\n\r\nPS: i tried to apply setspn, but failed:\r\n\u0060\u0060\u0060cmd\r\n\u003Esetspn -S HTTP/example.com Yustos\r\nChecking domain DC=---,DC=---\r\n\r\nRegistering ServicePrincipalNames for CN=Yustos,OU=Computers,OU=Clients,DC=---,DC=---\r\n        HTTP/example.com\r\nFailed to assign SPN on account \u0027CN=Yustos,OU=Computers,OU=Clients,DC=---,DC=---\u0027,\r\n error 0x2098/8344 -\u003E Insufficient access rights to perform the operation.\r\n\u0060\u0060\u0060\r\nI suppose this is not important.",
        "createdAt": "2020-04-05T06:53:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20540#issuecomment-609368380"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwOTM3NzkzNg==",
        "parentId": null,
        "author": "Yustos",
        "content": "Okay, i am collected fiddler logs for powershell with UseDefaultCredentials calls (HTTP-bodies excluded, tokens shortened).\r\nSuccess with HTTP.SYS: \r\n[success_http_sys.txt](https://github.com/dotnet/aspnetcore/files/4433140/success_http_sys.txt)\r\n\r\nFail with Kestrel negotiate:\r\n[fail_kestrel_negotiate.txt](https://github.com/dotnet/aspnetcore/files/4433143/fail_kestrel_negotiate.txt)\r\n\r\nI am not an Active Directory administrator, so setspn unpermitted. And i believe, that i should not ask administrator to register SPN for every test scenario or dynamically generated urls.\r\nSo my way is HTTP.SYS or other authentication mechanism.\r\n\r\nLast thing is error code. In the attached failure-logs was 400 error after series of handshakes.\r\nBut sometimes returned error 404 without any handshake:\r\n![image](https://user-images.githubusercontent.com/5267762/78469962-4818b080-772e-11ea-91f8-4806c651e3c2.png)\r\nHere details for 404:\r\n\u0060\u0060\u0060\r\nGET http://example.com:5000/ HTTP/1.1\r\nUser-Agent: Mozilla/5.0 (Windows NT; Windows NT 10.0; ru-RU) WindowsPowerShell/5.1.18362.628\r\nHost: example.com:5000\r\n\r\nHTTP/1.1 404 Not Found\r\nDate: Sun, 05 Apr 2020 07:29:13 GMT\r\nServer: Kestrel\r\nContent-Length: 0\r\nCache-Control: no-cache\r\nPragma: no-cache\r\nExpires: -1\r\n\u0060\u0060\u0060\r\nLooks like is one-after-one 400, 404, 400, 404...\r\n\r\nWell, confirm, please, that setspn is the strong requirement for Negotiate and close issue.\r\nThank you!",
        "createdAt": "2020-04-05T08:18:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20540#issuecomment-609377936"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwOTkxNTYzMw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Can you share the server logs for the 400 scenario?\r\n\r\nYes, SPNs are a strong requirement for Negotiate/Kerberos. When you run on the same machine it always defaults to NTLM which does not have the same SPN requirements. When it runs with HttpSys from a separate machine it\u0027s using kernel mode auth and the machine account which already has SPNs configured by default. When it\u0027s using Kestrel and user-mode auth from a remote machine it can\u0027t find any SPNs in the user account, tries to fall back to NTLM, but then gives up after a few round trips (not sure why yet).\r\n\r\n@JunTaoLuo this would be a good situation for you to repro with your current setup.",
        "createdAt": "2020-04-06T16:59:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20540#issuecomment-609915633"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwOTkxNjYxMw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "The 404 is likely the same redirect to \u0060/home/error\u0060 as before. The server logs would show that.",
        "createdAt": "2020-04-06T17:01:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20540#issuecomment-609916613"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwOTk1NzQ3NQ==",
        "parentId": null,
        "author": "Yustos",
        "content": "I did test again and this was my false - 400/404 problem is valid when i use fiddler as proxy to client-side requests sniffing.\r\nThis command will produce 400/404 errors:\r\n\u0060\u0060\u0060powershell\r\nInvoke-WebRequest -Uri \u0022http://example.com:5000\u0022 -UseDefaultCredentials -Proxy http://localhost:8888\r\n\u0060\u0060\u0060\u0060\r\n\r\nBut this is stable 401:\r\n\u0060\u0060\u0060powershell\r\nInvoke-WebRequest -Uri \u0022http://example.com:5000\u0022 -UseDefaultCredentials\r\nInvoke-WebRequest : The remote server returned an error: (401) Unauthorized.\r\nAt line:1 char:1\r\n\u002B Invoke-WebRequest -Uri \u0022http://example.com:5000\u0022 -UseDefaultCredent ...\r\n\u002B ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n    \u002B CategoryInfo          : InvalidOperation: (System.Net.HttpWebRequest:HttpWebRequest) [Invoke-WebRequest], WebExc\r\n   eption\r\n    \u002B FullyQualifiedErrorId : WebCmdletWebResponseException,Microsoft.PowerShell.Commands.InvokeWebRequestCommand\r\n\u0060\u0060\u0060\r\n\r\nHere is server log for 401 without proxy (single call): \r\n[server.txt](https://github.com/dotnet/aspnetcore/files/4440081/server.txt)\r\n\r\nAnyway, i can not use Kestrel negotiate with SPN\u0027s. I want to use dynamic subdomains and i have no opportunity to dynamically register SPN\u0027s in Active Directory. For my case HTTP.SYS and IIS works fine :(\r\n\r\nChris, thank you for explanation about SPN! I\u0027m sorry for your time.\r\n\r\n\r\n",
        "createdAt": "2020-04-06T18:19:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20540#issuecomment-609957475"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyMjA5NTY5MA==",
        "parentId": null,
        "author": "JunTaoLuo",
        "content": "FYI, the 401s we were seeing seem to be caused by the missing SPNs. I am able to reproduce the 401 errors on my local VMs when the SPNs are not configured and I am able to run your repro project successfully when I do have the SPN configured correctly. I think all the questions here have been resolved, please let us know if you have any other issues @Yustos ",
        "createdAt": "2020-04-30T20:35:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20540#issuecomment-622095690"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyMjA5NzkyNg==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@JunTaoLuo did you ever see the InvalidOperationException?",
        "createdAt": "2020-04-30T20:39:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20540#issuecomment-622097926"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyMjExNDEwOA==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Triage: @JunTaoLuo is going to take a quick look at a few other clients (Legacy Edge/Edgium, etc.) to see if we can repro the InvalidOperationException. We do require an SPN though so I don\u0027t think there\u0027s much we can do about that. Using HttpSys is probably a better option in this scenario.",
        "createdAt": "2020-04-30T21:10:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20540#issuecomment-622114108"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNTUwMDU4NQ==",
        "parentId": null,
        "author": "analogrelay",
        "content": "@JunTaoLuo was able to identify that Edge Chromium does indeed produce this error when SPNs aren\u0027t configured. We\u0027re forwarding the details on to that team for further investigation.",
        "createdAt": "2020-05-07T21:13:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20540#issuecomment-625500585"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU2MTQ0NjMxOTU=",
    "title": "Misleading error message when an Authorization Handler is not registered",
    "url": "https://github.com/dotnet/aspnetcore/issues/21607",
    "createdAt": "2020-05-08T02:41:12Z",
    "lastUpdated": "2020-11-10T23:30:03Z",
    "body": "### Describe the bug\r\nThe error message provided when Authorization failed due to a Handler not being registered is currently:\r\n\u0060info: Microsoft.AspNetCore.Authorization.DefaultAuthorizationService[2]\r\n      Authorization failed.\r\ninfo: Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler[13]\r\n      AuthenticationScheme: Bearer was forbidden.\u0060\r\nThis suggests there is something wrong with the Bearer Token provided, the Authentication scheme, or the default Authorization (ie. not signed in / bearer token is missing). It\u0027s especially confusing when you aren\u0027t using the [Authorize] tag at all.\r\n\r\nThe error message would be far more useful if it at least logged the usual \u0022Dependency  [HandlerName] could not be resolved\u0022 like other missing dependency errors, though maybe throwing an exception is applicable here too. The current error message is sending programmers down a rabbit hole unrelated to the actual issue.\r\n\r\n### To Reproduce\r\nUse the code from [this sample](https://github.com/dotnet/aspnetcore/blob/v3.1.3/src/Security/samples/CustomPolicyProvider/Startup.cs) and remove:\r\n\u0060services.AddSingleton\u003CIAuthorizationHandler, MinimumAgeAuthorizationHandler\u003E();\u0060\r\nfrom Startup.cs. Try to access methods in the HomeController.\r\n\r\n### Further technical details\r\n- ASP.NET Core version 3.1\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   3.1.101\r\n Commit:    b377529961\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.18362\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\3.1.101\\\r\n\r\nHost (useful for support):\r\n  Version: 3.1.1\r\n  Commit:  a1388f194c\r\n\r\n.NET Core SDKs installed:\r\n  3.0.100 [C:\\Program Files\\dotnet\\sdk]\r\n  3.1.101 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.13 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.13 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.1.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.0.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.13 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.1.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 3.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 3.1.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n- Visual Studio 2019 community edition 16.3.2\r\n",
    "upvotes": 4,
    "labels": [
      "enhancement",
      "area-auth",
      "affected-few",
      "severity-minor"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyODg5NTczOQ==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Triage: We could probably do something to improve logging here.",
        "createdAt": "2020-05-14T21:27:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21607#issuecomment-628895739"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU2MjAzMjU4MjM=",
    "title": "Make CookieAuthenticationOptions.SlidingExpiration behaviour configurable",
    "url": "https://github.com/dotnet/aspnetcore/issues/21949",
    "createdAt": "2020-05-18T15:59:14Z",
    "lastUpdated": "2021-04-30T17:13:37Z",
    "body": "### Issue\r\nThe \u0060SlidingExpiration\u0060 option when set to \u0060true\u0060 only configures the handler to re-issue the cookie if it processes a request more than half way through the expiry window. As a result, in a 1 hour expiry window a request processed at 29 minutes will not reset the window.\r\n\r\nThe \u0060CheckForRefresh\u0060 method which handles this is \u0060private\u0060, and therefore this behaviour cannot be modified easily by the calling application.\r\n\r\n### Potential solution\r\nIntroduce another configuration option that allows the developer to set the period elapsed of the timeout window at which the cookie will be re-issued - this should default to 50% of the \u0060ExpireTimeSpan\u0060 for backwards compatibility.\r\n\r\nCurrent handler code:\r\n\u0060\u0060\u0060\r\nprivate void CheckForRefresh(AuthenticationTicket ticket)\r\n        {\r\n            var currentUtc = Clock.UtcNow;\r\n            var issuedUtc = ticket.Properties.IssuedUtc;\r\n            var expiresUtc = ticket.Properties.ExpiresUtc;\r\n            var allowRefresh = ticket.Properties.AllowRefresh ?? true;\r\n            if (issuedUtc != null \u0026\u0026 expiresUtc != null \u0026\u0026 Options.SlidingExpiration \u0026\u0026 allowRefresh)\r\n            {\r\n                var timeElapsed = currentUtc.Subtract(issuedUtc.Value);\r\n                var timeRemaining = expiresUtc.Value.Subtract(currentUtc);\r\n\r\n                if (timeRemaining \u003C timeElapsed)\r\n                {\r\n                    RequestRefresh(ticket);\r\n                }\r\n            }\r\n        }\r\n\u0060\u0060\u0060\r\n\r\nSuggested handler code:\r\n\u0060\u0060\u0060\r\nprivate void CheckForRefresh(AuthenticationTicket ticket)\r\n        {\r\n            var currentUtc = Clock.UtcNow;\r\n            var issuedUtc = ticket.Properties.IssuedUtc;\r\n            var refreshUtc = issuedUtc \u002B Options.RefreshPeriod;\r\n            var allowRefresh = ticket.Properties.AllowRefresh ?? true;\r\n            if (issuedUtc != null \u0026\u0026 Options.SlidingExpiration \u0026\u0026 allowRefresh \u0026\u0026 currentUtc \u003E refreshUtc)\r\n            {\r\n                RequestRefresh(ticket);\r\n            }\r\n        }\r\n\u0060\u0060\u0060\r\n\r\n",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "affected-few",
      "severity-minor"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYzMjM0OTMzMg==",
        "parentId": null,
        "author": "blowdart",
        "content": "This is a reasonably common ask.\r\n\r\nIf we made it configurable what sort of property would you want? We\u0027d probably still go with a percentage, you can adjust. \r\n\r\nIn any case it\u0027d take design, which means it\u0027ll be backlogged for now.",
        "createdAt": "2020-05-21T21:13:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21949#issuecomment-632349332"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY0NDM0ODQ0NA==",
        "parentId": null,
        "author": "??",
        "content": "This issue has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **4 days**. It will be closed if no further activity occurs **within 3 days of this comment**. If it *is* closed, feel free to comment when you are able to provide the additional information and we will re-investigate.\n\nSee [our Issue Management Policies](https://aka.ms/aspnet/issue-policies) for more information.",
        "createdAt": "2020-06-15T20:00:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21949#issuecomment-644348444"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY0NDU4MDY5OA==",
        "parentId": null,
        "author": "HarryRobertson",
        "content": "A percentage would suit me fine.\r\n\r\nIf it\u0027s going to be backlogged, I assume I can\u0027t expect to see this any time soon?",
        "createdAt": "2020-06-16T07:17:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21949#issuecomment-644580698"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU2NTI1Mjc1MjY=",
    "title": "Consider adding an event to the OAuth 2.0 base handler to validate token responses",
    "url": "https://github.com/dotnet/aspnetcore/issues/23749",
    "createdAt": "2020-07-07T18:24:46Z",
    "lastUpdated": "2020-07-11T14:56:41Z",
    "body": "In some cases, developers want to make sure that the scopes granted by the authorization server/resource owner exactly match the requested scopes. In OAuth 2.0/OIDC, this can be done by determining whether a \u0060scope\u0060 property was returned as part of the authorization response (for the implicit flow, but it\u0027s easy to bypass) or the token response, and ensuring it matches the requested scopes.\r\n\r\nUnfortunately, there\u0027s currently no event that would allow implementing that.\r\nAlternatively, if we think it\u0027s a common enough scenario, it should be natively implemented as a \u0060ValidateGrantedScope\u0060 option.\r\n\r\nhttps://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/pull/444#issuecomment-655032756\r\n\r\n/cc @Tratcher @bryantlikes",
    "upvotes": 2,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY1NjM1ODYxNw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "So for OAuth there\u0027d be a change to capture the scopes about here as part of the OAuthTokenResponse:\r\nhttps://github.com/dotnet/aspnetcore/blob/a5901c084aab5aba6162a57b6fe2dc0ec7764e48/src/Security/Authentication/OAuth/src/OAuthHandler.cs#L204\r\n\r\nThen you could check the scopes in the existing CreateTicket event, right?\r\nhttps://github.com/dotnet/aspnetcore/blob/a5901c084aab5aba6162a57b6fe2dc0ec7764e48/src/Security/Authentication/OAuth/src/OAuthHandler.cs#L165\r\n\r\nFor OIDC implicit flow could you do this check in the MessageReceived event?\r\nhttps://github.com/dotnet/aspnetcore/blob/a5901c084aab5aba6162a57b6fe2dc0ec7764e48/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectHandler.cs#L527\r\n\r\nFor the OIDC token endpoint response, it seems like you could check this in the TokenResponseReceived event.\r\nhttps://github.com/dotnet/aspnetcore/blob/a5901c084aab5aba6162a57b6fe2dc0ec7764e48/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectHandler.cs#L658",
        "createdAt": "2020-07-09T21:24:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/23749#issuecomment-656358617"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY1NzA3NjE1OA==",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E So for OAuth there\u0027d be a change to capture the scopes about here as part of the OAuthTokenResponse:\r\n\r\nYep. Now the question is: do we want the base OAuth 2.0 handler to do that or do we just want to provide an event to allow folks to implement that themselves?\r\n\r\n\u003E For OIDC implicit flow could you do this check in the MessageReceived event?\r\n\r\nYeah, the OIDC handler has a much better events story and it\u0027s already possible to support that scenario using the existing hooks (that\u0027s why I only mentioned the OAuth 2.0 handler in my OP).",
        "createdAt": "2020-07-11T14:56:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/23749#issuecomment-657076158"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU2ODUwOTc5OTI=",
    "title": "ChunkingCookieManager ChunkSize calculation fails to account for Uri Encoding",
    "url": "https://github.com/dotnet/aspnetcore/issues/25224",
    "createdAt": "2020-08-25T02:00:48Z",
    "lastUpdated": "2020-10-06T15:00:22Z",
    "body": "### Describe the bug\r\nThe ChunkingCookieManager attempts to break cookies up according to the default or configured ChunkSize. The calculation it performs against the length of the value is based on the raw value. However, the cookie value is encoded (via Uri.EscapeDataString) before being appended to response headers. Depending on the cookie value, that encoding step can significantly inflate the size of each chunk - easily surpassing what some browsers will accept.\r\n\r\nI\u0027m not clear on why we\u0027re aggressively encoding all cookies when that isn\u0027t required by the spec. But in any case, I believe ChunkingCookieManager has a bug. It should be considering the length of the encoded value since that is what browsers will see, not the passed in value.\r\n\r\n### To Reproduce\r\nSet a cookie using:\r\n\u0060new ChunkingCookieManager().AppendResponseCookie(HttpContext, \u0022Test\u0022, \u0022{\\\u0022Key\\\u0022:\\\u0022Value\\\u0022}\u0022);\u0060\r\n\r\nTransmitted header is encoded:\r\n\u0060Set-Cookie: Test=%7B%22Key%22%3A%22Value%22%7D; path=/;\u0060\r\n\r\nChunkingCookieManager believes it is dealing with a 15 character value. The actual cookie value is 29 characters.",
    "upvotes": 0,
    "labels": [
      "bug",
      "area-auth",
      "affected-few",
      "severity-minor"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3OTgwMDIzMg==",
        "parentId": null,
        "author": "Tratcher",
        "content": "A) you\u0027re right, the math is off.\r\nB) the encoding is a bit aggressive, but it is needed in some cases.\r\nC) the spec does restrict what characters can be used in cookie values. For example most JSON would result in invalid cookies, just like the sample you gave.\r\nD) so far the chunking cookie manager has been used with components that only produce valid cookies like cookie auth and mvc temp data.\r\nE) the caller can mitigate this by producing valid cookies or pre-encoding.",
        "createdAt": "2020-08-25T06:05:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/25224#issuecomment-679800232"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3OTgwMjUyMg==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Where were you intending to use ChunkingCookieManager, and why aren\u0027t you producing valid cookies to start with?",
        "createdAt": "2020-08-25T06:06:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/25224#issuecomment-679802522"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3OTgzMjYyMw==",
        "parentId": null,
        "author": "hempels",
        "content": "Fair questions.\r\n\r\n- Where were you intending to use ChunkingCookieManager?\r\n\r\nWe have a custom OAuth handler (for LTI) that allows new users to authenticate with an openid provider (MS, Google, etc) to connect multiple auths to a single account. That requires storing the original JWT in a cookie to be read back later. JWTs can be quite large. We already use ChunkingCookieManager for this by overriding ChunkSize to a much smaller value, but I finally decided to dig into why we\u0027re having to do that.\r\n\r\n- Why aren\u0027t you producing valid cookies to start with?\r\n\r\n1. Not a documented requirement of AppendResponseCookie and is not something we are used to having to do with AppendCookie. They both perform encoding (which cannot be opted out of) presumably so the caller doesn\u0027t have to.\r\n\r\n2. Pre-encoding would result in a double-escaped value and could cause problems trying to read it back. RFC 2396 makes clear that this should be avoided:\r\n\u003E Implementers should be careful not to escape or unescape the same string more than once, since unescaping an already unescaped string might lead to misinterpreting a percent data character as another escaped character, or vice versa in the case of escaping an already escaped string.",
        "createdAt": "2020-08-25T06:35:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/25224#issuecomment-679832623"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3OTgzNjc4Mw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Note cookie auth has one alternative strategy for dealing with large data. It can save the data in a local store and only send a unique identifier to the client. You may consider something similar.",
        "createdAt": "2020-08-25T06:45:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/25224#issuecomment-679836783"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3OTgzODU5Nw==",
        "parentId": null,
        "author": "hempels",
        "content": "\u003E save the data in a local store and only send a unique identifier to the client\r\n\r\nThis would be a nice optimization, though a good deal more effort than the working solution we already have.\r\n\r\nI just wanted to point out what I believe to be an oversite with ChunkingCookieManager. Admittedly it likely doesn\u0027t impact many developers.",
        "createdAt": "2020-08-25T06:49:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/25224#issuecomment-679838597"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY4MjE4NzU2NA==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-08-27T20:59:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/25224#issuecomment-682187564"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU2ODc2NDAzNDQ=",
    "title": "Negotiate reflection performance improvements",
    "url": "https://github.com/dotnet/aspnetcore/issues/25335",
    "createdAt": "2020-08-28T01:16:01Z",
    "lastUpdated": "2020-10-06T14:59:59Z",
    "body": "Feedback from @mconnew:\r\n\r\nI was looking over your reflected abstraction of the negotiate code ... and noticed a significant performance problem in the code. There is lots of code which looks similar to this:\r\n \r\n        public bool IsCompleted\r\n        {\r\n            get =\u003E (bool)_isCompleted.Invoke(_instance, Array.Empty\u003Cobject\u003E());\r\n        }\r\n \r\nThe problem with calling the Invoke method on an MethodInfo is it does a whole bunch of runtime type checking to make sure the number and type of arguments is correct. There\u2019s also a boxing and unboxing as well as a cast type check on the return value. You can use MethodInfo.CreateDelegate to create a delegate you can straight up call. Because it only does the type checking of the delegate type to the method info when you call CreateDelegate, it\u2019s a lot cheaper to call. The generated delegate is strongly typed so the CLR just depends on the strong typing to ensure all the parameters etc are correct.\r\n\r\n---\r\n\r\nIf we get a proper API for this in 6.0 then this code can be removed (https://github.com/dotnet/runtime/issues/29270). If not we may consider making some improvements.\r\n\r\nNote it\u0027s not clear how these costs reflect on RPS. Windows Auth is already a very in-efficient process that often involves multiple request.\r\n",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "Perf",
      "area-auth",
      "severity-nice-to-have",
      "affected-very-few"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY5MDczMTIzOQ==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-09-10T21:06:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/25335#issuecomment-690731239"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcwMjU2NDU5Mg==",
        "parentId": null,
        "author": "davidfowl",
        "content": "@mconnew is there a wcf scenario we can setup and run?",
        "createdAt": "2020-10-02T07:03:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/25335#issuecomment-702564592"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcwMjg4NjYwNQ==",
        "parentId": null,
        "author": "mconnew",
        "content": "The scenario for this with WCF is no different than any other ASP.NET Core application using Windows auth. I just know from experience that the cost of using Invoke to use a reflected property is significantly higher than using a created delegate. I have no idea how that translates to actual additional cost for authentication in a running service. I opened this issue because it\u0027s a small quick change to do without any refactoring needed and there is some performance gain to it. I have a dev working on CoreWCF who is working on using the same reflection based usage of the Nego abstraction to implement Windows  authentication with Token based message security and I discovered this when I was finding references for them.",
        "createdAt": "2020-10-02T18:19:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/25335#issuecomment-702886605"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3MjM3Njg0NzU=",
    "title": "SAML2 and CAS Auth",
    "url": "https://github.com/dotnet/aspnetcore/issues/27004",
    "createdAt": "2020-10-17T14:17:21Z",
    "lastUpdated": "2020-10-22T21:16:33Z",
    "body": "\u003C!--\r\n\r\nMore information on our issue management policies can be found here: https://aka.ms/aspnet/issue-policies\r\n\r\n--\u003E\r\n\r\n## Add SAML2.0 and CAS authentication support to native asp core.\r\n\r\nPlease add SAML2 and CAS authentication to the natively supported auth types for ASP core.\r\n\r\nThere are very many old auth systems out there that still require that you use this for logins.\r\n\r\nThank you",
    "upvotes": 3,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxMTA0MDM3NA==",
        "parentId": null,
        "author": "blowdart",
        "content": "What do you mean by CAS?",
        "createdAt": "2020-10-17T16:30:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27004#issuecomment-711040374"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxMTA0MjQ0Nw==",
        "parentId": null,
        "author": "tbonham",
        "content": "\u003E What do you mean by CAS?\r\n\r\nCentral Authentication Service (CAS) [https://www.apereo.org/projects/cas](https://www.apereo.org/projects/cas)\r\n\r\nCAS is a SSO technology that is used a lot in the EDU environment.",
        "createdAt": "2020-10-17T16:39:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27004#issuecomment-711042447"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxMTA0OTM4NQ==",
        "parentId": null,
        "author": "blowdart",
        "content": "That\u0027s new to me. Given that it\u0027s the first request we\u0027ve had it\u0027s unlikely we\u0027d look at implementing another protocol without much more demand.",
        "createdAt": "2020-10-17T17:11:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27004#issuecomment-711049385"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxNDc2NzA0OA==",
        "parentId": null,
        "author": "blowdart",
        "content": "For SAML2 there are multiple 3rd party libraries, as you\u0027ve discovered already. \r\n\r\nThe underlying stuff we use for WS-Fed and SAML come from AAD and as AD/ADFS don\u0027t do SAML2 there\u0027s no real interest there in supporting it.\r\n\r\nI\u0027ll drop this into backlog, but it would need a lot of popularity before SAML2 is considered.",
        "createdAt": "2020-10-22T21:16:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27004#issuecomment-714767048"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxNDc2NzE3Nw==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-10-22T21:16:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27004#issuecomment-714767177"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3MjU2NjM2NzI=",
    "title": "Allow combining authorization policies in Authorize attribute same way how it works with roles.",
    "url": "https://github.com/dotnet/aspnetcore/issues/27061",
    "createdAt": "2020-10-20T14:44:20Z",
    "lastUpdated": "2023-12-07T07:47:47Z",
    "body": "\u0060Authorize\u0060 attribute allows to specify multiple roles which work with OR-semantics. Unfortunately, there\u0027s only \u0060Policy\u0060 property rather than \u0060Policies\u0060.\r\n\r\nPolicy defines requirements with AND-semantics. OR-semantics for single requirement can be implemented with multiple handlers. However, there\u0027s no option to easily combine policies in OR-mode.\r\n\r\nFor example, we want to check that user is Administrator, or resource belongs to the user. I see these checks as two distinct policies having various requirements:\r\n\r\n\u0060\u0060\u0060CSharp\r\n[Authorize(Policies=\u0022UserIsAdministrator, UserOwnsTheOrder\u0022]\r\n[ApiController]\r\nMyController : Controller {}\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060CSharp\r\nservices.AddAuthorization(cfg =\u003E {\r\n    cfg.AddPolicy(\r\n        \u0022UserOwnsTheOrder\u0022,\r\n        policy =\u003E policy.Requirements.Add(new UserOwnsTheOrderRequirement()));\r\n    cfg.AddPolicy(\r\n        \u0022UserIsAdministrator\u0022,\r\n        policy =\u003E policy.RequireRole(UserAuthorizeRole.Operator));\r\n\r\n});\r\nservices.AddTransient\u003CIAuthorizationHandler, UserOwnsTheOrderAuthorizationHandler\u003E();\r\n\u0060\u0060\u0060\r\n\r\n",
    "upvotes": 2,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxNDc2MzM2MA==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-10-22T21:08:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27061#issuecomment-714763360"
      },
      {
        "id": "IC_kwDOAQzde85tyrlr",
        "parentId": null,
        "author": "hossameldeen",
        "content": "I have the exact same need.\r\n\r\nHow are you, or anyone reading this post, implementing this behaviour for now?",
        "createdAt": "2023-12-06T02:53:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27061#issuecomment-1842002283"
      },
      {
        "id": "IC_kwDOAQzde85t0gnd",
        "parentId": null,
        "author": "voroninp",
        "content": "@hossameldeen , using [imperative approach](https://learn.microsoft.com/en-us/aspnet/core/security/authorization/resourcebased?view=aspnetcore-8.0#use-imperative-authorization). \r\n\r\nBut yes, declarative would be nicer.",
        "createdAt": "2023-12-06T09:13:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27061#issuecomment-1842481629"
      },
      {
        "id": "IC_kwDOAQzde85t6uWk",
        "parentId": null,
        "author": "hossameldeen",
        "content": "@voroninp I see. Thank you.\r\n\r\nIndeed, declarative would be nicer. My main motivation for declarative also is features like fallback \u0026 default policy that help protect against forgetting authorization logic in an endpoint.\r\n\r\nSeems like I\u0027ll go for creating combination policies (e.g., \u0060UserIsAdministratorOrUserOwnsTheOrder\u0060), especially that the number of policies shouldn\u0027t grow to N^2 since most or all of them would need to be combined with only 1 or 2 policies (e.g., \u0060UserIsAdministrator\u0060).\r\n\r\nAnd might extract bulk of authorization logic into, e.g., \u0060AdministratorUserAuthorizationService\u0060 and similar services, so that it can be reused in handlers of policies and their combinations, if anyone is curious.",
        "createdAt": "2023-12-07T02:29:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27061#issuecomment-1844110756"
      },
      {
        "id": "IC_kwDOAQzde85t61gb",
        "parentId": null,
        "author": "hossameldeen",
        "content": "For prioritization considerations, this is a discussed [StackOverflow question](https://stackoverflow.com/q/35609632/6690391) that could be a useful data point.\r\n\r\nThe accepted answer _seems_ to only provide an \u0060OR\u0060 of a full set of policies/requirements. But it doesn\u0027t provide the ability to \u0060OR\u0060 different subsets of this set.\r\n\r\nE.g., if we have policies/requirements \u0060X\u0060, \u0060Y\u0060, and \u0060Z\u0060, the accepted answer would give us \u0060OR(X, Y, Z)\u0060, but not \u0060X\u0060, \u0060Y\u0060, \u0060Z\u0060, \u0060OR(X, Y)\u0060, .. etc.",
        "createdAt": "2023-12-07T02:53:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27061#issuecomment-1844140059"
      },
      {
        "id": "IC_kwDOAQzde85t9ea2",
        "parentId": null,
        "author": "voroninp",
        "content": "As another workaround solution you could create an authorization handler which will  build its configuration from endpoint metadata (applied attributes).\n\n\u0060Authorize\u0060 attribute is not sealed, so you can create a descendant which specifies the policy to activate that universal handler.",
        "createdAt": "2023-12-07T07:47:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27061#issuecomment-1844831926"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3Mjk4ODMwMjg=",
    "title": "[Performance] Authentication middleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/27220",
    "createdAt": "2020-10-26T20:30:03Z",
    "lastUpdated": "2024-09-10T19:33:16Z",
    "body": "- [x] Add cert support to http client load client\r\n- [x] Add baseline scenarios for cert/jwt\r\n- [x] Add reporting/charts for cert/jwt\r\n- [x] Add competitive scenarios for cert/jwt for comparison\r\n- [ ] Figure out what the target improvements/goals are\r\n- [ ] Investigate traces and improve performance\r\n- [x] Add scenario using https://github.com/uruk-project/Jwt/ as comparison\r\n- [ ] Add baseline for cookie auth\r\n- [x] Improve JwtSecurityTokenHandler.ValidateToken perf (locking?)\r\n- [ ] Consider adding some form of caching invalid/expired certs\r\n\r\nImprove performance characteristics of authentication middleware.\r\n\r\nAreas of interest:\r\n\r\n- JWT\r\n- Certificate based authentication\r\n",
    "upvotes": 20,
    "labels": [
      "Perf",
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxODIzMDM3OQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "- Cookie authentication",
        "createdAt": "2020-10-28T21:53:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27220#issuecomment-718230379"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc0MDEwMTUwNw==",
        "parentId": null,
        "author": "HaoK",
        "content": "@sebastienros what\u0027s the best way for me to started on this issue, I\u0027m assuming add some baseline scenario tests to get initial numbers and profiles?",
        "createdAt": "2020-12-07T18:36:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27220#issuecomment-740101507"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc0MTI0Njg0Nw==",
        "parentId": null,
        "author": "HaoK",
        "content": "Adding table for tracking some initial numbers (using existing mvc product crud APIs):\r\n\r\n| Scenario | request/second | % |\r\n| ------------- | ------------- | ------------- |\r\n|Jwt bombadier Baseline (Auth/JwtAuth = false) |97,840| 0% |\r\n|UseAuthN/AuthZ (no app usage) | 93,830 | -4% |\r\n|UseAuthN/AuthZ (with allow anon) | 88,658 | -9.5% |\r\n|UseAuthN/AuthZ (send jwt \u002B default scheme \u002B no valid audience/issuer) | 41,133 | -58% |\r\n|UseAuthN/AuthZ (send jwt \u002B default scheme \u002B valid audience/issuer) | 48,447 | -50.5% |\r\n|UseAuthN/AuthZ (custom jwtwebtoken handler send jwt \u002B default scheme \u002B valid audience/issuer) | 66,035 | -32.5% |\r\n|UseAuthN/AuthZ (with 6.8.0 handler send jwt \u002B default scheme \u002B valid audience/issuer) | 54,189 | -44.6% |\r\n|Cert http client Baseline(Auth/CertAuth = false) |71,668 | 0% |\r\n|UseAuthN/AuthZ (with expired cert, https, ssl required, cert cache miss, cert forwarding) | 13,085 | -81.7% |\r\n|UseAuthN/AuthZ (with expired cert, https, ssl required, cert cache miss, no cert forwarding) | 13,337 | -81.4% |\r\n|UseAuthN/AuthZ (with expired cert, https, ssl required, cert cache hit with removed expiry check, no cert forwarding) | 58,960 | -17.8% |\r\n\r\n\r\n",
        "createdAt": "2020-12-08T23:43:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27220#issuecomment-741246847"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc0MjAzMTY5NA==",
        "parentId": null,
        "author": "HaoK",
        "content": "Just sending an authorization bearer header with jwtbearer authentication as the default scheme results in a drop to 41,133 requests/second so a -58% hit",
        "createdAt": "2020-12-09T20:33:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27220#issuecomment-742031694"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3MTA5Mzc5MA==",
        "parentId": null,
        "author": "sebastienros",
        "content": "Status: @HaoK has started looking at traces",
        "createdAt": "2021-02-01T19:17:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27220#issuecomment-771093790"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3MzY4NTU2MQ==",
        "parentId": null,
        "author": "HaoK",
        "content": "Next steps following sync up:\r\n\r\nJwt\r\n- Focus on micro benchmark of JwtSecurityToken.ValidateToken\r\n\r\nCert\r\n- Look into why cert caching is not working\r\n- Try ARR-Header to avoid ssl\r\n\r\nCookies\r\n- Add baseline scenario for traces\r\n\r\nAlso remove MVC from the scenarios to reduce clutter",
        "createdAt": "2021-02-05T00:06:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27220#issuecomment-773685561"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3NDIwNjQ4MA==",
        "parentId": null,
        "author": "HaoK",
        "content": "@brentschmaltz @jmprieur just giving you guys a heads up that I\u0027m going to be playing a bit around and looking at micro benchmarking JwtSecurityToken.ValidateToken since it seems to be a hot path in our current perf benchmarks.  If you\u0027ve done any work in this area already, or if there\u0027s any preferred way you\u0027d like us to collaborate on perf improvements here, please let us know",
        "createdAt": "2021-02-05T18:25:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27220#issuecomment-774206480"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3NDM1OTM3OA==",
        "parentId": null,
        "author": "HaoK",
        "content": "Starting profile using VS of ValidateToken of our current jwt token in a loop 100x\r\n\r\n![image](https://user-images.githubusercontent.com/6537861/107097658-5a3a0400-67c2-11eb-97ca-e42a042dd8e8.png)\r\n\r\nAnd starting BenchmarkDotNumber numbers for ValidateToken\r\n\r\n|   Method |     Mean |    Error |   StdDev |  Gen 0 | Gen 1 | Gen 2 | Allocated |\r\n|--------- |---------:|---------:|---------:|-------:|------:|------:|----------:|\r\n| Validate | 25.54 us | 34.87 us | 1.912 us | 4.5776 |     - |     - |  18.73 KB |\r\n",
        "createdAt": "2021-02-06T00:29:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27220#issuecomment-774359378"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc4MTUwMTI5NA==",
        "parentId": null,
        "author": "HaoK",
        "content": "Updates:\r\n- Jwt: Moving to the 6.8 packages should take Jwt perf from -51%(48k) to -45% by eliminating locking (54k rps)\r\n- Jwt: Using a simple custom auth handler implementation of JsonWebToken 3rd party package for comp (66k rps)\r\n- Cert: Removing the expired cert check in the cache code, shows that cert cache hits go from -81% to -17% compared to baseline (no auth)\r\n",
        "createdAt": "2021-02-18T17:16:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27220#issuecomment-781501294"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc4Mzc0NDA4Mw==",
        "parentId": null,
        "author": "MessyFork",
        "content": "Is there any chance of using AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet#1365 ? I remember seeing claims of massive speed improvements from moving to the new class. ",
        "createdAt": "2021-02-22T23:10:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27220#issuecomment-783744083"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgxMjA4OTA5Mg==",
        "parentId": null,
        "author": "HaoK",
        "content": "Updated perf view removing MVC with the new 6.8 packages:\r\n\r\nJWT\r\n![image](https://user-images.githubusercontent.com/6537861/113337522-b447d900-92dc-11eb-82fe-c0b01b9c03cb.png)\r\n",
        "createdAt": "2021-04-01T18:24:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27220#issuecomment-812089092"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgxMjA5OTcyOA==",
        "parentId": null,
        "author": "HaoK",
        "content": "Cert perf with no mvc and a valid cert and validation cache hit, basically don\u0027t see cert auth at all in the profile now\r\n\r\n![image](https://user-images.githubusercontent.com/6537861/113339557-7e582400-92df-11eb-9e31-dcbced80f4ec.png)\r\n",
        "createdAt": "2021-04-01T18:43:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27220#issuecomment-812099728"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3MzYzNTc1OTM=",
    "title": "Improve Kerberos-based auth experience",
    "url": "https://github.com/dotnet/aspnetcore/issues/27527",
    "createdAt": "2020-11-04T19:09:42Z",
    "lastUpdated": "2022-11-17T22:42:14Z",
    "body": "\u003C!--\r\nThis template is useful to build consensus about whether work should be done, and if so, the high-level shape of how it should be approached. Use this before fixating on a particular implementation.\r\n--\u003E\r\n\r\n## Summary\r\n\r\nWe\u0027ve seen some feedback indicating that Kerberos auth is not usable in some E2E scenarios (@Tratcher can you please clarify this as none of the attendees of the meeting have context about this).\r\nThis issue tracks the work to identify all those experiences and later decide which ones we would like to address in 6.0 timeframe.\r\n\r\n@blowdart thinks that this may be related to authentication delegation to SQL.\r\n\r\n### People with more context\r\n@Tratcher, @JunTaoLuo\r\n\r\n## Motivation and goals\r\n\r\nThe initial 3.x Negotiate handler provided only minimal functionality on linux. In 5.0 @JunTaoLuo did work to expand that to include roles. However, none of the partners have been able to validate the new 5.0 features yet, so we\u0027re still expecting feedback that we may need to address.\r\n\r\nWe\u0027re also still waiting for a proper Negotiate API from the runtime. We\u0027ve been using reflection since 3.x. https://github.com/dotnet/runtime/issues/29270\r\n\r\nThere have also been asks about delegating to SQL cross platform.\r\n\r\n## In scope\r\n\r\nA list of major scenarios, perhaps in priority order.\r\n\r\n## Out of scope\r\n\r\nScenarios you explicitly want to exclude.\r\n\r\n## Risks / unknowns\r\n\r\nHow might developers misinterpret/misuse this? How might implementing it restrict us from other enhancements in the future? Also list any perf/security/correctness concerns.\r\n\r\n## Examples\r\n\r\nGive brief examples of possible developer experiences (e.g., code they would write).\r\n\r\nDon\u0027t be deeply concerned with how it would be implemented yet. Your examples could even be from other technology stacks.\r\n\r\n\u003C!--\r\n# Detailed design\r\n\r\nIt\u0027s often best not to fill this out until you get basic consensus about the above. When you do, consider adding an implementation proposal with the following headings:\r\n\r\nDetailed design\r\nDrawbacks\r\nConsidered alternatives\r\nOpen questions\r\nReferences\r\n\r\nIf there\u0027s one clear design you have consensus on, you could do that directly in a PR.\r\n--\u003E\r\n",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "design-proposal",
      "Theme: meeting developer expectations"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyMTkxOTU0Mw==",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\nWe\u0027re moving this issue to the \u0060Next sprint planning\u0060 milestone for future evaluation / consideration. We will evaluate the request when we are planning the work for the next milestone. To learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-11-04T19:09:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27527#issuecomment-721919543"
      },
      {
        "id": "IC_kwDOAQzde85Oj-D2",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@blowdart Looks like this hasn\u0027t been addressed for a couple of years. Is this something we want to invest in for 8 or should we just close it?",
        "createdAt": "2022-11-17T04:29:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27527#issuecomment-1318052086"
      },
      {
        "id": "IC_kwDOAQzde85OovZf",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-11-17T22:41:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27527#issuecomment-1319302751"
      },
      {
        "id": "IC_kwDOAQzde85Oovbh",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "Moving to \u0060Backlog\u0060 until the decision is made.",
        "createdAt": "2022-11-17T22:41:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27527#issuecomment-1319302881"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3NDYxMjE3NTY=",
    "title": "LDAP support in negotiate authentication fails with \u0022connection reset by peer\u0022",
    "url": "https://github.com/dotnet/aspnetcore/issues/27968",
    "createdAt": "2020-11-18T23:30:16Z",
    "lastUpdated": "2022-12-27T14:24:17Z",
    "body": "When using LDAP under Linux, so that one can have group membership in negotiate authentication, the connection to the LDAP server (domain controller) fails with error  \u0022connection reset by peer\u0022.\r\n\r\nThe reason is that the connection to the LDAP server is made when the server application starts up. But if the connection is idle, it is closed. Thus the error when an query is made.\r\n\r\nEither the connection should be retried after receiving ECONNRESET error, or tcp keepalive should be enabled.\r\n\r\nIn addition, the connection is unencrypted, therefore ldap user and password are sent in cleartext. It should be possible to enable TLS in LdapSettings.\r\n\r\nOf course, the right thing to do would be to parse the group membership data from the Kerberos ticket.\r\n",
    "upvotes": 0,
    "labels": [
      "bug",
      "blocked",
      "area-auth",
      "affected-few",
      "severity-major"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczMDQxNTIzMg==",
        "parentId": null,
        "author": "blowdart",
        "content": "LDAP being unencrypted under Linux may not be implemented yet\r\n\r\nThe group membership in the ticket may not enough for us to build a complete identity, hence having to run off to the ldap server to get groups, but is should be working. A follow up from the devs will come.",
        "createdAt": "2020-11-19T14:34:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27968#issuecomment-730415232"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczMDQ3NjIyOQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E Of course, the right thing to do would be to parse the group membership data from the Kerberos ticket.\r\n\r\nThe APIs we use don\u0027t give us access to the raw kerberos ticket or role data, and the ticket doesn\u0027t always contain the roles. Hence the LDAP lookup.",
        "createdAt": "2020-11-19T16:07:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27968#issuecomment-730476229"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczNDY5OTU3Mg==",
        "parentId": null,
        "author": "ramon-garcia",
        "content": "\u003E \u003E Of course, the right thing to do would be to parse the group membership data from the Kerberos ticket.\r\n\u003E \r\n\u003E The APIs we use don\u0027t give us access to the raw kerberos ticket or role data, and the ticket doesn\u0027t always contain the roles. Hence the LDAP lookup.\r\n\r\nYes we can have access to the PAC authorization data, with the function gss_get_name_attribute with attribute name \u0022urn:mspac:\u0022. For instance, the [Samba code does that](https://git.samba.org/?p=samba.git;a=blob;f=auth/kerberos/gssapi_pac.c).\r\n\r\nThis is the solution with MIT Kerberos. (Heimdal Kerberos is better at many things, and had integrated PAC support earlier, but for now let us stay focused in solving the issue)\r\n\r\n\r\n\r\n",
        "createdAt": "2020-11-27T07:58:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27968#issuecomment-734699572"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1MTcyODM4OA==",
        "parentId": null,
        "author": "blowdart",
        "content": "As @Tratcher said the APIs available to ASP Net don\u0027t get access to the raw ticket, or the PAC data, so we can\u0027t parse it. So, that is not an option for us.",
        "createdAt": "2020-12-28T14:22:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27968#issuecomment-751728388"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1NjQyODU5NQ==",
        "parentId": null,
        "author": "JunTaoLuo",
        "content": "Need to keep an eye out on https://github.com/dotnet/runtime/issues/43890.",
        "createdAt": "2021-01-07T22:33:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27968#issuecomment-756428595"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0MDgzNDIwOQ==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-05-13T21:05:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27968#issuecomment-840834209"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3NzU0Mzg0MDE=",
    "title": "AddIdentityServerJwt might accidentally use the wrong issuer URL.",
    "url": "https://github.com/dotnet/aspnetcore/issues/28880",
    "createdAt": "2020-12-28T14:54:18Z",
    "lastUpdated": "2021-09-17T20:41:39Z",
    "body": "### Describe the bug\r\nWhen using \u0060AddIdentityServerJwt\u0060 the IssuerURL seems to be derived from the actual request. The option management hooks into the events and enriches the options with the host name from the request:\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/b795ac3546eb3e2f47a01a64feb3020794ca33bb/src/Identity/ApiAuthorization.IdentityServer/src/Authentication/IdentityServerJwtBearerOptionsConfiguration.cs#L63\r\n\r\nWhen the first request that comes in is not the public host name, the options is enriched with the wrong host and all subsequent calls to authorize fail because the issuer URL does not match.\r\n\r\nConsider a scenario where you have a health check running. The health service uses the internal IP (e.g. in kubernetes) to call the health endpoint and the issuer URL is configured with the IP address.\r\n\r\n### To Reproduce\r\n1. Create a new SPA sample (dotnet new react -au Individual)\r\n2. Login\r\n3. Restart the server\r\n4. Go to https://127.0.0.1:5001 before you go to any other URL\r\n5. Go to https://localhost:5001 and press fetch data\r\n\r\nThe result in Chrome:\r\n\r\n\u0060\u0060\u0060\r\nBearer error=\u0022invalid_token\u0022, error_description=\u0022The issuer \u0027https://localhost:5001\u0027 is invalid\u0022\r\n\u0060\u0060\u0060\r\n\r\n### Further technical details\r\n- ASP.NET Core version 5\r\n",
    "upvotes": 0,
    "labels": [
      "area-auth",
      "area-identity"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1MTc1OTAyMQ==",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "Thanks for contacting us, @SebastianStehle.\r\nDue to the holiday season please expect some delays in our responses.\r\n@HaoK can you please investigate this when you\u0027re back? Thanks!",
        "createdAt": "2020-12-28T15:49:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28880#issuecomment-751759021"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1MTc1OTE3MA==",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\nWe\u0027re moving this issue to the \u0060Next sprint planning\u0060 milestone for future evaluation / consideration. We will evaluate the request when we are planning the work for the next milestone. To learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-12-28T15:49:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28880#issuecomment-751759170"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1MTkxNTcxMQ==",
        "parentId": null,
        "author": "blowdart",
        "content": "This is by design and matches what identity server itself does.\r\n\r\nIf you have multiple host names you must select an canonical one by setting the Authority on the actual underlying identity server options.\r\n\r\n\u0060\u0060\u0060c#\r\n            services.AddIdentityServer(options =\u003E options.IssuerUri = \u0022https://localhost\u0022)\r\n                .AddApiAuthorization\u003CApplicationUser, ApplicationDbContext\u003E();\r\n\u0060\u0060\u0060\r\n\r\nThe JWT pieces should then use the identity server metadata to resolve the issuer.\r\n\r\nHowever what I\u0027m seeing at that point is that the URL in the template for the metadata is wrong, and doesn\u0027t have the port number. As I\u0027m not a react person, I can\u0027t help further, but it feels more like a template issue that identity itself.",
        "createdAt": "2020-12-29T01:34:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28880#issuecomment-751915711"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1MTk5ODI2Mg==",
        "parentId": null,
        "author": "SebastianStehle",
        "content": "Thank your @blowdart for your answer. I also solved the problem with IssuerUri before writing this bug report.\r\n\r\nI think it is a very weird behavior. It first happened to me, when I had no health check at all, so I was not using a second host by purpose. So you actually make your server unusable by accident and it took my days to figure out what the problem is. If you think the behavior is okay there should be at least a warning. e.g. a Middleware that writes all the hosts to a hashset and logs a warning if 2 or more hosts are received.\r\n\r\nI had a similar problem a while ago in another project: https://github.com/squidex/squidex. A java client of a customer was using a library that always added the port number to the host header. So instead of adding \u0060host: cloud.squidex.io\u0060 this client has added \u0060host: cloud.squidex.io:443\u0060. Then the customer also got an issuer URL error and I had to integrate a workaround for this customer: https://github.com/Squidex/squidex/blob/master/backend/src/Squidex.Web/Pipeline/CleanupHostMiddleware.cs. In this scenario here one customer could accidentally make the whole application unusable.\r\n\r\nIf I check my logs I see a lot of requests to paths like \u0060/setup.php\u0060 or \u0060/install.php\u0060 and so on. Websites seem to be under constant attack these days. And with this behavior some attacker could bring your system down (or make it unusable) by pure luck.",
        "createdAt": "2020-12-29T08:45:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28880#issuecomment-751998262"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1MjA5Nzk2Mg==",
        "parentId": null,
        "author": "blowdart",
        "content": "To be fair this isn\u0027t us, this is Identity Server\u0027s behaviour, we\u0027re just not overriding it. Whilst I can\u0027t speak for Dom \u0026 Brock, when we make decisions like this, it\u0027s because customers want an f5 experience, where you can run a project immediately without having to think about configuration. \r\n\r\nAs for bringing hosts down, I\u0027d say maybe, but again it\u0027s something to take up with the identity server folks. We tend to lean towards saying not to listen on * and not to bind to IP addresses, but rather host names, and once you\u0027re thinking about host names, you tend to start thinking about configuration of everything more. Hopefully :)",
        "createdAt": "2020-12-29T14:32:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28880#issuecomment-752097962"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1MjEyMjAzNA==",
        "parentId": null,
        "author": "SebastianStehle",
        "content": "I don\u0027t see that this is a identity server behavior. The problem is the \u0022caching\u0022 and that the options property is changed. If you would always use the \u0060HttpContext.GetIdentityServerIssuerUri()\u0060 for each request, if not specified otherwise, the problem would not exist. I had a look to the source code and I actually do not see that much identity server code at all. You just use identity server to copy over some values like the signing key and the issuer URL, but that\u0027s it.\r\n\r\nYou need to hook into this place: https://github.com/dotnet/aspnetcore/blob/b795ac3546eb3e2f47a01a64feb3020794ca33bb/src/Security/Authentication/JwtBearer/src/JwtBearerHandler.cs#L94 and then just change the cloned parameter.\r\n\r\nI totally agree to the host name thing, but the question is: Who handles that. There are load balancers, requests and stuff like kubernetes wo make requests and manipulate the request and especially if your software is hosted in so many crazy ways you do not have full control over everything.",
        "createdAt": "2020-12-29T15:28:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28880#issuecomment-752122034"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc2NDk0NTc3Mw==",
        "parentId": null,
        "author": "SebastianStehle",
        "content": "I still don\u0027t understand how a behavior that can bring your system down without any warning can be by design.",
        "createdAt": "2021-01-21T21:14:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28880#issuecomment-764945773"
      },
      {
        "id": "IC_kwDOAQzde8429ahJ",
        "parentId": null,
        "author": "HaoK",
        "content": "Doc/release note issue filed to track this for 6.0 https://github.com/dotnet/aspnetcore/issues/36676",
        "createdAt": "2021-09-17T20:40:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28880#issuecomment-922069065"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3NzY4MTYyMjk=",
    "title": "Stale signing key cache results in 401 response during key rollover in JwtBearerHandler",
    "url": "https://github.com/dotnet/aspnetcore/issues/28948",
    "createdAt": "2020-12-31T06:34:30Z",
    "lastUpdated": "2024-05-27T17:28:44Z",
    "body": "\u003C!--\r\n\r\nMore information on our issue management policies can be found here: https://aka.ms/aspnet/issue-policies\r\n\r\n--\u003E\r\n\r\n### Is your feature request related to a problem? Please describe.\r\nFollowing a signing key rollover, it appears that \u0060Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler\u0060 may incorrectly report an authentication failure (which results in a 401 Unauthorized response) in \u0060HandleAuthenticateAsync\u0060 due to a stale local cache of the signing keys.\r\n\r\n\u0060Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler\u0060 relies on \u0060Microsoft.IdentityModel.Protocols.IConfigurationManager\u003COpenIdConnectConfiguration\u003E\u0060 as a cache for the signing keys when validating the signature in JWT tokens. In \u0060HandleAuthenticateAsync()\u0060, when authentication fails due to \u0060SecurityTokenSignatureKeyNotFoundException\u0060 (which may legitimately occur due to key rollovers), \u0060JwtBearerHandler\u0060 simply calls \u0060IConfigurationManager.RequestRefresh()\u0060, which does not refresh the signing keys immediately. Instead, it sets a timestamp which causes the configuration to be refreshed beginning with the next request. The request in question will still fail at the authentication stage. The relevant code here:\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/41eab27ef39706c5c08183c740eb0d5f3ab32df4/src/Security/Authentication/JwtBearer/src/JwtBearerHandler.cs#L124-L128\r\n\r\n### Describe the solution you\u0027d like\r\nFrom my point of view, upon encountering a \u0060SecurityTokenSignatureKeyNotFoundException\u0060, the signing keys should be refreshed immediately and signature validation should be attempted again with the refreshed keys, all within that same request lifetime. However, I suspect that the reason that this is not done is deliberate - as mentioned in https://github.com/dotnet/aspnetcore/issues/26504#issuecomment-702364883:\r\n\r\n\u003E This is about a request using a consistent configuration for all stages. We wouldn\u0027t want the config to change part way through or you could get inconsistent results.\r\n\r\nBut this actually results in incorrect 401 responses - the user should in fact be authenticated, and the system fails to authenticate the user purely due to some technical constraints that causes the authentication to be based on stale data. In a distributed system, this may result in a spike in 401 responses across the system when key rollover occurs - certainly a less than ideal situation.\r\n",
    "upvotes": 6,
    "labels": [
      "Needs: Design",
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1MzE0ODQ0MA==",
        "parentId": null,
        "author": "blowdart",
        "content": "If we tried to refresh whenever a key was not found it would be a denial of service waiting to happen - an attacker could send multiple requests with a new, bogus signing key in each request, and then the web server would block trying to refresh the metadata to see if the key has rolled over. This obviously isn\u0027t acceptable from a security, or indeed a performance point of view.\r\n\r\nBest practice for key rollover is for the issuing server to start serving the new key in the metadata before it rolls over to give systems time to refresh, and to also publish the expired key for a little while after the roll over has happened to enable validation of tokens which have not expired and were signed with the older key. JWKS specifically supports this. ",
        "createdAt": "2020-12-31T21:00:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28948#issuecomment-753148440"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1MzQ0NzA0OA==",
        "parentId": null,
        "author": "scharnyw",
        "content": "@blowdart Thanks a lot for the explanation. While I agree that \r\n\r\n\u003E Best practice for key rollover is for the issuing server to start serving the new key in the metadata before it rolls over to give systems time to refresh\r\n\r\nthis often has problems in practice:\r\n\r\n1. The issuing server is not obliged to do this. It is by no means mandated by the spec and the issuing server is typically outside the control of application developers.\r\n2. It still requires that the duration the issuing server pre-serves the new keys (duration in which the new keys are published in metadata, but no token signed with the new key is issued) should be longer than the \u0060AutomaticRefreshInterval\u0060 of \u0060ConfigurationManager\u0060. Only then will it be guaranteed that the new keys can reach the local cache of all applications before tokens signed with the new keys are issued and used. The duration that issuing server pre-serves new keys (and also the rollover frequency) are often neither predictable nor made known to consumers.\r\n\r\nSince \u0060ConfigurationManager\u0060 already enforces some minimum time span (default is 30s) that must elapse before configurations can be refreshed, would it be sufficient in most cases to protect against DoS? If so, I imagine the ability to refresh configuration upon key-not-found could be an explicit opt-in that consumers can choose if they understand the risks involved?",
        "createdAt": "2021-01-02T08:25:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28948#issuecomment-753447048"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1NDQ3OTgxMw==",
        "parentId": null,
        "author": "wangyingmm",
        "content": "\u003E If we tried to refresh whenever a key was not found it would be a denial of service waiting to happen - an attacker could send multiple requests with a new, bogus signing key in each request, and then the web server would block trying to refresh the metadata to see if the key has rolled over. This obviously isn\u0027t acceptable from a security, or indeed a performance point of view.\r\n\r\n@blowdart Looking at the code for JwtBearerHandler below, if an attacker sent multiple requests with a new, bogus signing key in each request, Options.ConfigurationManager.RequestRefresh() is called each time anyway. it just doesn\u0027t do validation after refresh. if calling RequestRefresh() could lead to a DoS, it still happens.\r\n\r\n\u0060try\r\n                        {\r\n                            principal = validator.ValidateToken(token, validationParameters, out validatedToken);\r\n                        }\r\n                        catch (Exception ex)\r\n                        {\r\n                            Logger.TokenValidationFailed(ex);\r\n\r\n                            // Refresh the configuration for exceptions that may be caused by key rollovers. The user can also request a refresh in the event.\r\n                            if (Options.RefreshOnIssuerKeyNotFound \u0026\u0026 Options.ConfigurationManager != null\r\n                                \u0026\u0026 ex is SecurityTokenSignatureKeyNotFoundException)\r\n                            {\r\n                                Options.ConfigurationManager.RequestRefresh();\r\n                            }\r\n\r\n                            if (validationFailures == null)\r\n                            {\r\n                                validationFailures = new List\u003CException\u003E(1);\r\n                            }\r\n                            validationFailures.Add(ex);\r\n                            continue;\r\n                        }\u0060",
        "createdAt": "2021-01-05T08:14:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28948#issuecomment-754479813"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1NjQxODA4OA==",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\nWe\u0027re moving this issue to the \u0060Next sprint planning\u0060 milestone for future evaluation / consideration. We will evaluate the request when we are planning the work for the next milestone. To learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-01-07T22:09:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28948#issuecomment-756418088"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1NjQxODY3Mw==",
        "parentId": null,
        "author": "blowdart",
        "content": "OK, we\u0027re going to have a think about this. There are interesting edge cases around having two jwt middlewares, and the majority of the metadata pieces are owned by an external team. \r\n\r\nUnfortunately right now there\u0027s no mitigation for you, this will be a redesign of how the JWT middleware works ",
        "createdAt": "2021-01-07T22:10:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28948#issuecomment-756418673"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1NjQ5NTUzOA==",
        "parentId": null,
        "author": "scharnyw",
        "content": "@blowdart  Thanks for the update. For now, we will just set \u0060AutomaticRefreshInterval\u0060 to a sufficiently low value to mitigate this issue.",
        "createdAt": "2021-01-08T01:49:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28948#issuecomment-756495538"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1NjUwOTc2NA==",
        "parentId": null,
        "author": "blowdart",
        "content": "We\u0027ll start brainstorming soon and keep the thread updated.",
        "createdAt": "2021-01-08T02:40:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28948#issuecomment-756509764"
      },
      {
        "id": "IC_kwDOAQzde840wfu_",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-07-22T18:11:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28948#issuecomment-885128127"
      },
      {
        "id": "IC_kwDOAQzde85Aa9lD",
        "parentId": null,
        "author": "Xriuk",
        "content": "No updates on this?\r\nI came across this issue too, I have 2 JwtBearers, each with it\u0027s own settings, I use one for regular tokens, and the other one for refresh tokens, if I try to authenticate with the regular token and it\u0027s expired I get a 401, so I try to authenticate with the refresh token and it gives me a 401 too (but the token is not expired), with the error \u0022The signature key was not found\u0022, which is caused by the exception mentioned here.\r\nSetting the \u0060AutomaticRefreshInterval\u0060 configuration to a millisecond or so solves the issue...",
        "createdAt": "2022-03-28T15:39:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28948#issuecomment-1080809795"
      },
      {
        "id": "IC_kwDOAQzde85YEKZ5",
        "parentId": null,
        "author": "RobinVangampelaere",
        "content": "Any updates on this problem? Still having the same issue and setting the \u0060AutomaticRefreshInterval\u0060 configuration to a millisecond is not a healthy solution for our infrastructure.",
        "createdAt": "2023-03-21T09:07:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28948#issuecomment-1477486201"
      },
      {
        "id": "IC_kwDOAQzde85s_KcM",
        "parentId": null,
        "author": "mariogit08",
        "content": "In fact it is refreshing the key after a key rollover happens. It just take longer if the JWKS change more the once in a short amount of time.",
        "createdAt": "2023-11-27T19:48:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28948#issuecomment-1828497164"
      },
      {
        "id": "IC_kwDOAQzde850scOh",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "IsOptions.RefreshOnIssuerKeyNotFound set to true?",
        "createdAt": "2024-02-21T20:02:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28948#issuecomment-1957807009"
      },
      {
        "id": "IC_kwDOAQzde850sc95",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@Xriuk setting refresh interval to a millisec is as @RobinVangampelaere mentioned open you up to a large number of http requests.",
        "createdAt": "2024-02-21T20:03:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28948#issuecomment-1957810041"
      },
      {
        "id": "IC_kwDOAQzde85_MCOE",
        "parentId": null,
        "author": "sevensolutions",
        "content": "Any update here in 2024?\r\nI\u0027am facing the same problem using the OIDC middleware.",
        "createdAt": "2024-05-27T17:26:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28948#issuecomment-2133861252"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU4NjIxNjgyMDM=",
    "title": "[FR] [Kerberos] [Linux] Add SID Claims under Linux when using kerberos auth.",
    "url": "https://github.com/dotnet/aspnetcore/issues/31959",
    "createdAt": "2021-04-20T00:20:47Z",
    "lastUpdated": "2021-07-14T23:11:18Z",
    "body": "ActiveDirectory (Windows) specific claims should be added when using Negotiate Kerberos auth under Linux implementation.\r\n\u0060\u0060\u0060\r\nprimarysid\r\nprimarygroupsid\r\ngroupsid\r\ndenyonlysid\r\n\u0060\u0060\u0060\r\n\r\nUnder Linux, claims described above are currently received using LDAP. \r\nKerberos has mechanisms to avoid any additional queries to get group SIDs and user SIDs.\r\nHowever, currently under Linux the only claim receivced without using LDAP is \u0060name\u0060 claim.\r\n",
    "upvotes": 1,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgyOTU5NzEzMA==",
        "parentId": null,
        "author": "blowdart",
        "content": "Linking these two together for Jun to investigate https://github.com/dotnet/aspnetcore/issues/32037",
        "createdAt": "2021-04-29T21:07:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/31959#issuecomment-829597130"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgyOTU5NzI5MA==",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060Next sprint planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-04-29T21:08:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/31959#issuecomment-829597290"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgzMjE0OTMyNQ==",
        "parentId": null,
        "author": "gozhang2",
        "content": "\u002B1 on this request, I am using the Negotiate library in a linux setup as well but by default there is only the \u0060name\u0060 claim available, we have to make additional LDAP query to get the \u0060primarysid\u0060 claim. \r\n\r\nBTW can you please share how the \u0060name\u0060 claim is formed? Based on my experiment it is \u0060\u003CsAMAccountName\u003E@\u003Cdomain\u003E\u0060, is this correct? \r\n\r\nYour help is much appreciated!",
        "createdAt": "2021-05-04T18:23:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/31959#issuecomment-832149325"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgzMzkyNjUxNQ==",
        "parentId": null,
        "author": "JunTaoLuo",
        "content": "Yes that is the format we expect for \u0060name\u0060.",
        "createdAt": "2021-05-06T22:51:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/31959#issuecomment-833926515"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg4MDI2OTA1MQ==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-07-14T23:11:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/31959#issuecomment-880269051"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU4NjQzMTg5ODY=",
    "title": "Negotiate\\LdapAdapter.cs should query only for required LDAP attributes instead of all available.",
    "url": "https://github.com/dotnet/aspnetcore/issues/32037",
    "createdAt": "2021-04-21T21:29:07Z",
    "lastUpdated": "2021-07-14T23:10:06Z",
    "body": "### Describe the bug\r\nIn internal class \u0060Microsoft.AspNetCore.Authentication.Negotiate.LdapAdapter\u0060, \u0060SearchRequest\u0060s are constructed using \u0060attributeList: null\u0060, which means _query for all available attributes_. \r\n\r\n\u0060LdapAdapter\u0060 should query only for attributes it requires (\u0060memberOf\u0060 and, possibly, \u0060distinguishedName\u0060).\r\n\r\n",
    "upvotes": 0,
    "labels": [
      "Needs: Design",
      "enhancement",
      "area-auth"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgyOTU5NTkxNA==",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060Next sprint planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-04-29T21:05:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32037#issuecomment-829595914"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg4MDI2ODU0NA==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-07-14T23:09:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32037#issuecomment-880268544"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU4OTI0NzY3NjI=",
    "title": "Better \u0022how to run samples\u0022 instructions needed for Authentication samples",
    "url": "https://github.com/dotnet/aspnetcore/issues/32734",
    "createdAt": "2021-05-15T13:02:11Z",
    "lastUpdated": "2023-10-28T14:08:36Z",
    "body": "Instructions on how to run the samples are very sparse, and after trying a few things I never could. I had cloned the entire aspnetcore repo and tried to run and example from src\\Security\\samples:\r\n\u0060dotnet run --project DynamicSchemes\u0060\r\n\r\nthat build failed due to missing nuget packages. had to\r\n\u0060dotnet restore ..\\..\\eng\\tools\\RepoTasks\u0060\r\n\r\nNow build just fails\r\n\u0060C:\\Program Files\\dotnet\\sdk\\5.0.202\\Microsoft.Common.CurrentVersion.targets(4919,5): error MSB3030: Could not copy the file \u0022C:\\Development\\aspnetcore\\artifacts\\bin\\InProcessRequestHandler\\Win32\\Debug\\aspnetcorev2_inprocess.dll\u0022 because it was not found. [C:\\Development\\aspnetcore\\src\\Servers\\IIS\\IIS\\src\\Microsoft.AspNetCore.Server.IIS.csproj]\r\n\u0060\r\n---\r\n#### Document Details\r\n\r\n\u26A0 *Do not edit this section. It is required for docs.microsoft.com \u279F GitHub issue linking.*\r\n\r\n* ID: 82950389-524e-0754-a125-addeccbdb1b3\r\n* Version Independent ID: 80b7f7cf-dc2e-137a-5aa7-fa88da63ac80\r\n* Content: [Authentication samples for ASP.NET Core](https://docs.microsoft.com/en-us/aspnet/core/security/authentication/samples?view=aspnetcore-5.0)\r\n* Content Source: [aspnetcore/security/authentication/samples.md](https://github.com/dotnet/AspNetCore.Docs/blob/main/aspnetcore/security/authentication/samples.md)\r\n* Product: **aspnet-core**\r\n* Technology: **aspnetcore-security**\r\n* GitHub Login: @Rick-Anderson\r\n* Microsoft Alias: **riande**",
    "upvotes": 0,
    "labels": [
      "area-auth",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0NTQzOTAzOA==",
        "parentId": null,
        "author": "blowdart",
        "content": "I don\u0027t believe that issue is specific to our samples, rather engineering all up. @Tratcher whose responsibility would this be?",
        "createdAt": "2021-05-20T20:02:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32734#issuecomment-845439038"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0NTUyNjc1NQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "We have these two:\r\n- https://github.com/dotnet/aspnetcore/blob/main/src/Security/README.md\r\n- https://github.com/dotnet/aspnetcore/blob/main/docs/BuildFromSource.md\r\n\r\nWe could either add another readme to the samples folder, or at least update the base Security readme to include running the samples.\r\n\r\nThat said, the instructions in https://docs.microsoft.com/en-us/aspnet/core/security/authentication/samples are misleading, you can\u0027t just dotnet run projects in our repo. For prior versions it would be easier for people to copy the samples out of the repo and remove the \u0060Reference\u0060\u0027s.\r\nhttps://github.com/dotnet/aspnetcore/blob/e897454413fe2103a5b3fdbaacd40472e1cabfd7/src/Security/samples/Cookies/Cookies.csproj#L8-L13\r\n",
        "createdAt": "2021-05-20T22:38:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32734#issuecomment-845526755"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg1NDE3ODg4MA==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-06-03T21:04:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32734#issuecomment-854178880"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU5NDg5Nzc0MTI=",
    "title": "[Spec] WebApi Project Template Add the ability to generate boiler plate code for authorization and Bearer Token ",
    "url": "https://github.com/dotnet/aspnetcore/issues/34560",
    "createdAt": "2021-07-17T09:51:16Z",
    "lastUpdated": "2023-10-19T21:56:47Z",
    "body": "Most apis cannot do without this day and age but to add a Bearer token and swagger documentation to the structure of their web api.\r\n\r\nI think an option to be added to the new project screen for webapi. It seems very mundan code having to recreate it each time in a web api project and would create more continuity for the api to be standard.\r\n\r\n***b*File New WIndowb***\r\nProject Type: Web Api\r\n\r\nCheckbox for Swagger Docs\r\nCheckbox for  Bearer  Tokens\r\n\r\nUpon chosen this option the system should be smart enough to add the code to our header calls for httpclient\r\n\r\nIt should add the following code as default to the configure section.\r\n \r\n      services.AddSwaggerGen(c =\u003E {\r\n                c.SwaggerDoc(\u0022v1\u0022, new OpenApiInfo { Title = \u0022Cella Crm\u0022, Version = \u0022v1\u0022 });\r\n                //   c.ResolveConflictingActions(apiDescriptions =\u003E apiDescriptions.First());\r\n                //Expose XML comments in doc.\r\n                c.AddSecurityDefinition(\u0022Bearer\u0022, new OpenApiSecurityScheme\r\n                {\r\n                    Description =\r\n                        \u0022JWT Authorization header using the Bearer scheme. \\r\\n\\r\\n Enter \u0027Bearer\u0027 [space] and then your token in the text input below.\\r\\n\\r\\nExample: \\\u0022Bearer 12345abcdef\\\u0022\u0022,\r\n                    Name = \u0022Authorization\u0022,\r\n                    In = ParameterLocation.Header,\r\n                    Type = SecuritySchemeType.ApiKey,\r\n                    Scheme = \u0022Bearer\u0022\r\n                });\r\n                c.AddSecurityRequirement(new OpenApiSecurityRequirement\r\n                {\r\n                    {\r\n                        new OpenApiSecurityScheme\r\n                        {\r\n                            Reference = new OpenApiReference\r\n                            {\r\n                                Type = ReferenceType.SecurityScheme,\r\n                                Id = \u0022Bearer\u0022\r\n                            },\r\n                            Scheme = \u0022oauth2\u0022,\r\n                            Name = \u0022Bearer\u0022,\r\n                            In = ParameterLocation.Header\r\n                        },\r\n                        new List\u003Cstring\u003E()\r\n                    }\r\n                });\r\n            });\r\n\r\n            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\r\n           .AddJwtBearer(options =\u003E {\r\n            options.TokenValidationParameters = new TokenValidationParameters\r\n            {\r\n                ValidateIssuerSigningKey = true,\r\n                IssuerSigningKey = new SymmetricSecurityKey(Encoding.ASCII.GetBytes(Configuration.GetSection(Constants.ApiSecretValue).Value)),\r\n                ValidateIssuer = false,\r\n                ValidateAudience = false\r\n            };\r\n        });\r\n\r\nAlso as I am implementing swagger we should configure it as well in the configure section.\r\n\r\n           if (env.IsDevelopment())\r\n            {\r\n                app.UseDeveloperExceptionPage();\r\n                app.UseSwagger();\r\n            }\r\nI understand that Microsoft are re doing web apis at present maybe this could all be replaced with a simple call.\r\n \r\n  webpi-\u003EsetupbarrerToken() ",
    "upvotes": 0,
    "labels": [
      "area-auth",
      "Tooling",
      "feature-templates"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde840wfpo",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-07-22T18:10:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34560#issuecomment-885127784"
      },
      {
        "id": "IC_kwDOAQzde85pmu7p",
        "parentId": null,
        "author": "davidbuckleyni",
        "content": "thus seems to be covered by what @davidfowl did for blazor ",
        "createdAt": "2023-10-19T21:56:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34560#issuecomment-1771761385"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU5NTEyNjc1MzE=",
    "title": "Making HttpContext.User available to 3rd party code without Microsoft.AspNetCore.Http dependency",
    "url": "https://github.com/dotnet/aspnetcore/issues/34636",
    "createdAt": "2021-07-23T05:38:21Z",
    "lastUpdated": "2023-02-19T17:55:22Z",
    "body": "## Background and Motivation\r\n\r\nOn AspNetCore, when you need to access the \u0060HttpContext\u0060 in a \u0022service\u0022 class, you use an \u0060IHttpContextAccessor\u0060 to get the thread-safe instance of the \u0060HttpContext\u0060 used by the current thread, thanks to its internal use of \u0060AsyncLocal\u0060.\r\n\r\nHowever, if you need to be able to access the \u0060HttpContext.User\u0060, AND the service class is in another assembly, you can no longer rely on \u0060ClaimsPrincipal.Current\u0060 or \u0060Thread.CurrentPrincipal\u0060 to get you that information. If you control the external assembly, you\u0027re now dependent on \u0060Microsoft.AspNetCore.Http\u0060 in all of your libraries, which is unnecessary.\r\n\r\n## Proposed API\r\n\r\nThe proposal is a stand-alone class that does not affect the behavior or functionality of any existing APIs, which should make it quick to approve and get into the current release, even given the current timeframe for .NET 6\u0027s release.\r\n\r\nThe solution is to implement an identical pattern to \u0060IHttpContextAccessor\u0060 for \u0060IPrincipal\u0060. This will require an Interface to be added to \u0060System.Security\u0060, and an \u0060HttpContextPrincipalAccessor\u0060 in \u0060Microsoft.AspNetCore.Http\u0060.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.AspNetCore.Authentication\r\n{\r\n    public class AuthenticationOptions\r\n    {\r\n\u002B       bool EnableThreadCurrentPrincipal { get; set; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\nBecause the shipped implementation takes an \u0060IHttpContextAccessor\u0060 in the constructor, it will pull in the thread\u0027s \u0060HttpContext\u0060 to correctly pull the user from.\r\n\r\n## Usage Examples\r\n\r\n\u0060\u0060\u0060 C#\r\npublic class Startup\r\n{\r\n    public void ConfigureServices(IServiceCollection services)\r\n    {\r\n        services\r\n            .AddAuthentication(options =\u003E \r\n             {\r\n                  options.EnableThreadCurrentPrincipal = true;\r\n                  options.DefaultScheme = \u0022Cookies\u0022;\r\n             });\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n## Alternative Designs\r\n\r\n- I considered making everything a \u0060ClaimsPrincipal\u0060, as that is the proper way to do things, but I considered that it could be a \u0060WindowsPrincipal\u0060 instead, so \u0060IPrincipal\u0060 is probably a better approach.\r\n- The implementation would probably do a \u0060TryAddService()\u0060 on \u0060IHttpContextAccessor\u0060, just in case the user forgot to add one.\r\n\r\n## Risks\r\n\r\n- AFAIK there are no risks to the added API itself, just the timing.\r\n- The \u0060IPrincipalAccessor\u0060 API would need to get in the .NET Core Libraries, which risks the team not wanting to add it at this stage of the game.\r\n- The AspNetCore team may decide not to add the \u0060HttpContextPrincipalAccessor\u0060 at this stage of the game, even if the .NET Core team is cool with it.\r\n\r\nI have the requisite pull requests ready to submit if the team is OK with this.",
    "upvotes": 1,
    "labels": [
      "area-auth",
      "api-suggestion"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde840xlRX",
        "parentId": null,
        "author": "robertmclaws",
        "content": "@davidfowl @terrajobst think this might be possible to get into .NET 6.0? [We used the pattern on Restier and it worked quite well](https://github.com/OData/RESTier/blob/breakdance-net5/src/Microsoft.Restier.AspNetCore/ClaimsPrincipalAccessor.cs).",
        "createdAt": "2021-07-23T05:41:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885412951"
      },
      {
        "id": "IC_kwDOAQzde840xwOx",
        "parentId": null,
        "author": "davidfowl",
        "content": "A couple of things:\r\n- I don\u0027t think IPrincipalAccessor belongs in ASP.NET Core, there should be an [API proposal in .NET](https://github.com/dotnet/runtime) to add it and I\u0027m not 100% sure it\u0027s something that fits into the BCL.\r\n- Existing alternatives are \u0060Thread.CurrentPrincipal\u0060 and \u0060ClaimsPrincipal.ClaimsPrincipalSelector\u0060. \r\n  - Maybe there could be a way to opt-into setting \u0060Thread.CurrentPrincipal\u0060 in the auth middleware. This is something we refused to do before but maybe it could be opt in and it would give you an agnostic way to \u0060ClaimsPrincipal.Current\u0060. It would still be someone\u0027s job to wrap it in an interface so it\u0027s mockable I guess but I\u0027m not sure where that should live.\r\n- What other tech would set the current principal besides unit tests? Is this interface solely for testing or do you have other technology that isn\u0027t tied to ASP.NET Core that needs to provide an implementation for the interface?",
        "createdAt": "2021-07-23T07:38:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885457841"
      },
      {
        "id": "IC_kwDOAQzde840y_As",
        "parentId": null,
        "author": "terrajobst",
        "content": "\u003E * I don\u0027t think IPrincipalAccessor belongs in ASP.NET Core, there should be an [API proposal in .NET](https://github.com/dotnet/runtime) to add it and I\u0027m not 100% sure it\u0027s something that fits into the BCL.\r\n\r\nMaybe, maybe not. It\u0027s similar to \u0060ISystemClock\u0060 in the sense that it doesn\u0027t really provide any additional capabilities but allows higher-level DI concepts to use them as exchange types. Considering the interface is very simple, I\u0027m not opposed to it, so long we ship a sensible implementation too (and the implementation could reside at a higher layer, such as \u0060Microsoft.Extensions\u0060 or ASP.NET Core).\r\n\r\n/cc @bartonjs ",
        "createdAt": "2021-07-23T17:11:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885780524"
      },
      {
        "id": "IC_kwDOAQzde840zDfh",
        "parentId": null,
        "author": "bartonjs",
        "content": "My general stance, in Mr. Garrison\u0027s voice, is \u0022interfaces are bad, mmkay?\u0022, because of their lack of evolvability. (I\u0027m also pretty firmly in the camp that if you can\u0027t come up with a reasonable name ending in \u0022-able\u0022 (or \u0022-ible\u0022 for linguistic reasons) then you don\u0027t have an interface, you have an abstract class.)\r\n\r\nLike \u0060ISystemClock\u0060, I don\u0027t think it makes sense for the BCL... things in the BCL that need the current principal (which, ideally, would be 0) are going to use Thread.CurrentPrincipal, because the proposal really only makes sense for a DI environment, and the BCL doesn\u0027t have one.  (My recollection was that our end belief was that something like \u0060ISystemClock\u0060 should be defined along with the DI system, so it\u0027d be in Microsoft.Extensions somewhere)\r\n\r\nDespite the name saying \u0022Thread\u0022, \u0060Thread.CurrentPrincipal\u0060 is backed by an async local (https://source.dot.net/#System.Private.CoreLib/Thread.cs,af38dde3f1bd6b93), so my personal preference would be to take @davidfowl\u0027s \u0022maybe\u0022 approach (\u0022Maybe there could be a way to opt-into setting Thread.CurrentPrincipal in the auth middleware.\u0022)",
        "createdAt": "2021-07-23T17:45:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885798881"
      },
      {
        "id": "IC_kwDOAQzde840zWk1",
        "parentId": null,
        "author": "robertmclaws",
        "content": "Thanks for weighing in on this everyone! Totally agree with @bartonjs, I\u0027m usually vehemently against interfaces. I\u0027m glad there is some consensus on setting \u0060ThreadPrincipal.Current\u0060, because that\u0027s [exactly what I\u0027m doing in Restier](https://github.com/OData/RESTier/blob/breakdance-net5/src/Microsoft.Restier.AspNetCore/RestierController.cs#L694-L701), and I was worried it was the wrong approach.\r\n\r\nI avoided doing that this proposal because I assumed it was going to be some sort of SecureString-esque third rail for the team, but setting it directly in the Authorization pipeline instead of this pattern would be a *much* better approach.\r\n\r\n@davidfowl to answer your question, we use it for a lot more than just unit tests. Up until now Restier only ran on .NET Framework, and BurnRate\u0027s business logic was in a separate assembly leveraging \u0060ClaimsPrincipal.Current\u0060 for filtering data based on claims. When we migrated BurnRate to .NET Core via Restier\u0027s new AspNetCore version, the business logic was failing due to \u0060ClaimsPrincipal.Current\u0060 not being set. \r\n\r\nI searched for a solution but didn\u0027t find any, so I came up with this pattern to try to match what you were doing with \u0060HttpContextAccessor\u0060, and maintained compatibility by setting \u0060ClaimsPrincipal.ClaimsPrincipalSelector\u0060 in Restier\u0027s pipeline.\r\n\r\n### Alternate Solution\r\nSo would we add a line under [this one in AuthenticationMiddleware.cs](https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Core/src/AuthenticationMiddleware.cs#L73) that said \u0060ClaimsPrincipal.ClaimsPrincipalSelector = () =\u003E context.User;\u0060?",
        "createdAt": "2021-07-23T19:48:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885877045"
      },
      {
        "id": "IC_kwDOAQzde840zXm-",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E So would we add a line under this one in AuthenticationMiddleware.cs that said ClaimsPrincipal.ClaimsPrincipalSelector = () =\u003E context.User;?\r\n\r\nNo, we would set \u0060Thread.CurrentPrincipal\u0060 there. ClaimsPrincipalSelector  uses \u0060Thread.CurrentPrincipal\u0060 by default. This would be opt in though via a flag somewhere. Probably \u0060AuthentictionOptions\u0060. Another reason for the option would be the performance hit for too many async locals. The performance degrades when there are  more than 3 of them. Today we have:\r\n\r\n- HttpContextAccessor\r\n- Activity.Current\r\n- The request logging scope\r\n- Now the auth middleware\r\n- Culture\r\n\r\nFor prior art here, we set the current culture (and UI culture) in the localization middleware by default without an option (https://github.com/dotnet/aspnetcore/blob/3eb0fa8abe62f9a937a78890762908159174ff91/src/Middleware/Localization/src/RequestLocalizationMiddleware.cs#L136-L140).\r\n\r\ncc @blowdart @Tratcher @HaoK for feedback.\r\n",
        "createdAt": "2021-07-23T19:56:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885881278"
      },
      {
        "id": "IC_kwDOAQzde840zavI",
        "parentId": null,
        "author": "HaoK",
        "content": "So to summarize the current proposal we add something like\r\n\r\n\u0060authenticationOptions.ShouldSetThreadCurrentPrincipalToo = true\u0060 // defaults to false (better name TBD)\r\n\r\nwhich would opt the middleware (and authorization logic whenever HttpContext.User is set) to also update Thread.CurrentPrincipal at the same time.\r\n\r\nSounds reasonable to me!",
        "createdAt": "2021-07-23T20:21:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885894088"
      },
      {
        "id": "IC_kwDOAQzde840zbim",
        "parentId": null,
        "author": "Tratcher",
        "content": "How likely is that Identity instance to leak onto background threads and outlive the request? For WindowsIdentity specifically we dispose it at the end of each request, so if it had leaked to a background thread you\u0027d get ODEs.",
        "createdAt": "2021-07-23T20:28:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885897382"
      },
      {
        "id": "IC_kwDOAQzde840zceD",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E * I considered making everything a \u0060ClaimsPrincipal\u0060, as that is the proper way to do things, but I considered that it could be a \u0060WindowsPrincipal\u0060 instead, so \u0060IPrincipal\u0060 is probably a better approach.\r\n\r\nWindowsPrincipal already derives from ClaimsPrincipal.\r\n\r\nWould Thread.CurrentPrincipal get reverted when the middleware exited?",
        "createdAt": "2021-07-23T20:37:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885901187"
      },
      {
        "id": "IC_kwDOAQzde840zeHR",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E authenticationOptions.ShouldSetThreadCurrentPrincipalToo = true // defaults to false (better name TBD)\r\n\r\nBut with a less bad name.\r\n\r\n\u003E How likely is that Identity instance to leak onto background threads and outlive the request? For WindowsIdentity specifically we dispose it at the end of each request, so if it had leaked to a background thread you\u0027d get ODEs.\r\n\r\nYou know the answer to this question \uD83D\uDE04.\r\n\r\n\u003E Would Thread.CurrentPrincipal get reverted when the middleware exited?\r\n\r\nIt doesn\u0027t need to, async methods revert the execution context.",
        "createdAt": "2021-07-23T20:52:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885907921"
      },
      {
        "id": "IC_kwDOAQzde840zhf-",
        "parentId": null,
        "author": "davidfowl",
        "content": "I updated the API proposal.",
        "createdAt": "2021-07-23T21:24:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885921790"
      },
      {
        "id": "IC_kwDOAQzde840zhsv",
        "parentId": null,
        "author": "blowdart",
        "content": "We worked very hard to avoid using Thread.CurrentPrincipal or indeed *.Current* in Core, because of threading and potential async issues, and required library owners to take a principal as a parameter. \r\n\r\nIt seems like a massive step back to return to that way of doing things.",
        "createdAt": "2021-07-23T21:26:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885922607"
      },
      {
        "id": "IC_kwDOAQzde840ziCx",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E We worked very hard to avoid using Thread.CurrentPrincipal or indeed .Current in Core, because of threading and potential async issues, and required library owners to take a principal as a parameter.\r\n\r\n\u003E It seems like a massive step back to return to that way of doing things.\r\n\r\nThat\u0027s why it\u0027s opt in.\r\n\r\nI should mention, the alternative is for us to do nothing and for customers to set the claims principal selector like so:\r\n\r\n\u0060\u0060\u0060C#\r\npublic class Program\r\n{\r\n    public static void Main(string[] args)\r\n    {\r\n        // This only works because we use a static async local as the backing field.\r\n        var contextAccessor = new HttpContextAccessor();\r\n        ClaimsPrincipal.ClaimsPrincipalSelector = () =\u003E contextAccessor.HttpContext.User;\r\n\r\n        CreateHostBuilder(args).Build().Run();\r\n    }\r\n\r\n    public static IHostBuilder CreateHostBuilder(string[] args) =\u003E\r\n        Host.CreateDefaultBuilder(args)\r\n            .ConfigureWebHostDefaults(webBuilder =\u003E\r\n            {\r\n                webBuilder.UseStartup\u003CStartup\u003E();\r\n            });\r\n}\r\n\r\n\r\npublic class Startup\r\n{\r\n    public void ConfigureServices(IServiceCollection services)\r\n    {\r\n        services.AddHttpContextAccessor();        \r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThe above approach will avoid another async local and will let users opt into this behavior in a more explicit way. We could document this approach.\r\n\r\nThe other approach is to have users set Thread.CurrentPrincipal in middleware themselves:\r\n\r\n\u0060\u0060\u0060C#\r\napp.UseAuthentication();\r\n\r\napp.Use(async (context, next) =\u003E \r\n{\r\n    Thread.CurrentPrincipal = context.User;\r\n    await next(context);\r\n});\r\n\r\napp.UseAuthorization();\r\n\u0060\u0060\u0060\r\n\r\nThis is something you can do today without an added feature.",
        "createdAt": "2021-07-23T21:30:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885924017"
      },
      {
        "id": "IC_kwDOAQzde840zi4g",
        "parentId": null,
        "author": "blowdart",
        "content": "Yea, if it can be done already I\u0027m rather dead set against backing anything based on .Current_Anything_ into asp.net, or worse corefx. It had reliability issues before and I\u0027m not convinced it\u0027d be problematic again.",
        "createdAt": "2021-07-23T21:39:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885927456"
      },
      {
        "id": "IC_kwDOAQzde840zjry",
        "parentId": null,
        "author": "davidfowl",
        "content": "@robertmclaws Can you try those solutions and let us know if it works out? As @blowdart says, we try really really hard to avoid doing this by default especially in the box.",
        "createdAt": "2021-07-23T21:48:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885930738"
      },
      {
        "id": "IC_kwDOAQzde840zjvz",
        "parentId": null,
        "author": "robertmclaws",
        "content": "I\u0027m all about having a way to do it in the framework vs having to look something up.\r\n\r\nThe challenge @blowdart for situations like Restier (where the class processing the \u0060HttpRequest\u0060 is 100% decoupled from *any* concept of HTTP) is that passing the \u0060HttpContext.User\u0060 as a parameter up the chain would require every method to take a \u0060ClaimsPrincipal\u0060, even those that don\u0027t use them. \r\n\r\nThat\u0027s why my original approach was basically to be able to pull it out of DI if you need it, the same as an \u0060IHttpContextAccessor\u0060.\r\n\r\nAnother alternative could be to wrap @davidfowl\u0027s first suggestion from his previous post into a clean extension method:\r\n\u0060\u0060\u0060C#\r\npublic static class HttpServiceCollectionExtensions\r\n{\r\n    public static IServiceCollection AddClaimsPrincipal(this IServiceCollection services)\r\n    {\r\n        services.AddHttpContextAccessor();        \r\n\r\n        // This only works because we use a static async local as the backing field.\r\n        var contextAccessor = new HttpContextAccessor();\r\n        ClaimsPrincipal.ClaimsPrincipalSelector = () =\u003E contextAccessor.HttpContext.User;\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThe idea is not to \u0022bake\u0022 it into the pipeline, but to make it available if people need it. \r\n\r\nMy question would then be @blowdart, if \u0060HttpContextAccessor\u0060 and \u0060Thread.CurrentPrincipal\u0060 BOTH use \u0060AsyncLocal\u0060 internally... why is one OK and the other is not?",
        "createdAt": "2021-07-23T21:49:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885930995"
      },
      {
        "id": "IC_kwDOAQzde840zkRm",
        "parentId": null,
        "author": "robertmclaws",
        "content": "@davidfowl The point of the API Proposal was that I already have a solution that works. I can\u0027t be the only person in the same situation that can\u0027t get this any other way. So my original API proposal was NOT to set \u0060Thread.CurrentPrincipal\u0060, but to access the \u0060IPrincipal\u0060 from the injected \u0060HttpContextAccessor\u0060 instead, and pull out the \u0060IPrincipalAccessor\u0060 when you need it. That way, I don\u0027t need a dependency on \u0060Microsoft.AspNetCore.Http\u0060 in order to get the \u0060Principal\u0060 out of the container.",
        "createdAt": "2021-07-23T21:55:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885933158"
      },
      {
        "id": "IC_kwDOAQzde840zkSW",
        "parentId": null,
        "author": "blowdart",
        "content": "We had instances of other pieces of code setting the current principal after asp.net had, or doing strange things with it (the old ws-trust stuff) and if memory serves in asp.net core we moved everything to hang off the request because of this. \n\nMoving back I wouldn\u0027t be able to make guarantees around correctness without a lot of work (and it feels like hobbling aspnet and net6/7 with a legacy approach)",
        "createdAt": "2021-07-23T21:55:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885933206"
      },
      {
        "id": "IC_kwDOAQzde840zkqj",
        "parentId": null,
        "author": "robertmclaws",
        "content": "@blowdart fair enough. Do you have any other suggestions on how to get the HttpContext.User into the DI container so that it can be retrieved like any other service?",
        "createdAt": "2021-07-23T22:00:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885934755"
      },
      {
        "id": "IC_kwDOAQzde840zleq",
        "parentId": null,
        "author": "blowdart",
        "content": "I don\u0027t I\u0027m afraid, I defer that to @davidfowl, We\u0027ve never treated the current request identity as a discreet item at all, it\u0027s always been part of the request.",
        "createdAt": "2021-07-23T22:09:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885938090"
      },
      {
        "id": "IC_kwDOAQzde840z31A",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E @davidfowl The point of the API Proposal was that I already have a solution that works. I can\u0027t be the only person in the same situation that can\u0027t get this any other way. So my original API proposal was NOT to set Thread.CurrentPrincipal, but to access the IPrincipal from the injected HttpContextAccessor instead, and pull out the IPrincipalAccessor when you need it. That way, I don\u0027t need a dependency on Microsoft.AspNetCore.Http in order to get the Principal out of the container.\r\n\r\nYes but as the above conversation revealed, we don\u0027t have any plans to offer this interface. Because there are existing well known async locals that can be used instead that are already defined by the framework. Nothing in the framework needs to use an IPrincipalAccessor, this service is convenience for users that want to avoid the ASP.NET Core dependency (which is why it\u0027s strange trying to define it inside of ASP.NET Core). \r\n\r\nThis isn\u0027t about making stuff work per se, you can already add any service you\u0027d like to the DI container and any service can use it. This is about an \u0022official\u0022 exchange type for doing so. The solution I offered [above](https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-885924017) allow the same exchange types to work.\r\n\r\n\r\n\u003E Thanks for weighing in on this everyone! Totally agree with @bartonjs, I\u0027m usually vehemently against interfaces. I\u0027m glad there is some consensus on setting ThreadPrincipal.Current, because that\u0027s exactly what I\u0027m doing in Restier, and I was worried it was the wrong approach.\r\n\r\nThis solution is really bad because it\u0027s capturing the HttpContext in the static callback, permanently rooting that reference. It also doesn\u0027t work well if there are multiple hosts in the same process that might define their own \u0060ClaimsPrincipalSelector\u0060. That\u0027s why it really belongs in \u0060Program.cs\u0060 and why it shouldn\u0027t be an extension method on anything. This is code you wire up once, in the application entry point.\r\n\r\nThe middleware approach is much cleaner as it makes everything work even across hosts in a safer way without touching the ClaimsPrincipalSelector static. Then your \u0060IClaimsPrincipalAccessor\u0060 implementation just looks like this:\r\n\r\n\u0060\u0060\u0060C#\r\npublic interface IClaimsPrincipalAccessor \r\n{\r\n    ClaimsPrincipal ClaimsPrincipal { get; } \r\n}\r\n\r\npublic class ClaimsPrincipalAccessor : IClaimsPrincipalAccessor\r\n{\r\n    public ClaimsPrincipal ClaimsPrincipal =\u003E ClaimsPrincipal.Current;\r\n}\r\n\u0060\u0060\u0060\r\n",
        "createdAt": "2021-07-24T07:23:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-886013248"
      },
      {
        "id": "IC_kwDOAQzde8407WNn",
        "parentId": null,
        "author": "robertmclaws",
        "content": "@davidfowl you are right, with the middleware approach, the ClaimsPrincipalAccessor seems unnecessary.\r\n\r\nHow would you folks feel about shipping the middleware approach as an extension method in the framework?\r\n\r\n\u0060\u0060\u0060c#\r\n  public static IApplicationBuilder UseThreadPrincipals(this IApplicationBuilder app)\r\n  {\r\n      app.Use(async (context, next) =\u003E\r\n      {\r\n          Thread.CurrentPrincipal = context.User;\r\n          await next();\r\n      });\r\n      return app;\r\n  }\r\n\u0060\u0060\u0060\r\n\r\n@blowdart I know you\u0027re not a huge fan of baking it in, but honestly if it\u0027s this easy to do anyway, wouldn\u0027t you rather do it a simple and official way, rather having people like me invent sh!ttier and less performant ways to do it?",
        "createdAt": "2021-07-28T03:04:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-887972711"
      },
      {
        "id": "IC_kwDOAQzde8407Z0x",
        "parentId": null,
        "author": "davidfowl",
        "content": "So the options are:\r\n1. Do nothing in the framework and document this showing the 3 different approaches above:\r\n   - The middleware to set \u0060Thread.CurrentPrincipal\u0060\r\n   - Setting the \u0060ClaimsPrincipalSelector\u0060 in \u0060Program.Main\u0060.\r\n   - Using a custom interface like \u0060IClaimsPrincipalAccessor\u0060 and implementing an \u0060HttpContextClaimsPrincipalAccessor\u0060 that uses the \u0060IHttpContextAccessor\u0060.\r\n   - Manually passing around the ClaimsPrincipal.\r\n2. Make it an optional part of the AuthN middleware:\r\n   - We don\u0027t make the performance worse by default by adding another async local into the mix.\r\n   - The \u0060Thread.CurrentPrincipal\u0060 needs to be set *after* the AuthN middleware runs.\r\n   - Shared library code that works on the User can work between .NET Framework and .NET Core (I\u0027m dubious of this just working because most web based library code depends on \u0060HttpContext.Current\u0060).\r\n\r\nThe hardest thing about 2 is it feels a little like an endorsement of \u0060Thread.CurrentPrincipal\u0060 and \u0060ClaimsPrincipal.Current\u0060 when trying to access the current user from assemblies that don\u0027t want to reference ASP.NET Core. At least with the first approach it feels less like strict guidance and more like a smattering of options.",
        "createdAt": "2021-07-28T03:49:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-887987505"
      },
      {
        "id": "IC_kwDOAQzde841EXl8",
        "parentId": null,
        "author": "Kahbazi",
        "content": "\u003E Make it an optional part of the AuthN middleware:\r\n\r\n@davidfowl and also AuthZ middleware?",
        "createdAt": "2021-07-31T11:59:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-890337660"
      },
      {
        "id": "IC_kwDOAQzde841Ega4",
        "parentId": null,
        "author": "davidfowl",
        "content": "Why would it be part of the authz middleware?",
        "createdAt": "2021-07-31T16:45:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-890373816"
      },
      {
        "id": "IC_kwDOAQzde841Eg2u",
        "parentId": null,
        "author": "Kahbazi",
        "content": "\u003E Why would it be part of the authz middleware?\r\n\r\nIn our application we don\u0027t have a default authN scheme so we don\u0027t even use AuthN middleware. Each endpoint has one or multiple authN scheme which would be authenticated in AuthZ middleware and HttpContext.User would be filled here :\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/9fa3421e1302bce7dbc50269edbd3072907e7832/src/Security/Authorization/Policy/src/PolicyEvaluator.cs#L58",
        "createdAt": "2021-07-31T17:02:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-890375598"
      },
      {
        "id": "IC_kwDOAQzde841EhO_",
        "parentId": null,
        "author": "davidfowl",
        "content": "Tricky, you really want to set this outside of arbitrary components like this. In fact, maybe I\u0027d argue that we shouldn\u0027t be setting the context.User here and instead the middleware should be responsible for doing that.",
        "createdAt": "2021-07-31T17:12:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-890377151"
      },
      {
        "id": "IC_kwDOAQzde841Ehlm",
        "parentId": null,
        "author": "Kahbazi",
        "content": "\u003E In fact, maybe I\u0027d argue that we shouldn\u0027t be setting the context.User here and instead the middleware should be responsible for doing that.\r\n\r\nWhich middleware? AuthZ?",
        "createdAt": "2021-07-31T17:22:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-890378598"
      },
      {
        "id": "IC_kwDOAQzde841Ei0d",
        "parentId": null,
        "author": "HaoK",
        "content": "\u003E In fact, maybe I\u0027d argue that we shouldn\u0027t be setting the context.User here and instead the middleware should be responsible for doing that.\r\n\r\nYeah this always felt odd to me too, but we did this to keep the same behavior as what \u0060[Authorize]\u0060 always did",
        "createdAt": "2021-07-31T18:01:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-890383645"
      },
      {
        "id": "IC_kwDOAQzde841E1_D",
        "parentId": null,
        "author": "davidfowl",
        "content": "We should fix it and move the assignment to the callers",
        "createdAt": "2021-08-01T06:37:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-890462147"
      },
      {
        "id": "IC_kwDOAQzde841FAIx",
        "parentId": null,
        "author": "poke",
        "content": "Remembering how many issues we had in the past with the usage of \u0060IHttpContextAccessor\u0060 where users incorrectly used it all over places _because it was there_, I would also agree that we should hesitate to add another thing alike that for the current principal. If \u0060Thread.CurrentPrincipal\u0060 is backed by an async local, then this would include that.\r\n\r\nI\u2019m more than fine with adding a dedicated article in the documentation about how one could possibly approach this. Seeing the different ideas in this issue which often just span a few lines to integrate makes it clear IMO that we don\u2019t need to expand ASP.NET Core by default and send the wrong message that it\u2019s okay to do this. Instead, people can just copy over the relevant pieces into their own code, making this behavior and the downsides (which should also be clearly documented) very explicit.\r\n\r\nAs for libraries like Restier that want to rely on this: Usually, these libraries will need some kind of integration package for ASP.NET Core anyway, so they could always add their own capabilities there. If you control the full library, switching to a custom interface to access the principal should be possible too. And if you really need, the library could provide a way to set up \u0060Thread.CurrentPrincipal\u0060 or similar.\r\n\r\nAs a framework, ASP.NET Core and .NET (Core) itself should make it clear that the static \u0060.Current\u0060s are meant to be legacy though. So I would agree that we should avoid advertising their usage here by providing quick opt-ins that will be seen as an invitation to enable it by default.",
        "createdAt": "2021-08-01T11:39:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-890503729"
      },
      {
        "id": "IC_kwDOAQzde841FAhG",
        "parentId": null,
        "author": "MattJeanes",
        "content": "Echoing my reply to @davidfowl\u0027s [Twitter post](https://twitter.com/davidfowl/status/1420228413923631112?s=19), our team uses an authentication workflow (in our case using attributes on controllers) which sets a custom user DTO in a scope-injected helper class which we can then access from within our libraries by injecting the helper and retrieving the user DTO again. The DTO contains things like the username/id, permissions and roles etc that we need in our application.\r\n\r\nThis works really well for us but the two problems I see with our approach however is primarily that it is our own class and wouldn\u0027t work within any public libraries from NuGet for example where adding a more generic class built into [ASP].NET Core might, and there is discovery problems with our approach in the sense of there isn\u0027t any documentation (that I\u0027ve come across at least) that tells you that this is an approach you can take to solve this problem.",
        "createdAt": "2021-08-01T11:50:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-890505286"
      },
      {
        "id": "IC_kwDOAQzde841FJcx",
        "parentId": null,
        "author": "robertmclaws",
        "content": "One pattern that I liked quite a bit from David\u0027s Twitter thread was this:\r\n\u0060\u0060\u0060c#\r\n...\r\n    services.AddHttpContextAccessor();\r\n    services.AddScoped(sp =\u003E sp.GetService\u003CIHttpContextAccessor\u003E().Context.User;\r\n...\r\n\u0060\u0060\u0060\r\n\r\nImplementing it means that *every* business logic service would have to be scoped so it could accept a \u0060ClaimsPrincipal\u0060 as a constructor parameter, but in in the cases where that is possible, it would be pretty clean and not require a direct HTTP dependency.\r\n\r\nFrom the compatibility standpoint of helping people from .NET Framework to .NET Core (which sometimes means having the same code, i.e. business logic, run on both for a while), \u0060Thread.CurrentPrincipal\u0060 funneling into \u0060ClaimsPrincipal.Current\u0060 is the most consistent solution, and should have a specific and documented way get wired in as easily as possible.. \r\n\r\nMoving away from \u0060Thread.CurrentPrincipal\u0060 may have seemed like a good idea at the time, but as David\u0027s Twitter thread showed, leaving people to their own devices just made the problem worse. If mutability and thread-safety were the issue, we now have tools we didn\u0027t back then. A combination of \u0060AsyncLocal\u0060 and refactoring \u0060Thread.CurrentPrincipal\u0060 to use C# Records *might* a safe and cross-device way of doing things.\r\n\r\nIf too many \u0060AsyncLocals\u0060 cause performance issues, then we could flip the script. If you think about it. an \u0060HttpContext\u0060 is essentially just a container for information passing down the current thread. Console and Windows apps don\u0027t typically have this problem because they do not usually have concurrent-but-different users executing at the same time. But sometimes batch job Console apps need to get tokens that impersonate users, and run different users on different threads.\r\n\r\nIf you push that concept down into the \u0060GenericHost\u0060, then an \u0060AsyncLocal\u0060-backed \u0060ThreadContext\u0060 could create that generic thread storage object, and \u0060HttpContext\u0060 could inherit from it to retrieve HTTP-specific things from that object. \u0060HttpContextAccessor\u0060 would be adjusted to use the THAT \u0060AsyncLocal\u0060 instead, and you get a consistent implementation across all of .NET with no change in performance.",
        "createdAt": "2021-08-01T15:42:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-890541873"
      },
      {
        "id": "IC_kwDOAQzde841FJ_k",
        "parentId": null,
        "author": "davidfowl",
        "content": "I\u0027m less worried about the async local performance for any other situation than the default. That\u0027s why it wouldn\u0027t be on by default. This problem exists for http context accessor, culture, windows principal, activity, logging scopes, thread current user. Removing one of those won\u0027t significantly change anything. ",
        "createdAt": "2021-08-01T15:58:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-890544100"
      },
      {
        "id": "IC_kwDOAQzde841FKJJ",
        "parentId": null,
        "author": "davidfowl",
        "content": "The other interesting thing about this is that the raw claims principal is usually fine if you\u0027re only reading it in a single place but the moment you need to transform claims, you want to store your own scoped service/async local with the projected data. ",
        "createdAt": "2021-08-01T16:02:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-890544713"
      },
      {
        "id": "IC_kwDOAQzde841FTmY",
        "parentId": null,
        "author": "robertmclaws",
        "content": "The architecture we use at BurnRate stores the UserId in Auth0\u0027s user metadata, so it comes over the wire in the signed JWT, and you don\u0027t have to do DB lookups to get it. We transform Claims in the JWT middleware process, so the \u0060ClaimsPrincipal\u0060 that comes out the other side of the built-in middleware has everything it needs. That usually just entails splitting a comma-separated list of roles into individual Role claims.",
        "createdAt": "2021-08-01T20:40:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-890583448"
      },
      {
        "id": "IC_kwDOAQzde841FTzI",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E That usually just entails splitting a comma-separated list of roles into individual Role claims.\r\n\r\nDo you parse then every time you want to consume it? Where do you store the preprocessed claims?",
        "createdAt": "2021-08-01T20:48:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-890584264"
      },
      {
        "id": "IC_kwDOAQzde841IRQw",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E \u0060\u0060\u0060cs\r\n\u003E ...\r\n\u003E     services.AddHttpContextAccessor();\r\n\u003E     services.AddScoped(sp =\u003E sp.GetService\u003CIHttpContextAccessor\u003E().Context.User;\r\n\u003E ...\r\n\u003E \u0060\u0060\u0060\r\n\r\nNote this pattern doesn\u0027t account for the fact that the user can and will change during the lifetime of a request (e.g. by the AuthN middleware). If the scoped ClaimsPrincipal service were accessed too soon it would cache the wrong value for the user for the duration of the request.",
        "createdAt": "2021-08-02T21:56:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-891360304"
      },
      {
        "id": "IC_kwDOAQzde841Kakv",
        "parentId": null,
        "author": "mqudsi",
        "content": "Can I ask a dumb question? Why *should* it be possible to get the user associated with the current http request without a dependency on ASP.NET Core? It feels like an abstraction for the sake of having an abstraction, at least from ASP.NET Core\u2019s perspective. I get that\u2019s what Restier needs, but does that make it right? \r\n\r\nLet\u2019s say there *is* an abstraction that makes sense where there are multiple authenticated request providers and only one of which is ASP.NET Core; shouldn\u2019t this abstraction (and the extension method configuring the .NET Core pipeline to support it) live in whatever library is abstracting over all that, then? \r\n\r\nIf it\u2019s just about migrating legacy projects.. then there are lots of examples of things that were easier to do before and this probably isn\u2019t the most egregious; plus, there\u2019s a reason why all of ASP.NET Core is so compartmentalized as compared to its predecessor, and that\u2019s mostly a good thing (TM), no?",
        "createdAt": "2021-08-03T15:04:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-891922735"
      },
      {
        "id": "IC_kwDOAQzde841RYzv",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-08-05T19:50:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-893750511"
      },
      {
        "id": "IC_kwDOAQzde85QMjuj",
        "parentId": null,
        "author": "davidfowl",
        "content": "I wrote some notes on async locals and why they need to be designed intentionally https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md#asynclocalt\r\n\r\nThis comes from experience with the HttpContextAccessor and the issues we\u2019ve seen customers run into over the years. ",
        "createdAt": "2022-12-11T06:18:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-1345469347"
      },
      {
        "id": "IC_kwDOAQzde85RHrgg",
        "parentId": null,
        "author": "davidfowl",
        "content": "Given the [issues we\u0027ve seen with HttpContextAccessor](https://github.com/dotnet/aspnetcore/issues/42040), I\u0027m feeling sure that using \u0060Thread.CurrentPrincipal\u0060 would end up in the same boat:\r\n\r\n- \u0060ClaimsPrincipal\u0060 isn\u0027t thread safe\r\n- \u0060WindowsIdentity\u0060 is disposable (and disposed in the request pipeline and other pipelines)\r\n\r\nWhen used from arbitrary library code that is ignorant of this, it can be extremely problematic. I\u0027m not sure of a 100% safe way to do this given the current APIs and that makes me not want to have anything built into the pipeline for this. Maybe we can start with documentation here. \r\n\r\nUsing \u0060Thread.CurrentPrincipal\u0060 is the most pragmatic approach (with those caveats listed):\r\n1. There must be no concurrent access to \u0060Thread.CurrentPrincipal\u0060 (this is very subtle as code you don\u0027t control will capture the execution context and extend the lifetime of it)\r\n2. If the current user is a \u0060WindowsPrincipal\u0060 then it must be used within the lifetime of the request (that can\u0027t guarantee statically). This is to avoid the disposal race.\r\n\r\nIf you haven\u0027t yet read the above comment, please do as it details how these could happen and what they might look like.",
        "createdAt": "2022-12-21T07:51:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-1360967712"
      },
      {
        "id": "IC_kwDOAQzde85RIRRn",
        "parentId": null,
        "author": "robertmclaws",
        "content": "\u003E Can I ask a dumb question? Why _should_ it be possible to get the user associated with the current http request without a dependency on ASP.NET Core? It feels like an abstraction for the sake of having an abstraction, at least from ASP.NET Core\u2019s perspective. I get that\u2019s what Restier needs, but does that make it right?\r\n\r\nBecause in a library of business logic that can use LINQ queries to filter down resultsets (whether using Restier or not), an end user needs to be able to get/read/act on the current permission set. The standard for that has been a ClaimsPrincipal (regardless of whether or not ClaimsPrincipal.Current is thread-safe or not, it still contains claims processing logic).\r\n\r\nThis way, if I\u0027m executing on an out-of-band runtime (like a MessageBus), each message on the queue gets a new thread and a new Thread.CurrentPrincipal, and the business logic code still works.\r\n\r\nIronically, @davidfowl I\u0027m seeing the same issue with the Features cache in Restier. Every so often a request fails because a feature is disposed while OData 7.X on APp.NET Core is trying to access it.\r\n\r\nY\u0027all are smarter than me, but happy to help however I can. Maybe we can find a good solution for .NET 8 together.\r\n\r\nThanks so much, and I hope y\u0027all have a very Happy Christmas / Kwanzaa / Hanukkah / Festivus / etc. \uD83E\uDD1C\uD83C\uDFFB",
        "createdAt": "2022-12-21T10:16:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-1361122407"
      },
      {
        "id": "IC_kwDOAQzde85RJJze",
        "parentId": null,
        "author": "HamsterExAstris",
        "content": "\u003E * \u0060ClaimsPrincipal\u0060 isn\u0027t thread safe\r\n\r\nIs a \u0060ClaimsPrincipal\u0060 _instance_ (as opposed to \u0060ClaimsPrincipal.CurrentPrincipal\u0060) really not thread-safe? I thought that passing the user as a method parameter was [considered safe](https://learn.microsoft.com/en-us/aspnet/core/migration/claimsprincipal-current?view=aspnetcore-7.0).\r\n\r\ni.e. could the following controller action run into issues if the services both _read_ the \u0060ClaimsPrincipal\u0060 retrieved from \u0060ControllerBase.User\u0060 simultaneously? Or is it only an issue if \u0060ThingThatUsesPrincipalAsync\u0060 _mutates_ the \u0060ClaimsPrincipal\u0060?\r\n\r\n\u0060\u0060\u0060\u0060csharp\r\n[HttpPost]\r\npublic ActionResult DoThing()\r\n{\r\n    var task1 = _service.ThingThatUsesPrincipalAsync(User);\r\n    var task2 = _service.ThingThatUsesPrincipalAsync(User);\r\n    await Task.WhenAll(task1, task2);\r\n    return Ok();\r\n}\r\n\u0060\u0060\u0060\u0060",
        "createdAt": "2022-12-21T14:06:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-1361353950"
      },
      {
        "id": "IC_kwDOAQzde85RKd0T",
        "parentId": null,
        "author": "Tratcher",
        "content": "@HamsterExAstris mutation is certainly not thread safe. Most types don\u0027t guarantee even reading is thread safe, though they are in practice. HttpContext is an example of a type that isn\u0027t thread safe for reads either since it generates many fields lazily.",
        "createdAt": "2022-12-21T17:21:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-1361698067"
      },
      {
        "id": "IC_kwDOAQzde85RRxGB",
        "parentId": null,
        "author": "davidfowl",
        "content": "Right. So, I just took a quick look at \u0060ClaimsPrincipal\u0060 and \u0060WindowsPrincipal\u0060.  \u0060ClaimsPrincipal\u0060 is mutable and you can run into trouble if the identities are changed while it\u0027s being read, but it looks pretty safe to be read concurrently. \u0060WindowsPrincipal\u0060 does have lazy properties but it is protected by a lock. \u0060WindowsPrincipal\u0060 is still disposable so if you do end up trying to use it outside of the context where it was set, there\u0027s an inherent race condition that you cannot protect against. Of course, this doesn\u0027t say anything about types derived from \u0060ClaimsPrincipal\u0060.\r\n\r\nGiven that, I think documenting this:\r\n\r\nSetting \u0060Thread.CurrentPrincipal\u0060 in middleware:\r\n\r\n\u0060\u0060\u0060C#\r\npublic static IApplicationBuilder UseThreadCurrentPrincipal(this IApplicationBuilder app) =\u003E\r\n    app.Use(async (context, next) =\u003E\r\n    {\r\n        Thread.CurrentPrincipal = context.User;\r\n        await next();\r\n    });\r\n\u0060\u0060\u0060\r\n\r\nWould be a good place to start here.\r\n\r\n",
        "createdAt": "2022-12-23T04:47:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-1363612033"
      },
      {
        "id": "IC_kwDOAQzde85VDUhm",
        "parentId": null,
        "author": "ericsampson",
        "content": "@davidfowl if I set the \u0060Thread.CurrentPrincipal\u0060 in an \u0060AuthenticationHandler \u003E HandleAuthenticateAsync()\u0060, it gets reverted to the default instance of \u0060GenericPrincipal\u0060 by the time it arrives in the next middleware.\r\n\r\nI haven\u0027t yet set things up to run the aspnetcore code locally in order to step through in the debugger, but just looking at the code in \u0060AuthenticationMiddleware\u0060 and various other things, I cannot figure out why this would be happening.\r\n\r\nAny thoughts? I\u0027m probably missing something obvious :) \r\nThanks!",
        "createdAt": "2023-02-12T03:33:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-1426933862"
      },
      {
        "id": "IC_kwDOAQzde85VDU5l",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E @davidfowl if I set the Thread.CurrentPrincipal in an AuthenticationHandler \u003E HandleAuthenticateAsync(), it gets reverted to the default instance of GenericPrincipal by the time it arrives in the next middleware.\r\n\r\nYep. That\u0027s the wrong place to set it \uD83D\uDE04. Async locals can\u0027t be set from anywhere, you have to understand how the execution context is set and reverted to make sure they \u0022survive\u0022 long enough that they can be observed. Async methods revert the execution context when they exit, that\u0027s why it needs to be set in a middleware. I can\u0027t think of any other component that doesn\u0027t revert execution context in the framework.\r\n\r\nIs there a reason you\u0027re trying to set it in a custom authentication handler?",
        "createdAt": "2023-02-12T03:48:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-1426935397"
      },
      {
        "id": "IC_kwDOAQzde85VDWrC",
        "parentId": null,
        "author": "ericsampson",
        "content": "Oh shoot, reading your response immediately made it clear what I was forgetting, and why it works when set in middleware before doing the \u0060await next\u0060, but not where I was setting it--because the execution context only flows downwards, not upwards. I already knew that, but just didn\u0027t put 2 and 2 together for some reason. Thanks!\r\n\r\nThe reason it\u0027s like this is that I\u0027m porting a large (poorly-written) Framework API over to Core, and that\u0027s what the existing code was doing. I\u0027m trying to minimize changes for now and just do a straight port to Core--the current code uses Thread.CurrentPrincipal in a million places.\r\n\r\nSetting it in the next middleware like you showed fixed the issue, I was just trying to figure out what I was misunderstanding :)\r\n\r\nCheers!",
        "createdAt": "2023-02-12T04:51:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-1426942658"
      },
      {
        "id": "IC_kwDOAQzde85VmEq9",
        "parentId": null,
        "author": "ericsampson",
        "content": "regarding the original issue, I think that adding the snippet that David posted to the docs somewhere would be helpful/sufficient, rather than baking in new functionality to be maintained forever for a situation that is a) not a good pattern to encourage, b) most useful for porting existing old codebases, and c) cleanly solved using a simple 4-line snippet.\nI don\u0027t know if there is existing docs around Framework migration, but if so perhaps it could be put there.",
        "createdAt": "2023-02-19T17:19:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-1436043965"
      },
      {
        "id": "IC_kwDOAQzde85VmGkg",
        "parentId": null,
        "author": "mqudsi",
        "content": "AsyncLocal is basically impossible to use correctly without mentally (or on a whiteboard!) desugaring all async/await into a state machine to figure out what the \u201Cspan\u201D of an AsyncLocal value is. \r\n\r\nI wrote [an entire async locking library](https://www.nuget.org/packages/NeoSmart.AsyncLock) around AsyncLocal and it works great and is used by a lot of people but I am still not comfortable writing greenfield code w/ AsyncLocal, truth be told. \r\n\r\nIs there some way of getting Roslyn to spit out the desugared C# (instead of reversing the IL to C#)? ",
        "createdAt": "2023-02-19T17:55:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34636#issuecomment-1436051744"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU5ODgyMTUwMzk=",
    "title": "ASP.NET Core OIDC/JWT Handlers should not have a direct dependency on the AAD JWT Library",
    "url": "https://github.com/dotnet/aspnetcore/issues/36175",
    "createdAt": "2021-09-04T05:25:15Z",
    "lastUpdated": "2024-09-10T19:33:17Z",
    "body": "\u003C!--\r\n\r\nMore information on our issue management policies can be found here: https://aka.ms/aspnet/issue-policies\r\n\r\n--\u003E\r\n\r\n### Is your feature request related to a problem? Please describe.\r\nRight now, ASP.NET Core has a direct dependency on the AAD JWT library (token handler, token validation parameters etc). This library is primarily driven by its sponsor - the AAD team.\r\n\r\nThere are more JWT options in .NET - being able to plug in a different JWT implementation would be beneficial for the .NET ecosystem.\r\n\r\n### Describe the solution you\u0027d like\r\nASP.NET Core should own its main JWT validation abstractions and rather ship with an by-default integration with the preferred JWT library. If that is the \u0022in-house\u0022 one - fine. But it should be possible to plug in different implementations - similar to the DI system.\r\n\r\n### Additional context\r\nhttps://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/pull/1687#issuecomment-912905994\r\n\r\nhttps://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/1574\r\n\r\nhttps://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/1516\r\n\r\nhttps://twitter.com/ycrumeyrolle/status/1431544530357075968\r\n\r\n\r\n",
    "upvotes": 20,
    "labels": [
      "Needs: Design",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde842ahMc",
        "parentId": null,
        "author": "davidfowl",
        "content": "@leastprivilege would you like to write up an API proposal for these APIs? That will help kick start the process and also help us better understand the scope of the work.",
        "createdAt": "2021-09-04T06:49:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-912921372"
      },
      {
        "id": "IC_kwDOAQzde842aw4h",
        "parentId": null,
        "author": "Tratcher",
        "content": "The current auth handlers are very thin wrappers around the IdentityModel libraries and have little additional functionality. What benefit do you get from abstracting the IdentityModel layer vs providing alternative auth handlers? \r\n\r\nI expect you\u0027d want different types in the options which isn\u0027t something that abstracts well.",
        "createdAt": "2021-09-04T14:44:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-912985633"
      },
      {
        "id": "IC_kwDOAQzde842axWO",
        "parentId": null,
        "author": "davidfowl",
        "content": "Which is why I think a concrete API proposal would be a great starting point ",
        "createdAt": "2021-09-04T14:57:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-912987534"
      },
      {
        "id": "IC_kwDOAQzde842axbc",
        "parentId": null,
        "author": "brockallen",
        "content": "\u003E The current auth handlers are very thin wrappers around the IdentityModel libraries and have little additional functionality. What benefit do you get from abstracting the IdentityModel layer vs providing alternative auth handlers?\r\n\r\nI think the concern is that the current JWT library that\u0027s mainly for AAD has a poor track record of quality, consistency, and breaking changes, and it would be nice to be able to not use it.",
        "createdAt": "2021-09-04T14:59:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-912987868"
      },
      {
        "id": "IC_kwDOAQzde842ayRt",
        "parentId": null,
        "author": "kevinchalet",
        "content": "As @leastprivilege and @brockallen said, the main problem is that IdentityModel is exclusively driven by AAD\u0027s needs, with close to **zero consideration** for the third-party projects that depend on it (e.g IdentityServer or OpenIddict). Sensitive things like AAD-specific telemetry being added to the metadata retrieval feature or the deprecation of the \u0060Validate*\u0060 options in \u0060TokenValidationParameters\u0060 are not even discussed with the community.\r\n\r\nThat said, I\u0027m not sure this situation is specific to the IdentityModel project: lately, even the ASP.NET team hasn\u0027t really been interested in gathering feedback from community members/projects prior to introducing new changes. The situation even got worse with the adoption of the \u0022monorepo\u0022 approach, that makes monitoring topics you\u0027re interested in - and thus sending spontaneous feedback - almost impossible \uD83E\uDD37\uD83C\uDFFB ",
        "createdAt": "2021-09-04T15:24:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-912991341"
      },
      {
        "id": "IC_kwDOAQzde842ay0l",
        "parentId": null,
        "author": "davidfowl",
        "content": "Thanks for that feedback @kevinchalet, if this issue turns into more than just an API proposal then I\u0027m inclined to move it to the discussions milestone.",
        "createdAt": "2021-09-04T15:39:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-912993573"
      },
      {
        "id": "IC_kwDOAQzde842azRe",
        "parentId": null,
        "author": "veikkoeeva",
        "content": "I concur. I tried the JWT tokens quickly as a prototype at https://github.com/lumoin/Verifiable and removing soon all the last traces. Mostly also my concerns are recorded here or in the links. Maybe relevant to think if \u0060.NET\u0060 should be the owner and not ASP.NET. Noting also that [web safe Base64 encoder](https://docs.microsoft.com/en-us/dotnet/api/microsoft.identitymodel.tokens.base64urlencoder.encode) in .NET could be nice.",
        "createdAt": "2021-09-04T15:52:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-912995422"
      },
      {
        "id": "IC_kwDOAQzde842azYG",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E Maybe relevant to think if .NET should be the owner and not ASP.NET. Noting also that web safe Base64 encoder in .NET could be nice.\r\n\r\nI was thinking the same thing. It\u0027s possible this should just be an API proposal on the dotnet/runtime repo. I\u0027m not sure it needs to be an abstraction then, maybe it should just be a core part of the libraries that implement the spec and use System.Text.Json as the implementation.\r\n\r\n@leastprivilege does that sound like a good idea? If so, can you close this issue and create an issue on dotnet/runtime with the API proposal template?",
        "createdAt": "2021-09-04T15:55:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-912995846"
      },
      {
        "id": "IC_kwDOAQzde842ba41",
        "parentId": null,
        "author": "blowdart",
        "content": "I\u0027ve been mulling this since the proposed changes from AAD last week, thinking about it in terms of how we abstracted json away and provided a reference implementation.\r\n\r\nAt its bare minimum what is needed is just JwtValidator/Parser with a single method Validate/Parse, which returns the information needed. But I don\u0027t think that simple an implementation is flexible enough -\r\n\r\n1. We can view a jwt as made up of three things, the header, the payload and the signature, all of which are part of a single string. Whilst in general most folks care about the claims in the payload and nothing more, it would make sense an optiolnal results object to contain all three sections of the token, so we\u0027d end up with JwtValidationResult class which might be returned from a Parse method, which also includes a boolean of IsValid()\r\n2. Users may want to know why a parsed JWT is invalid, so, like X509Validation, a collection of JwtValidationErrors could be useful.\r\n3. ASP.NET takes claims and turns them into a principal which is treated like a User. But JWT can be used to encapsulate more than just a user. one question is would it be up to ASP.NET to transform the validation results into a Principal from the claims collection, or does that belong in the Validator/Parser?\r\n4. Do we want to go further, and allow creation of Jwts from the base classes? That becomes more complicated, because if we allow creation, do we support producing the right type of metadata endpoint contents for key publication etc,.? Personally, I\u0027d say no to this, we\u0027d want to go as simple as possible here, and creation of new tokens is beyond simple.\r\n5. Finally, do we create our own lightweight parser/validation in runtime to sit alongside the rest of the security classes? If so that has risks around getting it right and patching, and down-level support (would we package it as a nuget package for older .NET versions - by which I mean 6.0, rather than, say, Framework). We\u0027d want to consider where its boundaries lie, given that the associated standards around jwt keep growing and branching. I\u0027m not sure we\u0027d want to play catchup. \r\n\r\nConfiguration of the actual parser should be opaque to any parsing functions, so a parser can decide on all those contentious things, like claims mapping, metadata retrieval, refreshing of cached keys etc.  Keeping the actual mechanics opaque would allow for alternative classes to start supporting things the community has wanted for quite a while like encrypted JWTs without consumers having to change code, but should we look at some base events, or callbacks much like Json.Net did or does that fall to a consumer like asp.net to expose?\r\n\r\nAs for @veikkoeeva\u0027s comment on encoding, that\u0027s separate, I\u0027d suggestion that becomes an issue in the runtime repo all its own and linked to the existing encoding classes.\r\n\r\nAnyway, these are random thoughts, dropping from my head over the last week, and gathered on an early Sunday as I drink the first coffee of the day, so they\u0027re by no means anything well designed, or complete, but thoughts for further discussion.",
        "createdAt": "2021-09-05T13:45:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913157685"
      },
      {
        "id": "IC_kwDOAQzde842bbvr",
        "parentId": null,
        "author": "veikkoeeva",
        "content": "@blowdart Let I do the same on my evening coffee... I could add one more and that is flexibility of choosing one\u0027s library to sign, validate and encrypt. The AAD one doesn\u0027t make it easy while also not providing much options either (one could say the hierarcy feels fairly rigid). It would be nice to have have a clear way to choose one\u0027s preferred library due to concerns such as:\r\n- BouncyCastle/NSec is approved and mandaged in some organization X. So it needs to be used if not something that\u0027s straight from the official .NET supply-chain.\r\n- Wanting to cross-test or develop other libraries.\r\n- Choosing platform dependent way something, say something that works well in browser and WASM environment.\r\n- Using specialized hardware: TPMs, HSMs, TEEs...\r\n\r\nI have currently a shim ([test showing here](https://github.com/lumoin/Verifiable/blob/main/test/Verifiable.Tests/CryptographicCrossTests.cs#L55), also will be properly named and not just tuples at some point) for NSec, BouncyCastle and at some point for .NET and TPM ones too. And looking how to best do some of this JWT stuff. Maybe I\u0027d like to make a note, partially related to hardware that having a \u0060new byte[]\u0060 in somewhere in the guts of a library that has sensitive bytes there may make people, say, in payments, wonder if it\u0027s worth coming up mitigations or do something else (as that code shows, I\u0027m mitigating it with prototyping a sensitive boundary wrapped, so that could consider TPMs, AES encryptinh memory, whatever). Maybe performance related issues too there.\r\n\r\nI concur about that encoding. Goes to show there are many issues within many issues.",
        "createdAt": "2021-09-05T14:05:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913161195"
      },
      {
        "id": "IC_kwDOAQzde842bcGt",
        "parentId": null,
        "author": "blowdart",
        "content": "Oh dear lord let\u0027s not reinvent secure string \uD83D\uDE02\n\nJwt creation is interesting. I\u0027m not sure it\u0027s a key scenario for a lot of folks, that tends to be for token servers rather than a mainline scenario for the majority of users. I\u0027d worry that would overcomplicate a parsing abstraction.",
        "createdAt": "2021-09-05T14:14:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913162669"
      },
      {
        "id": "IC_kwDOAQzde842bcd0",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E As for @veikkoeeva\u0027s comment on encoding, that\u0027s separate, I\u0027d suggestion that becomes an issue in the runtime repo all its own and linked to the existing encoding classes.\r\n\r\n- https://github.com/dotnet/runtime/issues/1658\r\n- https://github.com/dotnet/runtime/issues/31099",
        "createdAt": "2021-09-05T14:24:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913164148"
      },
      {
        "id": "IC_kwDOAQzde842bet-",
        "parentId": null,
        "author": "veikkoeeva",
        "content": "@blowdart Maybe I don\u0027t care about \u0060SecureString\u0060 that much. I think I have seen those discussion somewhere in GH. :)\r\n\r\n\u003E Jwt creation is interesting. I\u0027m not sure it\u0027s a key scenario for a lot of folks, that tends to be for token servers rather than a mainline scenario for the majority of users. I\u0027d worry that would overcomplicate a parsing abstraction.\r\n\r\nI think I understand. Let I persist a little while still.\r\n\r\nAs this is a hopefully bit more free-wheeling discussion, maybe this is a good place make a note that if someone somewhere is thinking something, a strict class hierarchy that _fixes_ internally everything to .NET platform offering may exclude people building on top abstractions that perhaps could have a bit more breathing room.\r\n\r\nThis is a separate issue from parsing, token creation, validation and those for sure. But this _fixing_ was one of the problems I experienced when I thought that maybe I could reuse the AAD abstractions and plug something else there. Maybe one example still concerning even users of \u0060Microsoft.IdentityModel.Tokens\u0060 is how easy is it to plug in Azure HSM (maybe it\u0027s all working nicely these days and I used missed it). Maybe a good abstraction could use them too.\r\n\r\nSpecifically concerning the library I\u0027m building: It seem that AAD owns the MS DID/VC libraries too, while not having a .NET library for that (hence I\u0027m working on one, likely need in the future :)). When someone in MS is considering to write one, maybe it\u0027d be nice if it\u0027d be useable in higher trust/regulated scenarios.\r\n\r\nSome more fringe but useable considerations... Besides, say, using HSMs, someone somewhere may mandate that \u0060mlocked\u0060 pages need to be used (on a separate server maybe, but can be a desktop too, as part of some regulated system). We can agree it may not be a splendid idea. Or that using a custom memory pools are too easy to use wrongly. Or maybe using the TPM RNG for some operations (or maybe just something like [here](https://twitter.com/rene_mobile/status/1434053050008756229) \u0060Having separate public and secret RNGs for different purposes (IVs vs. session keys etc) sounds like an excellent defense in depth mitigation.\u0060). But it would be nice too if things like these could be more easily useable.\r\n\r\nI think I don\u0027t have much more to tell here (well, a plead of hands ands minds to https://github.com/microsoft/TSS.MSR :D) and I don\u0027t want to steal the thread. Maybe sufficient to note this is a pain point to other than the OP and the usual well known .NET names in the space. The perspective may be a bit different. There are people who have in passing mentioned building something like https://keylime.dev/ or things related to card payments handling, but are thinking if the .NET environment is too MS centric and fixed to what MS provides and so it\u0027s just too much of an effort to work around issues.\r\n\r\nBesides the already mentioned one, I would like to build maybe something into Orleans grains with the idea of semi-autonomous AI agents but using good abstractions (esp. if [regulated](https://github.com/lumoin/circomy/blob/main/ai/eu-ai-watch.md), and that doesn\u0027t include cybersecurity and digital markets ones coming down too, we probably need to add docs for those later!). Of course this is anedoctal.",
        "createdAt": "2021-09-05T15:15:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913173374"
      },
      {
        "id": "IC_kwDOAQzde842bfRu",
        "parentId": null,
        "author": "Tratcher",
        "content": "Some points on logistics:\r\n- The OpenIdConnect and JwtBearer packages have a tight public API coupling to IdentityModel with properties like ConfigurationManager, SecurityTokenValidator, SecurityToken, and TokenValidationParameters. Breaking that API surface, along with the likely behavioral changes of a new implementation, is way beyond our compatibility guidelines.\r\n- This means creating new packages and APIs, either as a fork of the current ones or starting from scratch. The biggest downside I see to that is naming collisions.\r\n- The OpenIdConnect and JwtBearer packages are not part of the shared framework due to the various risks of the external dependency, that makes them easier to replace.\r\n- Nor does anything else in ASP.NET Core depend on these packages except for the templates. Templates can accept breaking changes or provide alternative templates.\r\n- Since we would need new packages and APIs, I recommend starting with some collaborative prototyping in a place like https://github.com/orgs/aspnet-contrib/ where we can all iterate quickly.\r\n\r\nThoughts?",
        "createdAt": "2021-09-05T15:28:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913175662"
      },
      {
        "id": "IC_kwDOAQzde842bg1c",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E The OpenIdConnect and JwtBearer packages are not part of the shared framework due to the various risks of the external dependency.\r\n\r\nThis says a lot about IdentityModel\u0027s governance when even the ASP.NET team considers IM too risky to have packages that depend on it in the shared framework. Building an abstraction on top of IM would certainly help _advanced_ users opt out of IM, but it wouldn\u0027t solve the root causes we mentioned earlier, as IM would very likely stay the default implementation. At this point, [IM\u0027s governance is still a central point](https://github.com/dotnet/runtime/issues/18945).\r\n\r\nA few concrete proposals that could help improve things:\r\n  - Introducing an \u0022advisory council\u0022 similar to what was suggested for DI (excellent idea, BTW), where members of the ASP.NET team and external people could help the IM team make the right choices on sensitive design decisions.\r\n  - Transferring the IdentityModel code to the _dotnet/runtime_ repository, where it could be reviewed by members of the .NET team way more easily.\r\n  - Transferring IM\u0027s ownership to the .NET team.\r\n\r\nIt\u0027s definitely something that should be discussed with @jmprieur and @brentschmaltz.",
        "createdAt": "2021-09-05T16:06:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913182044"
      },
      {
        "id": "IC_kwDOAQzde842bhn3",
        "parentId": null,
        "author": "blowdart",
        "content": "_Introducing an \u0022advisory council\u0022 similar to what was suggested for DI (excellent idea, BTW), where members of the ASP.NET team and external people could help the IM team make the right choices on sensitive design decisions._\r\n\r\nIf that\u0027s your end goal then **here** is not the place to discuss how other teams should govern themselves.\r\n\r\nGiven that identity model is intimately linked with AAD, it\u0027s not something .NET should own either. We tried that with the WS* stuff before, and it did not work well. And what is up for discussion is _not_ an abstraction over identity model, but something much simpler in terms of abstraction, jwt parsing,\r\n\r\nAs for solving what you see as the root problem, let\u0027s note that it is _advanced users_ that started this discussion and want the opt-out.  I would posit that the vast majority of users don\u0027t care, they just want working ODIC and JWT, and how they get it doesn\u0027t matter.",
        "createdAt": "2021-09-05T16:26:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913185271"
      },
      {
        "id": "IC_kwDOAQzde842bimq",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E If that\u0027s your end goal then here is not the place to discuss how other teams should govern themselves.\r\n\r\nIt\u0027s more about discussing how such a critical library could stop being exclusively driven by AAD\u0027s needs with no consideration for the impact on external projects. If it\u0027s not here, what\u0027s the right place to discuss that?\r\n\r\n\u003E Given that identity model is intimately linked with AAD, it\u0027s not something .NET should own either.\r\n\r\nThat\u0027s the problem: JWT and OIDC are open standards and it\u0027s regrettable their implementation in .NET is tied to Azure. IdentityModel - that was originally part of the .NET Framework BTW, in case you don\u0027t remember - fills a **critical** role in .NET and it\u0027s not clear to me why the JWT/JWS/JWE implementation couldn\u0027t be owned by .NET.\r\n\r\n\u003E And what is up for discussion is not an abstraction over identity model, but something much simpler in terms of abstraction, jwt parsing,\r\n\r\nIt\u0027s so much more than just \u0022parsing\u0022, it\u0027s the whole validation stuff you\u0027ll need to abstract and make extensible enough to be as usable as the current implementation.",
        "createdAt": "2021-09-05T16:53:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913189290"
      },
      {
        "id": "IC_kwDOAQzde842blqC",
        "parentId": null,
        "author": "blowdart",
        "content": "You\u0027re conflating two issues. AAD having their own JWT library that\u0027s driven by AAD\u0027s needs (external and internal), and the desire to swap it with something else that isn\u0027t driven by AAD\u0027s needs.\r\n\r\nWe don\u0027t need to abstract validation away if parsing includes validation, it can be an opaque process, controlled by configuration of the implementation class, where its config is set at startup, or though the options patterns. \r\n\r\nConfiguration and validation parameters don\u0027t need to be exposed to the end call site, after all your criticism of the Identity Model doesn\u0027t call for that. That feels quite leaky.\r\n\r\nIf you wanted to add validation external to parsing you might end up with TryParse, TryValidate and that\u0027s it, the internal mechanisms don\u0027t matter to the caller, only the failures that result from failed validation or parsing. \r\n",
        "createdAt": "2021-09-05T18:18:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913201794"
      },
      {
        "id": "IC_kwDOAQzde842bmON",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E You\u0027re conflating two issues. AAD having their own JWT library that\u0027s driven by AAD\u0027s needs (external and internal), and the desire to swap it with something else that isn\u0027t driven by AAD\u0027s needs.\r\n\r\nI\u0027m not. It\u0027s just that the two are closely related: if IdentityModel didn\u0027t have this governance issue, I doubt anyone would complain. It\u0027s because of that that @leastprivilege suggested we should be able to switch to a different - vendor-neutral - implementation. There\u0027s clearly a cause and effect relationship here.\r\n\r\n\u003E Configuration and validation parameters don\u0027t need to be exposed to the end call site, after all your criticism of the Identity Model doesn\u0027t call for that. That feels quite leaky.\r\n\r\nUnless you design your new stack to only support OIDC configuration discovery and don\u0027t allow tweaking the validation logic (what\u0027s the issuer that is considered valid? do we check the not before/expiration dates? what audiences are allowed, etc.), you\u0027ll need to make basic things configurable via an options-like class, potentially with delegates if more control is needed.\r\n\r\nEven essential things like registering signing or encryption keys will require designing new types if you don\u0027t want to expose IdentityModel\u0027s \u0060EncryptingCredentials\u0060/\u0060SigningCredentials\u0060/\u0060SecurityKey\u0060 types.",
        "createdAt": "2021-09-05T18:36:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913204109"
      },
      {
        "id": "IC_kwDOAQzde842bm23",
        "parentId": null,
        "author": "blowdart",
        "content": "_Even essential things like registering signing or encryption keys will require designing new types_\r\n\r\nIf rely on DI to pass it around in ASP.NET (yes, I realise that you may end up wanting it in everything from WinForms to Blazer), you don\u0027t need the types, it\u0027s still just config and/or delegates that can be unique to the actual implementation rather than abstracted away.\r\n\r\nIf we go back to JSON like approach, \r\n\r\n\u0060\u0060\u0060\r\n    services.AddContosoJwtParser(options =\u003E\r\n        options =\u003E options.SigningCredentials = ....)\r\n\u0060\u0060\u0060\r\n\r\nbut is that not just sugar really? Just something prettier than adding an IJwtParser into DI for everything to resolve? The System.Text.Json.JsonSerializerOptions is specific to the built in Json classes, just like the SerializerSettings in json.net are specific to json.net - the actual options.SerializerSettings is, in MVC just an object, but it sort of looks like it isn\u0027t during config.\r\n\r\nAnd going back to what most people use JWTs for, it\u0027s parsing/validation still, that\u0027s the main use. Very few people run off manually to refresh keys or credentials, that\u0027s set at startup, and that\u0027s still specific to the actual parser. If the parser wants to run off and grab things from /wellknown, great, internal implementation detail, if it wants to read all the keys from Hashicorp Vault, again, internal implemtation detail. Parsing/Validation from a caller perspective should not need to care.",
        "createdAt": "2021-09-05T18:57:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913206711"
      },
      {
        "id": "IC_kwDOAQzde842boe7",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E If rely on DI to pass it around in ASP.NET (yes, I realise that you may end up wanting it in everything from WinForms to Blazer), you don\u0027t need the types, it\u0027s still just config and/or delegates that can be unique to the actual implementation rather than abstracted away.\r\n\r\nUsing DI would be problematic if you wanted to support multiple authentication handlers with different \u0022parsers\u0022/\u0022validators\u0022 (MS\u0027 DI container doesn\u0027t natively support named services). You\u0027d probably want services-as-options here.\r\n\r\n\u003E If we go back to JSON like approach,\r\n\r\nAt this point, if everything is implementation-specific instead of being abstracted and absolutely nothing can be configured without being coupled to a specific \u0022JWT validator\u0022 implementation, what\u0027s the difference with just rolling your own authentication handler? Genuine question.\r\n\r\nBTW, you say \u0022JWT parser/validator\u0022, but it\u0027s more than that: the OIDC handler also uses IdentityModel to validate critical parts of the OIDC flow via its \u0060OpenIdConnectProtocolValidator\u0060. If it was something up to the \u0022JWT implementation\u0022 to do, how would that be better than just creating your own ASP.NET Core authentication handler?\r\n\r\n(since you mentioned MVC, it\u0027s interesting to note that while MVC uses an \u0060object\u0060 property, the read/write JSON \u0060HttpContext\u0060 extensions introduced more recently are tied to System.Text.Json and don\u0027t use \u0060object\u0060).\r\n\r\nEventually, I find very sad the fact we\u0027re debating about potential designs when the original issue could have been solved by being just a little bit more reasonable... \uD83E\uDD37\uD83C\uDFFB ",
        "createdAt": "2021-09-05T19:24:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913213371"
      },
      {
        "id": "IC_kwDOAQzde842brrv",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@kevinchalet thanks for including the IdentityModel team on this thread.\r\nThere seems to be an overstatement that the IM is simply servicing AAD and as a secondary function providing 3p support.\r\nIt is actually the reverse. The project (post WCF) was first shipped with Katana and then was a part of the .NET release cycle.\r\nAfter a couple of releases, we thought that we could move faster by decoupling IM from .NET release.\r\nThere are times when AAD specific features need to be added to IM, but we endeavor to make them off by default as we have internal wrappers that set the functionality needed.\r\nWe take feedback,  we are dropping the obsolete PR on TokenValidationParameters.\r\n\r\nThat said it appears there is some disconnect as the comments on this thread make that apparent.\r\nThe IM team is committed to supporting 3p\u0027s and are staffed to do so.\r\n\r\nWe are missing some key abstractions and have somewhat of an uncoordinated options setting structure where for example, JwtBearerOptions has some validation settings that need to be set by reaching down to IM and some on the options.\r\nThat is confusing.\r\n\r\nWe are working on currently working on abstractions that allow for plugging in handling of different protocols and tokens (auth is not just JwtBearer or JwtTokens).\r\nI would love to see some proposals for what the community wants.\r\n\r\n",
        "createdAt": "2021-09-05T20:59:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913226479"
      },
      {
        "id": "IC_kwDOAQzde842by43",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E We take feedback, we are dropping the obsolete PR on TokenValidationParameters.\r\n\r\nDo you mean the \u0060Validate*\u0060 switches deprecation? If so, that\u0027s great to hear! Such changes should always come with an impact study to ensure they are justified and affect 3rd party projects reasonably (which was not the case, AFAICT).\r\n\r\n\u003E There are times when AAD specific features need to be added to IM, but we endeavor to make them off by default as we have internal wrappers that set the functionality needed.\r\n\r\nIMHO, AAD-specific features should never be implemented in IdentityModel (that must remain as vendor-neutral as possible): they should be implemented higher in the \u0022Microsoft Identity Web\u0022 stack using the extensibility hooks offered by IdentityModel.\r\n\r\nAs for making these AAD-specific features opt-in, sadly I don\u0027t think it\u0027s true:\r\n  - In 2016, [your team - not you specifically - pushed *very hard* to introduce telemetry in one of IdentityModel\u0027s core types](https://github.com/aspnet/Security/issues/1035). After a lengthy debate, [an opt-out flag had to be introduced in ASP.NET Core to disable telemetry](https://github.com/aspnet/Security/pull/1140).\r\n  - Last month, [additional telemetry was added in the metadata retrieval feature](https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/pull/1678) without even discussing it publicly. When @brockallen asked for more details, his message was simply ignored. The flag we introduced in 2016 isn\u0027t honored by this new telemetry feature and I didn\u0027t see any ticket/PR in dotnet/aspnet that may indicate you plan to fix that.\r\n\r\nThese changes - made in IdentityModel\u0027s core - were exclusively designed for AAD (no other implementation supports the custom parameters/headers you use), they are not opt-in and they were not announced/discussed prior to being implemented. If @brockallen, @leastprivilege or I didn\u0027t keep an eye on the IdentityModel repo, we wouldn\u0027t even notice them: I\u0027m afraid, it\u0027s just unacceptable.\r\n\r\n\u003E The IM team is committed to supporting 3p\u0027s and are staffed to do so.\r\n\r\nI already said it elsewhere: the situation largely improved since 2015: back then, the IM team was clearly underfunded and didn\u0027t have the HR needed to maintain such a critical stack and I\u0027m glad to see it\u0027s no longer true. I\u0027m also very happy you merged the PRs I sent last year and took my feedback into consideration, it\u0027s clearly very positive.\r\n\r\nStill, the main problem remains and every time an AAD-specific thing lands in IdentityModel, the confidence 3rd-party developers have in IM is impacted... to the point where major projects would like to get rid of it. This needs to change.\r\n\r\n(BTW, this thread focuses on IM, but the \u0022push AAD stuff everywhere\u0022 movement is certainly not specific to IM: even the SQL client has a hard dependency on MSAL, which is unacceptable too: https://twitter.com/kevin_chalet/status/1434565739898449927)",
        "createdAt": "2021-09-06T00:25:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913255991"
      },
      {
        "id": "IC_kwDOAQzde842b1V1",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@kevinchalet thanks for the feedback.\r\nYes, the Validate* deprecation PR will not go through as a result of feedback from you, brock and leastpriviledge and others.\r\n\r\nI agree with you that our design strategy should be to make only the necessary changes to enable AAD required features possible and leave them off. The 2016 fix with telemetry was a case we don\u0027t want to repeat. \r\nThis time we  worked with @Tratcher to make sure we had the control in place.,\r\n\r\nYou are correct that we have much better funding now.\r\n\r\n\u003E Still, the main problem remains and every time an AAD-specific thing lands in IdentityModel, the confidence 3rd-party developers have in IM is impacted... to the point where major projects would like to get rid of it. This needs to change.\r\n\r\nWe have developed an internal layer on top of IM that has multiple features for AAD and plan on keeping AAD specific features for 1p\u0027s in that area.\r\nIt also plugs into the asp.net as the authentication layer.\r\nIt solves a number of interesting problems, we are factoring out the 1p\u0027s specific features and will be introducing the model this year.\r\n\r\nWhat is the best way to move forward so that we get the right product for everyone?\r\n",
        "createdAt": "2021-09-06T01:04:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913266037"
      },
      {
        "id": "IC_kwDOAQzde842d3WQ",
        "parentId": null,
        "author": "leastprivilege",
        "content": "Unfortunately this thread went into too many different directions - let me try to consolidate...\r\n\r\nMy initial reason for opening this issue was\r\n\r\n* I have an ongoing frustration with the *Wilson* set of libraries for the reasons mentioned in the OP. If I could replace it, I would (but honestly not sure with what).\r\n* there are other JWT libraries out there - but replacing the AAD JWT lib is not possible because of the tight coupling in ASP.NET Core (I do not agree with @Tratcher that e.g. the OIDC handler is just a thin wrapper over the underlying JWT / protocol libraries. This might be more true for JwtBearer - but the OIDC one is pretty involved)\r\n\r\nTbh - the biggest problems we had upgrading our code over the last ASP.NET Core versions was always Wilson. Again and again.\r\n\r\nBut once I thought about it a bit more - the issue is much more complicated. In a nutshell, it was a mistake from day 1 that the ASP.NET Core team did not invest in their own OIDC client plumbing.\r\n\r\nThere is no way to make all this pluggable in ASP.NET Core (at least in a feasible time frame) - OIDC discovery document parsing, OIDC protocol message creation and parsing, JWT parsing etc... it\u0027s all outsourced (and tightly coupled)\r\n\r\nSo yes - it crossed my mind if JWT should be part of the BCL. I think it should. It should be a compact and concise implementation of the spec - no opinions. After all JWT is \u0022just\u0022 a signature/encryption wrapper for JSON objects. But there is a lot of other complexities as well - JWS, JWE, JWK etc. These things don\u0027t exist isolated and must be somehow interoperable with the other OIDC plumbing.\r\n\r\nThis is a multi-year effort and we in particular have \u0022advanced\u0022 use-cases which will not be the 80/20 target of the next versions of .NET.\r\n\r\nNow looking at other JWT implementations - I am bit scared when I see the \u0022hand rolled\u0022 crypto. I was very tempted to create my own JWT handler on top of the Wilson crypto primitives. But I do not have the time for that.\r\n\r\nSo to conclude - I just wish Wilson would stop changing their APIs and keep the package more stable and reliable - and at the same time remove all that AAD specific stuff like e.g. telemetry (I mean the ridiculousness of claim mapping defaults is another good example). All efforts should go into their new JsonWebTokenHandler - and ASP.NET Core should switch to their new plumbing (again - this is not possible today).\r\n\r\nAt the same time the BCL needs a JWT implementation going forward - one that is going through the high standards of security testing that I would expect from Microsoft. If that base library is done right - opinionated semantics could be added at the app level.\r\n\r\n...and no - I don\u0027t think I will do an initial API proposal - but I am happy to be involved (in some capacity) in this effort ;) @davidfowl \r\n\r\n\r\n\r\n\r\n",
        "createdAt": "2021-09-06T18:12:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913798544"
      },
      {
        "id": "IC_kwDOAQzde842d4wZ",
        "parentId": null,
        "author": "davidfowl",
        "content": "The issue/API needs a champion and it needs to be filed in the right place. Otherwise this will just be a discussion issue. ",
        "createdAt": "2021-09-06T18:29:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913804313"
      },
      {
        "id": "IC_kwDOAQzde842d7hC",
        "parentId": null,
        "author": "leastprivilege",
        "content": "\u003E The issue/API needs a champion and it needs to be filed in the right place. Otherwise this will just be a discussion issue.\r\n\r\nok - then feel free to close it.",
        "createdAt": "2021-09-06T19:06:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-913815618"
      },
      {
        "id": "IC_kwDOAQzde842fny5",
        "parentId": null,
        "author": "blowdart",
        "content": "@davidfowl The right place is a discussion all to itself, given there are two things in one issue here, JWT and ODIC. The only place that uses them right now is ASP.NET, but, in much the same way we have a JSON parser, an actual implementation of a JWT is probably best outside of ASP.NET because no-one wants to bring in the weight of that into, say, a Winforms project. OIDC on the other hand may well be best off inside ASP.NET, until you think about mobile apps, but they way they handle logins is often through an embedded browser.\r\n\r\nI can certainly champion the issue, but it needs careful design, and that\u0027s a heavy weight for the community to do, both in terms of time, and money. A good start for asp.net may be moving the middleware to use the new abstractions that frankly I didn\u0027t even know existed, but that still leaves the abstractions in assemblies that move at a different pace to the framework. It could be worth investigation moving the abstrations out into asp.net and pivoting the middleware to use them as a starting point. If we have the abstractions nestled into asp.net they\u0027ll move at the same pace, and breaking changes would be reduced and come under a more semanticly versioned and governed space.",
        "createdAt": "2021-09-07T12:24:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-914259129"
      },
      {
        "id": "IC_kwDOAQzde842gPvf",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "\u003E (I mean the ridiculousness of claim mapping defaults is another good example). All efforts should go into their new JsonWebTokenHandler -\r\n\r\n@leastprivilege it\u0027s time to put the claim mapping to bed, beating that dead horse doesn\u0027t help. That was a different time and place, we acknowledge that decision caused issues and have workarounds. The new JsonWebTokenHandler did not follow that pattern\r\n\r\n\u003E JWT and ODIC. The only place that uses them right now is ASP.NET,\r\n\r\nThere is wider use of IM then just ASP.NET\r\n\r\n\u003Eit was a mistake from day 1 that the ASP.NET Core team did not invest in their own OIDC client plumbing.\r\n\r\nThe OIDC middleware for asp.net was developed with the asp.net team.\r\n\r\n\u003E  I just wish Wilson would stop changing their APIs and keep the package more stable and reliable\r\n\r\nWe do have strong api back-compat, but there are runtime concerns. A while back i suggested that we are open to the idea of users adding scenario tests that if broken would block the release until the scenario owner signs off. We didn\u0027t go very far with that, this may be a beneficial investment.\r\n\r\nI see frustration focusing on out of scope features such as telemetry and such items was internalizing Newtonsoft, which caught everyone by surprise.\r\n\r\nWe need better communication and an IM release model that ensures external scenarios are not broken.  \r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "createdAt": "2021-09-07T15:49:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-914422751"
      },
      {
        "id": "IC_kwDOAQzde842iOe-",
        "parentId": null,
        "author": "leastprivilege",
        "content": "I think sometimes discussions are better than inventing new APIs. Especially if they bring all the parties to the table.\r\n\r\nIt sounds like everybody here on this thread wants to do the right thing. While JWT handling is very important, implementing it is a multi-year effort. The Wilson team has already 10 years of investment in that space. At the same time .NET and ASP.NET in particular needs a good and modern JWT/OIDC implementation that is not riddled by internal Microsoft management challenges.\r\n\r\nSo let me summarize what I think is necessary going forward:\r\n\r\nThe Wilson team\r\n\r\n* will respect SemVer and not introduce breaking changes in minor and patch releases anymore \u2013 both from an API surface and functional perspective\r\n* remove all AAD specific features from the core library, e.g. remove all telemetry\r\n* be spec compliant (e.g. implement the resource parameters according to the spec and not according to how AAD is using it)\r\n* Maybe even moving the core libs and abstractions to MS OpenTech/DNF could be considered\r\n* prioritize fixing the JSON problems and move to the modern JSON APIs\r\n* establish a better communication with its users beyond the AAD team\r\n    * e.g. discuss if we should start over with the TokenValidationParameters plumbing for JsonWebTokenHandler\r\n* JsonWebToken/Handler does not need to be backwards compat with .NET Framework - remove all the netfx/nestandard complexity and focus on the latest and greatest in crypto, JSON, logging etc.\r\n\r\nThe ASP.NET team will\r\n\r\n* switch to JsonWebToken/JsonWebTokenHandler since this is the new stack where all the innovation goes to\r\n    * this would also put pressure on the Wilson team to focus on the new plumbing and make above mentioned quality guarantees\r\n\r\n\r\n\u003E A while back i suggested that we are open to the idea of users adding scenario tests that if broken would block the release until the scenario owner signs off. We didn\u0027t go very far with that, this may be a beneficial investment.\r\n\r\nWe did exactly this in IdentityServer because of the quality issues. We have several tests that just make sure the JSON still looks like what we expect...so yes, this is a good idea. You should start with writing JSON/JWT round-tripping tests, if they would exist, some of the problems could have been caught before release.\r\n\r\nDoes this sound like a foundation for a new discussion? @brentschmaltz @blowdart @Tratcher @davidfowl \r\n",
        "createdAt": "2021-09-08T06:00:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-914941886"
      },
      {
        "id": "IC_kwDOAQzde842qG_A",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@leastprivilege in general i agree with you, we need this conversation.\r\nIn general, the IM team wants our work to be tied to standards. Our early work was influenced by Ws* and we have had an interesting transition moving away from Ws* designs while still maintaining some support for SAML tokens, dsig and WsFed.\r\n\r\n\u003E You should start with writing JSON/JWT round-tripping tests, if they would exist, some of the problems could have been caught before release.\r\n\r\nWe have developed a system using a home grown IdentityComparer that helps us ensure the round-trip is as expected see:  \r\n[Tests](https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/5a77aab7b2074782bc097c58ffaf220ee564595b/test/Microsoft.IdentityModel.JsonWebTokens.Tests/JsonWebTokenHandlerTests.cs#L1741)\r\n\r\nWhat i was encouraging is that users can add some important tests for their scenarios that we add to our release process.\r\n\r\n\u003Eswitch to JsonWebToken/JsonWebTokenHandler \r\n\r\nThis needs to be the long term goal.  The IM team has identified some blockers that need to be implemented first. Some implementations leaked during our early development. Our performance runs are showing up to a 50% improvement. \r\n\r\n \u003Eremove all AAD specific features from the core library, e.g. remove all telemetry\r\n\r\nThe only item i am aware of is the telemetry. While we can\u0027t remove this, we can make sure that it is opt-in. We have internal layers that can turn it on for our 1p hosts. Asp.net can ensure it is off by default.\r\n\r\nBrent",
        "createdAt": "2021-09-10T15:46:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-917008320"
      },
      {
        "id": "IC_kwDOAQzde842rX2G",
        "parentId": null,
        "author": "PureKrome",
        "content": "\u003E While we can\u0027t remove this, we can make sure that it is opt-in.\r\n\r\n**Can\u0027t** or **Don\u0027t want to** ? I think people would really appreciate the clarification/confirmation.\r\n\r\nEDIT: Also, I\u0027m not trolling - It\u0027s an honest question.",
        "createdAt": "2021-09-11T04:46:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-917339526"
      },
      {
        "id": "IC_kwDOAQzde842sp88",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@PureKrome We would like to if possible. I haven\u0027t studied the call graph yet to see if it is possible. It\u0027s actually very valuable when a an important improvement arises to know the exact version of a library being used.\r\nBy reviewing the telemetry and mapping to the application id, one can inform application owners. It\u0027s not always simple to know what version of libraries applications are using. ",
        "createdAt": "2021-09-12T17:19:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-917675836"
      },
      {
        "id": "IC_kwDOAQzde842tWtn",
        "parentId": null,
        "author": "leastprivilege",
        "content": "\u003E By reviewing the telemetry and mapping to the application id, one can inform application owners. It\u0027s not always simple to know what version of libraries applications are using.\r\n\r\nSure - but this is not part of the RFC/spec - this is an AAD-specific product feature. Make it an extensibility point.",
        "createdAt": "2021-09-13T05:42:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-917859175"
      },
      {
        "id": "IC_kwDOAQzde842y-Gc",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@leastprivilege I always push back against any work that is not per spec (unless we all agree, lax on receive for example). There are other voices that have influence, currently i do have some influence and will try and hold the line. If there is a need for some odd behavior, we will need to mark the \u0027issue\u0027 and \u0027pr\u0027 in such a way that interested parties can chime in so there are no surprises.  Currently i do not see any items on the docket, but we all have work to do and smoothing this out will benefit us all.\r\n\r\nHow can we get folks involved in big issues? \r\nFor example, the change to JsonClaimSet using System.Json.Text is a big change, we want to make sure the dev community has opportunity to help us get it right. First step is for us to publish a design with intent, i suppose.  ",
        "createdAt": "2021-09-14T16:49:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-919331228"
      },
      {
        "id": "IC_kwDOAQzde842387E",
        "parentId": null,
        "author": "leastprivilege",
        "content": "\u003E I always push back against any work that is not per spec (unless we all agree, lax on receive for example)\r\n\r\nThat this is even needed is part of the problem. What is \u0022lax on receive\u0022?\r\n\r\n\u003E There are other voices that have influence, currently i do have some influence and will try and hold the line.\r\n\r\nIf you cannot get \u0022management buy-in\u0022 that the standards parts and AAD must be separate. We are back to square 1.\r\n\r\n\u003E We have developed a system using a home grown IdentityComparer\r\n\r\nThat seems to test at the claims level - thats good - but first of all you need to test at the JSON text level.\r\n\r\n\u003E How can we get folks involved in big issues? First step is for us to publish a design with intent, i suppose.\r\n\r\nYes. Open an issue. Write a proposal. Document the change and API usage. Then we can discuss. Feel free to tag me.",
        "createdAt": "2021-09-16T07:10:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-920637124"
      },
      {
        "id": "IC_kwDOAQzde843ZX18",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@leastprivilege (been on vacation :-)\r\n\u0022lax on receive\u0022 can be simply we accept \u0022BEArer\u0022, \u0022beaRer\u0022 for the protocol name. Or more complicated, if a SAML id is not a UUID but still matches the reference id, we will use it.\r\n\r\n\u0022management but-in\u0022 management is bought into respecting standards.\r\nWe cannot remove features, such as what we have in telemetry. When we need special feature such as when we added this for some internal needs,  https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/commit/be1c621755848b38ca3222f52d01465fef9b3189 we did it in such a way that is is opt-in.\r\nI also what to note, internal 1ps will have to write some unnatural code to make it work.\r\n\r\n\u0022proposal\u0022 - yes that is needed and will help us create a better product.",
        "createdAt": "2021-09-28T16:43:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-929398140"
      },
      {
        "id": "IC_kwDOAQzde844Ay3L",
        "parentId": null,
        "author": "leastprivilege",
        "content": "Any progress on this?",
        "createdAt": "2021-10-11T06:46:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-939732427"
      },
      {
        "id": "IC_kwDOAQzde844PIoM",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@leastprivilege i believe we are on the same page. Current management want us to be spec compliant and put any AAD specific features as opt-in or in separate internal libraries.\r\n\r\nWe are completing a proposal along with a proof-of-concept for improving the JsonWebToken so that it depends on System.Text.Json and working on providing a solution for asp.net developers to move off of JwtSecurityToken.\r\n\r\n\r\nI will tag @leastprivilege , @kevinchalet\r\nAnyone else that wants to be tagged, please add a comment here.",
        "createdAt": "2021-10-14T15:55:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-943491596"
      },
      {
        "id": "IC_kwDOAQzde846_GUU",
        "parentId": null,
        "author": "leastprivilege",
        "content": "Are we making any progress on the criticism in this thread? \r\n\r\n* JSON handling is still broken\r\n* things like the standard resource parameter are still not implemented\r\n\r\n\u003E \u0022lax on receive\u0022 can be simply we accept \u0022BEArer\u0022, \u0022beaRer\u0022 for the protocol name.\r\n\r\nAre you serious?\r\n\r\nTbh - maybe there should be an issue in the JWT handler repo to continue the discussion.",
        "createdAt": "2021-12-09T08:23:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-989619476"
      },
      {
        "id": "IC_kwDOAQzde848VuBt",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@leastprivilege \r\n\r\n\u003E \u0022lax on receive\u0022 ...\r\nYeah, serious about this, i don\u0027t think it\u0027s an interesting conversation.\r\n\r\nWe have made progress on using System.Text.Json and we are investing in separating AAD requirements into its own layer.\r\n  \r\n\r\n ",
        "createdAt": "2022-01-13T16:59:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-1012326509"
      },
      {
        "id": "IC_kwDOAQzde85NVKAL",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-10-31T17:00:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-1297391627"
      },
      {
        "id": "IC_kwDOAQzde85VfbMG",
        "parentId": null,
        "author": "leastprivilege",
        "content": "Just stumbled over this - over one year later. \r\n\r\nMaybe I am wrong - but it seems the situation has not improved in any way...",
        "createdAt": "2023-02-17T08:37:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36175#issuecomment-1434301190"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde847jMHF",
    "title": "Make AuthorizationMiddlewareResultHandler.HandleAsync virtual",
    "url": "https://github.com/dotnet/aspnetcore/issues/36645",
    "createdAt": "2021-09-17T08:18:01Z",
    "lastUpdated": "2021-09-17T20:06:03Z",
    "body": "## Background and Motivation\r\n\r\nIn the official documentation [example](\r\nhttps://docs.microsoft.com/en-us/aspnet/core/security/authorization/customizingauthorizationmiddlewareresponse?view=aspnetcore-5.0) on how to handle special cases in AuthorizationMiddleware have this code to extended the default \u0060IAuthorizationMiddlewareResultHandler\u0060 : \r\n\r\n\u0060\u0060\u0060c#\r\npublic class MyAuthorizationMiddlewareResultHandler : IAuthorizationMiddlewareResultHandler\r\n{\r\n    private readonly AuthorizationMiddlewareResultHandler DefaultHandler = new AuthorizationMiddlewareResultHandler();\r\n    \r\n    public async Task HandleAsync(\r\n        RequestDelegate requestDelegate,\r\n        HttpContext httpContext,\r\n        AuthorizationPolicy authorizationPolicy,\r\n        PolicyAuthorizationResult policyAuthorizationResult)\r\n    { \r\n        ...\r\n        // Fallback to the default implementation.\r\n        await DefaultHandler.HandleAsync(requestDelegate, httpContext, authorizationPolicy, \r\n                               policyAuthorizationResult);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n## Proposed API\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.AspNetCore.Authorization.Policy\r\n{\r\n    public class AuthorizationMiddlewareResultHandler : IAuthorizationMiddlewareResultHandler\r\n    {\r\n        /// \u003Cinheritdoc /\u003E\r\n        public virtual async Task HandleAsync(RequestDelegate next, HttpContext context, AuthorizationPolicy policy, PolicyAuthorizationResult authorizeResult)\r\n        {\r\n            ...\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n## Usage Examples\r\n\r\n\u0060\u0060\u0060 C#\r\npublic class MyAuthorizationMiddlewareResultHandler : AuthorizationMiddlewareResultHandler\r\n{\r\n    public override async Task HandleAsync(\r\n        RequestDelegate requestDelegate,\r\n        HttpContext httpContext,\r\n        AuthorizationPolicy authorizationPolicy,\r\n        PolicyAuthorizationResult policyAuthorizationResult)\r\n    { \r\n        ...\r\n        // Fallback to the default implementation.\r\n        await base.HandleAsync(requestDelegate, httpContext, authorizationPolicy, \r\n                               policyAuthorizationResult);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n## Risks\r\n\r\nI can\u0027t see any, maybe some performance regression if JIT can devirtualize the first scenario but not the second ?",
    "upvotes": 0,
    "labels": [
      "area-auth",
      "api-suggestion"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde8429WBK",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Triage: moving this to backlog. We may consider this if we get more feedback requesting it.",
        "createdAt": "2021-09-17T20:05:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36645#issuecomment-922050634"
      },
      {
        "id": "IC_kwDOAQzde8429WDQ",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-09-17T20:06:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36645#issuecomment-922050768"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde84-7w3U",
    "title": "TaskCanceled Exception thrown from  Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler class",
    "url": "https://github.com/dotnet/aspnetcore/issues/38467",
    "createdAt": "2021-11-17T08:38:09Z",
    "lastUpdated": "2024-09-10T19:32:53Z",
    "body": "Dear all,\r\n\r\nWe have a .NET Core Web API service which makes use of the Authentication middleware readily available with .NET 5.0. In our service we have registered 4 different jwt bearer authentication schemes on startup of the service, (why? - that\u0027s because we are in the process of migrating from two older identity providers to two newer ones. For example, we are migrating from Azure AD V1 auth endpoints to the Microsoft Identity Platform (V2)). \r\n\r\nIn a number of our deployments we see TaskCanceled exceptions with the below stack trace, when certain api\u0027s are called. The api\u0027s are all protected by an [Authorize] attribute which makes use of the aforementioned auth schemes that are registered at startup\r\n\r\nDetails of the service:\r\nSDK version: .NET 5.0.401\r\nBase docker image: mcr.microsoft.com/dotnet/aspnet:5.0.10\r\n\r\n We always seem to have 2 of these exceptions thrown simultaeneously:\r\n\r\n\u0060\u0060\u0060\r\nSystem.Threading.Tasks.TaskCanceledException:\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at Microsoft.IdentityModel.Protocols.ConfigurationManager\u00601\u002B\u003CGetConfigurationAsync\u003Ed__24.MoveNext (Microsoft.IdentityModel.Protocols, Version=6.7.1.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35)\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler\u002B\u003CHandleAuthenticateAsync\u003Ed__6.MoveNext (Microsoft.AspNetCore.Authentication.JwtBearer, Version=5.0.10.0, Culture=neutral, PublicKeyToken=adb9793829ddae60)\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler\u002B\u003CHandleAuthenticateAsync\u003Ed__6.MoveNext (Microsoft.AspNetCore.Authentication.JwtBearer, Version=5.0.10.0, Culture=neutral, PublicKeyToken=adb9793829ddae60)\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at Microsoft.AspNetCore.Authentication.AuthenticationHandler\u00601\u002B\u003CAuthenticateAsync\u003Ed__48.MoveNext (Microsoft.AspNetCore.Authentication, Version=5.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60)\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at Microsoft.AspNetCore.Authentication.AuthenticationService\u002B\u003CAuthenticateAsync\u003Ed__14.MoveNext (Microsoft.AspNetCore.Authentication.Core, Version=5.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60)\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at Microsoft.AspNetCore.Authorization.Policy.PolicyEvaluator\u002B\u003CAuthenticateAsync\u003Ed__2.MoveNext (Microsoft.AspNetCore.Authorization.Policy, Version=5.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60)\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware\u002B\u003CInvoke\u003Ed__6.MoveNext (Microsoft.AspNetCore.Authorization.Policy, Version=5.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60)\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware\u002B\u003CInvoke\u003Ed__6.MoveNext (Microsoft.AspNetCore.Authentication, Version=5.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60)\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at Startup\u002B\u003C\u003Ec\u002B\u003C\u003CConfigure\u003Eb__9_0\u003Ed.MoveNext\r\n   \u0060\u0060\u0060\r\n   \r\n   And the second exception stack trace:\r\n   \r\n\u0060\u0060\u0060\r\n  System.Threading.Tasks.TaskCanceledException:\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at Microsoft.IdentityModel.Protocols.ConfigurationManager\u00601\u002B\u003CGetConfigurationAsync\u003Ed__24.MoveNext (Microsoft.IdentityModel.Protocols, Version=6.7.1.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35)\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler\u002B\u003CHandleAuthenticateAsync\u003Ed__6.MoveNext (Microsoft.AspNetCore.Authentication.JwtBearer, Version=5.0.10.0, Culture=neutral, PublicKeyToken=adb9793829ddae60)\r\n\u0060\u0060\u0060\r\n   \r\n   The troublesome thing is that I can\u0027t seem to reproduce this error intentionally. We set up suitable load tests to test the affected api\u0027s, but we don\u0027t seem to be able to reproduce the failures as part of the load tests, but the errors keep happening in the same environments. As far as I can tell we have configured the middleware correctly as for the majority of our calls we are able to authenticate and authorize correctly (we have automated tests testing various scenarios).\r\n   \r\n   But in certain sporadic cases, we get these exceptions.  ",
    "upvotes": 5,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde84567l6",
        "parentId": null,
        "author": "Tratcher",
        "content": "Those look like they\u0027re coming from this line:\r\nhttps://github.com/dotnet/aspnetcore/blob/c6a270f7ddcc45e4ba6884ef72ffc28a54d76e51/src/Security/Authentication/JwtBearer/src/JwtBearerHandler.cs#L95\r\n\r\nThe CancellationToken passed in is HttpContext.RequestAborted which fires if the client disconnects mid operation. If you enable debug level server logs you should see other disconnect related logs around this. Do you have clients that are prone to disconnecting?",
        "createdAt": "2021-11-17T16:32:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-971749754"
      },
      {
        "id": "IC_kwDOAQzde8459vBG",
        "parentId": null,
        "author": "karun-verghese",
        "content": "@Tratcher thanks for the reply, I am still trying to determine this at the time of typing this message. Thanks for the tip on the debug logs, I will come back if I can find anything. Do you know if there\u0027s a way I can simulate a client that disconnects in the middle of the api call?",
        "createdAt": "2021-11-18T03:24:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-972484678"
      },
      {
        "id": "IC_kwDOAQzde845-BjT",
        "parentId": null,
        "author": "Tratcher",
        "content": "You can make the API call with a client like HttpClient or Curl and then cancel it.",
        "createdAt": "2021-11-18T05:53:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-972560595"
      },
      {
        "id": "IC_kwDOAQzde845-B6r",
        "parentId": null,
        "author": "karun-verghese",
        "content": "@Tratcher thanks, I did something similar, but I had to adjust the response timeout on my client to 20ms to cancel it and see this error. I am now able to reproduce the error. So am I right in understanding that this is expected behaviour right? The cancellation token is being invoked as the client has cancelled the request? \r\n\r\nCan you point me to any articles/resources on how to better handle this scenario? Maybe I need to configure a custom delegate for the OnAuthenticationFailed event while registering my authentication scheme?",
        "createdAt": "2021-11-18T05:57:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-972562091"
      },
      {
        "id": "IC_kwDOAQzde845-CkL",
        "parentId": null,
        "author": "Tratcher",
        "content": "This is expected behavior, and the exception is mainly noise in the app since the client has already disconnected. I\u0027ll talk to @blowdart and we\u0027ll see what we can do to avoid that.",
        "createdAt": "2021-11-18T06:03:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-972564747"
      },
      {
        "id": "IC_kwDOAQzde846FUYl",
        "parentId": null,
        "author": "blowdart",
        "content": "Less noise is good",
        "createdAt": "2021-11-19T21:06:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-974472741"
      },
      {
        "id": "IC_kwDOAQzde846FUZ4",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 7 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2021-11-19T21:07:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-974472824"
      },
      {
        "id": "IC_kwDOAQzde846Kpj3",
        "parentId": null,
        "author": "Tratcher",
        "content": "Options:\r\nA) Don\u0027t pass the RequestAborted CT to GetConfigurationAsync. Config is cached so even if the client disconnects, completing this operation will still have value. We should make sure there\u0027s another timeout though.\r\nB) IdentityModel has some changes in flight to fall back to a last-known-good configuration so validation could proceed even if this call failed.",
        "createdAt": "2021-11-22T19:59:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-975870199"
      },
      {
        "id": "IC_kwDOAQzde85KDu6h",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-09T21:24:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1242492577"
      },
      {
        "id": "IC_kwDOAQzde85V9foC",
        "parentId": null,
        "author": "chungvodim",
        "content": "This piece of code is not locked properly:\r\n\u0060\u0060\u0060\r\npublic override void RequestRefresh()\r\n        {\r\n            DateTimeOffset now = DateTimeOffset.UtcNow;\r\n            if (_isFirstRefreshRequest)\r\n            {\r\n                _syncAfter = now;\r\n                _isFirstRefreshRequest = false;\r\n            }\r\n            else if (now \u003E= DateTimeUtil.Add(_lastRefresh.UtcDateTime, RefreshInterval))\r\n            {\r\n                _syncAfter = now;\r\n            }\r\n        }\r\n\u0060\u0060\u0060\r\nSo if the condition \u0060(now \u003E= DateTimeUtil.Add(_lastRefresh.UtcDateTime, RefreshInterval))\u0060 is satisfied =\u003E  \u0060_syncAfter = now\u0060\r\nThis reset will allow awaiting threads that are trying to invoke the function \u0060GetConfigurationAsync\u0060 to call \u0060await _configRetriever.GetConfigurationAsync\u0060.",
        "createdAt": "2023-02-23T17:44:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1442183682"
      },
      {
        "id": "IC_kwDOAQzde85V9gz3",
        "parentId": null,
        "author": "chungvodim",
        "content": "- RequestRefresh: https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/9e6f90a9a8032107af6f5c851e9d257f4c6c8fdc/src/Microsoft.IdentityModel.Protocols/Configuration/ConfigurationManager.cs#L187-L199\r\n- GetConfigurationAsync : https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/9e6f90a9a8032107af6f5c851e9d257f4c6c8fdc/src/Microsoft.IdentityModel.Protocols/Configuration/ConfigurationManager.cs#L125-L166",
        "createdAt": "2023-02-23T17:48:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1442188535"
      },
      {
        "id": "IC_kwDOAQzde85V9iqv",
        "parentId": null,
        "author": "Tratcher",
        "content": "@chungvodim that doesn\u0027t seem related to this issue? Please open a new issue in AzureAd.\r\n\r\nI think I see how this could cause duplicate refreshes, but does that break anything?",
        "createdAt": "2023-02-23T17:54:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1442196143"
      },
      {
        "id": "IC_kwDOAQzde85V9m-6",
        "parentId": null,
        "author": "chungvodim",
        "content": "Hi @Tratcher , we\u0027re facing this issue\r\n\u0060\u0060\u0060System.OperationCanceledException: The operation was canceled.\r\n   at System.Threading.CancellationToken.ThrowOperationCanceledException()\r\n   at System.Threading.SemaphoreSlim.WaitUntilCountOrTimeoutAsync(TaskNode asyncWaiter, Int32 millisecondsTimeout, CancellationToken cancellationToken)\r\n   at Microsoft.IdentityModel.Protocols.ConfigurationManager\u00601.GetConfigurationAsync(CancellationToken cancel)\r\n   at Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler.HandleAuthenticateAsync()\r\n\u0060\u0060\u0060\r\nand\r\n\u0060\u0060\u0060\r\nSystem.OperationCanceledException: The operation was canceled.\r\n   at void System.Threading.CancellationToken.ThrowOperationCanceledException()\r\n   at async Task\u003Cbool\u003E System.Threading.SemaphoreSlim.WaitUntilCountOrTimeoutAsync(TaskNode asyncWaiter, int millisecondsTimeout, CancellationToken cancellationToken)\r\n   at async Task\u003CT\u003E Microsoft.IdentityModel.Protocols.ConfigurationManager\u003CT\u003E.GetConfigurationAsync(CancellationToken cancel)\r\n   at async Task\u003CAuthenticateResult\u003E Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler.HandleAuthenticateAsync() x 2\r\n   at async Task\u003CAuthenticateResult\u003E Microsoft.AspNetCore.Authentication.AuthenticationHandler\u003CTOptions\u003E.AuthenticateAsync()\r\n   at async Task\u003CAuthenticateResult\u003E Microsoft.AspNetCore.Authentication.AuthenticationService.AuthenticateAsync(HttpContext context, string scheme)\r\n   at async Task Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)\r\n   at async Task Microsoft.AspNetCore.ResponseCompression.ResponseCompressionMiddleware.Invoke(HttpContext context)\r\n\u0060\u0060\u0060",
        "createdAt": "2023-02-23T18:07:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1442213818"
      },
      {
        "id": "IC_kwDOAQzde85V9qjX",
        "parentId": null,
        "author": "Tratcher",
        "content": "So you\u0027re experiencing the original issue which is normally caused by a canceled client request, but how does the thread safety affect that? Worst case you\u0027d get multiple refreshes happening in parallel, they\u0027d all still be subject to the cancellation issue.",
        "createdAt": "2023-02-23T18:20:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1442228439"
      },
      {
        "id": "IC_kwDOAQzde85V9vrH",
        "parentId": null,
        "author": "chungvodim",
        "content": "If there are too many awaiting requests due to the lock \u0060await _refreshLock.WaitAsync(cancel).ConfigureAwait(false);\u0060 of the function [GetConfigurationAsync](https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/9e6f90a9a8032107af6f5c851e9d257f4c6c8fdc/src/Microsoft.IdentityModel.Protocols/Configuration/ConfigurationManager.cs#L125-L166) =\u003E System.Threading.SemaphoreSlim.WaitUntilCountOrTimeoutAsync will throw OperationCanceledException. \r\nIf the \u0060_syncAfter\u0060 variable is not reset to \u0060now\u0060 by the function [RequestRefresh](https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/9e6f90a9a8032107af6f5c851e9d257f4c6c8fdc/src/Microsoft.IdentityModel.Protocols/Configuration/ConfigurationManager.cs#L187-L199) so it doesn\u0027t matter at all. But if _syncAfter is continuously reset to \u0060now\u0060 (due to failed authorized requests) =\u003E Every threads that accesses the \u0060_refreshLock\u0060 will invoke \u0060await _configRetriever.GetConfigurationAsync\u0060. \r\nAssuming each external call takes 1 second =\u003E the 60th thread must wait 60 seconds.",
        "createdAt": "2023-02-23T18:35:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1442249415"
      },
      {
        "id": "IC_kwDOAQzde85V-IdC",
        "parentId": null,
        "author": "Tratcher",
        "content": "RequestRefresh is supposed to update _syncAfter. Any request after that gets queued waiting for new config. That\u0027s by design, though there\u0027s some plans to allow requests to continue with the last known good config.\r\n\r\nOne place I see that could be improved is here:\r\nhttps://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/9e6f90a9a8032107af6f5c851e9d257f4c6c8fdc/src/Microsoft.IdentityModel.Protocols/Configuration/ConfigurationManager.cs#L136-L143\r\nRight now it assumes the _refreshLock is acquired quickly and \u0060now\u0060 still current. However, if the refresh takes too long and/or there\u0027s lock contention, then \u0060now\u0060 could be outdated. \u0060now should be updated inside the lock (line 136), and again after the refresh finishes (line 143). Once the refresh completes that should help all other requests waiting on the lock to quickly exit.\r\n\r\nThe only other thing that could be changed is to protect RequestRefresh with _refreshLock, but that risks blocking threads that don\u0027t really need to wait for the refresh to happen.",
        "createdAt": "2023-02-23T19:54:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1442350914"
      },
      {
        "id": "IC_kwDOAQzde85V-Si3",
        "parentId": null,
        "author": "chungvodim",
        "content": "- \u0060now should be updated inside the lock (line 136)\u0060 \u003C= I absolutely agree with this great idea.\r\n- \u0060The only other thing that could be changed is to protect RequestRefresh with _refreshLock, but that risks blocking threads that don\u0027t really need to wait for the refresh to happen\u0060 \u003C= Thanks for your call out",
        "createdAt": "2023-02-23T20:31:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1442392247"
      },
      {
        "id": "IC_kwDOAQzde85V-djd",
        "parentId": null,
        "author": "Tratcher",
        "content": "Can you open an issue in https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/?",
        "createdAt": "2023-02-23T21:10:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1442437341"
      },
      {
        "id": "IC_kwDOAQzde85V-lEp",
        "parentId": null,
        "author": "chungvodim",
        "content": "\u003E Can you open an issue in https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/?\r\n\r\nSure.",
        "createdAt": "2023-02-23T21:41:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1442468137"
      },
      {
        "id": "IC_kwDOAQzde85XJP_s",
        "parentId": null,
        "author": "GKersten",
        "content": "We are facing the same issue as mentioned here. Having multiple endpoints that get called simultaneously, not able yet to get an intentional reproduction. However from deployed environment able to get these logs\r\n\r\n\u0060\u0060\u0060\u0060\r\nEROR   :    Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler   \r\n         Exception occurred while processing message.   \r\n            System.OperationCanceledException: The operation was canceled.\r\n         at System.Threading.CancellationToken.ThrowOperationCanceledException()\r\n         at System.Threading.SemaphoreSlim.WaitUntilCountOrTimeoutAsync(TaskNode asyncWaiter, Int32 millisecondsTimeout, CancellationToken cancellationToken)\r\n         at Microsoft.IdentityModel.Protocols.ConfigurationManager\u00601.GetConfigurationAsync(CancellationToken cancel)\r\n         at Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler.HandleAuthenticateAsync()   \r\n   EROR   :    Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler   \r\n         Exception occurred while processing message.   \r\n            System.OperationCanceledException: The operation was canceled.\r\n         at System.Threading.CancellationToken.ThrowOperationCanceledException()\r\n         at System.Threading.SemaphoreSlim.WaitUntilCountOrTimeoutAsync(TaskNode asyncWaiter, Int32 millisecondsTimeout, CancellationToken cancellationToken)\r\n         at Microsoft.IdentityModel.Protocols.ConfigurationManager\u00601.GetConfigurationAsync(CancellationToken cancel)\r\n         at Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler.HandleAuthenticateAsync()   \r\n   EROR   :    Microsoft.AspNetCore.Server.Kestrel   \r\n         Connection id \u00220HMOHKGT911S1\u0022, Request id \u00220HMOHKGT911S1:00000004\u0022: An unhandled exception was thrown by the application.   \r\n            System.OperationCanceledException: The operation was canceled.\r\n         at System.Threading.CancellationToken.ThrowOperationCanceledException()\r\n         at System.Threading.SemaphoreSlim.WaitUntilCountOrTimeoutAsync(TaskNode asyncWaiter, Int32 millisecondsTimeout, CancellationToken cancellationToken)\r\n         at Microsoft.IdentityModel.Protocols.ConfigurationManager\u00601.GetConfigurationAsync(CancellationToken cancel)\r\n         at Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler.HandleAuthenticateAsync()\r\n         at Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler.HandleAuthenticateAsync()\r\n         at Microsoft.AspNetCore.Authentication.AuthenticationHandler\u00601.AuthenticateAsync()\r\n         at Microsoft.AspNetCore.Authentication.AuthenticationService.AuthenticateAsync(HttpContext context, String scheme)\r\n         at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)\r\n         at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequests[TContext](IHttpApplication\u00601 application)   \r\n   EROR   :    Microsoft.AspNetCore.Server.Kestrel   \r\n         Connection id \u00220HMOHKGT911SH\u0022, Request id \u00220HMOHKGT911SH:00000001\u0022: An unhandled exception was thrown by the application.   \r\n            System.OperationCanceledException: The operation was canceled.\r\n         at System.Threading.CancellationToken.ThrowOperationCanceledException()\r\n         at System.Threading.SemaphoreSlim.WaitUntilCountOrTimeoutAsync(TaskNode asyncWaiter, Int32 millisecondsTimeout, CancellationToken cancellationToken)\r\n         at Microsoft.IdentityModel.Protocols.ConfigurationManager\u00601.GetConfigurationAsync(CancellationToken cancel)\r\n         at Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler.HandleAuthenticateAsync()\r\n         at Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler.HandleAuthenticateAsync()\r\n         at Microsoft.AspNetCore.Authentication.AuthenticationHandler\u00601.AuthenticateAsync()\r\n         at Microsoft.AspNetCore.Authentication.AuthenticationService.AuthenticateAsync(HttpContext context, String scheme)\r\n         at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)\r\n         at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequests[TContext](IHttpApplication\u00601 application)   \r\n   EROR   :    Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler   \r\n         Exception occurred while processing message.   \r\n            System.OperationCanceledException: The operation was canceled.\r\n         at System.Threading.CancellationToken.ThrowOperationCanceledException()\r\n         at System.Threading.SemaphoreSlim.WaitUntilCountOrTimeoutAsync(TaskNode asyncWaiter, Int32 millisecondsTimeout, CancellationToken cancellationToken)\r\n         at Microsoft.IdentityModel.Protocols.ConfigurationManager\u00601.GetConfigurationAsync(CancellationToken cancel)\r\n         at Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler.HandleAuthenticateAsync()   \r\n   EROR   :    Microsoft.AspNetCore.Server.Kestrel   \r\n         Connection id \u00220HMOHKGT911SI\u0022, Request id \u00220HMOHKGT911SI:00000001\u0022: An unhandled exception was thrown by the application.   \r\n            System.OperationCanceledException: The operation was canceled.\r\n         at System.Threading.CancellationToken.ThrowOperationCanceledException()\r\n         at System.Threading.SemaphoreSlim.WaitUntilCountOrTimeoutAsync(TaskNode asyncWaiter, Int32 millisecondsTimeout, CancellationToken cancellationToken)\r\n         at Microsoft.IdentityModel.Protocols.ConfigurationManager\u00601.GetConfigurationAsync(CancellationToken cancel)\r\n         at Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler.HandleAuthenticateAsync()\r\n         at Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler.HandleAuthenticateAsync()\r\n         at Microsoft.AspNetCore.Authentication.AuthenticationHandler\u00601.AuthenticateAsync()\r\n         at Microsoft.AspNetCore.Authentication.AuthenticationService.AuthenticateAsync(HttpContext context, String scheme)\r\n         at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)\r\n         at Microsoft.AspNetCore.Server.Kestrel.Core.Internal.Http.HttpProtocol.ProcessRequests[TContext](IHttpApplication\u00601 application)\r\n\u0060\u0060\u0060\u0060\r\n\r\nAs far as I understand from above thread, this seems to be noise (so can be ignored).\r\n\r\nIs there a suggested way of catching these exceptions or filtering them out? As a work-around until this issue is gone, we would like to keep our logs clean of this noise where possible.\r\n",
        "createdAt": "2023-03-09T13:11:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1462042604"
      },
      {
        "id": "IC_kwDOAQzde85djQck",
        "parentId": null,
        "author": "dzendras",
        "content": "We also seem to be affected by this.\r\n\u0060\u0060\u0060\r\nSystem.Threading.Tasks.TaskCanceledException:\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.ConfiguredTaskAwaitable\u002BConfiguredTaskAwaiter.GetResult (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at Microsoft.IdentityModel.Protocols.ConfigurationManager\u00601\u002B\u003CGetConfigurationAsync\u003Ed__14.MoveNext (Microsoft.IdentityModel.Protocols, Version=6.25.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35)\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler\u002B\u003CHandleAuthenticateAsync\u003Ed__6.MoveNext (Microsoft.AspNetCore.Authentication.JwtBearer, Version=5.0.12.0, Culture=neutral, PublicKeyToken=adb9793829ddae60)\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at Microsoft.AspNetCore.Authentication.JwtBearer.JwtBearerHandler\u002B\u003CHandleAuthenticateAsync\u003Ed__6.MoveNext (Microsoft.AspNetCore.Authentication.JwtBearer, Version=5.0.12.0, Culture=neutral, PublicKeyToken=adb9793829ddae60)\r\n   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at System.Runtime.CompilerServices.TaskAwaiter\u00601.GetResult (System.Private.CoreLib, Version=6.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e)\r\n   at Microsoft.AspNetCore.Authentication.AuthenticationHandler\u00601\u002B\u003CAuthenticateAsync\u003Ed__48.MoveNext (Microsoft.AspNetCore.Authentication, Version=6.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60)\r\n\u0060\u0060\u0060\r\n\r\nI understand that it\u0027s only noise, but it triggers an http server errors alert for us in Azure. The linked issue is closed and I am not sure why. Has the issue been mitigated or is there any known workaround?",
        "createdAt": "2023-05-31T05:34:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1569523492"
      },
      {
        "id": "IC_kwDOAQzde85h2Rnt",
        "parentId": null,
        "author": "gregolsky",
        "content": "In another issue (https://github.com/dotnet/aspnetcore/issues/43220) @Tratcher mentioned mitigation is to pre-init the configuration at startup. Can you explain how do you do that please?",
        "createdAt": "2023-07-19T08:04:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1641617901"
      },
      {
        "id": "IC_kwDOAQzde85jD-Pr",
        "parentId": null,
        "author": "gregolsky",
        "content": "I mean the comment here: https://github.com/dotnet/aspnetcore/issues/43220#issuecomment-1218553342\r\n\r\n\u003E The mitigation is to pre-init and load the ConfigurationManager during startup.\r\n\r\n@Tratcher could you help us please?\r\n",
        "createdAt": "2023-08-02T10:48:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1661985771"
      },
      {
        "id": "IC_kwDOAQzde85jFTrM",
        "parentId": null,
        "author": "chungvodim",
        "content": "\u003E I mean the comment here: [#43220 (comment)](https://github.com/dotnet/aspnetcore/issues/43220#issuecomment-1218553342)\r\n\u003E \r\n\u003E \u003E The mitigation is to pre-init and load the ConfigurationManager during startup.\r\n\u003E \r\n\u003E @Tratcher could you help us please?\r\n\r\nCould you share your configuration?",
        "createdAt": "2023-08-02T14:39:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1662335692"
      },
      {
        "id": "IC_kwDOAQzde85jKhFB",
        "parentId": null,
        "author": "gregolsky",
        "content": "We just use the defaults in \u0060Startup.cs\u0060:\r\n\u0060\u0060\u0060\r\nservices.AddJwtBearerDefaultAuthentication(settings.IdentityServerAudience, Environment);\r\n\u0060\u0060\u0060\r\n\r\nIn the settings it has 3 things passed: \u0022ValidAudience\u0022, \u0022TokenIssuer\u0022 and \u0022IdentityServerBaseUrl\u0022.\r\n\r\nIs that what you were looking for @chungvodim ?",
        "createdAt": "2023-08-03T10:03:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1663701313"
      },
      {
        "id": "IC_kwDOAQzde85jMpsj",
        "parentId": null,
        "author": "chungvodim",
        "content": "\u003E AddJwtBearerDefaultAuthentication\r\n\r\nSomething likes this \r\n![image](https://github.com/dotnet/aspnetcore/assets/2534578/786b8caa-3f86-47a8-96ba-edebaa2cdc26)\r\n",
        "createdAt": "2023-08-03T16:10:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1664260899"
      },
      {
        "id": "IC_kwDOAQzde85jRF6K",
        "parentId": null,
        "author": "gregolsky",
        "content": "@chungvodim Ah, gotcha, that was an extension method we have there, nevermind. \r\n\r\nFound the config part:\r\n\u0060\u0060\u0060\r\noptions.Authority = settings.IdentityServerBaseUrl;\r\noptions.RequireHttpsMetadata = environment.IsProduction();\r\noptions.TokenValidationParameters = new TokenValidationParameters\r\n{\r\n    ValidateAudience = true,\r\n    ValidAudience = settings.ValidAudience,\r\n    ValidateIssuer = true,\r\n    ValidIssuer = settings.TokenIssuer,\r\n    RequireSignedTokens = true,\r\n    ClockSkew = TimeSpan.FromMinutes(1),\r\n    ValidateLifetime = true,\r\n    ValidateIssuerSigningKey = true\r\n};\r\n\u0060\u0060\u0060\r\n\r\nI think we use the defaults mostly for this particular app. What should we do?\r\nShould we initialize \u0060ConfigurationManager\u0060 in a way you have in your screenshot?",
        "createdAt": "2023-08-04T10:58:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1665425034"
      },
      {
        "id": "IC_kwDOAQzde85jSdw5",
        "parentId": null,
        "author": "chungvodim",
        "content": "\u003E GetConfigurationAsync\r\n\r\nIf not provided, then one will be created using the MetadataAddress and Backchannel properties. So you should explicitly initialize \u0060ConfigurationManager\u0060 .\r\nBasically, this issue could not be fixed thoroughly, you can only mitigate it by increasing \u0060RefreshInterval\u0060 and \u0060AutomaticRefreshInterval\u0060 to an appropriate number (I\u0027m setting 5 minutes and 12 minutes accordingly).",
        "createdAt": "2023-08-04T15:25:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1665784889"
      },
      {
        "id": "IC_kwDOAQzde85jcqZ1",
        "parentId": null,
        "author": "Tratcher",
        "content": "Creating the ConfigurationManager at startup only helps with the cancellation issue unless you actually call it while starting the server. That way it\u0027s pulling from the local cache per-request until a refresh is needed.\r\n\r\n\u0060\u0060\u0060c#\r\nvar configManager = new ConfigurationManager....;\r\nawait configManager.GetConfigurationAsync(); // Wait for the first config download\r\noptions.ConfigurationManager = configManager;\r\n\u0060\u0060\u0060\r\n",
        "createdAt": "2023-08-07T19:28:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-1668458101"
      },
      {
        "id": "IC_kwDOAQzde86HhuXQ",
        "parentId": null,
        "author": "DinantvanHarmelen-Bryder",
        "content": "We are experiencing this issue in production (Azure) as well on at least 2 different Dot Net 6.0 Web API\u0027s, but its not noise. \r\n3th party developers are now contacting us, because our API\u0027s can now take up to 60 seconds to respond.\r\nI have clear evidence (profiler trace from Application Insights) pointing towards this issue but it is not on startup but randomly happens when running. We have multiple API\u0027s running and this issue is now affecting us and 3th party users of our API\u0027s. \r\n\r\n- When can we expect this issue to be resolved (it now has been open for 3 years) \r\n- Is the workaround mentioned by @Tratcher enough to prevent this from happening or do we need to \r\nset the \u0060RefreshInterval\u0060 and \u0060AutomaticRefreshInterval\u0060 mentioned by @chungvodim aswell?\r\n\r\n![image](https://github.com/user-attachments/assets/3a0e778a-1132-490e-bd55-59be284bd0ac)",
        "createdAt": "2024-08-07T15:37:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-2273764816"
      },
      {
        "id": "IC_kwDOAQzde86Hmrk_",
        "parentId": null,
        "author": "dzendras",
        "content": "Here\u0027s a workaround I use and the issue has practically been resolved.\r\nPlace it **before** app.UseAuthentication(); in your Program file and no exception is going to bother you anymore :) \r\n\r\n\u0060\u0060\u0060\r\nclass ExpectedOperationCanceledExceptionSupressionMiddleware\r\n{\r\n    private readonly RequestDelegate next;\r\n    private readonly ILogger\u003CExpectedOperationCanceledExceptionSupressionMiddleware\u003E logger;\r\n\r\n    public ExpectedOperationCanceledExceptionSupressionMiddleware(RequestDelegate next, ILogger\u003CExpectedOperationCanceledExceptionSupressionMiddleware\u003E logger)\r\n    {\r\n        this.next = next;\r\n        this.logger = logger;\r\n    }\r\n\r\n    public async Task Invoke(HttpContext context)\r\n    {\r\n        try\r\n        {\r\n            await this.next(context);\r\n        }\r\n        catch (OperationCanceledException e) when (IsExpectedDueToAnUnresolvedBugInIdentityModel(e, context))\r\n        {\r\n            this.logger.LogWarning(\r\n                \u0022Compensating for a bug in IdentityModel. Request to \u0027{RequestPath}\u0027 has already been aborted, so nothing to worry about.\u0022,\r\n                context.Request.Path);\r\n        }\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// https://github.com/dotnet/aspnetcore/issues/38467\r\n    /// \u003C/summary\u003E\r\n    private static bool IsExpectedDueToAnUnresolvedBugInIdentityModel(OperationCanceledException e, HttpContext context) =\u003E\r\n        e.CancellationToken == context.RequestAborted \u0026\u0026\r\n        e.StackTrace != null \u0026\u0026\r\n        e.StackTrace.Contains(\u0022GetConfigurationAsync\u0022);\r\n}\r\n\u0060\u0060\u0060",
        "createdAt": "2024-08-08T06:40:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-2275064127"
      },
      {
        "id": "IC_kwDOAQzde86IICiZ",
        "parentId": null,
        "author": "DinantvanHarmelen-Bryder",
        "content": "\u003E Here\u0027s a workaround I use and the issue has practically been resolved. Place it **before** app.UseAuthentication(); in your Program file and no exception is going to bother you anymore :)\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E class ExpectedOperationCanceledExceptionSupressionMiddleware\r\n\u003E {\r\n\u003E     private readonly RequestDelegate next;\r\n\u003E     private readonly ILogger\u003CExpectedOperationCanceledExceptionSupressionMiddleware\u003E logger;\r\n\u003E \r\n\u003E     public ExpectedOperationCanceledExceptionSupressionMiddleware(RequestDelegate next, ILogger\u003CExpectedOperationCanceledExceptionSupressionMiddleware\u003E logger)\r\n\u003E     {\r\n\u003E         this.next = next;\r\n\u003E         this.logger = logger;\r\n\u003E     }\r\n\u003E \r\n\u003E     public async Task Invoke(HttpContext context)\r\n\u003E     {\r\n\u003E         try\r\n\u003E         {\r\n\u003E             await this.next(context);\r\n\u003E         }\r\n\u003E         catch (OperationCanceledException e) when (IsExpectedDueToAnUnresolvedBugInIdentityModel(e, context))\r\n\u003E         {\r\n\u003E             this.logger.LogWarning(\r\n\u003E                 \u0022Compensating for a bug in IdentityModel. Request to \u0027{RequestPath}\u0027 has already been aborted, so nothing to worry about.\u0022,\r\n\u003E                 context.Request.Path);\r\n\u003E         }\r\n\u003E     }\r\n\u003E \r\n\u003E     /// \u003Csummary\u003E\r\n\u003E     /// https://github.com/dotnet/aspnetcore/issues/38467\r\n\u003E     /// \u003C/summary\u003E\r\n\u003E     private static bool IsExpectedDueToAnUnresolvedBugInIdentityModel(OperationCanceledException e, HttpContext context) =\u003E\r\n\u003E         e.CancellationToken == context.RequestAborted \u0026\u0026\r\n\u003E         e.StackTrace != null \u0026\u0026\r\n\u003E         e.StackTrace.Contains(\u0022GetConfigurationAsync\u0022);\r\n\u003E }\r\n\u003E \u0060\u0060\u0060\r\n\r\nThx for sharing this, but we actually had the delays in our code execution. It is not just delayed ghost logs, but an actual issue.\r\n",
        "createdAt": "2024-08-12T12:13:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38467#issuecomment-2283808921"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85BPWOC",
    "title": "Blazor Server Side AADB2C AllowAnonymous Not working in latest template",
    "url": "https://github.com/dotnet/aspnetcore/issues/39321",
    "createdAt": "2022-01-05T16:41:06Z",
    "lastUpdated": "2024-10-28T22:52:07Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nIn the latest template for Blazor Server Side with Microsoft Identity platform. program.cs has:\r\n\r\n\u0060\u0060\u0060c#\r\nbuilder.Services.AddAuthorization(options =\u003E\r\n{\r\n// By default, all incoming requests will be authorized according to the default policy\r\noptions.FallbackPolicy = options.DefaultPolicy;\r\n});\r\n\u0060\u0060\u0060\r\n\r\nSo now all pages will direct to login. However, if I want to define a landing page that doesn\u0027t require login with\r\n\r\n\u0060@Attribute [Microsoft.AspNetCore.Authorization.AllowAnonymous]\u0060, it doesn\u0027t work. Page still gets redirected to login.\r\n\r\n\r\nMaybe this is related to https://github.com/dotnet/aspnetcore/issues/37064 and dotnet/aspnetcore#23157\r\n\r\n\r\ncc: @guardrex per https://github.com/dotnet/AspNetCore.Docs/issues/24473\r\n\r\n### Expected Behavior\r\n\r\nPages marked with Attribute AllowAnonymous should not be redirected to login if not logged in\r\n\r\n### Steps To Reproduce\r\n\r\n-Start a project with Blazor Server Side with Microsoft Identity Platform.\r\n-Fill in all the required AADB2C configs\r\n-Launch the site to see if AADB2C is setup correctly. clean up (logout)\r\n-go to index.razor or fetchData.razor and add @Attribute [Microsoft.AspNetCore.Authorization.AllowAnonymous]\r\n-Launch site. It still requires AADB2C login on index,razor or fetchData.razor\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n6.0.100\r\n\r\n### Anything else?\r\n\r\n_No response_",
    "upvotes": 5,
    "labels": [
      "bug",
      "area-auth",
      "area-blazor",
      "feature-blazor-server",
      "Pillar: Technical Debt"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde8479QbM",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 7 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-01-05T17:11:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1005913804"
      },
      {
        "id": "IC_kwDOAQzde848FmD1",
        "parentId": null,
        "author": "silentdevnull",
        "content": "Has anyone gotten this to work or have a work around for it? ",
        "createdAt": "2022-01-08T18:39:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1008099573"
      },
      {
        "id": "IC_kwDOAQzde848FmQu",
        "parentId": null,
        "author": "MetaHex",
        "content": "Not I am aware of\n\nGet Outlook for iOS\u003Chttps://aka.ms/o0ukef\u003E\n________________________________\nFrom: silentdevnull ***@***.***\u003E\nSent: Saturday, January 8, 2022 10:39:32 AM\nTo: dotnet/aspnetcore ***@***.***\u003E\nCc: MetaHex ***@***.***\u003E; Author ***@***.***\u003E\nSubject: Re: [dotnet/aspnetcore] Blazor Server Side AADB2C AllowAnonymous Not working in latest template (Issue #39321)\n\n\nHas anyone gotten this to work or have a work around for it?\n\n\u2014\nReply to this email directly, view it on GitHub\u003Chttps://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1008099573\u003E, or unsubscribe\u003Chttps://github.com/notifications/unsubscribe-auth/AWOI5HLOZKBD7N3FNHNNZN3UVCAGJANCNFSM5LKK3NZQ\u003E.\nTriage notifications on the go with GitHub Mobile for iOS\u003Chttps://apps.apple.com/app/apple-store/id1477376905?ct=notification-email\u0026mt=8\u0026pt=524675\u003E or Android\u003Chttps://play.google.com/store/apps/details?id=com.github.android\u0026referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub\u003E.\nYou are receiving this because you authored the thread.Message ID: ***@***.***\u003E\n",
        "createdAt": "2022-01-08T18:41:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1008100398"
      },
      {
        "id": "IC_kwDOAQzde848Rg_-",
        "parentId": null,
        "author": "silentdevnull",
        "content": "@MetaHex Thanks. \r\n\r\nThe only workaround I was able to do was to use two projects and a reverse proxy to route the URL to each project. It is a big pain and I\u0027m still trying to work through some of it, but it is slow working and coming together. \r\n\r\nHopefully, the time will get this fixed fast",
        "createdAt": "2022-01-12T16:24:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1011224574"
      },
      {
        "id": "IC_kwDOAQzde848rV4p",
        "parentId": null,
        "author": "rpskelton2",
        "content": "Modifying _Hosts.chtml and opting into auth worked for me.\r\nhttps://stackoverflow.com/questions/60768399/blazor-using-azure-ad-authentication-allowing-anonymous-access\r\n",
        "createdAt": "2022-01-20T22:48:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1017994793"
      },
      {
        "id": "IC_kwDOAQzde848rehJ",
        "parentId": null,
        "author": "MetaHex",
        "content": "@rpskelton2  I think this was the default case previously. I think MSFT now recommends (at least from their samples) auth to be set by default and allow anonymous on individual pages. ",
        "createdAt": "2022-01-20T23:56:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1018030153"
      },
      {
        "id": "IC_kwDOAQzde848rgPe",
        "parentId": null,
        "author": "rpskelton2",
        "content": "@MetaHex , that\u0027s what I tried first but the AllowAnonymous attribute seemed to be ignored.  (Server Side Blazor)  Whenever I hit my razor page that contained the AllowAnonymous attribute it would redirect me to the Azure login.  If you know of a working sample please pass along! ",
        "createdAt": "2022-01-21T00:09:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1018037214"
      },
      {
        "id": "IC_kwDOAQzde85CmF5n",
        "parentId": null,
        "author": "tjorvenK",
        "content": "Has anyone been able to figure this out?",
        "createdAt": "2022-05-04T12:57:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1117281895"
      },
      {
        "id": "IC_kwDOAQzde85EKJQj",
        "parentId": null,
        "author": "larsholm",
        "content": "Not an actual (or practical) work-around, but we decided to allow anyone to signup in B2C, and instead check for association in our own User table. If user==null then they\u0027re \u0022anonymous\u0022. This will definitely be changed to AllowAnonymous once working.",
        "createdAt": "2022-06-01T11:54:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1143510051"
      },
      {
        "id": "IC_kwDOAQzde85IVjqO",
        "parentId": null,
        "author": "hammypants",
        "content": "This affects even non-Blazor pages. E.g. endpoints and everything MVC.",
        "createdAt": "2022-08-13T00:22:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1213610638"
      },
      {
        "id": "IC_kwDOAQzde85J08Dj",
        "parentId": null,
        "author": "dgiagio",
        "content": "@javiercn @danroth27 I\u0027m evaluating the .NET ecosystem (ASP.NET, Blazor and .NET in general) for our company, and I just got hit with this bug. Unfortunately the workaround (authorize everything \u002B deny specific pages) isn\u0027t sufficient for our requirements.\r\n\r\nSince I\u0027m not familiar with the codebase, if you point me roughly in the right direction I can dig deeper and prepare a PR with a proposed fix. This could be an interesting opportunity to get my feet wet with .NET. Thanks.",
        "createdAt": "2022-09-06T20:24:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1238614243"
      },
      {
        "id": "IC_kwDOAQzde85J3XZE",
        "parentId": null,
        "author": "javiercn",
        "content": "@dgiagio for this particular scenario there are two times that auth plays a role:\r\n* When the _Host.cshtml Razor page is going to be rendered statically on the server.\r\n* When the Index.razor page is rendered on the client.\r\n\r\nFor this to work, you need to support AllowAnonymous on both code paths.\r\n* In the first case to enable the _Host.cshtml page to render.\r\n* In the second to allow the Index.razor to render.\r\n\r\nThe one causing trouble here is likely the _Host.cshtml. In this scenario, I would avoid requiring auth globally as the template does, as that is not what you want.\r\n\r\nIt is easier to declare the things that require authorization than add authorization for everything and then poke holes.\r\n\r\nI do not think there is a bug here, it\u0027s just a complex scenario to implement, hence why I recommend the alternative approach.",
        "createdAt": "2022-09-07T11:12:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1239250500"
      },
      {
        "id": "IC_kwDOAQzde85LnjeE",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-10-05T16:27:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1268660100"
      },
      {
        "id": "IC_kwDOAQzde85MEHIn",
        "parentId": null,
        "author": "brianpursley",
        "content": "\u003E It is easier to declare the things that require authorization than add authorization for everything and then poke holes.\r\n\r\nI guess it depends on your application, but it\u0027s not easier if 99% of your app needs to be secured, and only a single page needs to allow anonymous.\r\n",
        "createdAt": "2022-10-12T13:06:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1276146215"
      },
      {
        "id": "IC_kwDOAQzde85PIqpt",
        "parentId": null,
        "author": "EricEzaM",
        "content": "I added \u0060@attribute [AllowAnonymous]\u0060 to my \u0060_Host.cshtml\u0060, which stopped the redirect but now the connection is broken between the server and the client due to this JS error:\r\n![image](https://user-images.githubusercontent.com/41730826/204023598-8c7132e4-8e35-414d-aa5d-4406ce490090.png)\n\nEdit: ~~So I removed options.FallbackPolicy = options.DefaultPolicy; and then it all worked OK.~~",
        "createdAt": "2022-11-25T16:18:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1327671917"
      },
      {
        "id": "IC_kwDOAQzde85PJ-Qx",
        "parentId": null,
        "author": "MetaHex",
        "content": "@EricEzaM \r\nIf you removed fallback policy, of course it will work.\r\n\r\nThe ask is for the use case that most site requires login, but we also needs some pages that allows anonymous...",
        "createdAt": "2022-11-26T09:36:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1328014385"
      },
      {
        "id": "IC_kwDOAQzde85PJ-ta",
        "parentId": null,
        "author": "EricEzaM",
        "content": "Ah, my apologies, I misunderstood the usage of the Fallback policy. \n\nI agree the problem is frustrating as you do expect the allow anonymous attribute to work with the template as is. ",
        "createdAt": "2022-11-26T09:51:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1328016218"
      },
      {
        "id": "IC_kwDOAQzde85Vxnlv",
        "parentId": null,
        "author": "yandoldonov",
        "content": "I understand this issue is moved to .NET 8 Planning but what do we do with immediate development requirements? i\u0022ve got projects where UI is Blazor Server based and i need to have some components publicly available allowing anonymous access. what do we do?",
        "createdAt": "2023-02-21T20:46:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1439070575"
      },
      {
        "id": "IC_kwDOAQzde85Vxyl2",
        "parentId": null,
        "author": "stefan-helios",
        "content": "\u002B1, same issue here. Just trying to add one endpoint for a B2C connector, guess I\u0027ll go make an azure function instead.",
        "createdAt": "2023-02-21T21:28:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1439115638"
      },
      {
        "id": "IC_kwDOAQzde85Wh2jU",
        "parentId": null,
        "author": "phcd30",
        "content": "I\u0027ve hit this same issue. After a bit of experimenting I can see that AllowAnonymous works in .cshtml pages but not in .razor pages. Definitely seems to be a bug. I\u0027m surprised this isn\u0027t a higher priority, I don\u0027t see how I can proceed with Blazor without creating two seperate applications which is too much overhead. ",
        "createdAt": "2023-03-02T11:25:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1451714772"
      },
      {
        "id": "IC_kwDOAQzde85Wh95R",
        "parentId": null,
        "author": "yandoldonov",
        "content": "@phcd30 I\u0027ve managed an emergency work-around in a vice-versa authentication/authorization pattern, which sucks but does work. basically, the idea is - you make the root accessible for anonymous and then control authorization on a per-page level.\r\n\r\nyou set the anonimous flag in the _Host.cshtml file like so:\r\n\r\n\u0060\u0060\u0060\r\n@page \u0022/\u0022\r\n@using Microsoft.AspNetCore.Components.Web\r\n@using Microsoft.AspNetCore.Authorization\r\n@attribute [AllowAnonymous]\r\n@namespace YourProjectNameSpace.Blazor.Pages\r\n@addTagHelper *, Microsoft.AspNetCore.Mvc.TagHelpers\r\n\r\n\u003C!DOCTYPE html\u003E\r\n\u003Chtml lang=\u0022en\u0022\u003E\r\n\u003Chead\u003E\r\n    \u003Cmeta charset=\u0022utf-8\u0022 /\u003E\r\n    \u003Cmeta name=\u0022viewport\u0022 content=\u0022width=device-width, initial-scale=1.0\u0022 /\u003E\r\n    \u003Cbase href=\u0022~/\u0022 /\u003E\r\n    \u003Clink rel=\u0022stylesheet\u0022 href=\u0022css/bootstrap/bootstrap.min.css\u0022 /\u003E\r\n    \u003Clink href=\u0022css/site.css\u0022 rel=\u0022stylesheet\u0022 /\u003E    \r\n    \u003Clink rel=\u0022icon\u0022 type=\u0022image/png\u0022 href=\u0022favicon.png\u0022/\u003E\r\n    \u003Ccomponent type=\u0022typeof(HeadOutlet)\u0022 render-mode=\u0022ServerPrerendered\u0022 /\u003E\r\n\u003C/head\u003E\r\n\u003Cbody\u003E\r\n    \u003Ccomponent type=\u0022typeof(App)\u0022 render-mode=\u0022ServerPrerendered\u0022 /\u003E\r\n\r\n    \u003Cdiv id=\u0022blazor-error-ui\u0022\u003E\r\n        \u003Cenvironment include=\u0022Staging,Production\u0022\u003E\r\n            An error has occurred. This application may no longer respond until reloaded.\r\n        \u003C/environment\u003E\r\n        \u003Cenvironment include=\u0022Development\u0022\u003E\r\n            An unhandled exception has occurred. See browser dev tools for details.\r\n        \u003C/environment\u003E\r\n        \u003Ca href=\u0022\u0022 class=\u0022reload\u0022\u003EReload\u003C/a\u003E\r\n        \u003Ca class=\u0022dismiss\u0022\u003E\uD83D\uDDD9\u003C/a\u003E\r\n    \u003C/div\u003E\r\n\r\n    \u003Cscript src=\u0022_framework/blazor.server.js\u0022\u003E\u003C/script\u003E\r\n\u003C/body\u003E\r\n\u003C/html\u003E\r\n\u0060\u0060\u0060\r\nbut then in each page you have to control authorization by doing this:\r\n\r\n\u0060\u0060\u0060\r\n@page \u0022/\u0022\r\n@attribute [Authorize]\r\n\u003CPageTitle\u003EIndex\u003C/PageTitle\u003E\r\n\u0060\u0060\u0060\r\nthis works but as i said, this approach really sucks because you HAVE to remember to apply authorisation attribute to EACH page but i am unable to wait and have to move forward with development.\r\n",
        "createdAt": "2023-03-02T11:51:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1451744849"
      },
      {
        "id": "IC_kwDOAQzde85WiPrw",
        "parentId": null,
        "author": "phcd30",
        "content": "Thanks @yandoldonov! I\u0027ll take this approach as well until something is fixed. I can\u0027t believe this has been open for a year so I\u0027m thinking we both must have hit an edge case in our specific use cases. Either that or no-one is using blazor of mixed public and private pages in a normal manner. \r\n\r\nI noticed with AWS Cognito template uses cshtml for their public authentication pages, maybe everyone is just working around this issue silently. \r\n\r\n@yandoldonov are you also using AWS Cognito and \u0027AddOpenIdConnect\u0027",
        "createdAt": "2023-03-02T12:49:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1451817712"
      },
      {
        "id": "IC_kwDOAQzde85WkUo4",
        "parentId": null,
        "author": "dgiagio",
        "content": "Unfortunately my company had to skip Blazor because of this issue. As a CTO, I cannot afford to rely on \u0022authorize everything \u002B deny specific pages only\u0022 if you take security seriously.\r\n\r\nPreviously I\u0027ve also offered help to fix this for .NET in general, but as you can see on the conversation history, it didn\u0027t go well.\r\n\r\nWe\u0027re looking forward to Blazor authentication story improvements. Until then, we\u0027ll use other technologies.",
        "createdAt": "2023-03-02T18:39:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1452362296"
      },
      {
        "id": "IC_kwDOAQzde85Wl9e_",
        "parentId": null,
        "author": "MetaHex",
        "content": "You could take the approach of having different servers and have them redirect. I do that between server side and client side to have best of both world. Looks like that\u0027s future as well\n\nGet Outlook for iOS\u003Chttps://aka.ms/o0ukef\u003E\n________________________________\nFrom: Diego Giagio ***@***.***\u003E\nSent: Thursday, March 2, 2023 10:39:55 AM\nTo: dotnet/aspnetcore ***@***.***\u003E\nCc: MetaHex ***@***.***\u003E; Mention ***@***.***\u003E\nSubject: Re: [dotnet/aspnetcore] Blazor Server Side AADB2C AllowAnonymous Not working in latest template (Issue #39321)\n\n\nUnfortunately my company had to skip Blazor because of this issue. As a CTO, I cannot afford to rely on \u0022authorize everything \u002B deny specific pages only\u0022 if you take security seriously.\n\nPreviously I\u0027ve also offered help to fix this for .NET in general, but as you can see on the conversation history, it didn\u0027t go well.\n\nWe\u0027re looking forward to Blazor authentication story improvements. Until then, we\u0027ll use other technologies.\n\n\u2014\nReply to this email directly, view it on GitHub\u003Chttps://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1452362296\u003E, or unsubscribe\u003Chttps://github.com/notifications/unsubscribe-auth/AWOI5HJYNRU7F37PD77CLMDW2DSPXANCNFSM5LKK3NZQ\u003E.\nYou are receiving this because you were mentioned.Message ID: ***@***.***\u003E\n",
        "createdAt": "2023-03-03T01:09:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1452791743"
      },
      {
        "id": "IC_kwDOAQzde85YwoO1",
        "parentId": null,
        "author": "javiercn",
        "content": "@yandoldonov You can put the \u0060@attribute [Authorize]\u0060 directive within an \u0060_Imports.razor\u0060 file in the Pages directory and that way you would avoid having to set it on every page.\r\n\r\nThat \u002B AllowAnonymous on the _Host.cshtml should do what you want (I believe).",
        "createdAt": "2023-03-29T18:59:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1489142709"
      },
      {
        "id": "IC_kwDOAQzde85Yw6Gq",
        "parentId": null,
        "author": "MetaHex",
        "content": "Hi javier, i think the original ask was [allowanonymous] was broken. I haven\u2019t tested on the latest.\n\nGet Outlook for iOS\u003Chttps://aka.ms/o0ukef\u003E\n________________________________\nFrom: Javier Calvarro Nelson ***@***.***\u003E\nSent: Wednesday, March 29, 2023 12:00:12 PM\nTo: dotnet/aspnetcore ***@***.***\u003E\nCc: MetaHex ***@***.***\u003E; Mention ***@***.***\u003E\nSubject: Re: [dotnet/aspnetcore] Blazor Server Side AADB2C AllowAnonymous Not working in latest template (Issue #39321)\n\n\n@yandoldonov\u003Chttps://github.com/yandoldonov\u003E You can put the @attribute [Authorize] directive within an _Imports.razor file in the Pages directory and that way you would avoid having to set it on every page.\n\nThat \u002B AllowAnonymous on the _Host.cshtml should do what you want (I believe).\n\n\u2014\nReply to this email directly, view it on GitHub\u003Chttps://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1489142709\u003E, or unsubscribe\u003Chttps://github.com/notifications/unsubscribe-auth/AWOI5HNLMTQ2HB3OK7J6MYTW6SBDZANCNFSM5LKK3NZQ\u003E.\nYou are receiving this because you were mentioned.Message ID: ***@***.***\u003E\n",
        "createdAt": "2023-03-29T19:54:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1489215914"
      },
      {
        "id": "IC_kwDOAQzde85kpfBf",
        "parentId": null,
        "author": "abuche-cyclops",
        "content": "The solution I found for this problem was to remove the fallback policy and instead implement authorization on the root folder of the project. My understanding is that the fallback policy applies the specified policy to every page where no policy was set as an override. By adding the default authorization to the root of the project, it achieves the same. The difference? The AllowAnonymous attribute is taken into account!\r\n\r\n\u0060\r\nbuilder.Services.AddRazorPages(options =\u003E\r\n{\r\n    options.Conventions.AuthorizeFolder(\u0022/\u0022);\r\n});\u0060\r\n\r\nI also needed to create a _Host_Public with the [AllowAnonymous] and a PublicApp.razor to skip getting the auth tokens. These are implement using a \u0060app.MapFallbackToPage(pattern, \u0022/_Host_Public\u0022)\u0060 This also allowed me to define a different template for public pages.\r\n\r\nEDIT: After further testing, I am not sure how the folder authorization works. So I instead replaced the Fallback Policy by adding an [Authorize] attribute on the \u0022_Host.cshtml\u0022. Together with the \u0060app.MapFallbackToPage(\u0022/_Host\u0022);\u0060, this ensures that every page will be authorized expect ones we explicitly map to the \u0022_Host_Public.cshtml\u0022. Again, without a Fallback Policy, the [AllowAnonymous] attribute is honored. Any over specification of authorization using \r\n\u0060@attribute [Authorize(Policy = \u0022potatoPolicy\u0022)\u0060 is also honored (As it was using the fallback policy).",
        "createdAt": "2023-08-22T17:06:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1688596575"
      },
      {
        "id": "IC_kwDOAQzde85oYMex",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 9 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-10-06T17:38:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1751173041"
      },
      {
        "id": "IC_kwDOAQzde85p-acW",
        "parentId": null,
        "author": "gthvidsten",
        "content": "Are you absolutely sure this is moved to .NET 9? I just installed .NET 8 (rc2), created a new Blazor Server app, set it up with OIDC and FallbackPolicy and suddenly \u0060AllowAnonymous\u0060 started working again!",
        "createdAt": "2023-10-24T20:15:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1777968918"
      },
      {
        "id": "IC_kwDOAQzde85ua_me",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "Closing as it seems this has also been addressed in .NET 8 (as part of some other work, potentially \uD83D\uDC4D  )",
        "createdAt": "2023-12-12T18:16:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1852570014"
      },
      {
        "id": "IC_kwDOAQzde85zdhKN",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "Reopening as a conversation [here](https://twitter.com/codemullins/status/1755965157476319245) indicates that this issue was not resolved. Will let this go through triage again.",
        "createdAt": "2024-02-10T20:52:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1937117837"
      },
      {
        "id": "IC_kwDOAQzde85018Ni",
        "parentId": null,
        "author": "halter73",
        "content": "One potential fix for this issue is to add \u0060[AllowAnonymous]\u0060 to all the non-sensitive static Blazor endpoints such as \u0060/_framework/blazor.web.js\u0060. This would allow \u0060[AllowAnonymous]\u0060 to work even if there is a non-null \u0060FallbackPolicy\u0060 configured.\r\n\r\nI mentioned this in a meeting with @javiercn who voiced that this would not be a safe thing to do from a security perspective because some Blazor customers might really want all Blazor assets, even static ones like blazor.web.js, to require authentication to download. I\u0027m not sure of the specifics of why that is, but if we think that\u0027s the case, we could make it opt-in.\r\n\r\nBut at that point, if people are willing to make changes to their app, it unclear why a \u0060FallbackPolicy\u0060 is desirable and people cannot do the workaround suggested by @javiercn earlier in the thread:\r\n\r\n\u003E You can put the \u0060@attribute [Authorize]\u0060 directive within an \u0060_Imports.razor\u0060 file in the Pages directory and that way you would avoid having to set it on every page.\r\n\u003E \r\n\u003E That \u002B AllowAnonymous on the _Host.cshtml should do what you want (I believe).\r\n\r\nYou can also call \u0060MapGroup(\u0022\u0022).RequireAuthorization()\u0060 to easily require auth for any other endpoints defined using [endpoint routing](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-8.0) which should be most things other than raw middleware these days including MVC Controllers, Razor Pages, SignalR, Health Checks, etc...\r\n\r\nI\u0027ve added the \u0060area-auth\u0060 label so we can decide priority in our upcoming auth planning. We might be able to do something here for .NET 9, but I think the only thing worth doing is adding \u0060[AllowAnonymous]\u0060 to static Blazor endpoints by default. As soon as people are forced to learn about setting another option to fix this, you might as well use one of workarounds listed above reather than rely on \u0060FallbackPolicy\u0060.\r\n\r\n#23157 Does appear to be the same issue, and @javiercn himself filed it. I don\u0027t know why it was ever considered fixed.\r\n\r\n#37064 Is pretty niche. It applies to how the \u0022415 HTTP Unsupported Media Type\u0022 endpoint created by a [Consumes] attribute on an MVC controller does not copy the \u0060[AllowAnonymous]\u0060 metadata from the associated action if present.",
        "createdAt": "2024-02-22T20:55:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39321#issuecomment-1960297314"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85BtX1Y",
    "title": "Allow acr_values and ui_locales to be specified in OpenIdConnectOptions",
    "url": "https://github.com/dotnet/aspnetcore/issues/39503",
    "createdAt": "2022-01-13T21:33:51Z",
    "lastUpdated": "2024-11-14T17:14:21Z",
    "body": "## Background and Motivation\r\n\r\nCurrently to set the \u0060acr_values\u0060 and \u0060ui_locales\u0060 parameters in the authorization request (https://openid.net/specs/openid-connect-core-1_0.html section 3.1.2.1. Authentication Request), we need to use the \u0060OnRedirectToIdentityProvider\u0060 event like:\r\n\r\n\u0060\u0060\u0060cs\r\nvar builder = WebApplication.CreateBuilder(args);\r\nbuilder.Services.AddAuthentication().AddOpenIdConnect(options =\u003E\r\n{\r\n   options.Events.OnRedirectToIdentityProvider = context =\u003E\r\n   {\r\n       context.ProtocolMessage.AcrValues = \u0022tenant:abc\u0022;\r\n       context.ProtocolMessage.UiLocales = \u0022en-us\u0022\r\n       return Task.CompletedTask;\r\n   };\r\n});\r\n\u0060\u0060\u0060\r\n\r\nIt would be interesting to add these two properties directly in \u0060OpenIdConnectOptions\u0060. \r\n\r\nThe mapping should be easy (here https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectHandler.cs#L382) as these two properties already exist in the OpenIdConnectMessage (https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/dev/src/Microsoft.IdentityModel.Protocols.OpenIdConnect/OpenIdConnectMessage.cs)\r\n\r\n## Proposed API\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.AspNetCore.Authentication.OpenIdConnect;\r\n\r\npublic class OpenIdConnectOptions : RemoteAuthenticationOptions\r\n{\r\n\u002B    public string? AcrValues { get; set; }\r\n\u002B    public string? UiLocales { get; set; }\r\n}\r\n\r\n\u0060\u0060\u0060\r\n\r\n## Usage Examples\r\n\r\n\u0060\u0060\u0060cs\r\nvar builder = WebApplication.CreateBuilder(args);\r\nbuilder.Services.AddAuthentication().AddOpenIdConnect(options =\u003E\r\n{\r\n    options.AcrValues = \u0022tenant:abc\u0022;\r\n    options.UiLocales = \u0022en-us\u0022;\r\n});\r\n\u0060\u0060\u0060\r\n\r\n## Alternative Designs\r\n\r\nWe can maybe rely on the new \u0060AdditionalAuthorizationParameters\u0060 proposed in https://github.com/dotnet/aspnetcore/issues/39243 to set these two parameters but should we reserve this property only for non standard OAuth/OpenID parameters?\r\n\r\n## Risks\r\n\r\nNothing I can think of now.\r\n\r\ncc @Tratcher @martincostello ",
    "upvotes": 4,
    "labels": [
      "area-auth",
      "api-suggestion"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde848YPxx",
        "parentId": null,
        "author": "martincostello",
        "content": "We have something similar to \u0060AdditionalAuthorizationParameters\u0060 in the \u0060AspNet.Security.OpenId.Providers\u0060 package:\r\n\r\nhttps://github.com/aspnet-contrib/AspNet.Security.OpenId.Providers/blob/1a826454dea02d73712a550532b14b4c9cc07180/src/AspNet.Security.OpenId/OpenIdAuthenticationHandler.cs#L328-L337\r\n\r\nSomething similar to that is probably best, rather than trying to introduce strongly-typed parameters for ACR and UI, as then it can be a bit of a slippery slope of _\u0022oh, can we add \u0060Foo\u0060 too?\u0022_.\r\n\r\nUltimately those properties are just backed by a dictionary anyway ([\u0060AuthenticationProtocolMessage.Parameters\u0060](https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/824d58cb554ee37defb1ff09c23fffdb91d7f6ec/src/Microsoft.IdentityModel.Protocols/AuthenticationProtocolMessage.cs#L161-L167)) when they\u0027re accessed via [\u0060SetParameter(string, string)\u0060](https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/824d58cb554ee37defb1ff09c23fffdb91d7f6ec/src/Microsoft.IdentityModel.Protocols/AuthenticationProtocolMessage.cs#L210).\r\n\r\nA more generic solution would be something like \u0060AdditionalAuthorizationParameters\u0060 that could loop through an \u0060IDictionary\u003Cstring, string\u003E\u0060 and add them to the message before the redirect. You\u0027d just need to know the property names for configuring them (e.g. [\u0060OpenIdConnectParameterNames.AcrValues\u0060](https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/824d58cb554ee37defb1ff09c23fffdb91d7f6ec/src/Microsoft.IdentityModel.Protocols.OpenIdConnect/OpenIdConnectParameterNames.cs#L37)) on \u0060OpenIdConnectOptions\u0060.\r\n",
        "createdAt": "2022-01-14T10:18:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39503#issuecomment-1012989041"
      },
      {
        "id": "IC_kwDOAQzde848aGcK",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 7 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-01-14T21:09:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39503#issuecomment-1013475082"
      },
      {
        "id": "IC_kwDOAQzde848aGsM",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "\u003E We can maybe rely on the new AdditionalAuthorizationParameters proposed in #39243 to set these two parameters\r\n\r\nThis is the approach we should probably go with, so this is consistent with how we specify the other properties.",
        "createdAt": "2022-01-14T21:11:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39503#issuecomment-1013476108"
      },
      {
        "id": "IC_kwDOAQzde848dJdg",
        "parentId": null,
        "author": "Ponant",
        "content": "Hello,\r\nI faced a similar issue, and found out that also redirection back should/could be addressed, when users cancel the oidc flow. See https://github.com/AzureAD/microsoft-identity-web/issues/1596",
        "createdAt": "2022-01-17T08:48:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39503#issuecomment-1014273888"
      },
      {
        "id": "IC_kwDOAQzde85KRGVF",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-13T22:02:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39503#issuecomment-1245996357"
      },
      {
        "id": "IC_kwDOAQzde86LYDbi",
        "parentId": null,
        "author": "Eagle3386",
        "content": "@mkArtakMSFT \u0026 @javiercn\r\nSince the workaround suggested in #45832 can\u0027t be done anymore (there\u0027s no \u0060options.Events\u0060 anymore), how am I supposed to add \u0060ui_locales\u0060 to my MSAL setup in my Blazor WASM standalone app that connects to our Azure B2C tenant?",
        "createdAt": "2024-09-09T14:50:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39503#issuecomment-2338338530"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85CKLMo",
    "title": "ClientCertificate expired causing test failures",
    "url": "https://github.com/dotnet/aspnetcore/issues/39669",
    "createdAt": "2022-01-21T01:53:41Z",
    "lastUpdated": "2023-02-23T19:27:34Z",
    "body": "VerifyValidClientCertWithTrustedChainAuthenticates\r\nVerifyValidClientCertWithAdditionalCertificatesAuthenticates\r\n\r\nare failing because the test client cert: https://github.com/dotnet/aspnetcore/blob/c85baf8db0c72ae8e68643029d514b2e737c9fae/src/Shared/test/Certificates/validSignedClientCertificate.cer expired on 1/20/22\r\n\r\nneed to update the cert/extend the expiration and reenable these tests",
    "upvotes": 0,
    "labels": [
      "test-failure",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde848unDr",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "Needs to be backported to 6.0 and probably 5.0 as well.",
        "createdAt": "2022-01-21T20:53:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39669#issuecomment-1018851563"
      },
      {
        "id": "IC_kwDOAQzde848un2A",
        "parentId": null,
        "author": "HaoK",
        "content": "/backport to release/6.0",
        "createdAt": "2022-01-21T20:58:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39669#issuecomment-1018854784"
      },
      {
        "id": "IC_kwDOAQzde848un3c",
        "parentId": null,
        "author": "HaoK",
        "content": "/backport to release/5.0",
        "createdAt": "2022-01-21T20:58:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39669#issuecomment-1018854876"
      },
      {
        "id": "IC_kwDOAQzde848un7H",
        "parentId": null,
        "author": "HaoK",
        "content": "Rip not a PR ",
        "createdAt": "2022-01-21T20:59:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39669#issuecomment-1018855111"
      },
      {
        "id": "IC_kwDOAQzde848uzsl",
        "parentId": null,
        "author": "HaoK",
        "content": "Luckily these tests aren\u0027t in 5.0, they were added in 6.0 https://github.com/dotnet/aspnetcore/commit/ae6e9c834c86348da34431790d082c91a822d27f#diff-0ca82662fe7488251aa5453edd2bb21a0844e259d1cae0f3b35c1e7520cec1a7",
        "createdAt": "2022-01-21T22:14:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39669#issuecomment-1018903333"
      },
      {
        "id": "IC_kwDOAQzde848uz5u",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "This looks like it\u0027s in 5.0 https://github.com/dotnet/aspnetcore/blob/release/5.0/src/Security/Authentication/test/CertificateTests.cs#L310",
        "createdAt": "2022-01-21T22:16:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39669#issuecomment-1018904174"
      },
      {
        "id": "IC_kwDOAQzde848u1FG",
        "parentId": null,
        "author": "HaoK",
        "content": "Doh, okay guess I have to manually do 5.0",
        "createdAt": "2022-01-21T22:25:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39669#issuecomment-1018908998"
      },
      {
        "id": "IC_kwDOAQzde85ARuxx",
        "parentId": null,
        "author": "HaoK",
        "content": "Note: these tests currently are still skipped because the logic to generate certs does not handle generating chained client certs",
        "createdAt": "2022-03-24T21:26:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39669#issuecomment-1078389873"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85C5cgp",
    "title": "OpenID Connect correlation cookie and changes to SameSite=None Cookie-Handling",
    "url": "https://github.com/dotnet/aspnetcore/issues/39941",
    "createdAt": "2022-02-02T20:27:12Z",
    "lastUpdated": "2022-02-03T19:00:07Z",
    "body": "According to https://developer.chrome.com/en/blog/progress-in-the-privacy-sandbox-2021-12/ there are going to be changes in the handling of cookies with SameSite=None. \r\n\r\nWhen using the OpenID Connect authentication the base classes are used that issue and validate a correlation cookie with SameSite=None, so this cookie is affected by the change.\r\n\r\nSee\r\n\r\n- https://github.com/dotnet/aspnetcore/blob/b89eba6c3cda331ee98063e3c4a04267ec540315/src/Security/Authentication/OAuth/src/OAuthHandler.cs\r\n\r\n- https://github.com/dotnet/aspnetcore/blob/b89eba6c3cda331ee98063e3c4a04267ec540315/src/Security/Authentication/Core/src/RemoteAuthenticationHandler.cs\r\n\r\n\r\nCould you please share the plans how to deal with this issue? Is this going to be fixed in aspnetcore?",
    "upvotes": 1,
    "labels": [
      "area-auth",
      "feature-oidc"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde849TCvs",
        "parentId": null,
        "author": "blowdart",
        "content": "As it\u0027s just a proposal right now, we can\u0027t react, as it may not happen (floc is a great example of this). \r\n\r\nUntil there\u0027s something more concrete and actual dates for implementation we can\u0027t plan for it.",
        "createdAt": "2022-02-02T22:05:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39941#issuecomment-1028402156"
      },
      {
        "id": "IC_kwDOAQzde849TCxq",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-02-02T22:05:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39941#issuecomment-1028402282"
      },
      {
        "id": "IC_kwDOAQzde849UuC2",
        "parentId": null,
        "author": "fschmied",
        "content": "Note that the \u0022nonce\u0022 OpenID Connect cookie will also be affected if SameSite=None stops working.",
        "createdAt": "2022-02-03T10:28:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39941#issuecomment-1028841654"
      },
      {
        "id": "IC_kwDOAQzde849WezP",
        "parentId": null,
        "author": "blowdart",
        "content": "However @ernstscheithauer  thinking on it last night we could improve things so you don\u0027t have to wait for us to implement new properties.\r\n\r\nSee https://github.com/dotnet/aspnetcore/issues/39968 as a general proposal",
        "createdAt": "2022-02-03T19:00:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39941#issuecomment-1029303503"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85GJWE_",
    "title": "Multiple Authentication Schemes are mutually exclusive",
    "url": "https://github.com/dotnet/aspnetcore/issues/40820",
    "createdAt": "2022-03-22T14:15:55Z",
    "lastUpdated": "2024-09-10T19:32:55Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nI have a React SPA and a Mobile App that calls a Web API protected by Azure AD OIDC.\r\n- The React SPA uses the default **JWT authentication scheme** provided by the \u0060AddMicrosoftIdentityWebApi()\u0060 extension\r\n- The Mobile App uses a custom HTTP Header-based authentication scheme\r\n\r\nGoal: If AT LEAST one of the schemes succeeds then the user should be authenticated. Unfortunately the two schemes are mutually exclusive:\r\n- If I set \u0060AddAuthenticationSchemes(JwtBearerDefaults.AuthenticationScheme)\u0060 then the React SPA authenticates the user but the Mobile App returns 401\r\n- If I set \u0060AddAuthenticationSchemes(MobileAuthenticationDefaults.AuthenticationScheme)\u0060 then the Mobile App authenticates the user but the React SPA returns 401\r\n\r\n### Expected Behavior\r\n\r\nBoth React SPA and Mobile App should be able to authenticate using their separate authentication schemes.\r\n\r\n\r\n### Steps To Reproduce\r\n\r\nstartup.cs example with JWT default:\r\n\u0060\u0060\u0060c#\r\nservices.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\r\n                .AddScheme\u003CMobileAuthenticationSchemeOptions, MobileAuthenticationHandler\u003E(MobileAuthenticationDefaults.AuthenticationScheme, null)\r\n                .AddMicrosoftIdentityWebApi(Configuration.GetSection(\u0022AzureAD:LycheeWebAPI\u0022));\r\nservices.AddAuthorization(options =\u003E\r\n            {\r\n                options.DefaultPolicy = new AuthorizationPolicyBuilder(\r\n                    JwtBearerDefaults.AuthenticationScheme,\r\n                    MobileAuthenticationDefaults.AuthenticationScheme)\r\n                    .RequireAuthenticatedUser()\r\n                    .Build();\r\n            });\r\nservices.AddScoped\u003CIAuthenticationHandler, MobileAuthenticationHandler\u003E();\r\n...\r\nvar policy = new AuthorizationPolicyBuilder()\r\n                .AddAuthenticationSchemes(JwtBearerDefaults.AuthenticationScheme, MobileAuthenticationDefaults.AuthenticationScheme)\r\n                .RequireAuthenticatedUser()\r\n                .Build();\r\nmvcOptions.Filters.Add(new AuthorizeFilter(policy));\r\n...\r\napp.UseStaticFiles();\r\napp.UseRouting();\r\napp.UseAuthentication();\r\napp.UseAuthorization();\r\napp.UseEndpoints(endpoints =\u003E\r\n            {\r\n                endpoints.MapControllerRoute(\r\n                    name: \u0022default\u0022,\r\n                    pattern: \u0022{controller=Home}/{action=Index}/{id?}\u0022);\r\n            });\r\n\u0060\u0060\u0060\r\n\r\nMobileAuthenticationHandler:\r\n\u0060\u0060\u0060c#\r\npublic class MobileAuthenticationHandler : AuthenticationHandler\u003CMobileAuthenticationSchemeOptions\u003E\r\n{\r\nprotected override Task\u003CAuthenticateResult\u003E HandleAuthenticateAsync()\r\n        {\r\n            // validation comes in here\r\n            if (!Request.Headers.ContainsKey(ApiConstants.MobileApiHttpHeader))\r\n            {\r\n                return Task.FromResult(AuthenticateResult.NoResult());\r\n            }\r\n            ...\r\n            var claimsIdentity = new ClaimsIdentity(claims, nameof(MobileAuthenticationHandler));\r\n            var ticket = new AuthenticationTicket(\r\n                new ClaimsPrincipal(claimsIdentity), this.Scheme.Name);\r\n            return Task.FromResult(AuthenticateResult.Success(ticket));\r\n}\r\n\u0060\u0060\u0060\r\n\r\nMobileAuthenticationOptions.cs:\r\n\u0060\u0060\u0060c#\r\npublic class MobileAuthenticationSchemeOptions : AuthenticationSchemeOptions\r\n{\r\n}\r\n\u0060\u0060\u0060\r\n\r\nMobileAuthenticationDefaults.cs:\r\n\u0060\u0060\u0060c#\r\npublic static class MobileAuthenticationDefaults\r\n{\r\n    public const string AuthenticationScheme = \u0022MobileAuthenticationScheme\u0022;\r\n}\r\n\u0060\u0060\u0060\r\n\r\n### Exceptions (if any)\r\n\r\nN/A\r\n\r\n### .NET Version\r\n\r\n6.0.101\r\n\r\n### Anything else?\r\n\r\n- ASP.NET Core 5\r\n- VS 2022 Community\r\n\r\n\u0060\u0060\u0060\r\n.NET SDK (reflecting any global.json):\r\n Version:   6.0.101\r\n Commit:    ef49f6213a\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.19043\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\6.0.101\\\r\n\r\nHost (useful for support):\r\n  Version: 6.0.3\r\n  Commit:  c24d9a9c91\r\n\r\n.NET SDKs installed:\r\n  6.0.101 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.App 5.0.13 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 5.0.15 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 6.0.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 6.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 5.0.13 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 5.0.15 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 6.0.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 6.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 5.0.13 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 5.0.15 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 6.0.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\u0060\u0060\u0060",
    "upvotes": 2,
    "labels": [
      "Docs",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85AF68x",
        "parentId": null,
        "author": "davidfowl",
        "content": "They can\u0027t both be active so that\u0027s not the right approach. I think you have 2 options. Add a policy scheme that selects the right scheme based on the incoming request. See https://docs.microsoft.com/en-us/aspnet/core/security/authentication/policyschemes?view=aspnetcore-6.0\r\n\r\ncc @HaoK Do we have this in the box (pass N schemes to an uber scheme and it\u0027ll pick the first one that succeeds).",
        "createdAt": "2022-03-22T15:02:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1075294001"
      },
      {
        "id": "IC_kwDOAQzde85AGBV4",
        "parentId": null,
        "author": "HaoK",
        "content": "No we don\u0027t have any additional logic in our policy (uber) schemes, the only sugar we have is the set of ForwardXyz properties on the default auth options for schemes (Authenticate/Challenge/Forbid) that will make it easy to forward to another scheme.  You have to implement your own handler today to try N schemes and stop on the first one.",
        "createdAt": "2022-03-22T15:23:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1075320184"
      },
      {
        "id": "IC_kwDOAQzde85AGB5A",
        "parentId": null,
        "author": "HaoK",
        "content": "Certainly easy to add some built in policy schemes that do some common scenarios though, but it seems like people haven\u0027t had too much trouble rolling there own",
        "createdAt": "2022-03-22T15:25:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1075322432"
      },
      {
        "id": "IC_kwDOAQzde85AGCde",
        "parentId": null,
        "author": "HaoK",
        "content": "Or maybe we should just add a ne example of this pick first scheme that succeeds Authenticate to the policyschemes docs",
        "createdAt": "2022-03-22T15:27:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1075324766"
      },
      {
        "id": "IC_kwDOAQzde85AGC4g",
        "parentId": null,
        "author": "HaoK",
        "content": "The ForwardDefaultSelector is an implementation detail of our auth handlers, there\u0027s no concept of this in the authentication/authorization stacks themselves.  So its not exposed at the AddAuthentication level because not all auth schemes will support that concept",
        "createdAt": "2022-03-22T15:29:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1075326496"
      },
      {
        "id": "IC_kwDOAQzde85AGiXE",
        "parentId": null,
        "author": "davidfowl",
        "content": "Let\u2019s update the docs for this scenario ",
        "createdAt": "2022-03-22T18:02:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1075455428"
      },
      {
        "id": "IC_kwDOAQzde85AGjwd",
        "parentId": null,
        "author": "HaoK",
        "content": "Is it good enough to document the common case of having the default scheme fallback to another scheme if it doesn\u0027t succeed?  I don\u0027t think the N scheme case is really that common, its usually just between 2 schemes right?",
        "createdAt": "2022-03-22T18:07:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1075461149"
      },
      {
        "id": "IC_kwDOAQzde85AGm_V",
        "parentId": null,
        "author": "davidfowl",
        "content": "Is 2 -\u003E 3 much harder?  ",
        "createdAt": "2022-03-22T18:21:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1075474389"
      },
      {
        "id": "IC_kwDOAQzde85AGpie",
        "parentId": null,
        "author": "HaoK",
        "content": "Depends on exactly what we want to illustrate, something like logic in the ForwardDefaultSelector doesn\u0027t really care as that\u0027s just a big switch.  Are we looking to document that pattern?  Alternatively I could just show something generic like a FallbackPolicyScheme, which you could then chain up like a linked list, i.e.\r\n\r\n\u0060\u0060\u0060\r\n  services.AddAuthentication(\u0022Primary\u0022)\r\n    .AddScheme\u003CFallbackPolicyScheme\u003E(\u0022Primary\u0022, o =\u003E o.FallbackScheme(\u0022Secondary\u0022); o.ForwardAuthenticate(\u0022Cookies\u0022))\r\n    .AddScheme\u003CFallbackPolicyScheme\u003E(\u0022Secondary\u0022, o =\u003E o.FallbackScheme(\u0022Third\u0022); o.ForwardAuthenticate(\u0022Bearer\u0022));\r\n    .AddScheme\u003CFallbackPolicyScheme\u003E(\u0022Third\u0022, o =\u003E o.FallbackScheme(\u0022Fourth\u0022; o.ForwardAuthenticate(\u0022Cookie2\u0022))\r\n    .AddCookie(\u0022Fourth\u0022)\r\n\u0060\u0060\u0060\r\n\r\nAnd show how to implement the FallbackPolicyScheme to do this kind of chaining",
        "createdAt": "2022-03-22T18:30:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1075484830"
      },
      {
        "id": "IC_kwDOAQzde85AGqtW",
        "parentId": null,
        "author": "HaoK",
        "content": "I guess if we wanted to make this in the box, we could also just add the concept of \u0060FallbackAuthenticateScheme\u0060 to our default implementation so this kind of thing just works for authenticate (check yourself for authentication, if you don\u0027t have anything, then fallback to the FallbackAuthenticateScheme), its basically a second Foward, but instead of always forwarding, you only fallback",
        "createdAt": "2022-03-22T18:35:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1075489622"
      },
      {
        "id": "IC_kwDOAQzde85ALpOC",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 7 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-03-23T20:35:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1076794242"
      },
      {
        "id": "IC_kwDOAQzde85HCJHK",
        "parentId": null,
        "author": "gjmoyer",
        "content": "I have to support 3 schemes (ADFS2012, ADFS2016, and Azure AD). Azure AD is new I am adding. When I added Azure AD as teh 3rd scheme via AddMicrosoftIdentityWebApi where my .NET6 WebAPI is deployed to Azure App Service. The Trace log started filling up with IDX10503, IDX10223, IDX10516, IDX10205 errors. Not sure why these classified as errors and then go to Trace and not Exceptions. I removed AddMicrosoftIdentityWebApi  and used AddJwtBearer instead to remove the errors. \r\n\r\nCan someone please make it more clear how to implement the forward selector? In my case I wish to authorize all 3 to every controller. I currently have the following which always tries all 3.\r\n\r\n\u0060builder.Services\r\n    .AddAuthorization(options =\u003E\r\n    {\r\n        options.DefaultPolicy = new AuthorizationPolicyBuilder()\r\n            .RequireAuthenticatedUser()\r\n            .AddAuthenticationSchemes(AzureAd, Adfs2012, Adfs2016)\r\n            .RequireRole(User_Roles)\r\n            .Build();\r\n    });\u0060",
        "createdAt": "2022-07-21T17:18:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1191743946"
      },
      {
        "id": "IC_kwDOAQzde85HDfpt",
        "parentId": null,
        "author": "maxandriani",
        "content": "\u003E Depends on exactly what we want to illustrate, something like logic in the ForwardDefaultSelector doesn\u0027t really care as that\u0027s just a big switch. Are we looking to document that pattern? Alternatively I could just show something generic like a FallbackPolicyScheme, which you could then chain up like a linked list, i.e.\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E   services.AddAuthentication(\u0022Primary\u0022)\r\n\u003E     .AddScheme\u003CFallbackPolicyScheme\u003E(\u0022Primary\u0022, o =\u003E o.FallbackScheme(\u0022Secondary\u0022); o.ForwardAuthenticate(\u0022Cookies\u0022))\r\n\u003E     .AddScheme\u003CFallbackPolicyScheme\u003E(\u0022Secondary\u0022, o =\u003E o.FallbackScheme(\u0022Third\u0022); o.ForwardAuthenticate(\u0022Bearer\u0022));\r\n\u003E     .AddScheme\u003CFallbackPolicyScheme\u003E(\u0022Third\u0022, o =\u003E o.FallbackScheme(\u0022Fourth\u0022; o.ForwardAuthenticate(\u0022Cookie2\u0022))\r\n\u003E     .AddCookie(\u0022Fourth\u0022)\r\n\u003E \u0060\u0060\u0060\r\n\u003E \r\n\u003E And show how to implement the FallbackPolicyScheme to do this kind of chaining\r\n\r\n@HaoK That is interesting. I\u0027m strugling w/ one use case I have on my company, and I hope this ForwardAuthenticate pattern will help me to provide an elegant solution.\r\n\r\nWe actually solve the use case described by @exagran by delegate the responsibility to handle multiple ISP providers to a SSO Gateway. This gateway generates authorization tokens to all my applications. But my aplications has a very diverse authorization strategies. Some of then use rbac, some use permission/claims, and other a mix of rbac at high level and permissions at application level. In short, I have a JWT Bearer as Authentication Scheme with provides the user identity and some enterprise (SSO) level rbac. But I also have a custom scheme that loads application level claims and join those to the ClaimsPrincipal.\r\n\r\nInitially, we wrote an Middleware to grant the local claims to the authenticated identity. Then we migrate this code to authorization scheme level because it seems the right place to put this code. So we have now the AppSchemeHandler that uses JwtBearerHandler as dependency by composition that validates the JWT and create the Principal, then AppScheme attach additional claims and officially return AuthenticateResult.Success.\r\n\r\nSo, my question is, can this proposal pattern of ForwardAuthentication fit my use case instead of build an AuthorizationSchema w/ dependencies by composition, and chain then as an Authorization workflow?\r\n\r\nOr i\u0027m messing up the authorization schema purpose?",
        "createdAt": "2022-07-22T01:51:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1192098413"
      },
      {
        "id": "IC_kwDOAQzde85HGqAm",
        "parentId": null,
        "author": "HaoK",
        "content": "Hey @maxandriani let me see if I understand your scenario properly before trying to answer anything:\r\n\r\nIt sounds like you have a jwt bearer scheme which has your basic user / roles claims.  And then you want to also have additional application level claims that you want included in the ClaimsPrincipal.\r\n\r\nThere are indeed lots of different ways you can do this:\r\n1. Using an AuthorizationPolicy that specifies both your JwtBearer \u002B AppSchemes as AuthenticationSchemes, this will merge them and give you a combined ClaimsPrincipal\r\n2. Implement a JwtAppScheme that takes care of the combining inside of its authenticate, it could do something simple like check for the jwt, if it had that, then get the app schemes and return the unified claims principle.  If no jwt, respond with a challenge to the jwt scheme.\r\n3. ForwardAuthenticate would be helpful if you wanted to explicitly handle the delegation of the authentication in schemes instead, i.e. where you mention having an assortment of ISP providers, RBAC or claims etc, you could implement logic that returns the right scheme via a Selector on a single authentication scheme(i.e. AppSchemeForwarder), and then register an actual authentication scheme for each of your ISPs that hopefully would give you exactly what you want, in terms of a ClaimsPrincipal, and the AppSchemeForwarder is just forwarding to the appropriate ISP (each of which could also have similar logic if needed to continue forwarding/combining)\r\n\r\n",
        "createdAt": "2022-07-22T20:53:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1192927270"
      },
      {
        "id": "IC_kwDOAQzde85HHZHi",
        "parentId": null,
        "author": "maxandriani",
        "content": "Thanks to clarify @HaoK ! We choose the option 2 strategy. It worked like a charm.",
        "createdAt": "2022-07-23T12:48:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1193120226"
      },
      {
        "id": "IC_kwDOAQzde85Kfjyx",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-16T20:33:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1249787057"
      },
      {
        "id": "IC_kwDOAQzde85Kmchc",
        "parentId": null,
        "author": "devich2",
        "content": "Hi, also met the same issue, RequireAuthenticated() method forces all authentication schemes to be tried.\r\nIf i properly understood, that was designed to collect as much information about user as possible.\r\nBut in our case we have different api clients, that are supposed to authenticate via different schemas, and it\u0027s a bit annoying to see a lot of error logs, when in fact user pas authentication. ",
        "createdAt": "2022-09-19T21:41:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1251592284"
      },
      {
        "id": "IC_kwDOAQzde85KpWhX",
        "parentId": null,
        "author": "maxandriani",
        "content": "@devich2 Hi! As far as I understood the thread and your use case, I think you should write you own proxy scheme and properly evaluate wich  schema to challenge based some information about the origin of the request (client id registration table, \u2026). ",
        "createdAt": "2022-09-20T13:27:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1252354135"
      },
      {
        "id": "IC_kwDOAQzde851-JwA",
        "parentId": null,
        "author": "muj-beg",
        "content": "We\u0027re using multiple Azure AD and Azure AD B2C schemes in various applications.  What we would like to do is create a generic policy scheme selector based on issuer matching.  Ideally, instead of using a static list of issuers, we want to match the HTTP request\u0027s token issuer  to a configured \u0060jwtOptions.ClaimsIssuer\u0060 or  \u0060jwtOptions.Configuration.Issuer\u0060. However, MSAL retrieves issuer information using a \u0060ConfigurationManager\u0060, and the configuration hasn\u0027t been loaded by the time \u0060ForwardDefaultSelector()\u0060 method is called.  We can try to manually load the configuration using \u0060jwtOptions.ConfigurationManager.GetConfigurationAsync()\u0060 in order to retrieve the issuer value.  However, that requires a blocking wait, since  that\u0027s an async method, but \u0060ForwardDefaultSelector()\u0060 isn\u0027t!\r\n\r\nThe other (minor) downside to the above approach is that the token had to be decoded twice -- once by the policy scheme handler, and then again by the real scheme handler.",
        "createdAt": "2024-03-05T16:59:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40820#issuecomment-1979227136"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85Hvrwu",
    "title": "Resource indicators are missing in access token request",
    "url": "https://github.com/dotnet/aspnetcore/issues/41176",
    "createdAt": "2022-04-13T19:12:13Z",
    "lastUpdated": "2024-09-10T19:32:55Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nThe Resource-property set in the OpenIdConnectOptions does not flow through the whole process.\r\n\r\nWhen configuring OpenIdConnect authentication with a resource indication, the resource value is only added to the initial authorization request but not to the subsequent access token request.\n\n### Expected Behavior\n\nWhen setting the Resource-property the value should be set in subsequent requests and no additional configuration should be needed.\r\nAs per [RFC 8707 Section 2.2](https://datatracker.ietf.org/doc/html/rfc8707#section-2.2) the access token request in the \u0027authorization_code\u0027 grant type should also contain the resource indicator.\n\n### Steps To Reproduce\n\nExample configuration:\r\n\u0060\u0060\u0060c#\r\nbuilder.Services.AddAuthentication()\r\n    .AddOpenIdConnect(options =\u003E\r\n    {\r\n        options.Authority = \u0022https://localhost:5001/\u0022;\r\n        options.Resource = \u0022urn:test\u0022;\r\n\r\n        options.Scope.Add(\u0022profile\u0022);\r\n\r\n        options.ClientId = \u0022testclient\u0022;\r\n        options.ClientSecret = \u0022secret\u0022;\r\n        options.ResponseType = \u0022code\u0022;\r\n\r\n        // workaround:\r\n        options.Events = new OpenIdConnectEvents\r\n        {\r\n            OnAuthorizationCodeReceived = context =\u003E\r\n            {\r\n                // the resource property here is null but should be set\r\n                context.TokenEndpointRequest.Resource = \u0022urn:test\u0022;\r\n\r\n                return Task.FromResult(0);\r\n            }\r\n        }\r\n    };\r\n\u0060\u0060\u0060\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n6.0.201\n\n### Anything else?\n\nA fix may be applied somewhere around [this line](https://github.com/dotnet/aspnetcore/blob/c85baf8db0c72ae8e68643029d514b2e737c9fae/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectHandler.cs#L1110).\r\n\r\nSomething simple like this may already be enough:\r\n\u0060\u0060\u0060c#\r\nif (Options.Resource != null)\r\n{\r\n    tokenEndpointRequest.Resource = Options.Resource;\r\n}\r\n\u0060\u0060\u0060",
    "upvotes": 0,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85BfL0m",
        "parentId": null,
        "author": "brockallen",
        "content": "Just for context, the \u0060Resource\u0060 setting in the current OIDC plumbing was added pre-RFC8707 and was for an AAD-specific feature, IIRC.",
        "createdAt": "2022-04-14T04:18:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41176#issuecomment-1098693926"
      },
      {
        "id": "IC_kwDOAQzde85BljXw",
        "parentId": null,
        "author": "Tratcher",
        "content": "@jennyf19 Is the Resource supposed to be used in the access token request?",
        "createdAt": "2022-04-15T20:06:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41176#issuecomment-1100363248"
      },
      {
        "id": "IC_kwDOAQzde85Bl00T",
        "parentId": null,
        "author": "jennyf19",
        "content": "@Tratcher No, on the Azure AD v2 endpoint scopes are used, not resource. Resource was an AAD v1 concept which was not standard compliant.",
        "createdAt": "2022-04-15T22:02:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41176#issuecomment-1100434707"
      },
      {
        "id": "IC_kwDOAQzde85BmFOZ",
        "parentId": null,
        "author": "brockallen",
        "content": "And in RFC8707 referenced above, multiple resource params are possible (and expected) on the authorize endpoint. And not a single param with multiple values mind you, but multiple instances of the same param each with one value. IIRC the current OIDC plumbing can\u0027t handle this as specified by the RFC.",
        "createdAt": "2022-04-16T01:41:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41176#issuecomment-1100501913"
      },
      {
        "id": "IC_kwDOAQzde85B-Pde",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@blowdart Should we pursue this?",
        "createdAt": "2022-04-22T20:29:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41176#issuecomment-1106835294"
      },
      {
        "id": "IC_kwDOAQzde85B-kvc",
        "parentId": null,
        "author": "blowdart",
        "content": "Yes, but the question is do we reuse the existing parameter, or pull it out, and then replace it with a Resources one. Would that break existing users who never moved to Identity Web for aad?\r\n\r\nNeeds a dev to explore approaches.",
        "createdAt": "2022-04-22T22:01:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41176#issuecomment-1106922460"
      },
      {
        "id": "IC_kwDOAQzde85CwXrP",
        "parentId": null,
        "author": "blowdart",
        "content": "@jennyf19 @brentschmaltz Now that there\u0027s a real spec that clashes with AAD\u0027s custom use of resources IdentityModel needs correcting to match RFC8707. Brent have you looked into this? If not, can you?",
        "createdAt": "2022-05-06T20:12:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41176#issuecomment-1119976143"
      },
      {
        "id": "IC_kwDOAQzde85CyTAC",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@blowdart just read the spec, interesting that this is similar to [SignedHttpRequest](https://datatracker.ietf.org/doc/html/[draft-ietf-oauth-signed-http-request-03]) - draft, \u0027u\u0027 parameter.\r\n\r\nThis does map nicely to some work we are completing where inbound policy has an \u0027address\u0027 that could be used to identify policies that are applicable to a token.\r\n\r\nWhat type of changes are you suggesting?",
        "createdAt": "2022-05-08T20:19:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41176#issuecomment-1120481282"
      },
      {
        "id": "IC_kwDOAQzde85C1x4f",
        "parentId": null,
        "author": "blowdart",
        "content": "Is the AAD feature still called Resource? It\u0027d need to get changed first, and then bring Wilson in line with the spec\u0027s idea of resource",
        "createdAt": "2022-05-09T17:45:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41176#issuecomment-1121394207"
      },
      {
        "id": "IC_kwDOAQzde85EtNV3",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@brentschmaltz Any further comment on this one?",
        "createdAt": "2022-06-10T20:10:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41176#issuecomment-1152701815"
      },
      {
        "id": "IC_kwDOAQzde85HGjYf",
        "parentId": null,
        "author": "blowdart",
        "content": "@jmprieur As Brent isn\u0027t answering, could you take a look here?",
        "createdAt": "2022-07-22T20:09:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41176#issuecomment-1192900127"
      },
      {
        "id": "IC_kwDOAQzde85HHkxF",
        "parentId": null,
        "author": "jmprieur",
        "content": "@blowdart : will discuss this with @brentschmaltz at the beginning of next week (beginning of August)\r\ncc: @jennyf19",
        "createdAt": "2022-07-23T18:22:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41176#issuecomment-1193167941"
      },
      {
        "id": "IC_kwDOAQzde85KDa-a",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-09T20:05:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41176#issuecomment-1242410906"
      },
      {
        "id": "IC_kwDOAQzde858NPG7",
        "parentId": null,
        "author": "jpda",
        "content": "Any movement on this? We are designing our oauth2 systems and determining if we follow 8707 or mimic AAD\u0027s resource/scope parsing. A lot of our customers are dotnet shops and requiring a workaround if we adopt 8707 wouldn\u0027t be ideal.",
        "createdAt": "2024-04-29T23:18:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41176#issuecomment-2083844539"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85H-nC_",
    "title": "Testing ASP.NET Core with trimming",
    "url": "https://github.com/dotnet/aspnetcore/issues/41252",
    "createdAt": "2022-04-19T00:58:14Z",
    "lastUpdated": "2024-09-25T16:15:26Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Is your feature request related to a problem? Please describe the problem.\r\n\r\nWe\u0027re annotating ASP.NET Core for trimming in .NET 7. In theory, the linker and trim warnings should ensure frameworks, libraries and apps work.\r\n\r\nWe should double-check that ASP.NET Core continues to run in some trimmed, published apps.\r\n\r\n### Describe the solution you\u0027d like\r\n\r\nWith trimming it\u0027s difficult to test trimmed features in isolation, e.g. an app uses features A and B. Did A and B only work because they were both used, etc. Building and running an app to test each feature in isolation isn\u0027t realistic.\r\n\r\nWe should do some basic smoke testing of core scenarios.\r\n\r\ne.g.\r\nMVC\r\nMinimal API\r\nSignalR\r\nAuthN/AuthZ\r\nKestrel/IIS/HttpSys\r\nData protection/security/identity\r\n\r\n### Additional context\r\n\r\n_No response_",
    "upvotes": 1,
    "labels": [
      "task",
      "area-dataprotection",
      "area-mvc",
      "area-auth",
      "area-signalr",
      "linker-friendliness",
      "area-networking"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85BtU6k",
        "parentId": null,
        "author": "javiercn",
        "content": "@JamesNK you can take inspiration on how we test trimming in Blazor Webassembly apps. We trim the projects on the CI only based on the Release configuration.",
        "createdAt": "2022-04-19T09:42:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41252#issuecomment-1102401188"
      },
      {
        "id": "IC_kwDOAQzde85BvEmX",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "@JamesNK how do you want all of us to track this? Do you want to put out a PR to which everyone will contribute or file separate issues?",
        "createdAt": "2022-04-19T16:35:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41252#issuecomment-1102858647"
      },
      {
        "id": "IC_kwDOAQzde85Bwdhm",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 7 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-04-19T22:18:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41252#issuecomment-1103222886"
      },
      {
        "id": "IC_kwDOAQzde85Gx48t",
        "parentId": null,
        "author": "hez2010",
        "content": "Seems that Blazor doesn\u0027t support \u0060/p:TrimMode=full\u0060 (with .NET 7 nightly sdk). If I use \u0060/p:TrimMode=full\u0060 while publishing, even a hello world blazor wasm website will fail to load because of trimming.",
        "createdAt": "2022-07-18T13:50:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41252#issuecomment-1187483437"
      },
      {
        "id": "IC_kwDOAQzde85M8agy",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "\u003E Seems that Blazor doesn\u0027t support \u0060/p:TrimMode=full\u0060 (with .NET 7 nightly sdk). If I use \u0060/p:TrimMode=full\u0060 while publishing, even a hello world blazor wasm website will fail to load because of trimming.\r\n\r\n@hez2010 can you please file a separate issue for this? Thanks!",
        "createdAt": "2022-10-25T17:34:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41252#issuecomment-1290905650"
      },
      {
        "id": "IC_kwDOAQzde85O2A_F",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-11-21T23:14:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41252#issuecomment-1322782661"
      },
      {
        "id": "IC_kwDOAQzde85xp6do",
        "parentId": null,
        "author": "amcasey",
        "content": "@JamesNK I feel like we have a much more sophisticated understanding of our trimming needs now.  Is this issue still relevant?",
        "createdAt": "2024-01-23T19:48:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41252#issuecomment-1906812776"
      },
      {
        "id": "IC_kwDOAQzde85xqwoW",
        "parentId": null,
        "author": "JamesNK",
        "content": "Tests are still important. Does trimming have enough tests? If yes, then close this.",
        "createdAt": "2024-01-23T22:34:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41252#issuecomment-1907034646"
      },
      {
        "id": "IC_kwDOAQzde86LnLbR",
        "parentId": null,
        "author": "captainsafia",
        "content": "Assuming the coverage we want here is via the \u0060Trimming.Tests\u0060 and \u0060NativeAoT.Tests\u0060 infrastructure that is documented [in this doc](https://github.com/dotnet/aspnetcore/blob/951b6ead6510409a7847481f818963e696686ca9/docs/Trimming.md#adding-a-new-test-project), we have coverage for SignalR, OpenAPI, DataProtection, and WebApplicationBuilder so far. We also have source generator tests for minimal APIs that validate compile-time and runtime behavior.\r\n\r\nI think the authentication-related APIs are where we currently have a testing gap. @halter73 confirm if I am wrong.",
        "createdAt": "2024-09-10T22:56:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41252#issuecomment-2342303441"
      },
      {
        "id": "IC_kwDOAQzde86MpsAE",
        "parentId": null,
        "author": "halter73",
        "content": "We definitely have a gap for a lot of auth-related stuff. There are other areas we don\u0027t appear to test trimmed output including MVC/Razor Pages, gRPC, Blazor Server/Web, IIS/HttpSys, static files/assets, and various other middleware. I\u0027m pretty sure we don\u0027t have any plans to support trimming MVC. I\u0027m not sure about the other stuff.",
        "createdAt": "2024-09-19T01:35:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41252#issuecomment-2359738372"
      },
      {
        "id": "IC_kwDOAQzde86NiCfk",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "@halter73 can you please file a separate issue for our part of this work, so that we can park it in .NET 10 planning and go from there.",
        "createdAt": "2024-09-25T16:05:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41252#issuecomment-2374510564"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85JUKTz",
    "title": "OpenIdConnect: setting the ClaimsIssuer property in configuration options has no effect",
    "url": "https://github.com/dotnet/aspnetcore/issues/41589",
    "createdAt": "2022-05-09T17:19:27Z",
    "lastUpdated": "2024-09-10T19:32:56Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nWhen using the package Microsoft.AspNetCore.Authentication.OpenIdConnect in an ASP.NET Core application to add external login providers supporting OpenId Connect protocol, setting the \u0060ClaimsIssuer\u0060 property in \u0060OpenIdConnectOptions\u0060 has no effect; the principal claims still get generated with the issuer that comes from the external identity provider. \r\n\r\nThis behavior is in contrast with other social media login providers (Microsoft Account, Facebook, Google, etc.) where specifying this property in the configuration options would cause the principal claims to be issued with the specified claims issuer. \r\n\r\nIs is possible to fix that so the \u0060ClaimsIssuer\u0060 option in the OpenId Connect client works the same way it does in other social login provider packages? That way we can use it for any external identity provider that supports the OpenId Connect protocol but does not have a specific package built for it.\n\n### Expected Behavior\n\nOnce the \u0060ClaimsIssuer\u0060 property of the \u0060OpenIdConnectOptions\u0060 is set, the principal claims should be issued with the specified claims issuer.\n\n### Steps To Reproduce\n\n1. Configure the OpenIdConnect client with any identity provider that supports OpenId Connect;\r\n2. Set the \u0060ClaimsIssuer\u0060 property to something different (e.g. \u0022MyCustomIssuer\u0022) in \u0060.AddOpenIdConnect()\u0060 configuration;\r\n3. Verify that the actual issuer of the principal claims is unchanged.\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n_No response_\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "blocked",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85DBBog",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Let\u0027s investigate and see whether this is an IdentityModel limitation or we just need to pass something through.",
        "createdAt": "2022-05-11T22:12:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41589#issuecomment-1124342304"
      },
      {
        "id": "IC_kwDOAQzde85DBBqU",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\nWe\u0027re moving this issue to the \u0060.NET 7 Planning\u0060 milestone for future evaluation / consideration. Because it\u0027s not immediately obvious that this is a bug in our framework, we would like to keep this around to collect more feedback, which can later help us determine the impact of it. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-05-11T22:12:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41589#issuecomment-1124342420"
      },
      {
        "id": "IC_kwDOAQzde85KDpfu",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. Because it\u0027s not immediately obvious that this is a bug in our framework, we would like to keep this around to collect more feedback, which can later help us determine the impact of it. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-09T21:05:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41589#issuecomment-1242470382"
      },
      {
        "id": "IC_kwDOAQzde85PBftE",
        "parentId": null,
        "author": "Tratcher",
        "content": "ClaimsIssuer is used by implementations that create Claims from sources that don\u0027t provide that information. E.g. \r\nhttps://github.com/dotnet/aspnetcore/blob/f96dce6889fe67aaed33f0c2b147b8b537358f1e/src/Security/Authentication/Certificate/src/CertificateAuthenticationHandler.cs#L243\r\n\r\nOpenIdConnect actually has an issuer concept built in, that\u0027s what\u0027s used to validate the token and create the Claims.\r\nhttps://github.com/dotnet/aspnetcore/blob/971df4cbdc045c879f288b8cdfd726fd4212f882/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectHandler.cs#L1239-L1248\r\n\r\nSince the validation and claims creation steps are linked together within IdentityModel, that\u0027s not something we can change. The closest we could manage is to re-write the identity after it\u0027s created.\r\n\r\nWhy do you need to change the issuer?",
        "createdAt": "2022-11-24T00:14:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41589#issuecomment-1325792068"
      },
      {
        "id": "IC_kwDOAQzde85PBfvf",
        "parentId": null,
        "author": "??",
        "content": "Hi @amoszheng. We have added the \u0022Needs: Author Feedback\u0022 label to this issue, which indicates that we have an open question for you before we can take further action. This issue will be closed automatically in 7 days if we do not hear back from you by then - please feel free to re-open it if you come back to this issue after that time.",
        "createdAt": "2022-11-24T00:15:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41589#issuecomment-1325792223"
      },
      {
        "id": "IC_kwDOAQzde85PLbob",
        "parentId": null,
        "author": "??",
        "content": "This issue has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **4 days**. It will be closed if no further activity occurs **within 3 days of this comment**. If it *is* closed, feel free to comment when you are able to provide the additional information and we will re-investigate.\n\nSee [our Issue Management Policies](https://aka.ms/aspnet/issue-policies) for more information.",
        "createdAt": "2022-11-28T01:00:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41589#issuecomment-1328396827"
      },
      {
        "id": "IC_kwDOAQzde85POAml",
        "parentId": null,
        "author": "amoszheng",
        "content": "@Tratcher we wanted to use the OpenIdConnect client to implement external login integration for an identity provider that is not yet supported neither by Microsoft out of the box nor [aspnet-contrib](https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers). Since every supported provider changes the issuer of the claims to the name of the external provider (e.g. \u0022Google\u0022, \u0022Facebook\u0022, \u0022LinkedIn\u0022), we thought we would do the same with the OpenIdConnect client and have our external identity provider integrate seamlessly into the existing pipeline.\r\n\r\nHaving the OpenIdConnect client support changing the issuer of the claims would allow integration with any identity provider that supports OpenId Connect without having to write a custom provider. That provides a lot of flexibility to integrate new login providers to our applications, now that OpenId connect is pretty much the norm everywhere for this kind of stuff.",
        "createdAt": "2022-11-28T13:14:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41589#issuecomment-1329072549"
      },
      {
        "id": "IC_kwDOAQzde85PPHDb",
        "parentId": null,
        "author": "Tratcher",
        "content": "The claims issuer is still set to a unique provider ID like \u0022https://myprovider.com\u0022, right? Is your concern about the format?",
        "createdAt": "2022-11-28T16:11:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41589#issuecomment-1329361115"
      },
      {
        "id": "IC_kwDOAQzde85PPmmK",
        "parentId": null,
        "author": "amoszheng",
        "content": "@Tratcher yes, we tried to set it to \u0022MyProvider\u0022 but could not do it like it is for the other login providers.",
        "createdAt": "2022-11-28T17:41:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41589#issuecomment-1329490314"
      },
      {
        "id": "IC_kwDOAQzde85PPv9I",
        "parentId": null,
        "author": "Tratcher",
        "content": "Can you clarify why you _need_ it to be formatted as \u0022MyProvider\u0022 instead of the current value \u0022https://myprovider.com/\u0022?",
        "createdAt": "2022-11-28T18:08:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41589#issuecomment-1329528648"
      },
      {
        "id": "IC_kwDOAQzde85PPyfF",
        "parentId": null,
        "author": "brockallen",
        "content": "\u003E Can you clarify why you need it to be formatted as \u0022MyProvider\u0022\r\n\r\nI\u0027m guessing because it matches the scheme name, not the issuer. I was always confused by the discrepancy between the social providers and how the OIDC one is done.",
        "createdAt": "2022-11-28T18:16:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41589#issuecomment-1329539013"
      },
      {
        "id": "IC_kwDOAQzde85PPz1u",
        "parentId": null,
        "author": "amoszheng",
        "content": "@brockallen you are right, for all other social login providers the issuer matches the scheme name, e.g. for Google the issuer of the claims is \u0022Google\u0022, for Facebook it is \u0022Facebook\u0022, for LinkedIn it is \u0022LinkedIn\u0022, and so forth.",
        "createdAt": "2022-11-28T18:21:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41589#issuecomment-1329544558"
      },
      {
        "id": "IC_kwDOAQzde85PP0Q5",
        "parentId": null,
        "author": "Tratcher",
        "content": "@brockallen mainly because IdentityModel doesn\u0027t provide an API to set the claims issuer independently, and this is the first request I\u0027m aware of to do so. We can file an issue over there to add such an API.",
        "createdAt": "2022-11-28T18:22:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41589#issuecomment-1329546297"
      },
      {
        "id": "IC_kwDOAQzde85PP2k1",
        "parentId": null,
        "author": "Tratcher",
        "content": "Filed https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/1972.",
        "createdAt": "2022-11-28T18:30:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41589#issuecomment-1329555765"
      },
      {
        "id": "IC_kwDOAQzde85PQAAA",
        "parentId": null,
        "author": "Tratcher",
        "content": "Workaround:\r\n\u0060\u0060\u0060\r\n    private class IssuerFixupAction : ClaimAction\r\n    {\r\n        public IssuerFixupAction() : base(ClaimTypes.NameIdentifier, string.Empty) { }\r\n\r\n        public override void Run(JsonElement userData, ClaimsIdentity identity, string issuer)\r\n        {\r\n            var oldClaims = identity.Claims.ToList();\r\n            foreach (var claim in oldClaims)\r\n            {\r\n                identity.RemoveClaim(claim);\r\n                identity.AddClaim(new Claim(claim.Type, claim.Value, claim.ValueType, issuer, claim.OriginalIssuer, claim.Subject));\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n        services.AddAuthentication(...).AddCookie().AddOpenIdConnect(o =\u003E\r\n        {\r\n           // ...\r\n            o.ClaimsIssuer = \u0022MyCustomIssuer\u0022;\r\n            o.ClaimActions.Add(new IssuerFixupAction());\r\n\u0060\u0060\u0060",
        "createdAt": "2022-11-28T18:58:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41589#issuecomment-1329594368"
      },
      {
        "id": "IC_kwDOAQzde85PQEwd",
        "parentId": null,
        "author": "amoszheng",
        "content": "\u003E Workaround:\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E     private class IssuerFixupAction : ClaimAction\r\n\u003E     {\r\n\u003E         public IssuerFixupAction() : base(ClaimTypes.NameIdentifier, string.Empty) { }\r\n\u003E \r\n\u003E         public override void Run(JsonElement userData, ClaimsIdentity identity, string issuer)\r\n\u003E         {\r\n\u003E             var oldClaims = identity.Claims.ToList();\r\n\u003E             foreach (var claim in oldClaims)\r\n\u003E             {\r\n\u003E                 identity.RemoveClaim(claim);\r\n\u003E                 identity.AddClaim(new Claim(claim.Type, claim.Value, claim.ValueType, issuer, claim.OriginalIssuer, claim.Subject));\r\n\u003E             }\r\n\u003E         }\r\n\u003E     }\r\n\u003E \r\n\u003E \r\n\u003E         services.AddAuthentication(...).AddCookie().AddOpenIdConnect(o =\u003E\r\n\u003E         {\r\n\u003E            // ...\r\n\u003E             o.ClaimsIssuer = \u0022MyCustomIssuer\u0022;\r\n\u003E             o.ClaimActions.Add(new IssuerFixupAction());\r\n\u003E \u0060\u0060\u0060\r\n\r\nThanks for the workaround! Will try it while we wait for the permanent fix. Keep up the awesome work you guys do in the .NET team!",
        "createdAt": "2022-11-28T19:11:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41589#issuecomment-1329613853"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85KfMJn",
    "title": "Support configuring the defaults for JWTs created using the user-jwts tool",
    "url": "https://github.com/dotnet/aspnetcore/issues/41872",
    "createdAt": "2022-05-26T15:03:26Z",
    "lastUpdated": "2024-10-31T21:41:25Z",
    "body": "It would be useful to be able to configure the defaults used by \u0060dotnet user-jwts\u0060 so that they\u0027re used for further created JWTs until the defaults are changed again or reset.\r\n\r\nIntroduce a new \u0060defaults\u0060 sub-command that allows the setting of the default values for options:\r\n\r\n\u0060\u0060\u0060\r\n$ dotnet user-jwts defaults\r\nJWT defaults for project MyApp.csproj:\r\n  Option        Value\r\n  ------------  ----------------------\r\n  --name        [Environment.UserName]\r\n  --not-before  [DateTime.UtcNow]\r\n  --valid-for   28d\r\n  --scheme      Bearer\r\n  --issuer      dotnet-user-jwts\r\n  --audience   [ApplicationUrl]\r\n$ dotnet user-jwts defaults --valid-for 7d\r\nDefault value of --valid-for was set to 7d\r\n$ dotnet user-jwts defaults --name TestUser\r\nDefault value of --name was set to TestUser\r\n$ dotnet user-jwts defaults --name --reset\r\nDefault value of --name was set to [Environment.UserName]\r\n$ dotnet user-jwts defaults --reset\r\nDefault values for all JWT options were reset\r\n$ \r\n\u0060\u0060\u0060\r\n\r\n## Dynamic default values\r\n\r\nOptions that have default values that are set dynamically will be represented with a square-brace surrounded pseudo-value that represents where the default value comes from. Note that dynamic default values cannot be set via the CLI, this is just about how they\u0027re displayed to indicate their default value is currently set from a dynamic source:\r\n\r\n\u0060\u0060\u0060\r\n--name        [Environment.UserName]\r\n--not-before  [DateTime.UtcNow]\r\n--audience    [ApplicationUrl]\r\n\u0060\u0060\u0060\r\n\r\n## Multi-value options defaults\r\n\r\nSome options support specifying multiple values at JWT creation time, e.g. \u0060--claim\u0060, \u0060--scope\u0060, \u0060--role\u0060, \u0060--audience\u0060. These options can have multiple defaults configured with those defaults being applied to all JWTs created. A single default value can be removed for such options by using the \u0060--remove\u0060 option:\r\n\r\n\u0060\u0060\u0060\r\n$ dotnet user-jwts defaults --scope myapps:user --scope myapps:read\r\nDefault value of myapps:user for --scope added \r\nDefault value of myapps:read for --scope added \r\n$ dotnet user-jwts defaults --scope myapps:read --remove\r\nDefault value of myapps:read for --scope removed\r\n$\r\n\u0060\u0060\u0060\r\n\r\n## Global vs. project defaults\r\n\r\n\u003E\u2753 Do we think this is worthwhile, or should we just make all defaults apply globally?\r\n\r\nJWT defaults can be set either at the project level or global level. By default, the JWT defaults command sets defaults at the project level, defaulting to the project in the current directory. A specific project can be specified via the \u0060--project\u0060 option (note you cannot set a default value for \u0060--project\u0060, it is used to indicate which project to set the defaults for). Global default values can be set via the \u0060--global\u0060 option (\u0060-g\u0060 for short).\r\n\r\n\u0060\u0060\u0060\r\n$ dotnet user-jwts defaults --global\r\nGlobal JWT defaults:\r\n  Option        Value\r\n  ------------  ----------------------\r\n  --name        [Environment.UserName]\r\n  --not-before  [DateTime.UtcNow]\r\n  --valid-for   28d\r\n  --scheme      Bearer\r\n  --issuer      dotnet-user-jwts\r\n  --audience   [ApplicationUrl]\r\n$ dotnet user-jwts defaults --valid-for 7d --global\r\nDefault value of --valid-for was set to 7d\r\n$ dotnet user-jwts defaults --name --reset --global\r\nDefault value of --name was set to [Environment.UserName]\r\n$ dotnet user-jwts defaults --reset --global\r\nDefault values for all JWT options were reset\r\n$ \r\n\u0060\u0060\u0060\r\n\r\n## Resetting default values\r\n\r\nDefault values can be reset to their in-box defaults via the \u0060--reset\u0060 option. Each option that should be reset can be supplied via their respective option. If no other options are supplied then all values are reset.\r\n\r\n\u0060\u0060\u0060\r\n$ dotnet user-jwts defaults --name --reset\r\nDefault value of --name was reset to [Environment.UserName]\r\n$ dotnet user-jwts defaults --valid-for --not-before --reset\r\nDefault value of --valid-for was reset to 28d\r\nDefault value of --not-before was reset to [DateTime.UtcNow]\r\n$ dotnet user-jwts defaults --reset\r\nDefault values for all JWT options were reset\r\n$ \r\n\u0060\u0060\u0060",
    "upvotes": 2,
    "labels": [
      "enhancement",
      "area-auth",
      "area-commandlinetools",
      "feature-userjwts"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde85K5Fr_",
    "title": "user LDAP GlobalCatalog to get user groups and add them to ClaimPrincipal.",
    "url": "https://github.com/dotnet/aspnetcore/issues/41974",
    "createdAt": "2022-06-01T16:48:04Z",
    "lastUpdated": "2024-09-10T19:32:56Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Is your feature request related to a problem? Please describe the problem.\r\n\r\nThis is in context to response received from  \u0022ZhiLv-MSFT\u0022  for https://docs.microsoft.com/en-us/answers/questions/870212/issue-in-implementing-windows-authentication-and-l.html\r\n\r\nBackground:-\r\nWe have a intranet web api hosted in Windows box (on prem) which is consumed by our Angular UI and we need to implement Integration Windows Authentication in the API side. I was looking into the MS docs (see below url) and noticed that there is \u0022AddNegotiate\u0022 method which can help us authentication / authorize user.\r\n\r\n I see there is a method by the name \u0022EnableLDAP\u0022. But, when to try to pass LDAP GlobalCatalog then it throws error to us. However, If write simple LDAP code logic using \u0022DirectoryEntry\u0022 with GlobalCatalog then it works.\r\n\r\nCan we have a feature in AddNegotiate to use LDAP GlobalCatalog to pull user claims. \r\n\r\n### Describe the solution you\u0027d like\r\n\r\nCan we have a feature in AddNegotiate to use LDAP GlobalCatalog to pull user claims. \r\n\r\n### Additional context\r\n\r\nSo far I do not have any question expect that- Can this be provided as a feature ?",
    "upvotes": 0,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85EQSI1",
        "parentId": null,
        "author": "blowdart",
        "content": "The LDAP support is there for Kerberos auth, rather than Windows auth. You\u0027re hosting on Windows so the expectation is you use Windows/Integrated auth.\r\n\r\nWindows auth is somewhat special, groups appear as roles, and they\u0027re kind of there in the background, but you can\u0027t enumerate, you are forced to use IsInRole to validate membership, and that\u0027s only server side, not on the client. \r\n\r\nThe most \u0022blessed\u0022 way to do this, assuming you want full enumeration would be to treat it all like oauth, and have adfs running within your domain, then configure ADFS to deliver the claims you want in the token, and do an oauth login (if configured correctly adfs will do this silently in your intranet). There\u0027s an added bonus here that if you eventually move cloudwards you can use the same code, just point it at azure ad or whatever cloud auth provider you use.\r\n\r\nIs ADFS an option for you here?",
        "createdAt": "2022-06-02T17:28:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41974#issuecomment-1145119285"
      },
      {
        "id": "IC_kwDOAQzde85EQd5N",
        "parentId": null,
        "author": "srivastava-prashant",
        "content": "\u003E The LDAP support is there for Kerberos auth, rather than Windows auth. You\u0027re hosting on Windows so the expectation is you use Windows/Integrated auth.\r\n\u003E \r\n\u003E Windows auth is somewhat special, groups appear as roles, and they\u0027re kind of there in the background, but you can\u0027t enumerate, you are forced to use IsInRole to validate membership, and that\u0027s only server side, not on the client.\r\n\u003E \r\n\u003E The most \u0022blessed\u0022 way to do this, assuming you want full enumeration would be to treat it all like oauth, and have adfs running within your domain, then configure ADFS to deliver the claims you want in the token, and do an oauth login (if configured correctly adfs will do this silently in your intranet). There\u0027s an added bonus here that if you eventually move cloudwards you can use the same code, just point it at azure ad or whatever cloud auth provider you use.\r\n\u003E \r\n\u003E Is ADFS an option for you here?\r\n\r\n@blowdart - Currently, our department application server in my organization does not have ADFS configured due to manufacturing domain restriction ( majorly, data classification being confidential).  So, ADFS won\u0027t be an option here at the moment. We initially planned for Azure SSO but that too was not further approved to implement due to mentioned restriction. \r\n\r\n**For point:-** \u0022The LDAP support is there for Kerberos auth, rather than Windows auth. You\u0027re hosting on Windows so the expectation is you use Windows/Integrated auth.\u0022\r\n\r\n**Question #  1:-** Application hosted on Windows IIS with Integrated Windows Authentication approach can\u0027t connect to LDAP ?\r\n\r\nI mean I was under the impression that since .NET / Windows are both Microsoft product and LDAP is pretty common to be used in most of the organization. So, application hosted on Windows IIS would have some ability to connect to LDAP server.\r\n\r\nCurrently we are able to authenticate the user using Negotiate scheme and in ClaimsTransformation we pull the user claim from LDAP passing GlobalCatalog in .NET\u0027s DirectoryEntry class as a parameter then further add those claims to users Identity. But, problem with this approach is this ClaimsTransformation is called on every request. And, this in turn hits LDAP and recreate user claim/ Identity (which is not the right practice to follow).  And, this thing work on application hosted on Windows IIS.\r\n\r\n**Question #  2:-** Could you please shed some light on a way in Windows/Integrated auth where we can hit LDAP to pull user roles just once when they login and then later use them in some token for subsequent request ?\r\n\r\nThanks,\r\nPrashant \r\n\r\n\r\n",
        "createdAt": "2022-06-02T18:12:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41974#issuecomment-1145167437"
      },
      {
        "id": "IC_kwDOAQzde85EQgma",
        "parentId": null,
        "author": "blowdart",
        "content": "_Application hosted on Windows IIS with Integrated Windows Authentication approach can\u0027t connect to LDAP ?_\r\n\r\nThey can, it\u0027s just you need to write code to do it. \r\n\r\nIntegrated auth is special. Integrated auth is done by the browser and the server before the app sees anything, your app cannot influence it.\r\n\r\n_Could you please shed some light on a way in Windows/Integrated auth where we can hit LDAP to pull user roles just once when they login and then later use them in some token for subsequent request ?_\r\n\r\nWhat you could do is use a [claims transformation service](https://docs.microsoft.com/en-us/aspnet/core/security/authentication/claims?view=aspnetcore-6.0#extend-or-add-custom-claims-using-iclaimstransformation). That would run when an identity is created, which is _probably_ on every request even with integrated auth. So there are scalability issues here, you\u0027d have to concern caching the groups you retrieve from the LDAP querty. ",
        "createdAt": "2022-06-02T18:24:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41974#issuecomment-1145178522"
      },
      {
        "id": "IC_kwDOAQzde85EQi6S",
        "parentId": null,
        "author": "srivastava-prashant",
        "content": "\u003E _Application hosted on Windows IIS with Integrated Windows Authentication approach can\u0027t connect to LDAP ?_\r\n\u003E \r\n\u003E They can, it\u0027s just you need to write code to do it.\r\n\u003E \r\n\u003E Integrated auth is special. Integrated auth is done by the browser and the server before the app sees anything, your app cannot influence it.\r\n\u003E \r\n\u003E _Could you please shed some light on a way in Windows/Integrated auth where we can hit LDAP to pull user roles just once when they login and then later use them in some token for subsequent request ?_\r\n\u003E \r\n\u003E What you could do is use a [claims transformation service](https://docs.microsoft.com/en-us/aspnet/core/security/authentication/claims?view=aspnetcore-6.0#extend-or-add-custom-claims-using-iclaimstransformation). That would run when an identity is created, which is _probably_ on every request even with integrated auth. So there are scalability issues here, you\u0027d have to concern caching the groups you retrieve from the LDAP querty.\r\n\r\n@blowdart Thanks for your prompt response. I appreciate it !\r\nI see there is NegotiateHandler class too https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.negotiate.negotiatehandler?view=aspnetcore-6.0\r\nCan we by chance use this in a AddScheme rather than having AddNegotiate and then whatever code we wrote in ClaimsTransformation we can move that to this handler (with assumption this handler would not be called on each request) \r\n\r\nThis way may be we will not hit LDAP again and again to pull user role and recreate Identity. Assuming this NegotiateHandler will be called only once. Until and unless user logs out.\r\n\r\nAm I going in the right direction ? \r\n\r\nYour suggestion here would be much appreciated. \r\n\r\nThanks,\r\nPrashant ",
        "createdAt": "2022-06-02T18:35:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41974#issuecomment-1145187986"
      },
      {
        "id": "IC_kwDOAQzde85EQjT3",
        "parentId": null,
        "author": "blowdart",
        "content": "@Tratcher for thoughts here, I\u0027m honestly not sure how it would work. Negotiating is basically calling integrated auth manually AFAIK.",
        "createdAt": "2022-06-02T18:36:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41974#issuecomment-1145189623"
      },
      {
        "id": "IC_kwDOAQzde85ERBj7",
        "parentId": null,
        "author": "Tratcher",
        "content": "The NegotiateHandler is also invoked per request. You\u0027re better off using ClaimsTransformation or NegotiateEvents.OnAuthenticated and adding some of your own caching.",
        "createdAt": "2022-06-02T20:32:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41974#issuecomment-1145313531"
      },
      {
        "id": "IC_kwDOAQzde85ERIjN",
        "parentId": null,
        "author": "srivastava-prashant",
        "content": "\u003E The NegotiateHandler is also invoked per request. You\u0027re better off using ClaimsTransformation or NegotiateEvents.OnAuthenticated and adding some of your own caching.\r\n\r\n@Tratcher -\r\nDoes that means - we would have to re- populate the user claims from Cache on each and every request and then further in our authorization Policy handler check whether user is part of individual role ?\r\n\r\nIf yes, then it would be an overhead for application process it X number of times (where X is number of API calls we have on any individual page).\r\n\r\nIs my understanding correct here ?\r\n\r\nRegards,\r\nPrashant Srivastava",
        "createdAt": "2022-06-02T21:07:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41974#issuecomment-1145342157"
      },
      {
        "id": "IC_kwDOAQzde85ERJqT",
        "parentId": null,
        "author": "Tratcher",
        "content": "That\u0027s correct.\r\n\r\nIs there a reason your Authorization Policy can\u0027t call the built in IsInRole API?",
        "createdAt": "2022-06-02T21:13:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41974#issuecomment-1145346707"
      },
      {
        "id": "IC_kwDOAQzde85ERMTy",
        "parentId": null,
        "author": "srivastava-prashant",
        "content": "\u003E That\u0027s correct.\r\n\u003E \r\n\u003E Is there a reason your Authorization Policy can\u0027t call the built in IsInRole API?\r\n\r\n@Tratcher Nope, We can certainly do that. The thing we were concerned about here was majorly the \u0022re- populating of user claims from Cache on each and every request\u0022. \r\n\r\nI might be asking too much. Not sure whether it would be feasible or not.\r\nBut, can / do we have a plan for having a feature of having avoid caching in ClaimTransformation for populating user claims in MS future releases?\r\n\r\nRegards,\r\nPrashant Srivastava",
        "createdAt": "2022-06-02T21:26:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41974#issuecomment-1145357554"
      },
      {
        "id": "IC_kwDOAQzde85ER-uk",
        "parentId": null,
        "author": "davidfowl",
        "content": "This sounds like a reasonable request to me. I was asking recently about the usage of the negotiate API we\u0027re going to make public in .NET 7 and it seems like what we do right now is very inefficient. Seems like we should look in to caching if possible here.\r\n\r\nPS: This reminds me about what we did for certificate auth. There might be a similar solution here.",
        "createdAt": "2022-06-03T04:04:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41974#issuecomment-1145564068"
      },
      {
        "id": "IC_kwDOAQzde85ESB9b",
        "parentId": null,
        "author": "srivastava-prashant",
        "content": "\u003E This sounds like a reasonable request to me. I was asking recently about the usage of the negotiate API we\u0027re going to make public in .NET 7 and it seems like what we do right now is very inefficient. Seems like we should look in to caching if possible here.\r\n\u003E \r\n\u003E PS: This reminds me about what we did for certificate auth. There might be a similar solution here.\r\n\r\n@davidfowl So, Is this request which I was asking above to @Tratcher is going to be part of .NET 7 release ?\r\n\r\n**For Point:** \u0022PS: This reminds me about what we did for certificate auth. There might be a similar solution here.\u0022\r\nUnfortunately, the guideline from our department in our company  is to use IWA due to certain restriction (being a confidential application).  So, we cannot just rely on certificate.\r\n\r\nRegards,\r\nPrashant Srivastava",
        "createdAt": "2022-06-03T04:38:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41974#issuecomment-1145577307"
      },
      {
        "id": "IC_kwDOAQzde85FF_Nm",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "\u003E So, Is this request which I was asking above to @Tratcher is going to be part of .NET 7 release ?\r\n\r\nThis won\u0027t make it into .NET 7. We can consider this for inclusion in .NET 8.",
        "createdAt": "2022-06-17T20:12:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41974#issuecomment-1159197542"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85LLLqc",
    "title": "Add methods for registering both authentication and authorization middlewares/services",
    "url": "https://github.com/dotnet/aspnetcore/issues/42047",
    "createdAt": "2022-06-06T01:12:16Z",
    "lastUpdated": "2023-06-20T21:48:59Z",
    "body": "## Background and Motivation\r\n\r\nTo provide an abstraction of registering both authentication and authorization-related middlewares/services in an app with fewer lines of code and build on the foundation of automatically registering middlewares/services that we started in preview5, we would like to add extension methods for registering both authentication and authorization-related middlewares/services via one overload.\r\n\r\n## Proposed API\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace Microsoft.Extensions.DependencyInjection;\r\n\r\npublic static class AuthServiceCollectionExtensions \r\n{\r\n  public static IServiceCollection AddAuthenticationAndAuthorization(this IServiceCollection services);\r\n  public static IServiceCollection AddAuthenticationAndAuthorization(\r\n    this IServiceCollection services,\r\n    Action\u003CAuthorizationOptions\u003E configureAuthorizationOptions);\r\n  public static IServiceCollection AddAuthenticationAndAuthorization(\r\n    this IServiceCollection services,\r\n    Action\u003CAuthenticationOptions\u003E configureAuthenticationOptions);\r\n  public static IServiceCollection AddAuthenticationAndAuthorization(\r\n    this IServiceCollection services,\r\n    Action\u003CAuthenticationOptions\u003E configureAuthenticationOptions,\r\n    Action\u003CAuthorizationOptions\u003E configureAuthorizationOptions);\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace Microsoft.AspNetCore.Builder;\r\n\r\npublic static class AuthAppBuilderExtensions\r\n{\r\n  public static IApplicationBuilder UseAuthenticationAndAuthorization(this IApplicationBuilder app)\r\n}\r\n\u0060\u0060\u0060\r\n\r\n## Usage Examples\r\n\r\n**Before**\r\n\u0060\u0060\u0060csharp\r\nvar builder = WebApplication.CreateBuilder(args);\r\nbuilder.Services.AddAuthentication();\r\nbuilder.Services.AddAuthorization();\r\nvar app = builder.Build();\r\napp.UseAuthentication();\r\napp.UseAuthorization();\r\n\u0060\u0060\u0060\r\n\r\n**After**\r\n\u0060\u0060\u0060csharp\r\nvar builder = WebApplication.CreateBuilder(args);\r\nbuilder.Services.AddAuthenticationAndAuthorization();\r\nvar app = builder.Build();\r\napp.UseAuthenticationAndAuthorization();\r\n\u0060\u0060\u0060\r\n\r\n**After with Options**\r\n\u0060\u0060\u0060csharp\r\nvar builder = WebApplication.CreateBuilder(args);\r\nbuilder.Services.AddAuthenticationAndAuthorization(options =\u003E {\r\n  options.DefaultScheme = \u0022foobar\u0022;\r\n});\r\nvar app = builder.Build();\r\napp.UseAuthenticationAndAuthorization();\r\n\u0060\u0060\u0060\r\n",
    "upvotes": 0,
    "labels": [
      "area-auth",
      "api-needs-work"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85EXNKj",
        "parentId": null,
        "author": "??",
        "content": "Thank you for submitting this for API review. This will be reviewed by @dotnet/aspnet-api-review at the next meeting of the ASP.NET Core API Review group. Please ensure you take a look at [the API review process documentation](https://github.com/dotnet/aspnetcore/blob/main/docs/APIReviewProcess.md) and ensure that:\n\n* The PR contains changes to the reference-assembly that describe the API change. **Or**, you have included a snippet of reference-assembly-style code that illustrates the API change.\n* The PR describes the impact to users, both positive (useful new APIs) and negative (breaking changes).\n* Someone is assigned to \u0022champion\u0022 this change in the meeting, and they understand the impact and design of the change.",
        "createdAt": "2022-06-06T01:12:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42047#issuecomment-1146933923"
      },
      {
        "id": "IC_kwDOAQzde85EXODK",
        "parentId": null,
        "author": "davidfowl",
        "content": "Not sure about the adds as both need to be configured. The API sample should show a before and after with options.",
        "createdAt": "2022-06-06T01:20:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42047#issuecomment-1146937546"
      },
      {
        "id": "IC_kwDOAQzde85EzAZx",
        "parentId": null,
        "author": "halter73",
        "content": "API Review Notes:\r\n- Do we need \u0060AddAuthenticationAndAuthorization\u0060 given you can call \u0060AddAuthentication\u0060 and \u0060AddAuthorization\u0060 in either order? And that there are two different options objects to configure?\r\n  - No\r\n- What about \u0060UseAuthenticationAndAuthorization\u0060? Do we need it?\r\n  - Yes. It doesn\u0027t make sense to use authz without authn.\r\n- Can we come up with a better name?\r\n  - UseAuthNAndAuthZ\r\n  - UseAuth\r\n  - UseAuthStar \uD83D\uDE06 \r\n  - UseAuths\r\n- \u0060UseAuth\u0060 wins. We think it implies both authn and authz.\r\n- What assembly should \u0060UseAuth\u0060 live in?\r\n  - We can\u0027t find a good one\r\n\r\nAPI would be approved if we can find a good assembly for it. Until then, it needs work.\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.AspNetCore.Builder;\r\n\r\npublic static class AuthAppBuilderExtensions\r\n{\r\n\u002B  public static IApplicationBuilder UseAuth(this IApplicationBuilder app);\r\n}\r\n\u0060\u0060\u0060\r\n",
        "createdAt": "2022-06-13T18:04:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42047#issuecomment-1154221681"
      },
      {
        "id": "IC_kwDOAQzde85EzFul",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-06-13T18:28:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42047#issuecomment-1154243493"
      },
      {
        "id": "IC_kwDOAQzde85E2LXu",
        "parentId": null,
        "author": "Kahbazi",
        "content": "\u003E It doesn\u0027t make sense to use authz without authn.\r\n\r\n@halter73 Just FYI I don\u0027t use authn middleware in the applications that are just APIs. I don\u0027t have a default authn scheme and I also don\u0027t need any remote authentication handler. Also all endpoints are marked with Authorize attribute with different scheme.",
        "createdAt": "2022-06-14T11:22:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42047#issuecomment-1155053038"
      },
      {
        "id": "IC_kwDOAQzde85E21EU",
        "parentId": null,
        "author": "halter73",
        "content": "Thanks for pointing that out it\u0027s possible to use authz middleware without authn middleware. It\u0027s not a scenario I considered. Fortunately, we are not planning on removing any existing auth APIs, so you should be able to continue using just the authz middleware by itself.",
        "createdAt": "2022-06-14T13:58:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42047#issuecomment-1155223828"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85LLd_n",
    "title": "Make it easier to discover how to enforce/require auth in an application",
    "url": "https://github.com/dotnet/aspnetcore/issues/42048",
    "createdAt": "2022-06-06T03:34:45Z",
    "lastUpdated": "2024-09-10T19:32:57Z",
    "body": "From https://github.com/dotnet/aspnetcore/issues/39857#issuecomment-1107473315\r\n\r\n\u003E \u003E Make it easier to discover how to enforce auth: builder.Authentication.RequireAuthentication() or similar, which could just hide the call to add the AuthorizeAttribute filter.\r\n\r\n\u003E I like this idea. I\u0027ve personally struggled with finding the right settings to \u0022just require auth for the whole app\u0022 (FallbackPolicy et al). We\u0027ll consider this scenario.\r\n",
    "upvotes": 3,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85Ea6uJ",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "FYI @HaoK @blowdart @Tratcher @captainsafia @jcjiang @CamiloTerevint\r\n\r\nInterested in folks\u0027 thoughts on this one. The idea is to make it much easier to require authentication for the whole app. Today this is done something like the following which isn\u0027t terribly intuitive:\r\n\r\n\u0060\u0060\u0060csharp\r\nbuilder.Services.AddAuthorization(c =\u003E\r\n{\r\n    c.FallbackPolicy = c.DefaultPolicy;\r\n});\r\n\u0060\u0060\u0060\r\n\r\nI think the thought was that we could enable something like this that would essentially do the above in a way that can\u0027t be overridden by other \u0060IConfigureOptions\u003CAuthorizationOptions\u003E\u0060:\r\n\r\n\u0060\u0060\u0060csharp\r\nbuilder.Authentication.RequireAuthentication();\r\n\u0060\u0060\u0060\r\n\r\nAlternatively perhaps it could be inverted:\r\n\r\n\u0060\u0060\u0060csharp\r\nbuilder.Authentication.AllowAnonymousUsers = false;\r\n\u0060\u0060\u0060",
        "createdAt": "2022-06-06T20:44:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147906953"
      },
      {
        "id": "IC_kwDOAQzde85Ea8d-",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E I think the thought was that we could enable something like this that would essentially do the above in a way that can\u0027t be overridden by other \u0060IConfigureOptions\u003CAuthorizationOptions\u003E\u0060:\r\n\r\nWhy are you concerned about it being overridden? Do you think it would be common for people to have conflicting authz setups?\r\n\r\n\u003E \u0060\u0060\u0060cs\r\n\u003E builder.Authentication.RequireAuthentication();\r\n\u003E \u0060\u0060\u0060\r\n\r\nThis is fine.",
        "createdAt": "2022-06-06T20:51:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147914110"
      },
      {
        "id": "IC_kwDOAQzde85Ea-LI",
        "parentId": null,
        "author": "HaoK",
        "content": "So \u0060builder.Authentication.RequireAuthentication();\u0060 =\u003Ewould be the same as today\u0027s behavior of requiring the default authZ policy (any isAuthenticated = true clams identity)?  Or is this going to be slightly different than just setting the fallback policy, I believe the fallback policy only kicks in if NO policy is specified, so the fallback policy doesn\u0027t technically require authentication either.",
        "createdAt": "2022-06-06T20:57:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147921096"
      },
      {
        "id": "IC_kwDOAQzde85Ea-Ou",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "\u003E Why are you concerned about it being overridden? Do you think it would be common for people to have conflicting authz setups?\r\n\r\nI\u0027m concerned about scenarios where it\u0027s unclear that something else has loosened the auth requirements.",
        "createdAt": "2022-06-06T20:57:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147921326"
      },
      {
        "id": "IC_kwDOAQzde85Ea-ay",
        "parentId": null,
        "author": "blowdart",
        "content": "Definitely prefer require over AllowAnonymous=false, but allowanonymous on endpoints still needs to override",
        "createdAt": "2022-06-06T20:58:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147922098"
      },
      {
        "id": "IC_kwDOAQzde85Ea-qd",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "\u003E So \u0060builder.Authentication.RequireAuthentication();\u0060 =\u003Ewould be the same as today\u0027s behavior of requiring the default authZ policy (any isAuthenticated = true clams identity)? Or is this going to be slightly different than just setting the fallback policy, I believe the fallback policy only kicks in if NO policy is specified, so the fallback policy doesn\u0027t technically require authentication either.\r\n\r\nYeah that\u0027s a great point. The idea is this should \u0022do whatever it takes\u0022 to force all users of the app to be authenticated, with exceptions for resources that are explicitly marked as anonymous allowed.",
        "createdAt": "2022-06-06T20:58:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147923101"
      },
      {
        "id": "IC_kwDOAQzde85Ea-tk",
        "parentId": null,
        "author": "HaoK",
        "content": "\u003E I\u0027m concerned about scenarios where it\u0027s unclear that something else has loosened the auth requirements.\r\n\r\nRight this is a valid concern, as if we don\u0027t change what RequireAuthentication does, it does not really require authentication as implemented only via fallback policy.  You would easily bypass this by either changing the default policy, or specifying a policy that doesn\u0027t add the DenyAnonymous requirement.",
        "createdAt": "2022-06-06T20:58:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147923300"
      },
      {
        "id": "IC_kwDOAQzde85Ea--8",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "With those points clarified, what would the implementation of this look like? Does it need a new concept?",
        "createdAt": "2022-06-06T20:59:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147924412"
      },
      {
        "id": "IC_kwDOAQzde85Ea_AV",
        "parentId": null,
        "author": "HaoK",
        "content": "Right so I\u0027m fine with the name, but it needs to be implemented differently (in addition to using the fallback policy)",
        "createdAt": "2022-06-06T20:59:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147924501"
      },
      {
        "id": "IC_kwDOAQzde85Ea_MI",
        "parentId": null,
        "author": "HaoK",
        "content": "It doesn\u0027t need a new concept, it just needs to fully do what we want it to do which is probably additional logic in Combine or the actual AuthZ service to be aware of this flag",
        "createdAt": "2022-06-06T21:00:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147925256"
      },
      {
        "id": "IC_kwDOAQzde85Ea_hc",
        "parentId": null,
        "author": "HaoK",
        "content": "We have an Authorization requirement doing exactly what we want already, we would just need to force that requirement for all of Authorization perhaps when this turned on.",
        "createdAt": "2022-06-06T21:01:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147926620"
      },
      {
        "id": "IC_kwDOAQzde85Ea_nf",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "Right, kind of like a \u0022global requirement\u0022.",
        "createdAt": "2022-06-06T21:01:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147927007"
      },
      {
        "id": "IC_kwDOAQzde85Ea_9N",
        "parentId": null,
        "author": "HaoK",
        "content": "Yeah we are getting a bit fragmented as we\u0027d have Default Policy which is subtly different from fallback policy, and now global requirements, I guess we can introduce it that way and implement it like that",
        "createdAt": "2022-06-06T21:03:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147928397"
      },
      {
        "id": "IC_kwDOAQzde85EbAHq",
        "parentId": null,
        "author": "HaoK",
        "content": "A new IEnumerable on AuthorizationProperties (GlobalRequirements), RequireAuthentication would just add DenyAnonymous to the global requirements, we always add all global requirements to all Authorization requests.",
        "createdAt": "2022-06-06T21:04:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147929066"
      },
      {
        "id": "IC_kwDOAQzde85EbATi",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "Where is \u0060AuthorizationProperties\u0060? i.e. what types would actually change here?",
        "createdAt": "2022-06-06T21:04:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147929826"
      },
      {
        "id": "IC_kwDOAQzde85EbAW0",
        "parentId": null,
        "author": "HaoK",
        "content": "Oops AuthorizationOptions",
        "createdAt": "2022-06-06T21:05:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147930036"
      },
      {
        "id": "IC_kwDOAQzde85EbAdr",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "Ah got it. That seems fairly straightforward then. Something would have to explicitly remove it then to \u0022undo\u0022 what the proposed method does.",
        "createdAt": "2022-06-06T21:05:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147930475"
      },
      {
        "id": "IC_kwDOAQzde85EbAzd",
        "parentId": null,
        "author": "HaoK",
        "content": "We could have the global requirements as a mutable \u0060List\u003CIAuthorizationRequirement\u003E\u0060 or something so they can just \u0060Configure\u003CAuthorizationOptions\u003E\u0060 remove DenyAuthorizationRequirement themselves",
        "createdAt": "2022-06-06T21:07:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147931869"
      },
      {
        "id": "IC_kwDOAQzde85EbBOa",
        "parentId": null,
        "author": "HaoK",
        "content": "There is a bit of a danger here though as lifetime of these requirements becomes very tricky, as options are singleton lifetime, and for some requirements you may want to pull things from DI/request, so there\u0027s some complications here which we need to be careful about.",
        "createdAt": "2022-06-06T21:09:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147933594"
      },
      {
        "id": "IC_kwDOAQzde85EbBqZ",
        "parentId": null,
        "author": "HaoK",
        "content": "So we\u0027d probably need some kind of IGlobalAuthZRequirementProvider that enables requirements are more complicated in terms of construction",
        "createdAt": "2022-06-06T21:11:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147935385"
      },
      {
        "id": "IC_kwDOAQzde85EbCyU",
        "parentId": null,
        "author": "HaoK",
        "content": "So we have a method today \u0060policyBuilder.RequireAuthenticatedUser\u0060 which does the same thing for a specific policy, so maybe for naming \u0060builder.Authentication.AlwaysRequireAuthenticatedUser\u0060 if we want to be clear what this would be doing",
        "createdAt": "2022-06-06T21:16:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147939988"
      },
      {
        "id": "IC_kwDOAQzde85EbDjt",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "\u003E So we have a method today policyBuilder.RequireAuthenticatedUser which does the same thing for a specific policy, so maybe for naming builder.Authentication.AlwaysRequireAuthenticatedUser if we want to be clear what this would be doing\r\n\r\nThat\u0027s... verbose \uD83D\uDE04 How about \u0060RequireAuthenticatedUsers()\u0060? Also need to decide if the method/property is on \u0060AuthenticationBuilder\u0060 or just \u0060WebApplicationAuthenticationBuilder\u0060 (meaning it would have to be public now) or something else.",
        "createdAt": "2022-06-06T21:20:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147943149"
      },
      {
        "id": "IC_kwDOAQzde85EbEWd",
        "parentId": null,
        "author": "HaoK",
        "content": "Is there a reason we shouldn\u0027t build this as a full fledged security feature for all to use via AuthenticationBuilder?",
        "createdAt": "2022-06-06T21:23:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147946397"
      },
      {
        "id": "IC_kwDOAQzde85EbKpG",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "\u003E Is there a reason we shouldn\u0027t build this as a full fledged security feature for all to use via AuthenticationBuilder?\r\n\r\nIt requires authorization services to be present right? \u0060WebApplicationAuthenticationBuilder\u0060 already adds both sets of services (AuthN and AuthZ) but to make this work via \u0060builder.Services.AddAuthentiation().RequireAuthenticatedUsers()\u0060 it would need to add the authorization services too, yes?",
        "createdAt": "2022-06-06T21:55:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147972166"
      },
      {
        "id": "IC_kwDOAQzde85EbLdb",
        "parentId": null,
        "author": "HaoK",
        "content": "Sure, but is there no way for us to support the automatic adding of these services/middleware (only when needed) in a way that everyone could take advantage?\r\n\r\n- New apps would work via the new auto add behavior.\r\n- So existing apps (would be unaffected since they already contain Add/UseAuthN/Z calls).\r\nBut old apps could also remove their UseAuthN/Z calls to take advantage of the new behavior without any changes (they could delete their default/fallback policies and switch to using RequireAuthenticatedUsers())",
        "createdAt": "2022-06-06T21:59:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1147975515"
      },
      {
        "id": "IC_kwDOAQzde85EbT3Y",
        "parentId": null,
        "author": "captainsafia",
        "content": "\u003E That\u0027s... verbose \uD83D\uDE04 How about RequireAuthenticatedUsers()? Also need to decide if the method/property is on AuthenticationBuilder or just WebApplicationAuthenticationBuilder (meaning it would have to be public now) or something else.\r\n\r\nI\u0027m leaning towards \u0060AlwaysRequireAuthentication\u0060 because I think it\u0027s more important to empathize the fact that the behavior is enabled globally.\r\n\r\n\u003E but is there no way for us to support the automatic adding of these services/middleware (only when needed) in a way that everyone could take advantage?\r\n\r\nWe could integrate this logic in the base \u0060AuthenticationBuilder\u0060 with some additional glue but I think we were conservative about only supporting this in \u0060WebApplication\u0060-supporting apps only.\r\n\r\n",
        "createdAt": "2022-06-06T22:51:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1148009944"
      },
      {
        "id": "IC_kwDOAQzde85EbneO",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "\u003E We could integrate this logic in the base AuthenticationBuilder with some additional glue but I think we were conservative about only supporting this in WebApplication-supporting apps only.\r\n\r\nHow would we do this without \u0060WebApplication\u0060 though? We don\u0027t even control where routing gets added in those scenarios.",
        "createdAt": "2022-06-07T01:16:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1148090254"
      },
      {
        "id": "IC_kwDOAQzde85Eb2cE",
        "parentId": null,
        "author": "HaoK",
        "content": "I haven\u0027t looked at the host builder code since probably before the 1.0 timeframe so maybe I\u0027m super far off base here, but couldn\u0027t we do something like this?\r\n\r\n- After building the service provider, similar how IStartupFilter can add middleware\r\n- For authentication, if default scheme has been set, we need \u0060UseAuthorization()\u0060\r\n- For authorization, if any policies have been registered, we need \u0060UseAuthorization()\u0060\r\n- If either are required, inspect the app, make sure they haven\u0027t been added already, and only then add these calls after the routing middleware",
        "createdAt": "2022-06-07T03:23:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1148151556"
      },
      {
        "id": "IC_kwDOAQzde85Eb3RU",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "Yeah I think we should keep this kind of behavior to \u0060WebApplicationBuilder\u0060 only as it is able to reason about the application pipeline before it decides to add (or not add) automatic middleware, an \u0060IStartupFilter\u0060 can\u0027t do that and I don\u0027t think we want to update the old host with these new automatic behaviors.",
        "createdAt": "2022-06-07T03:30:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1148154964"
      },
      {
        "id": "IC_kwDOAQzde85Eb3sR",
        "parentId": null,
        "author": "HaoK",
        "content": "So irrespective of which host does the Use part of this, I think it makes sense for the AuthenticationBuilder to have the service side for this API, in the old host, if they aren\u0027t using Authorization it would just do nothing (no different than today, where you can set fallback policies which do nothing if you don\u0027t have UseAuthorization), basically the services are setup exactly the same, just you don\u0027t get the automatic middleware added for old hosts.  But as soon as they actually use Authorization, the global requirement would kick in",
        "createdAt": "2022-06-07T03:34:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1148156689"
      },
      {
        "id": "IC_kwDOAQzde85Ee2JC",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "@HaoK Yeah that sounds okay.\r\n\r\n@captainsafia I know naming is the hardest thing but none of these names are hitting the sweet spot for me yet. I guess it\u0027s time to start a poll \uD83D\uDE04 \r\n\r\n1. \u0060builder.Authentication.RequireAuthentication()\u0060\r\n1. \u0060builder.Authentication.RequireAuthentication = true;\u0060\r\n1. \u0060builder.Authentication.RequireAuthenticatedUsers()\u0060\r\n1. \u0060builder.Authentication.RequireAuthenticatedUsers = true;\u0060\r\n1. \u0060builder.Authentication.AlwaysRequireAuthentication()\u0060\r\n1. \u0060builder.Authentication.AlwaysRequireAuthentication = true;\u0060\r\n1. \u0060builder.Authentication.AuthenticationRequired()\u0060\r\n1. \u0060builder.Authentication.AuthenticationRequired= true;\u0060\r\n1. something else?",
        "createdAt": "2022-06-07T17:04:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1148936770"
      },
      {
        "id": "IC_kwDOAQzde85EfKu6",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E The idea is to make it much easier to require authentication for the whole app.\r\n\r\nCan you clarify what you mean by \u0022the whole app\u0022? Do you mean all the requests reaching MVC actions or minimal endpoints or really *all* requests, no matter how they are handled?\r\n\r\nI\u0027m asking that because IMHO, it rarely makes sense to block *all* unauthenticated requests (you should at least be able to serve things like \u0060favicon.ico\u0060 without any restriction). It\u0027s also not clear how things like CORS preflight requests or endpoints served by built-in handlers like OAuth 2.0 or OIDC or third-party libs like OpenIddict or IdSrv will be handled with your proposal.",
        "createdAt": "2022-06-07T18:25:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1149021114"
      },
      {
        "id": "IC_kwDOAQzde85EfM9l",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "@kevinchalet great question and very good points. I admit it\u0027s not super clear. On one hand we could imagine something like the old \u0022Windows Authentication\u0022 in IIS, where when enabled on a site it\u0027s literally for the whole site by default, and then allowing anonymous access to certain resources requires configuring file/dir ACLs along with the site config. On the other hand it could be based on routing, endpoints, and metadata, such that it means all endpoints require AuthN unless they explicitly opt to allow anonymous access.\r\n\r\nI agree with you that something like the latter is what makes sense here, i.e. turning this on effectively defaults all endpoints into requiring authorization, as if they\u0027d added the requisite AuthZ metdata to them.",
        "createdAt": "2022-06-07T18:36:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1149030245"
      },
      {
        "id": "IC_kwDOAQzde85EfO8D",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E On one hand we could imagine something like the old \u0022Windows Authentication\u0022 in IIS, where when enabled on a site it\u0027s literally for the whole site by default, and then allowing anonymous access to certain resources requires configuring file/dir ACLs along with the site config.\r\n\r\nPlease no, that was absolutely horrible (that and automatic 401 responses hijacking a-la-\u0060FormsAuthenticationModule\u0060!) \uD83D\uDE2D \r\n\r\n\u003E I agree with you that something like the latter is what makes sense here, i.e. turning this on effectively defaults all endpoints into requiring authorization, as if they\u0027d added the requisite AuthZ metdata to them.\r\n\r\nWell, in both cases, it\u0027s going to be a massive breaking change as all the libraries that don\u0027t currently use endpoints will need to use them to opt in a \u0022no-op authorization policy\u0022 to be compatible with this flag: not just third-party libs, but also all the middleware and authentication handlers that ship as part of ASP.NET Core itself, including all the social/OIDC providers (e.g their callback actions can\u0027t require authorization or they\u0027ll just stop working completely \uD83D\uDE04)",
        "createdAt": "2022-06-07T18:44:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1149038339"
      },
      {
        "id": "IC_kwDOAQzde85Efh8A",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "@kevinchalet I\u0027ll point back to the original motivation then: make it easier to require auth for \u0022the app\u0022. Today, that usually involves setting both the \u0060DefaultPolicy\u0060 and \u0060FallbackPolicy\u0060, which then results in everything **after** the AuthN/AuthZ middleware be protected by default. So it\u0027s less about endpoints, and more about where the middleware is in the pipeline (of course endpoints and their metadata are still part of that operation).",
        "createdAt": "2022-06-07T20:09:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1149116160"
      },
      {
        "id": "IC_kwDOAQzde85EfzZ7",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E Today, that usually involves setting both the \u0060DefaultPolicy\u0060 and \u0060FallbackPolicy\u0060, which then results in everything **after** the AuthN/AuthZ middleware be protected by default.\r\n\r\nCorrect me if I\u0027m wrong, but in another issue, you mentioned that you planned to update \u0060WebApplicationBuilder\u0060 to register both the authentication and authorization middleware automatically. De facto, this means that all the middleware registered by the users when configuring the pipeline will always appear after the authentication/authorization middleware and thus be affected by \u0060FallbackPolicy\u0060 in .NET 7.0 (I\u0027m ignoring \u0060DefaultPolicy\u0060 because it only applies to endpoints that are explicitly decorated with \u0060[Authorize]\u0060, so it\u0027s much less impacting).\r\n\r\nAs reminded in your OP, \u0060FallbackPolicy\u0060 is a quite advanced option so it\u0027s not massively used yet. But if it becomes an easy-to-use thing, you can be sure we\u0027ll all get reports asking why things break when folks will start using that new innocent-looking \u0060builder.Authentication.RequireAuthentication()\u0060 API. I\u0027m convinced most people won\u0027t realize that this method will not only affect their own APIs/endpoints but also everything present in the ASP.NET Core pipeline, including tons of middleware that need to handle unauthenticated requests (e.g ACME challenges for Let\u0027s Encrypt).\r\n\r\n\u003E So it\u0027s less about endpoints, and more about where the middleware is in the pipeline (of course endpoints and their metadata are still part of that operation).\r\n\r\nOnce its use is generalized, library writers will have basically two options to make their middleware work with \u0060FallbackPolicy\u0060/\u0060builder.Authentication.RequireAuthentication()\u0060:\r\n\r\n  - Force their users to explicitly register the authorization middleware (or the authentication middleware, if the \u0060builder.Authentication.RequireAuthentication()\u0060 logic is performed by the authentication middleware) and put it after their own middleware. It\u0027s quite horrible and a very-hard-to-discover requirement for most users.\r\n\r\n  - Make their middleware endpoint-aware and use the \u0060IAllowAnonymous\u0060 metadata interface, which is pretty much the only option given by the authorization middleware to opt out the \u0022fallback policy\u0022.\r\n\r\nGiven that option 1) is rather impractical - as a library author, you can\u0027t be sure the user will re-register the authorization middleware - option 2) will be the de facto choice and that\u0027s why I mentioned endpoints. Moving to a world where all middleware declare their endpoints in the routing mechanism might not be a bad thing, but it\u0027s clearly a paradigm change and potentially very impactful.",
        "createdAt": "2022-06-07T21:29:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1149187707"
      },
      {
        "id": "IC_kwDOAQzde85EgCF_",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "We indeed have introduced the feature that configuring AuthN via the \u0060WebApplicationBuilder.Authentication\u0060 property results in the AuthN/AuthZ middleware being added by default, if the app hasn\u0027t already added it in its pipeline. For scenarios where the middleware needs to explicitly run before AuthN/AuthZ middleware, the user will be required to manually place them in the pipeline, just like today, i.e. the experience isn\u0027t different from today.\r\n\r\nI\u0027m not sure I share your concern regarding the interplay between this new (opt-in) behavior, \u0060FallbackPolicy\u0060, and manually ordered middleware. Folks can continue to control the order of middleware as they do today. Also we use \u0060FallbackPolicy\u0060 to enable this behavior in [templates](https://github.com/dotnet/aspnetcore/blob/37c0ce91fd1d3a9d7641a5c31322c69cfddeddfe/src/ProjectTemplates/Web.ProjectTemplates/content/RazorPagesWeb-CSharp/Program.Main.cs#L94) already [today](https://github.com/dotnet/aspnetcore/blob/main/src/ProjectTemplates/Web.ProjectTemplates/content/BlazorServerWeb-CSharp/Program.Main.cs#L111).\r\n\r\nIf we are to limit this to endpoints only, we\u0027d need to name it accordingly, but even then my concern is that it\u0027s very difficult to make clear exactly which resources will be protected and which won\u0027t, as whether a middleware/framework integrates via routing/endpoints is fairly opaque.",
        "createdAt": "2022-06-07T22:50:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1149247871"
      },
      {
        "id": "IC_kwDOAQzde85EgHUo",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E For scenarios where the middleware needs to explicitly run before AuthN/AuthZ middleware, the user will be required to manually place them in the pipeline, just like today, i.e. the experience isn\u0027t different from today.\r\n\r\nI disagree, the experience is completely different: currently, the model is _explicit_: \u0060app.UseAuthentication()\u0060 and \u0060app.UseAuthorization()\u0060 appear very clearly in the pipeline so users have a chance to at least see that things are registered in a certain order and that it potentially matters.\r\n\r\nBy hiding all these things in your \u0060WebApplicationBuilder\u0060 helpers, you\u0027re just making them more obscure than they are currently: as soon as a user will hit one of the pain points we discussed, it will be an absolute nightmare to at least understand that authentication/authorization middleware are at play and that they should re-register them manually in a different order.\r\n\r\nSo sure, it makes templates super minimalist, but it doesn\u0027t help folks understand how components are linked together and I don\u0027t think it\u0027s a good thing. Sometimes, less is not better.\r\n\r\n(IMHO, \u0060FallbackPolicy\u0060 is basically like those global static switches: it shouldn\u0027t have existed in the first place)",
        "createdAt": "2022-06-07T23:25:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1149269288"
      },
      {
        "id": "IC_kwDOAQzde85Ei_UB",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "Can you help me understand what you would like to see instead of \u0060FallbackPolicy\u0060 to facilitate the \u0022just require auth for this whole app please\u0022 scenario?\r\n\r\nI would far prefer that configuring AuthN/AuthnZ leads to issues due to **more** protection than desired than less. That said, I\u0027m keen to find ways we can make identifying and correcting AuthN configuration issues easier, e.g. via logging, analyzers, API design, etc. ",
        "createdAt": "2022-06-08T14:49:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1150022913"
      },
      {
        "id": "IC_kwDOAQzde85EjCrL",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E Can you help me understand what you would like to see instead of \u0060FallbackPolicy\u0060 to facilitate the \u0022just require auth for this whole app please\u0022 scenario?\r\n\r\nIn my experience (and you mentioned System.Web ACLs earlier), most people are actually interested in securing whole \u0022sections\u0022 of their apps, not really the entire app without any distinction at all, so something URL-based would have - IMHO - made more sense that a unique \u0060FallbackPolicy\u0060. This would also be more flexible, as you could use \u0060Bearer\u0060 for \u0060/api\u0060 and \u0060Cookies\u0060 for \u0060/static-assets\u0060.\r\n\r\n\u003E I would far prefer that configuring AuthN/AuthnZ leads to issues due to more protection than desired than less. That said, I\u0027m keen to find ways we can make identifying and correcting AuthN configuration issues easier, e.g. via logging, analyzers, API design, etc.\r\n\r\nOh great to hear that, then PTAL at https://github.com/dotnet/aspnetcore/issues/4656#issuecomment-446947390 \uD83D\uDE04 ",
        "createdAt": "2022-06-08T15:00:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1150036683"
      },
      {
        "id": "IC_kwDOAQzde85EjM3m",
        "parentId": null,
        "author": "HaoK",
        "content": "Making \u0060DenyAnonymousAuthorizationRequirement\u0060 always required is already part of the plan for whatever the new \u0060[Always]RequireAuthenticatedUsers\u0060 method is called, we\u0027ll probably introduce the concept of global requirements which automatically get added to all policies, which this method would add \u0060DenyAnonymousAuthorizationRequirement\u0060 to as part of its implementation.  ",
        "createdAt": "2022-06-08T15:35:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1150078438"
      },
      {
        "id": "IC_kwDOAQzde85EjOJ6",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E we\u0027ll probably introduce the concept of global requirements which automatically get added to all policies\r\n\r\nWasn\u0027t the original plan supposed to simplify things? :trollface: ",
        "createdAt": "2022-06-08T15:39:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1150083706"
      },
      {
        "id": "IC_kwDOAQzde85EjSGG",
        "parentId": null,
        "author": "Tratcher",
        "content": "For background, FallbackPolicy was added for NegotiateAuth to emulate the IIS Windows Auth behavior of requiring all requests to authenticate. The middleware ordering still let you make exceptions for things like static files, but it\u0027s intentionally not more granular than that.",
        "createdAt": "2022-06-08T15:54:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1150099846"
      },
      {
        "id": "IC_kwDOAQzde85EjU7o",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E For background, FallbackPolicy was added for NegotiateAuth to emulate the IIS Windows Auth behavior of requiring all requests to authenticate.\r\n\r\nWhich is super bad from a security perspective, as IWA is - like cookies or basic - an automatic authentication method. By making IWA easy to enforce globally, you\u0027re just encouraging them to shoot themselves in the foot without realizing it: as soon as they\u0027ll innocently add an API endpoint, they\u0027ll end up with a CSRF vulnerability.\r\n\r\nI know all these automatic/default features are very appealing, but security is all about making the right choice and hiding everything behind defaults that can\u0027t work for all scenarios is, IMHO, a bad move.",
        "createdAt": "2022-06-08T16:04:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1150111464"
      },
      {
        "id": "IC_kwDOAQzde85EjdVU",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "\u003E In my experience (and you mentioned System.Web ACLs earlier), most people are actually interested in securing whole \u0022sections\u0022 of their apps, not really the entire app without any distinction at all, so something URL-based would have - IMHO - made more sense that a unique FallbackPolicy. This would also be more flexible, as you could use Bearer for /api and Cookies for /static-assets.\r\n\r\nI agree that it\u0027s often logical to think about configuring AuthN/AuthZ in a URL-based manner, similar to the old \u0060\u003CLocation\u003E\u0060 element in *web.config*. It would be interesting to explore this idea further. But I still think that defaulting to \u0022everything requires AuthZ\u0022 and then explicitly marking up exceptions is the safer approach, combined with the ability to control middleware ordering and policies such that middleware can be placed before the AuthN/AuthZ stage to completely opt it out (in cases where it doesn\u0027t project endpoints).\r\n\r\nWhile it\u0027s likely beyond the scope of what we can achieve now in .NET 7, given your extensive experience and interest in the area, I\u0027ll ask you, if you could make any changes to AuthN/AuthZ in ASP.NET Core, factoring in our limitations RE breaking changes, legacy, etc., what would you do?",
        "createdAt": "2022-06-08T16:38:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1150145876"
      },
      {
        "id": "IC_kwDOAQzde85EjkY9",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E While it\u0027s likely beyond the scope of what we can achieve now in .NET 7, given your extensive experience and interest in the area, I\u0027ll ask you, if you could make any changes to AuthN/AuthZ in ASP.NET Core, factoring in our limitations RE breaking changes, legacy, etc., what would you do?\r\n\r\nRegarding https://github.com/dotnet/aspnetcore/issues/4656, I would:\r\n  - Update \u0060AuthorizationPolicy\u0060 to always add \u0060DenyAnonymousAuthorizationRequirement\u0060 by default (if backcompat\u0027 is a concern, an \u0060AppContext\u0060 switch can be used to revert to the old behavior).\r\n  - Obsolete \u0060AuthorizationPolicyBuilder.RequireAuthenticatedUser()\u0060 and replace it by \u0060AuthorizationPolicyBuilder.AllowAnonymousUser()\u0060 (authorization policies that work on unauthenticated identities are fairly uncommon in practice but it\u0027s important to not break this scenario).\r\n\r\nThe current opt-in-for-authenticated-users approach is **bad** and leads to subtle security issues that could be easily mitigated by inverting the logic as I mentioned in 2018. The option suggested by @HaoK - depending on the global \u0022require authenticated user\u0022 to add \u0060DenyAnonymousAuthorizationRequirement\u0060 in the individual authorization policies - seems too complex to me.\r\n\r\nRegarding the API suggested in this thread, if it\u0027s really the approach you want to promote, I would avoid introducing a new layer if it ends up being as limited as \u0060FallbackPolicy\u0060, so probably just a set of helpers...\r\n\r\n\u0060\u0060\u0060csharp\r\npublic static void RequireAuthentication(this AuthorizationOptions options)\r\n    =\u003E options.FallbackPolicy = options.DefaultPolicy = new AuthorizationPolicyBuilder()\r\n        .RequireAuthenticatedUser()\r\n        .Build();\r\n\r\npublic static void RequireAuthentication(this AuthorizationOptions options, params string[] schemes)\r\n    =\u003E options.FallbackPolicy = options.DefaultPolicy = new AuthorizationPolicyBuilder()\r\n        .AddAuthenticationSchemes(schemes)\r\n        .RequireAuthenticatedUser()\r\n        .Build();\r\n\u0060\u0060\u0060\r\n\r\n... with extensive XML documentation indicating that it could break existing scenarios, as explained in this thread. Since it will stay at the authorization middleware level, authentication handlers like the OAuth 2.0/OIDC/Negotiate or the aspnet-contrib/OpenIddict projects shouldn\u0027t be impacted as their endpoints are handled by \u0060AuthenticationMiddleware\u0060.\r\n\r\nThat said, as I had mentioned in the other thread, OpenIddict will be impacted by the integration of \u0060app.UseAuthentication()\u0060 or \u0060app.UseAuthorization()\u0060 into \u0060WebApplicationBuilder\u0060 as its \u0022API endpoints\u0022 won\u0027t be covered by CORS policies since the CORS middleware is registered by the user after the middleware registered by the host. If you wanted to avoid this, I\u0027d recommend updating the \u0060WebApplicationBuilder\u0060 to also register the CORS middleware before the authentication middleware.",
        "createdAt": "2022-06-08T17:06:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1150174781"
      },
      {
        "id": "IC_kwDOAQzde85Ejqta",
        "parentId": null,
        "author": "HaoK",
        "content": "\u003E Update AuthorizationPolicy to always add DenyAnonymousAuthorizationRequirement by default \r\n\u003E depending on the global \u0022require authenticated user\u0022 to add DenyAnonymousAuthorizationRequirement in the individual authorization policies - seems too complex to me.\r\n\r\nIts complex because the primary concern was with layering, and we don\u0027t want authZ to require authN always, which is why there needs to be an explicit gesture (aka the new RequireAuthentication() method).  That said, effectively all AuthorizationPolicies will have the behavior of always adding DenyAnonymousAuthorizationRequirement but only when RequireAuthentication is called\r\n",
        "createdAt": "2022-06-08T17:32:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1150200666"
      },
      {
        "id": "IC_kwDOAQzde85EjrAS",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "Thanks for your input.\r\n\r\nTo be clear, the proposal in this thread was not to make the new method enforce any AuthN requirement earlier than when \u0060AuthorizationMiddleware\u0060 runs (at least as far as I understood it). It would still be that middleware that enforces the requirement. The API appearing on \u0060builder.Authentication\u0060 is more about discoverability but of course is open to discussion.\r\n\r\n\u003E If you wanted to avoid this, I\u0027d recommend updating the WebApplicationBuilder to also register the CORS middleware before the authentication middleware.\r\n\r\nThis has been suggested internally (hi there @halter73) and definitely seems worth exploring. Do we think it\u0027s as straightforward as always adding the CORS middleware before the authentication/authorization in the case where they\u0027ll be added (i.e. schemes are added via \u0060builder.Authentication\u0060), or is something more nuanced possible/appropriate?",
        "createdAt": "2022-06-08T17:33:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1150201874"
      },
      {
        "id": "IC_kwDOAQzde85Ejsor",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E Its complex because the primary concern was with layering\r\n\r\nWhat do you mean exactly by \u0022layering\u0022 here?\r\n\r\n\u003E and we don\u0027t want authZ to require authN always, which is why there needs to be an explicit gesture (aka the new RequireAuthentication() method).\r\n\r\nThat\u0027s exactly why I suggested adding an \u0060AuthorizationPolicyBuilder.AllowAnonymousUser()\u0060 API to cover the (very) rare cases where an authorization policy would need to work on unauthenticated identity.\r\n\r\nI\u0027d suggest re-reading https://github.com/dotnet/aspnetcore/issues/4656 so you can appreciate the number of people who\u0027ve been trapped by this design problem. Making it more complex is likely not going to help \uD83D\uDE04 ",
        "createdAt": "2022-06-08T17:40:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1150208555"
      },
      {
        "id": "IC_kwDOAQzde85FF--J",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@DamianEdwards can you put this in a milestone?",
        "createdAt": "2022-06-17T20:10:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1159196553"
      },
      {
        "id": "IC_kwDOAQzde85FGQFW",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 7 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-06-17T22:10:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1159266646"
      },
      {
        "id": "IC_kwDOAQzde85FcUdn",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "Moving to .NET 8.\r\n\r\nI implemented two approaches to enabling this via path-based authorization over at https://github.com/DamianEdwards/AspNetCorePathAuthorization\r\n\r\n@kevinchalet you might find this matches the kind of idea you proposed.\r\n\r\nOne approach uses a custom middleware which effectively has to do its own route matching via a custom trie, etc. (eww) and another approach actually integrates with routing by attaching metadata to any endpoint based on route pattern, even if there isn\u0027t an endpoint already registered there! That means you can make endpoint-aware middleware \u0022activate\u0022 even for requests with no endpoints, e.g. authorization can run on and protect requests for static files.",
        "createdAt": "2022-06-24T00:50:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1165051751"
      },
      {
        "id": "IC_kwDOAQzde85Fd3oA",
        "parentId": null,
        "author": "kevinchalet",
        "content": "@DamianEdwards looks nice and flexible \uD83D\uDC4D\uD83C\uDFFB ",
        "createdAt": "2022-06-24T10:56:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42048#issuecomment-1165457920"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85Lcovr",
    "title": "Authentication needs in ASP.NET Core going forward",
    "url": "https://github.com/dotnet/aspnetcore/issues/42105",
    "createdAt": "2022-06-09T08:43:22Z",
    "lastUpdated": "2024-11-04T20:56:59Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Is your feature request related to a problem? Please describe the problem.\r\n\r\nhttps://twitter.com/davidfowl/status/1534756765597720578\r\n\r\n### Describe the solution you\u0027d like\r\n\r\nI see 4 authentication grouped needs in ASP.NET Core\r\n\r\n1-\tEasy to implement standard client authn (OpenID Connect)\r\n2-\tStandalone with cookies and ASP.NET Core Identity (IDP solutions as well)\r\n3-\tCertificate auth \r\n4-\tAzureAD and Azure B2C client authn\r\n\r\nI believe Microsoft  should provide templates for just the client authn and docs \u002B links to products about how to use or implement the second and third type. The Azure AD and Azure B2C client templates are already good.\r\n\r\nIf you have simple authn templates for OIDC clients for an ASP.NET Core API, Razor page, MVC, Blazor (WASM, BFF ASP.NET Core hosted, Server) which are easy to adapt after, then we have a good solution. As part of the solution then, docs about using with different IDPs would help as all IDPs have small differences.\r\n\r\nHTTPS should be used with all these templates per default.\r\n\r\n\r\n### Additional context\r\n\r\n_No response_",
    "upvotes": 7,
    "labels": [
      "enhancement",
      "area-auth",
      "area-identity",
      "area-blazor",
      "Pillar: Complete Blazor Web"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85Emzmj",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 7 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-06-09T11:49:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42105#issuecomment-1151023523"
      },
      {
        "id": "IC_kwDOAQzde85E9sHJ",
        "parentId": null,
        "author": "Lonli-Lokli",
        "content": "My scenario is not about Auth but about Auth integration testing with Minimal api.\r\n\r\nOne of the cases of my project is to be sure that all routes, including minimal, are protected with either Authorize or AllowAnonymous attributes.\r\n\r\nPreviously it was possible to loaf all types and search for ControllerBase inheritors and checking their metadata\r\n\r\nIsn\u0027t it better to convert it to discussion?",
        "createdAt": "2022-06-15T22:45:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42105#issuecomment-1157022153"
      },
      {
        "id": "IC_kwDOAQzde85OJdJY",
        "parentId": null,
        "author": "danroth27",
        "content": "\u003E Easy to implement standard client authn (OpenID Connect)\r\n\r\n@damienbod Can share a bit more about what you believe is missing for this? Are you looking for a generic OIDC client setup that would work with most OIDC providers, similar to what we have for [Blazor WebAssembly](https://learn.microsoft.com/aspnet/core/blazor/security/webassembly/standalone-with-authentication-library)? Are there particular OIDC providers that you\u0027d want to ensure this works with?",
        "createdAt": "2022-11-11T01:07:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42105#issuecomment-1311101528"
      },
      {
        "id": "IC_kwDOAQzde85OM0A0",
        "parentId": null,
        "author": "damienbod",
        "content": "Hi @danroth27  thanks for asking. These are the projects we create for different clients which I think Microsoft could provide and would help the community developing secure applications. None of the templates are available per default.\r\n\r\nIndividual Accounts\r\n-\tnone\r\n\r\nExternal authentication\r\n\r\n-\tOpenID Connect client with Razor Pages\r\n-\tOpenID Connect client with Controller API\r\n-\tOpenID Connect Blazor WASM hosted in ASP.NET Core (BFF with cookies)\r\n-\tAAD Blazor WASM hosted in ASP.NET Core (BFF with cookies)\r\n-\tAAD B2C Blazor WASM hosted in ASP.NET Core (BFF with cookies)\r\n\r\nI created three Blazor templates to fill this gap but believe Microsoft could do this for the community. The basic template of a Razor Page using an external OIDC server is missing. This would be really simple to support as all the auth middleware is already available. A user would only need to change the OIDC configuration for each different server requirement. A generic OIDC client setup would be great.\r\n\r\nHere are the Blazor templates I created. These have no auth in the frontend and are simple to extend. The templates have also no third party dependencies either apart from the security headers package.\r\n\r\nhttps://github.com/damienbod/Blazor.BFF.OpenIDConnect.Template\r\n\r\nhttps://github.com/damienbod/Blazor.BFF.AzureAD.Template\r\n\r\nhttps://github.com/damienbod/Blazor.BFF.AzureB2C.Template\r\n\r\nIf I need to implement my own identity provider, I use either **IdentityServer** or **OpenIddict** with ASP.NET Core Identity using their templates (which are very good) and have no need for any of the Microsoft templates using these packages. So apart from the **Microsoft.Identity.Web** templates for Razor Pages and APIs, Microsoft provide none of the templates which would be useful to me and probably to others as well. \r\n\r\nThis might be useful for some project as well:\r\n\r\nIndividual Accounts \r\n-\tRazor Page with Cookies and ASP.NET Core Identity\r\n-\tBlazor WASM hosted and ASP.NET Core Identity (BFF Cookies)\r\n\r\nGreetings Damien\r\n",
        "createdAt": "2022-11-11T17:38:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42105#issuecomment-1311981620"
      },
      {
        "id": "IC_kwDOAQzde85ebVAE",
        "parentId": null,
        "author": "Ponant",
        "content": "https://learn.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/?view=aspnetcore-8.0\r\n\u0022The authentication support in Blazor WebAssembly is built on top of the OIDC Client Library (oidc-client.js), which is used to handle the underlying authentication protocol details.\u0022\r\n\r\nI think with this it should not be that trivial for BFF on blazor wasm apps.",
        "createdAt": "2023-06-09T08:59:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42105#issuecomment-1584222212"
      },
      {
        "id": "IC_kwDOAQzde85ebXvz",
        "parentId": null,
        "author": "Lonli-Lokli",
        "content": "Especially with the fact that https://github.com/IdentityModel/oidc-client-js is no longer maintained",
        "createdAt": "2023-06-09T09:07:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42105#issuecomment-1584233459"
      },
      {
        "id": "IC_kwDOAQzde85oYMlg",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 9 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-10-06T17:39:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42105#issuecomment-1751173472"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85LrQea",
    "title": "Support config-based options for different authentication schemes",
    "url": "https://github.com/dotnet/aspnetcore/issues/42170",
    "createdAt": "2022-06-13T15:43:15Z",
    "lastUpdated": "2024-09-10T19:32:57Z",
    "body": "Following up on the work done in #41520, we want to include support for config-based authentication options for all the authentication options that we currently support.\r\n\r\n- [x] JwtBearer\r\n- [x] OIDC\r\n- [ ] Cookie\r\n- [ ] Certificate\r\n- [ ] PolicyScheme\r\n- [ ] Negotiate\r\n- [ ] Social\r\n\r\n~~We\u0027ll also want to make sure that these implementations support \u0060IOptionsMonitor\u0060 for listening to changes in config.~~ We\u0027re moving this work to .NET 8.",
    "upvotes": 0,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85Fsu5H",
        "parentId": null,
        "author": "davidfowl",
        "content": "cc @martincostello for https://github.com/aspnet-contrib ",
        "createdAt": "2022-06-28T22:31:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42170#issuecomment-1169354311"
      },
      {
        "id": "IC_kwDOAQzde85G1V8q",
        "parentId": null,
        "author": "captainsafia",
        "content": "Support for loading OIDC options has been merged into preview7. Moving this into .NET 8 Planning as we consider addressing the other authentication types then.",
        "createdAt": "2022-07-18T22:31:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42170#issuecomment-1188388650"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85Lr3lw",
    "title": "Introduce support for defining Authorization policies via Configuration",
    "url": "https://github.com/dotnet/aspnetcore/issues/42172",
    "createdAt": "2022-06-13T18:19:09Z",
    "lastUpdated": "2023-06-02T00:52:25Z",
    "body": "Spin-off of #39855 focusing on addition of top-level authorization configuration API.\r\n\r\nExample matching \u0060Authorization\u0060 changes to consider, allowing sharing of policies, etc.:\r\n\r\n\u0060\u0060\u0060csharp\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\nbuilder.Authentication.AddJwtBearer();\r\nbuilder.Authorization.AddPolicy(\u0022HasProtectedAccess\u0022, policy =\u003E\r\n    policy.RequireClaim(\u0022scope\u0022, \u0022myapi:protected-access\u0022));\r\n\r\nvar app = builder.Build();\r\n\r\napp.MapGet(\u0022/hello\u0022, () =\u003E \u0022Hello!\u0022);\r\n\r\napp.MapGet(\u0022/hello-protected\u0022, () =\u003E \u0022Hello, you are authorized to see this!\u0022)\r\n    .RequireAuthorization(\u0022HasProtectedAccess\u0022);\r\n\r\napp.MapGet(\u0022/hello-also-protected\u0022, () =\u003E \u0022Hello, you authorized to see this to!\u0022)\r\n    .RequireAuthorization(\u0022HasProtectedAccess\u0022);\r\n\r\napp.Run();\r\n\u0060\u0060\u0060\r\n\r\nThe \u0060WebApplicationBuilder.Authorization\u0060 property is typed as \u0060AuthorizationOptions\u0060 allowing simple creation of policies and configuration of the default and fallback policies:\r\n\r\n\u0060\u0060\u0060csharp\r\nbuilder.Authorization.AddPolicy(\u0022HasProtectedAccess\u0022, policy =\u003E policy.RequireClaim(\u0022scope\u0022, \u0022myapi:protected-access\u0022));\r\nbuilder.Authorization.DefaultPolicy = builder.Authorization.GetPolicy(\u0022HasProtectedAccess\u0022);\r\n\r\n// Consider new methods to enable easily setting default/fallback policies by name\r\nbuilder.Authorization.SetDefaultPolicy(\u0022HasProtectedAccess\u0022);\r\nbuilder.Authorization.SetFallbackPolicy(\u0022HasProtectedAccess\u0022);\r\n\u0060\u0060\u0060 \r\n\r\nThe \u0060WebApplicationBuilder\u0060 would register an \u0060IConfigureOptions\u003CAuthorizationOptions\u003E\u0060 in the services collection with a delegate that applies the settings.\r\n\r\nNote this suggestion has a fundamental issue in that the \u0060AuthorizationOptions\u0060 isn\u0027t designed to be mutated in this way, rather it should be configured via a callback registered in DI so that it runs at the appropriate time during app startup and composes with other code that wishes to configure it.\r\n\r\nPerhaps instead the \u0060Authentication\u0060 property should also read from configuration for authorization settings, and the \u0060Authorization\u0060 property would be a new type that simply provides easy access to adding a configuration delegate, e.g.:\r\n\r\n\u0060\u0060\u0060jsonc\r\n{\r\n  \u0022Authorization\u0022: {\r\n    \u0022DefaultPolicy\u0022: \u0022HasProtectedAccess\u0022,\r\n    \u0022FallbackPolicy\u0022: \u0022\u0022,\r\n    \u0022InvokeHandlersAfterFailure\u0022: true,\r\n    \u0022Policies\u0022: {\r\n      \u0022HasProtectedAccess\u0022: {\r\n        \u0022Claims\u0022: [\r\n          { \u0022scope\u0022 : \u0022myapi:protected-access\u0022 }\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060csharp\r\nbuilder.Authentication.AddJwtBearer();\r\nbuilder.Authorization.Configure(authz =\u003E\r\n{\r\n    // Following is the code-based equivalent of config above\r\n    authz.AddPolicy(\u0022HasProtectedAccess\u0022, policy =\u003E policy.RequireClaim(\u0022scope\u0022, \u0022myapi:protected-access\u0022));\r\n    authz.DefaultPolicy = authz.GetPolicy(\u0022HasProtectedAccess\u0022);\r\n});\r\n\u0060\u0060\u0060\r\n\r\nSome other potential example policies as defined via configuration:\r\n\r\n\u0060\u0060\u0060jsonc\r\n{\r\n  \u0022Authorization\u0022: {\r\n    \u0022DefaultPolicy\u0022: \u0022HasProtectedAccess\u0022,\r\n    \u0022Policies\u0022: {\r\n      \u0022AuthenticatedUsers\u0022: {\r\n        \u0022AuthenticationRequired\u0022: true\r\n      },\r\n      \u0022Employees\u0022: {\r\n        \u0022AuthenticationRequired\u0022: true,\r\n        \u0022Roles\u0022: [ \u0022Employees\u0022 ]\r\n      },\r\n      \u0022OnlyHomers\u0022: {\r\n        \u0022AuthenticationRequired\u0022: true,\r\n        \u0022UserName\u0022: \u0022Homer\u0022\r\n      },\r\n      \u0022ApiClients\u0022: {\r\n        \u0022AuthenticationRequired\u0022: true,\r\n        // Any unrecognized properties are auto-mapped as claims perhaps?\r\n        \u0022scope\u0022: [ \u0022myapi:read\u0022, \u0022myapi:protected-access\u0022 ]\r\n      }\r\n    }\r\n  }\r\n}\r\n\u0060\u0060\u0060",
    "upvotes": 0,
    "labels": [
      "area-auth",
      "feature-minimal-hosting",
      "area-minimal"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85Ez80Z",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "FYI @HaoK @Tratcher @davidfowl @captainsafia @jcjiang @blowdart ",
        "createdAt": "2022-06-13T21:44:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1154469145"
      },
      {
        "id": "IC_kwDOAQzde85Ez817",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 7 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-06-13T21:44:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1154469243"
      },
      {
        "id": "IC_kwDOAQzde85Ez_Bb",
        "parentId": null,
        "author": "captainsafia",
        "content": "\u003E Perhaps instead the Authentication property should also read from configuration for authorization settings, and the Authorization property would be a new type that simply provides easy access to adding a configuration delegate, e.g.:\r\n\r\nI\u0027m a fan of this approach:\r\n\r\n- It\u0027s consistent with what we do for \u0060Authentication\u0060 and makes it easier for users to reason about the mental model here.\r\n- It provides us with a way to examine the authorization config for an application globally, which will help with some of the details in https://github.com/dotnet/aspnetcore/issues/39761 as I\u0027ve been discovering.\r\n\r\nI\u0027m not aware of any implementation complexities that make the options-from-config approach not viable for authorization but @HaoK might be able to add some color here.",
        "createdAt": "2022-06-13T21:55:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1154478171"
      },
      {
        "id": "IC_kwDOAQzde85E0B_c",
        "parentId": null,
        "author": "HaoK",
        "content": "Yeah config binding seems the cleanest for the properties (everything that\u0027s not a policy).  Directly configuring an instance of AuthorizationOptions off of the builder seems more trouble than what\u0027s it worth.  If you really want something like that, maybe just have an alternate dictionary of named policies, and settings, which you use in a regular options configuration of AuthorizationOptions, basically an AuthorizationOptionsBuilder property would be the analogy here.\r\n\r\nIn regards to authZ policies in config.  Personally I would rather define that in code rather than muck around with json but seems ok as long as we don\u0027t go too insane with what requirements we support.  We can certainly start with seeing what config definition of some simple policies look like, requiring the presence of a specific claim/role seems reasonably easy.  \r\n",
        "createdAt": "2022-06-13T22:09:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1154490332"
      },
      {
        "id": "IC_kwDOAQzde85E0dgN",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "Ok so the feature would be \u0060IServiceCollection.AddAuthorization()\u0060 will now also register an \u0060IConfigureOptions\u003CAuthorizationOptions\u003E\u0060 that enables the configuration of \u0060AuthorizationOptions\u0060 including defining policies from configuration.\r\n\r\n~A new property, \u0060WebApplicationBuilder.Authorization\u0060 will be added that enables registering custom \u0060Action\u003CAuthorizationOptions\u003E\u0060 configuration delegates that run in addition to the one added by \u0060WebApplicationBuilder.Authentication\u0060, essentially an alias for \u0060builder.Services.Configure(Action\u003CAuthorizationOptions\u003E configure)\u0060.~\r\n\r\nRegarding the AuthZ policy configuration binding support, here\u0027s a strawman:\r\n- \u0060DenyAnonymousAuthorizationRequirement\u0060\r\n    Configuration property name \u0060RequireAuthenticatedUsers\u0060. Supports a single boolean value.\r\n    \u0060\u0060\u0060json\r\n    \u0022PolicyName\u0022: {\r\n        \u0022RequireAuthenticatedUsers\u0022: true\r\n    },\r\n    \u0060\u0060\u0060\r\n- \u0060RolesAuthorizationRequirement\u0060\r\n    Configuration property name \u0060Roles\u0060. Supports a single string value **OR** an array of string values (i.e. it looks for configuration keys like \u0060Authorization.PolicyName.Roles.0\u0060, \u0060Authorization.PolicyName.Roles.1\u0060, etc.).\r\n    \u0060\u0060\u0060json\r\n    \u0022PolicyName1\u0022: {\r\n        \u0022Roles\u0022: [ \u0022RoleName1\u0022, \u0022RoleName2\u0022 ]\r\n    },\r\n    \u0022PolicyName2\u0022: {\r\n        \u0022Roles\u0022: \u0022SingleRole\u0022\r\n    },\r\n    \u0060\u0060\u0060\r\n- \u0060ClaimsAuthorizationRequirement\u0060\r\n    Configuration property name \u0060Claims\u0060. Supports an object where property names are claim types mapped to \u0060ClaimsAuthorizationRequirement.ClaimType\u0060 and property values are a single string value **OR** an array of string values which are mapped to \u0060ClaimsAuthorizationRequirement.AllowedValues\u0060.\r\n    \u0060\u0060\u0060json\r\n    \u0022PolicyName1\u0022: {\r\n        \u0022Claims\u0022: {\r\n            \u0022scope\u0022: [ \u0022scope1\u0022, \u0022scope2\u0022, \u0022scope3\u0022 ],\r\n            \u0022otherClaim\u0022: \u0022claim value\u0022,\r\n        }\r\n    },\r\n    \u0060\u0060\u0060\r\n- \u0060NameAuthorizationRequirement\u0060\r\n    Configuration property name \u0060RequiredName\u0060. Supports a single string value\r\n    \u0060\u0060\u0060json\r\n    \u0022PolicyName\u0022: {\r\n        \u0022RequiredName\u0022: \u0022SuperAdminUser\u0022\r\n    },\r\n    \u0060\u0060\u0060",
        "createdAt": "2022-06-14T01:08:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1154603021"
      },
      {
        "id": "IC_kwDOAQzde85E0nY5",
        "parentId": null,
        "author": "davidfowl",
        "content": "Does this really add much over the call to AddAuthorization call?",
        "createdAt": "2022-06-14T02:35:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1154643513"
      },
      {
        "id": "IC_kwDOAQzde85E0p0e",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "\u003E Does this really add much over the call to AddAuthorization call?\r\n\r\nThe top-level \u0060WebApplicationBuilder.Authorization\u0060 property doesn\u0027t no, we could not do that and just focus on the configuration binding aspect instead.",
        "createdAt": "2022-06-14T02:55:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1154653470"
      },
      {
        "id": "IC_kwDOAQzde85E0_gO",
        "parentId": null,
        "author": "HaoK",
        "content": "\u002B1 on just focusing on the configuration binding ",
        "createdAt": "2022-06-14T05:45:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1154742286"
      },
      {
        "id": "IC_kwDOAQzde85E20Qb",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "Removed the proposed API addition.",
        "createdAt": "2022-06-14T13:55:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1155220507"
      },
      {
        "id": "IC_kwDOAQzde85E3BM4",
        "parentId": null,
        "author": "captainsafia",
        "content": "Assuming it\u0027s just config work, the only public API that we might need is an \u0060IAuthorizationConfigProvider\u0060 interface for implementing getters for the \u0060Authorization\u0060 config and a \u0060GetPolicyByName\u0060 extension method for resolving individual policies from the config. The options implementations can likely remain internal.\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace Microsoft.AspNetCore.Authorization;\r\n\r\ninterface IAuthorizationConfigurationProvider\r\n{\r\n  IConfiguration AuthorizationConfiguration { get; }\r\n}\r\n\r\npublic static class AuthorizationConfigurationProviderExtensions\r\n{\r\n  public static IConfiguration GetAuthorizationPolicyByName(\r\n    this IAuthorizationConfigurationProvider provider,\r\n    string policyName)\r\n}\r\n\u0060\u0060\u0060\r\n\r\nEDIT: actually no extension method needed. The following should suffice:\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace Microsoft.AspNetCore.Authorization;\r\n\r\ninterface IAuthorizationConfigurationProvider\r\n{\r\n  IConfiguration AuthorizationConfiguration { get; }\r\n}\r\n\u0060\u0060\u0060",
        "createdAt": "2022-06-14T14:30:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1155273528"
      },
      {
        "id": "IC_kwDOAQzde85E4Ruw",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "@HaoK any thoughts on the [strawman binding rules](https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1154603021)?",
        "createdAt": "2022-06-14T18:56:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1155603376"
      },
      {
        "id": "IC_kwDOAQzde85E4fwA",
        "parentId": null,
        "author": "HaoK",
        "content": "What do we think about doing something spicier to make this extensible.  I was thinking about how we\u0027d implement this, and that lead me to something like the following schema instead, with a similar pluggable pattern we could use for authN as well for schemes.\r\n\r\n\u0060\u0060\u0060c#\r\n{ \u0022Policies\u0022: // Master list of named polices\r\n   { \u0022\u003CpolicyName\u003E\u0022 : // policyName : [list of requirements] all instances must be met for a success\r\n      [  \r\n          // General schema for a requirement, its identifier (for dispatching to the right factory, and its config data)\r\n          \u0022\u003CrequirementIdentifier\u003E\u0022 : {\r\n                // Arbitrary config data that gets passed to the requirement to initialize itself\r\n          },\r\n          // Examples of instances of our built in requirements\r\n          \u0022RequireAuthenticatedUsers\u0022 : { }, // DenyAnonymous takes no data\r\n          \u0022Roles\u0022 : {\r\n              \u0022AllowedRoles\u0022 : [ \u0022\u003Crole1\u003E\u0022 , \u0022\u003Crole2\u003E\u0022] // Maps directly to AllowedRoles property on requirement \r\n           }\r\n          \u0022Claim\u0022 : {\r\n               \u0022ClaimType\u0022: \u0022\u003CrequiredClaimType\u003E\u0022,\r\n               \u0022AllowedValues\u0022: [ \u0022\u003Cvalue1\u003E\u0022, \u0022\u003Cvalue2\u003E\u0022 ] // must match one of these if present.\r\n          }\r\n      ]\r\n   }\r\n}\r\n\r\n// We register our build in requirements and have them implement the factory to parse the config into instances\r\npublic interface IConfigurationRequirementRegistry {\r\n     // Hopefully we can let the factory use things in DI to create the requirements?\r\n     public void Register\u003CIConfigurationAuthorizationRequirementFactory\u003E(string requirementIdentifier) \r\n}\r\n\r\npublic interface IConfigurationAuthorizationRequirementFactory {\r\n       public IAuthorizationRequirement Create(IConfiguration configData); // Given the config data for a requirement, knows how create an instance\r\n}\r\n\r\n// Analog on the authN side could be IConfigurationAuthenticationSchemeRegistry / IConfigurationAuthenticationSchemeFactory or something which also would be passed something like:\r\n\r\n\u0022\u003CschemeName\u003E\u0022 : {\r\n    \u0022\u003CschemeIdentifer\u003E\u0022 : // i.e. \u0022Jwt | Cookie | Certificate\u0022, Extensible string -\u003E factory registration\r\n       {\r\n        // \u003Cscheme configuration data\r\n       }\r\n}\r\n\r\n\u0060\u0060\u0060\r\n\r\n\r\n\r\n",
        "createdAt": "2022-06-14T20:05:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1155660800"
      },
      {
        "id": "IC_kwDOAQzde85E4sM0",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "@HaoK my first thought is: wow, that\u0027s a lot. But I certainly appreciate that this kind of configuration extensibility is not uncommon at all, although I wonder if we can reduce by a couple of levels?\r\n\r\n- Why do the policies have to be an array rather than named objects (aka a dictionary)? You can\u0027t add two policies with the same name anyway so structuring it as dictionary would remove a layer of nesting.\r\n- It would need to support multiple claims in the list of requirements right? Your proposal seems as though it\u0027s limited to a single claim in the requirements list.\r\n- What was the reasoning to having a single nested object property called \u0022Requirements\u0022 instead of just having the policy itself be an array? Schema extensibility?\r\n- Similar question but for Roles/AllowedRoles. Are you allowing space for more options under Roles?",
        "createdAt": "2022-06-14T21:04:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1155711796"
      },
      {
        "id": "IC_kwDOAQzde85E4wvs",
        "parentId": null,
        "author": "HaoK",
        "content": "I was mostly thinking about the extensibility model, so I didn\u0027t put too much thought into the exact shape of the schema.\r\n\r\n\u003E Why do the policies have to be an array rather than named objects (aka a dictionary)? You can\u0027t add two policies with the same name anyway so structuring it as dictionary would remove a layer of nesting.\r\n\r\nGood point, the names are required to be unique so we can get rid of that outer array, i\u0027ll edit that above to remove\r\n\r\n\u003E It would need to support multiple claims in the list of requirements right? Your proposal seems as though it\u0027s limited to a single claim in the requirements list.\r\n\u003E What was the reasoning to having a single nested object property called \u0022Requirements\u0022 instead of just having the policy itself be an array? Schema extensibility?\r\n\r\nI was just demonstrating examples of what some requirement would look like, you can have duplicate requirements of the same instance.  The requirements can be dropped, with the downside of not leaving space if we ever want to add new metadata to \u0060AuthorizationPolicy\u0060 instances (although we could just add logic that branched on if the value was an array or a subobject in the future, so seems fine)\r\n\r\n\u0060\u0060\u0060\r\n     // \u003CPolicyName\u003E : \u003CList of requirements\u003E, all instances must be satisfied to succeed a policy\r\n     { \u0022exampleAdminPolicy\u0022 : \r\n          [ \r\n            \u0022RequireAuthenticatedUsers\u0022 : { }, // DenyAnonymous takes no data\r\n            \u0022Roles\u0022 : {\r\n                \u0022AllowedRoles\u0022 : [ \u0022Admin\u0022 ] // Maps directly to AllowedRoles property on requirement \r\n             },\r\n            \u0022Claim\u0022 : {\r\n                 \u0022ClaimType\u0022: \u0022someOrgClaim\u0022,\r\n                 \u0022AllowedValues\u0022: [ \u0022aspnet\u0022, \u0022devdiv\u0022 ] // must match one of these if present.\r\n            },\r\n            \u0022Claim\u0022 : {\r\n                 \u0022ClaimType\u0022: \u0022empId\u0022 // Must be an employee\r\n            },\r\n            \u0022CustomAdminRequirement\u0022: // Some custom requirement they register\r\n            {\r\n                  \u0022authenticatorRequired\u0022 : \u0022true\u0022,\r\n                  \u0022lastTfaVerifiedDate\u0022 : \u00225/14/2022\u0022\r\n                  \u0022passwordComplexityCheck\u0022 : \u0022true\u0022\r\n           }\r\n        ]\r\n     }\r\n\u0060\u0060\u0060\r\n\r\nBasically this lets each policy have space to store all of the custom data that any requirements would ever need, as they get passed the section underneath the requirement Identifier\r\n\r\n\u0060\u0060\u0060\r\n                    \u0022\u003CrequirementIdentifier\u003E\u0022 : {\r\n                          // Arbitrary config data that gets passed to the requirement to initialize itself\r\n                    },\r\n\u0060\u0060\u0060\r\n\r\nWe can certainly make our built in requirements have shorter/more concise config, I was just doing this mechanically to match the types at this point (basically viewing our requirements no differently than a 3rd party requirement that attempted to use the config binder even), our requirements could be implemented basically be \u0060configSection.Get\u003CTRequirement\u003E()\u0060 with this schema since we only have very simple requirements with strings",
        "createdAt": "2022-06-14T21:30:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1155730412"
      },
      {
        "id": "IC_kwDOAQzde85E42Q_",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "@HaoK yep that makes sense and your updated example looks reasonable.",
        "createdAt": "2022-06-14T22:01:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1155753023"
      },
      {
        "id": "IC_kwDOAQzde85E5MSN",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "@HaoK actually your example is invalid JSON now I think, as you have an array that contains object notation under the \u0022exampleAdminPolicy\u0022. I think we\u0027d likely support defining schemes for policies too yes?\r\n\r\nSo revised to this?\r\n\r\n\u0060\u0060\u0060jsonc\r\n{\r\n  \u0022Authorization\u0022: {\r\n    \u0022DefaultPolicy\u0022: \u0022HasProtectedAccess\u0022,\r\n    \u0022Policies\u0022: {\r\n      // Each property on the Policies object is a named policy comprised of an array of requirement objects\r\n      \u0022AuthenticatedUsers\u0022: [\r\n        { \u0022RequireAuthenticatedUsers\u0022 : {} } // DenyAnonymous takes no data, could \u0027null\u0027 too\r\n      ],\r\n      \u0022Employees\u0022: [\r\n        { \u0022Schemes\u0022 : { \u0022AllowedSchemes\u0022: [ \u0022Bearer\u0022 ] } },\r\n        { \u0022RequireAuthenticatedUsers\u0022 : {} },\r\n        { \u0022Roles\u0022: { \u0022AllowedRoles\u0022: [ \u0022Employees\u0022 ] } }\r\n      ],\r\n      \u0022OnlyHomers\u0022: [\r\n        { \u0022RequireAuthenticatedUsers\u0022 : {} },\r\n        { \u0022RequiresUserName\u0022 : { \u0022UserName\u0022: \u0022Homer\u0022 } }\r\n      ],\r\n      \u0022ApiClients\u0022: [\r\n        { \u0022RequireAuthenticatedUsers\u0022 : {} },\r\n        { \u0022Claim\u0022: { \u0022ClaimType\u0022: \u0022scope\u0022, \u0022AllowedValues\u0022: [ \u0022myapi:read\u0022, \u0022myapi:protected-access\u0022 ] } }\r\n      ],\r\n      \u0022exampleAdminPolicy\u0022: [\r\n        { \u0022RequireAuthenticatedUsers\u0022 : {} },\r\n        { \u0022Roles\u0022: { \u0022AllowedRoles\u0022: [ \u0022Admin\u0022 ] } }, // Maps directly to AllowedRoles property on requirement \r\n        { \u0022Claim\u0022: { \u0022ClaimType\u0022: \u0022someOrgClaim\u0022, \u0022AllowedValues\u0022: [ \u0022aspnet\u0022, \u0022devdiv\u0022 ] } }, // Must match one of these if present\r\n        { \u0022Claim\u0022: { \u0022ClaimType\u0022: \u0022empId\u0022 } }, // Must be an employee\r\n        { \u0022CustomAdminRequirement\u0022:  // Some custom requirement they register\r\n            {\r\n                \u0022authenticatorRequired\u0022 : \u0022true\u0022,\r\n                \u0022lastTfaVerifiedDate\u0022 : \u00225/14/2022\u0022,\r\n                \u0022passwordComplexityCheck\u0022 : \u0022true\u0022\r\n           }\r\n        }\r\n      ]\r\n    }\r\n  }\r\n}\r\n\u0060\u0060\u0060",
        "createdAt": "2022-06-15T00:30:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1155843213"
      },
      {
        "id": "IC_kwDOAQzde85E5YJr",
        "parentId": null,
        "author": "HaoK",
        "content": "Wait, you can\u0027t have an array of json objects?  Really?\r\n\r\nWell as soon as we are setting Schemes on Policies, then I\u0027d argue we want it to be like I had before with Requirements/Schemes being top level: so for that employees policy\r\n\r\n\u0060\u0060\u0060\r\n      \u0022Employees\u0022: {\r\n        \u0022AuthenticationSchemes\u0022 : [ \u0022Bearer\u0022 ],\r\n        \u0022Requirements\u0022 : [\r\n           { \u0022RequireAuthenticatedUsers\u0022 : {} },\r\n           { \u0022Roles\u0022: { \u0022AllowedRoles\u0022: [ \u0022Employees\u0022 ] } }\r\n         ],\r\n     }\r\n\u0060\u0060\u0060\r\n",
        "createdAt": "2022-06-15T02:01:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1155891819"
      },
      {
        "id": "IC_kwDOAQzde85E5asd",
        "parentId": null,
        "author": "HaoK",
        "content": "But it feels a bit icky to mix authenticationSchemes in with the policies definitions, because now if you want to have a slightly different Employee Cookie policy, you have to duplicate everything and just say \u0022Cookies\u0022 for the scheme.  \r\n\r\n\u0060[Authorize(AuthenticationSchemes = \u0022Bearer\u0022, Policy = \u0022Employees\u0022)]\u0060\r\n\u0060[Authorize(AuthenticationSchemes = \u0022Cookie\u0022, Policy = \u0022Employees\u0022)]\u0060\r\n\r\nvs\r\n\r\n\u0060[Authorize(\u0022Cookie-Employees\u0022)]\u0060\r\n\u0060[Authorize(\u0022Bearer-Employees\u0022)]\u0060\r\n\r\nBut that\u0027s already an issue today ",
        "createdAt": "2022-06-15T02:17:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1155902237"
      },
      {
        "id": "IC_kwDOAQzde85E8xet",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "A (fundamental?) issue that\u0027s been raised about this approach is that you can\u0027t define a policy in configuration that itself relies on values from configuration, as configuration is strictly statically defined name/value pairs with no ability to statically reference values from elsewhere.\r\n\r\nE.g. if one wanted to create a policy with a claim requirement for \u0022iss\u0022 (Issuer) that matches the configuration of the JWT scheme\u0027s issuer, which is also declared in configuration you\u0027d be forced to duplicate values in configuration:\r\n\r\n\u0060\u0060\u0060jsonc\r\n{\r\n  \u0022Authentication\u0022: {\r\n    \u0022Schemes\u0022: {\r\n      \u0022Bearer\u0022: {\r\n        \u0022Issuer\u0022: \u0022SuperDuperIdP\u0022 // \u003C-- Specified here\r\n      }\r\n    }\r\n  },\r\n  \u0022Authorization\u0022: {\r\n    \u0022DefaultPolicy\u0022: \u0022AuthenticatedUsers\u0022,\r\n    \u0022Policies\u0022: {\r\n      \u0022AuthenticatedUsers\u0022: [\r\n        // DenyAnonymousAuthorizationRequirement\r\n        \u0022RequireAuthenticatedUsers\u0022,\r\n        // ClaimsAuthorizationRequirement\r\n        {\r\n          \u0022Claims\u0022: {\r\n            \u0022ClaimType\u0022: \u0022iss\u0022,\r\n            \u0022AllowedValues\u0022: [ \u0022SuperDuperIdP\u0022 ] // \u003C-- Specified *again* here\r\n          }\r\n        }\r\n      ]\r\n    }\r\n  }\r\n}\r\n\u0060\u0060\u0060",
        "createdAt": "2022-06-15T18:12:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1156781997"
      },
      {
        "id": "IC_kwDOAQzde85FA2Qb",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "This proposal obviously has some issues that make it unpragmatic to include in .NET 7, so I\u0027ve spun-off #42235 to revisit the idea of a more top-level API (\u0060builder.Authorization\u0060) for setting up app-wide AuthZ options without needing to resort to \u0060builder.Services.AddAuthorization()\u0060 or \u0060builder.Services.Configure\u003CAuthorizationOptions\u003E()\u0060.",
        "createdAt": "2022-06-16T16:06:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1157850139"
      },
      {
        "id": "IC_kwDOAQzde85FA2Xc",
        "parentId": null,
        "author": "HaoK",
        "content": "RE the duplication of values, this seems more like a general issue for configuration.  We can certainly address that by introducing our own abstraction/layer to support configuration variables or something if this is really a blocker we need to solve.\r\n\r\nAdd some kind of notion of config variables in some special section:\r\n\r\n\u0060\u0060\u0060\r\n{ \u0022variables\u0022 : \r\n {\r\n     \u0022$idp$\u0022 = \u0022superDuperIdP\u0022\r\n     \u0022#var#\u0022 = \u0022whatever\u0022\r\n }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nHave our authorization config parsing system wrap IConfiguration to replace the final Get string calls to replace any variables using this section which allows folks to define this.  But this seems like a feature for config to add to me",
        "createdAt": "2022-06-16T16:06:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1157850588"
      },
      {
        "id": "IC_kwDOAQzde85TxZge",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "Think we should just close or move this to backlog at this point.",
        "createdAt": "2023-01-26T18:56:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1405458462"
      },
      {
        "id": "IC_kwDOAQzde85Tx51h",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-01-26T20:10:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42172#issuecomment-1405590881"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85LxSJr",
    "title": "Find ways to minimize the effort required to configure authz in an HTTP API by 30%",
    "url": "https://github.com/dotnet/aspnetcore/issues/42192",
    "createdAt": "2022-06-14T18:29:30Z",
    "lastUpdated": "2024-09-10T19:32:58Z",
    "body": "[This item was copied from the planning repo]\r\n\r\nThrough Cu, work with partners in AAD and internally within ASP.NET to collaborate on user research and experience measurement to find ways we can ease the burden of configuring popular auth providers like Microsoft Identity Platform or and 2 popular 3rd party providers. \r\n\r\nSpecifically concentrate on easing the friction and effort (keystrokes, clicks, and internet searches required) for one or all of the following scenarios:\r\n\r\n- [ ] Given a Swashbuckle-enabled Web or Minimal API project, add support for authenticating the user on the Swagger UI page. \r\n- [ ] Adding authz to an existing ASP.NET Core API so that it can be called only from an authenticated client.\r\n- [ ] Assessing if we need to add support for the OAuth2 endpoints for Twitter (our docs specifically call out that a 3rd party NuGet package can be used for this, but that package fails to work with ASP.NET Core identity, so customers who want to support Twitter auth are in a broken state; they lack support for the OAuth2 features with our provider but can\u0027t authenticate customers with the OSS provider. \r\n- [ ] Asses how many of the authz-related docs specific to social or 3rd-party auth providers in our ASP.NET Core Identity docs section can be completed by PMs on the team according to the docs in [this TOC node](https://docs.microsoft.com/en-us/aspnet/core/security/authentication/social/?view=aspnetcore-6.0\u0026tabs=visual-studio) and establish a content plan, if needed, for resolving hurdles in the experience. \r\n\r\nAs we improve the scenario with product work, we should accompany that product work with documentation for our testing team so the experience of configuring auth for these key scenarios can be tested repeatedly and so we know when service or API changes result in our needing to update the docs or the experience. ",
    "upvotes": 2,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85E4XtM",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E Assessing if we need to add support for the OAuth2 endpoints for Twitter (our docs specifically call out that a 3rd party NuGet package can be used for this, but that package fails to work with ASP.NET Core identity, so customers who want to support Twitter auth are in a broken state; they lack support for the OAuth2 features with our provider but can\u0027t authenticate customers with the OSS provider.\r\n\r\nAssuming you\u0027re referring to the \u0060AspNet.Security.OAuth.Twitter\u0060 package @martincostello and I maintain as part of the \u0060aspnet-contrib\u0060 initiative, it\u0027s based on the ASP.NET Core OAuth 2.0 base handler and thus should work with ASP.NET Core Identity like any other provider.\r\n\r\nShould that package not work with ASP.NET Core Identity, this would be a major issue that would deserve a quick fix so I\u0027m very surprised you didn\u0027t open a ticket to inform us about that \uD83D\uDE15 \r\n\r\nI\u0027d like to kindly remind you that [this provider was requested by the ASP.NET team](https://github.com/dotnet/aspnetcore/issues/39664#issuecomment-1018800346): the least you can do in return is to inform us ASAP when you think something is wrong with it.\r\n\r\n/cc @Tratcher ",
        "createdAt": "2022-06-14T19:26:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1155627852"
      },
      {
        "id": "IC_kwDOAQzde85E87-q",
        "parentId": null,
        "author": "kevinchalet",
        "content": "I just tested locally and I haven\u0027t encountered any issue with ASP.NET Core Identity.\r\n\r\n@martincostello do you mind giving it a try to confirm it works fine for you too?",
        "createdAt": "2022-06-15T19:05:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1156825002"
      },
      {
        "id": "IC_kwDOAQzde85E892E",
        "parentId": null,
        "author": "bradygaster",
        "content": "Oh i apologize - just saw this. :) In fact I tried with both the one we ship and the one from your side, in an experiment with Blazor  WebAssembly auth. I hadn\u0027t filed an issue against your repo because I hadn\u0027t validated it wasn\u0027t my own code doing something awry. I\u0027d love to sync up with you and show you what I ran into when I tried your libs. ",
        "createdAt": "2022-06-15T19:14:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1156832644"
      },
      {
        "id": "IC_kwDOAQzde85E8_bq",
        "parentId": null,
        "author": "martincostello",
        "content": "Blazor is an untested scenario on our side, mainly through lack of experience. We often get questions about it though for our OAuth providers in general (not specifically Twitter).\r\n\r\nIf it\u2019s a scenario that _should_ work with Blazor and it\u2019s fairly trivial to fix whatever\u2019s wrong, then I think we\u2019d be happy to work with you and the team to light it up. ",
        "createdAt": "2022-06-15T19:22:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1156839146"
      },
      {
        "id": "IC_kwDOAQzde85E9Aeg",
        "parentId": null,
        "author": "bradygaster",
        "content": "Absolutely appreciate that @martincostello and @kevinchalet - I\u0027ve used a few of your other providers for projects over the years so I was eager when the docs pointed me in your direction. Once you see my code/attempt-at-code, if we find something I can tweak, I\u0027d be eager to update the doc with something more tangible than a link showing folks who want to use the oauth2 approaches you provide that we don\u0027t, so I\u0027d be stoked to work on a deeper article highlighting some of what\u0027s possible with it once we figure out what else I\u0027ve done wrong in the sample. ",
        "createdAt": "2022-06-15T19:27:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1156843424"
      },
      {
        "id": "IC_kwDOAQzde85E9C_u",
        "parentId": null,
        "author": "martincostello",
        "content": "I can\u0027t speak for K\u00E9vin\u0027s availability, but I\u0027d be happy to do a call with you any time between 1600-1800 BST (0800-1000 PDT?) any weekday to try and work through what you have and do some troubleshooting.\n\nYou can get some [contact details](https://github.com/martincostello#contact) off my GH profile.",
        "createdAt": "2022-06-15T19:40:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1156853742"
      },
      {
        "id": "IC_kwDOAQzde85E9d7Y",
        "parentId": null,
        "author": "kevinchalet",
        "content": "@bradygaster sent me a repro: it\u0027s a classical Blazor WASM\u002BIdentity Server app with a custom \u0060ExternalLogin.cshtml\u0060 that uses the popular Tweetinvi library to retrieve the profile image and the email address (in this case, the Twitter authentication part is purely handled server-side and the Blazor WASM client gets local tokens from IdSrv after a transparent authorization dance).\r\n\r\nThere are 2 distinct issues:\r\n  - The Tweetinvi API used to achieve that - \u0060Users.GetAuthenticatedUserAsync()\u0060 - targets the v1 API endpoints. Yet, these endpoints don\u0027t work with the Twitter OAuth 2.0 integration, that requires using the v2 endpoints. Once you use the \u0060UsersV2.GetUserByNameAsync(\u0022me\u0022)\u0060 API to get the profile image (AFAIK, you can\u0027t retrieve the email address using the v2 user endpoints), things work fine.\r\n\r\n  - From time to time, too much data is stored in the \u0060AuthenticationProperties\u0060 and the handler ends up generating a \u0060state\u0060 bag that is too large for Twitter. Empirically, I was able to determine that states longer than 500 chars cause a generic error. I\u0027m fairly sure this potential issue was discussed during the review. Fixing that won\u0027t be exactly trivial as it will require storing the state elsewhere (e.g in a distributed cache or in a database, as the OpenIddict client does)",
        "createdAt": "2022-06-15T21:29:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1156964056"
      },
      {
        "id": "IC_kwDOAQzde85E9eni",
        "parentId": null,
        "author": "martincostello",
        "content": "Ah cool, glad one of them was a fairly easy fix.\r\n\r\nThe second issue sounds like the problem I had with the first implementation that _seemed_ to fix itself: https://github.com/dotnet/aspnetcore/issues/39664#issuecomment-1018598236",
        "createdAt": "2022-06-15T21:33:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1156966882"
      },
      {
        "id": "IC_kwDOAQzde85E9etV",
        "parentId": null,
        "author": "bradygaster",
        "content": "Oh that\u0027s very interesting - adding @ReubenBond as you said \u0022distributed caching\u0022 - an idea he and the Orleans team and I are discussing. ",
        "createdAt": "2022-06-15T21:33:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1156967253"
      },
      {
        "id": "IC_kwDOAQzde85E9fDK",
        "parentId": null,
        "author": "bradygaster",
        "content": "@kevinchalet - to be clear, I only used the Tweetinvi client because I couldn\u0027t figure out how to use the claims to get all the properties directly from Twitter. If I could make that work, I\u0027d probably have no use for that client package. ",
        "createdAt": "2022-06-15T21:35:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1156968650"
      },
      {
        "id": "IC_kwDOAQzde85E9gI3",
        "parentId": null,
        "author": "martincostello",
        "content": "I\u0027m not at a computer right now to try it myself by running the code, but maybe there\u0027s addition fields you can request in the user payload, and then map those to claims?\n\nhttps://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/blob/dev/docs/twitter.md",
        "createdAt": "2022-06-15T21:39:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1156973111"
      },
      {
        "id": "IC_kwDOAQzde85E9gde",
        "parentId": null,
        "author": "kevinchalet",
        "content": "@bradygaster by default, the v2 user API returns very few data: the ID,  the username and the name, nothing more: https://oauth-playground.glitch.me/?id=findMyUser.\r\n\r\nIf you need additional data, you need to use a special parameter called \u0060fields\u0060 (many providers do that). You can configure that via \u0060TwitterOptions.UserFields\u0060 and add a claim action to map the profile image field to a specific claim.",
        "createdAt": "2022-06-15T21:41:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1156974430"
      },
      {
        "id": "IC_kwDOAQzde85E9gie",
        "parentId": null,
        "author": "kevinchalet",
        "content": "_Crap, @martincostello is too fast for me_ \uD83E\uDD23 ",
        "createdAt": "2022-06-15T21:41:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1156974750"
      },
      {
        "id": "IC_kwDOAQzde85E9mbR",
        "parentId": null,
        "author": "bradygaster",
        "content": "\u003E I\u0027m not at a computer right now to try it myself by running the code, but maybe there\u0027s addition fields you can request in the user payload, and then map those to claims?\r\n\u003E \r\n\u003E https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/blob/dev/docs/twitter.md\r\n\r\nI think I tried that and the authentication part began to fail after switching over but I can surely try again. ",
        "createdAt": "2022-06-15T22:06:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1156998865"
      },
      {
        "id": "IC_kwDOAQzde85E_FzD",
        "parentId": null,
        "author": "martincostello",
        "content": "I haven\u0027t looked at getting the email yet, but adding these [two lines of configuration](https://github.com/martincostello/AspNet.Security.OAuth.Providers/commit/bc1069cd9120fb46785710d818569fdc86aadcee) for the provider using [our repo\u0027s sample app](https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/tree/dev/samples/Mvc.Client) gets me a claim containing the profile image\u0027s URL.\r\n\r\n\u0060\u0060\u0060csharp\r\n.AddTwitter(options =\u003E\r\n{\r\n    options.ClientId = Configuration[\u0022Twitter:ClientId\u0022];\r\n    options.ClientSecret = Configuration[\u0022Twitter:ClientSecret\u0022];\r\n    options.UserFields.Add(\u0022profile_image_url\u0022);\r\n    options.ClaimActions.MapJsonSubKey(\u0022urn:twitter:avatar\u0022, \u0022data\u0022, \u0022profile_image_url\u0022);\r\n})\r\n\u0060\u0060\u0060\r\n\r\n![image](https://user-images.githubusercontent.com/1439341/174029172-1e0eb2bb-2033-4a79-8aa0-15f0ca52bc64.png)\r\n\r\nThe available fields are documented [here](https://developer.twitter.com/en/docs/twitter-api/data-dictionary/object-model/user).",
        "createdAt": "2022-06-16T08:36:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1157389507"
      },
      {
        "id": "IC_kwDOAQzde85E_Hjv",
        "parentId": null,
        "author": "martincostello",
        "content": "It appears that it isn\u0027t possible to get the user\u0027s email address using the v2 Twitter API: [twittercommunity.com](https://twittercommunity.com/t/how-to-get-user-details-by-email-address-is-there-any-api-exists/143073)",
        "createdAt": "2022-06-16T08:43:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1157396719"
      },
      {
        "id": "IC_kwDOAQzde85E_LPI",
        "parentId": null,
        "author": "martincostello",
        "content": "I haven\u0027t run into the _\u0022state too long\u0022_ problem at all locally with our sample - probably because we don\u0027t do anything additional with the \u0060AuthenticationProperties\u0060.\r\n\r\nI\u0027ll have a think about how we could provide a way to work around that that isn\u0027t tied to much to a specific solution and/or is extensible.\r\n",
        "createdAt": "2022-06-16T08:59:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1157411784"
      },
      {
        "id": "IC_kwDOAQzde85FBa7m",
        "parentId": null,
        "author": "bradygaster",
        "content": "\u003E It appears that it isn\u0027t possible to get the user\u0027s email address using the v2 Twitter API: [twittercommunity.com](https://twittercommunity.com/t/how-to-get-user-details-by-email-address-is-there-any-api-exists/143073)\r\n\r\nGiven ASP.NET identity requires email, this seems bad. Any workarounds you\u0027d advise?",
        "createdAt": "2022-06-16T18:23:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1158000358"
      },
      {
        "id": "IC_kwDOAQzde85FBcgb",
        "parentId": null,
        "author": "Tratcher",
        "content": "@martincostello that twittercommunity thread was about looking up users _by_ e-mail, not retrieving their e-mail address.\r\n\r\nDoes the old approach work with the new OAuth2 flow?\r\nhttps://github.com/dotnet/aspnetcore/blob/4ea0f60dfbaf576e6ced5a107bc876b0784423d4/src/Security/Authentication/Twitter/src/TwitterHandler.cs#L313",
        "createdAt": "2022-06-16T18:31:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1158006811"
      },
      {
        "id": "IC_kwDOAQzde85FBdPo",
        "parentId": null,
        "author": "martincostello",
        "content": "I\u2019ll give it a try tomorrow, but I _assumed_ not as it\u2019s part of the 1.1 API.",
        "createdAt": "2022-06-16T18:35:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1158009832"
      },
      {
        "id": "IC_kwDOAQzde85FD-jK",
        "parentId": null,
        "author": "martincostello",
        "content": "Nope, that doesn\u0027t work. Using the access token as-is gets you an HTTP 403 error.\r\n\r\nI looked at the code for \u0060ExecuteRequestAsync()\u0060, but that needs a token secret to generate the relevant signature to call the API which you don\u0027t have in the OAuth 2 flow.\r\n\r\nAssuming I\u0027ve understood it all correctly, you can only get the email by using the ASP.NET Core provider that uses the 1.1 API. Otherwise you have to mix and match the two API versions to use the different capabilities.\r\n\r\nThe snippet I added to test the above was this:\r\n\r\n\u0060\u0060\u0060csharp\r\noptions.Events.OnCreatingTicket = async context =\u003E\r\n{\r\n    context.Backchannel.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\r\n        \u0022Bearer\u0022,\r\n        context.AccessToken);\r\n\r\n    using var response = await context.Backchannel.GetAsync(\r\n        \u0022https://api.twitter.com/1.1/account/verify_credentials.json?include_email=true\u0022,\r\n        context.HttpContext.RequestAborted);\r\n\r\n    response.EnsureSuccessStatusCode();\r\n\r\n    using var content = await response.Content.ReadAsStreamAsync();\r\n    using var document = await JsonDocument.ParseAsync(content);\r\n\r\n    if (document.RootElement is { } root)\r\n    {\r\n        // Do stuff\r\n    }\r\n};\r\n\u0060\u0060\u0060\r\n\r\nAccording to the [Twitter documentation](https://developer.twitter.com/en/docs/twitter-api/v1/accounts-and-users/manage-account-settings/api-reference/get-account-verify_credentials) for the endpoint there\u0027s no guarantee an email would be returned so even with the ASP.NET Core Twitter provider an application using ASP.NET Core Identity would need to handle the case of their being no email address when the user logs in:\r\n\r\n\u003E If the user does not have an email address on their account, or if the email address is not verified, null will be returned.\r\n",
        "createdAt": "2022-06-17T09:11:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1158670538"
      },
      {
        "id": "IC_kwDOAQzde85FFVPl",
        "parentId": null,
        "author": "bradygaster",
        "content": "\u003E Assuming I\u0027ve understood it all correctly, you can only get the email by using the ASP.NET Core provider that uses the 1.1 API. Otherwise you have to mix and match the two API versions to use the different capabilities.\r\n\r\nThis was my presumption at first glance. Eesh. Kinda sub-optimal. Really appreciate the diligence looking through and debugging it. \r\n",
        "createdAt": "2022-06-17T16:08:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1159025637"
      },
      {
        "id": "IC_kwDOAQzde85FFmbF",
        "parentId": null,
        "author": "kevinchalet",
        "content": "@bradygaster not sure if it works for you, but you always can ask the users for their email address using a good old form \uD83D\uDE03 (it\u0027s what the default Identity UI does).",
        "createdAt": "2022-06-17T17:31:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1159096005"
      },
      {
        "id": "IC_kwDOAQzde85FMdQD",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@bradygaster Can you put this issue into a milestone please?",
        "createdAt": "2022-06-20T22:18:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42192#issuecomment-1160893443"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85MNkIo",
    "title": "Avoid creating Context classes when Events have not been set",
    "url": "https://github.com/dotnet/aspnetcore/issues/42325",
    "createdAt": "2022-06-21T15:30:47Z",
    "lastUpdated": "2022-06-22T22:17:44Z",
    "body": "There are multiple events in \u0060CookieAuthenticationHandler\u0060 and each has its own context type which some of them are created _per request_ even when there\u0027s no event has been set. \r\n\r\nThe similar approach that used in [this PR](https://github.com/dotnet/aspnetcore/pull/36193) could be used to only allocate the context types if the event has been set.\r\n\r\nThis code:\r\nhttps://github.com/dotnet/aspnetcore/blob/9ac541b23b22882aebffcdc931c3575d33edcec8/src/Security/Authentication/Cookies/src/CookieAuthenticationHandler.cs#L200\r\n\r\nwould change to this: \r\n\u0060\u0060\u0060c#\r\nif (Events.GetType() == typeof(CookieAuthenticationEvents) \r\n    \u0026\u0026 Events.OnValidatePrincipal == CookieAuthenticationEvents._defaultOnValidatePrincipal)\r\n{\r\n    await Events.ValidatePrincipal(context);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThis would also apply to other authentication handlers.",
    "upvotes": 0,
    "labels": [
      "Perf",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85FXB6P",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Triage: we\u0027d need to see benchmarks showing the impact of this on performance to decide whether to take it.",
        "createdAt": "2022-06-22T22:17:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42325#issuecomment-1163665039"
      },
      {
        "id": "IC_kwDOAQzde85FXB-e",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-06-22T22:17:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42325#issuecomment-1163665310"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85OGGiK",
    "title": "[Discussion] Single authentication scheme is treated as default scheme",
    "url": "https://github.com/dotnet/aspnetcore/issues/42828",
    "createdAt": "2022-07-20T00:16:53Z",
    "lastUpdated": "2022-07-20T13:36:49Z",
    "body": "Starting in .NET 7 Preview 7, we introduced new behavior in the authentication area in ASP.NET Core to reduce boilerplate and help build sensible defaults into ASP.NET Core.\r\n\r\nPreviously, users were always required to set the default authentication scheme that would be used by authentication and authorization handlers, like so:\r\n\r\n\u0060\u0060\u0060csharp\r\nbuilder.Services.AddAuthentication(\u0022MyDefaultScheme\u0022);\r\n\u0060\u0060\u0060\r\n\r\nMoving forward, when (and only when) a single authentication scheme is registered, that scheme will be treated as the default scheme. For example, \u0022foobar\u0022 will be treated as the default scheme in the code below.\r\n\r\n\u0060\u0060\u0060chsarp\r\nbuilder.Services.AddAuthentication().AddOAuth(\u0022foobar\u0022);\r\n\u0060\u0060\u0060\r\n\r\nThis change might expose unintended behavior changes in applications, such as authentication options being validated earlier than expected.",
    "upvotes": 2,
    "labels": [
      "area-auth",
      "announcement"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85G6aiH",
        "parentId": null,
        "author": "WeihanLi",
        "content": "What if we had multi auth schema but no default schema registered, would it use the first or the last as the default schema?\r\n\r\nFor example:\r\n\r\n\u0060\u0060\u0060 c#\r\nservices.AddAuthentication()\r\n    .AddBasic()\r\n    .AddJwtBearer()\r\n    .AddCookie();\r\n\u0060\u0060\u0060\r\n",
        "createdAt": "2022-07-20T01:55:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42828#issuecomment-1189718151"
      },
      {
        "id": "IC_kwDOAQzde85G6ePK",
        "parentId": null,
        "author": "fowl2",
        "content": "I\u0027m assuming this is part of the overall effort to reduce boilerplate?\n\nEven if it\u0027s \u0022obvious\u0022 I think it\u0027s worth including an explicit motivation in announcements like this, so we know \u0027why\u0027 we\u0027re potentially breaking someone :)\n",
        "createdAt": "2022-07-20T02:21:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42828#issuecomment-1189733322"
      },
      {
        "id": "IC_kwDOAQzde85G6nSo",
        "parentId": null,
        "author": "captainsafia",
        "content": "\u003E What if we had multi auth schema but no default schema registered, would it use the first or the last as the default schema?\r\n\r\nIn this case, no default schema is set. This rule only applies when a single schema is registered.\r\n\r\n\u003E I\u0027m assuming this is part of the overall effort to reduce boilerplate?\r\n\r\nYep.\r\n\r\n\u003E Even if it\u0027s \u0022obvious\u0022 I think it\u0027s worth including an explicit motivation in announcements like this, so we know \u0027why\u0027 we\u0027re potentially breaking someone :)\r\n\r\nGood feedback!",
        "createdAt": "2022-07-20T03:23:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42828#issuecomment-1189770408"
      },
      {
        "id": "IC_kwDOAQzde85G8oHD",
        "parentId": null,
        "author": "poke",
        "content": "I think this is a good change which should help to reduce some of the confusion which occurs from \u201Cmagic defaults\u201D. Thanks! \uD83D\uDE0A",
        "createdAt": "2022-07-20T13:36:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42828#issuecomment-1190298051"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85OlcOo",
    "title": "Move away from bower as a package manager",
    "url": "https://github.com/dotnet/aspnetcore/issues/42922",
    "createdAt": "2022-07-26T15:51:00Z",
    "lastUpdated": "2022-12-13T23:41:37Z",
    "body": "There are still places in our codebase where we use Bower for npm package management.\r\nBower is now in maintenance mode, so we need to move to a better alternative.\r\n\u003Cimg width=\u0022826\u0022 alt=\u0022image\u0022 src=\u0022https://user-images.githubusercontent.com/34246760/181051875-99752288-bf73-43a8-b92c-926a5877d4f5.png\u0022\u003E\r\n\r\n## Areas of consideration\r\n- [ ] Templates\r\n- [ ] Test projects\r\n- [ ] Scaffolded content\r\n\r\n\u003Cimg width=\u0022555\u0022 alt=\u0022image\u0022 src=\u0022https://user-images.githubusercontent.com/34246760/181052312-e8a64920-4bd8-4650-9db2-2c2a0195fa87.png\u0022\u003E\r\n",
    "upvotes": 0,
    "labels": [
      "task",
      "area-auth",
      "feature-templates"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85M8WNa",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "@adityamandaleeka will you be able to handle the changes in the security areas ? We\u0027ll handle the remaining ones.",
        "createdAt": "2022-10-25T17:17:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42922#issuecomment-1290888026"
      },
      {
        "id": "IC_kwDOAQzde85M_vDp",
        "parentId": null,
        "author": "javiercn",
        "content": "@mkArtakMSFT @surayya-MS will tackle the MVC ones.",
        "createdAt": "2022-10-26T09:45:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42922#issuecomment-1291776233"
      },
      {
        "id": "IC_kwDOAQzde85QDirp",
        "parentId": null,
        "author": "surayya-MS",
        "content": "I\u0027ve resolved all the MVC ones as part of [Deleted bower from Mvc](https://github.com/dotnet/aspnetcore/pull/44779) PR. Removing the \u0060area-mvc\u0060 as the remaining work is in the security area only.",
        "createdAt": "2022-12-08T18:07:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42922#issuecomment-1343105769"
      },
      {
        "id": "IC_kwDOAQzde85QElLm",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Un-milestoning so this shows up in web frameworks triage.\r\n\r\ncc: @captainsafia ",
        "createdAt": "2022-12-08T21:24:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42922#issuecomment-1343378150"
      },
      {
        "id": "IC_kwDOAQzde85QeGZ7",
        "parentId": null,
        "author": "captainsafia",
        "content": "Triage: the usage is currently only in sample and doesn\u0027t appear in templates so we\u0027ll prioritize this as infrastructure work.",
        "createdAt": "2022-12-13T23:41:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42922#issuecomment-1350067835"
      },
      {
        "id": "IC_kwDOAQzde85QeGnw",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-12-13T23:41:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42922#issuecomment-1350068720"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85P3O8h",
    "title": "JwtBearerEvents might be null, despite being marked as not null",
    "url": "https://github.com/dotnet/aspnetcore/issues/43313",
    "createdAt": "2022-08-16T06:32:43Z",
    "lastUpdated": "2024-11-13T22:46:25Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nThe following code will throw a NullReferenceException:\r\n\u0060\u0060\u0060\r\nservices.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\r\n                .AddJwtBearer(o =\u003E\r\n                {\r\n                    o.Events.OnMessageReceived \u002B= (ctx) =\u003E Task.CompletedTask;\r\n                });\r\n\u0060\u0060\u0060\r\n\r\nIt will do so despite o.Events being flagged as not nullable.\n\n### Expected Behavior\n\no.Events is not \u0060null\u0060\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n6.0.400\n\n### Anything else?\n\nhttps://github.com/dotnet/aspnetcore/blob/cccab50fba1c7335fdb48a735246374b5ddd7e69/src/Security/Authentication/JwtBearer/src/JwtBearerOptions.cs#L57-L66\r\n\r\nThis should probably have \u0060JwtBearerEvents?\u0060",
    "upvotes": 3,
    "labels": [
      "area-auth",
      "nullable"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85Iohi2",
        "parentId": null,
        "author": "Tratcher",
        "content": "You\u0027re correct, the base Events field is nullable and so should this one be. Note this applies to all auth handlers.\r\nhttps://github.com/dotnet/aspnetcore/blob/cccab50fba1c7335fdb48a735246374b5ddd7e69/src/Security/Authentication/Core/src/AuthenticationSchemeOptions.cs#L33\r\n\r\nEvents will be initialized to a default value later if one is not provided.\r\nhttps://github.com/dotnet/aspnetcore/blob/c85baf8db0c72ae8e68643029d514b2e737c9fae/src/Security/Authentication/Core/src/AuthenticationHandler.cs#L154",
        "createdAt": "2022-08-17T22:58:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43313#issuecomment-1218582710"
      },
      {
        "id": "IC_kwDOAQzde85MfOKJ",
        "parentId": null,
        "author": "akonyer",
        "content": "I\u0027m running into this as well. For now just have to null check it even though the compiler tells me you shouldn\u0027t have to",
        "createdAt": "2022-10-19T01:30:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43313#issuecomment-1283252873"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85Q6yiU",
    "title": " Certificate authentication fails validation when intermediate certificate isn\u0027t in store against TLS specification",
    "url": "https://github.com/dotnet/aspnetcore/issues/43661",
    "createdAt": "2022-08-31T16:34:16Z",
    "lastUpdated": "2024-11-12T12:35:54Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nWhen you configure Kestler to use certificate authentication and a client sends certificate including an intermediate certificate to a server then server will fail the chain validation if it has the root CA in certificate store but doesn\u0027t have the intermediate certificate in the certificate store on Windows.\n\n### Expected Behavior\n\nThe chain validation should succeed, it should read the intermediate certificates from the TLS connection to build the chain.\r\n\r\nToday the implementation is against RFC 5246, the RFC states about client certificate message: \u0022This message conveys the client\u0027s certificate chain to the server; the server will use it when verifying the CertificateVerify message...\u0022 also it describes the structure \u0022This is a sequence (chain) of certificates. The sender\u0027s certificate MUST come first in the list. Each following certificate MUST directly certify the one preceding it. Because certificate validation requires that root keys be distributed independently, the self-signed certificate that specifies the root certificate authority MAY be omitted from the chain, under the assumption that the remote end must already possess it in order to validate it in any case.\u0022 I feel it clearly expects the server to do the validation using the chain that is sent (with the exception of root).\n\n### Steps To Reproduce\n\nCreate CA, intermediate and child certificates (e.g. like described https://docs.microsoft.com/en-us/aspnet/core/security/authentication/certauth?view=aspnetcore-6.0#create-certificates-in-powershell)\r\n\r\nYou can use a simple web server with certificate authentication, e.g.:\r\n\u0060\u0060\u0060CSharp\r\nusing Microsoft.AspNetCore.Authentication.Certificate;\r\nusing Microsoft.AspNetCore.Server.Kestrel.Core;\r\nusing Microsoft.AspNetCore.Server.Kestrel.Https;\r\n\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\nbuilder.Services.AddAuthentication(\r\n        CertificateAuthenticationDefaults.AuthenticationScheme)\r\n    .AddCertificate();\r\nbuilder.Services.Configure\u003CKestrelServerOptions\u003E(options =\u003E\r\n{\r\n    options.ConfigureHttpsDefaults(options =\u003E\r\n        options.ClientCertificateMode = ClientCertificateMode.AllowCertificate);\r\n});\r\n\r\nvar app = builder.Build();\r\n\r\napp.UseAuthentication();\r\napp.UseHttpsRedirection();\r\n\r\napp.MapGet(\u0022/\u0022, () =\u003E \u0022Hello World!\u0022);\r\n\r\napp.Run();\r\n\u0060\u0060\u0060\r\nPut the CA into windows store where you have the server.\r\n\r\nThen put on a different computer all 3 certificates into certificate stores and call the service from that computer. The service will ask you for a certificate, choose the child certificate.\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n6.0.400\n\n### Anything else?\n\nThis was first risen as a ticket https://github.com/dotnet/aspnetcore/issues/42010 but the ticket was closed based on improvement to my other request \u0022how to work around the issue\u0022 which was made more possible using making a connection context available (https://github.com/dotnet/aspnetcore/pull/33953). Nevertheless, the asp .net default code is still not following the TLS specification for client authentication (and it is hard to customize it to follow it).",
    "upvotes": 1,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85Jg6Pk",
        "parentId": null,
        "author": "davidfowl",
        "content": "Not follow it the TLS specification? I think it\u2019s fair to say you\u2019d prefer it if there was an easier way to get the full cert chain without writing code but this doesn\u2019t have anything to do with \u201Cthe specification\u201D AFAIK (happy yo be proven wrong).\r\n\r\nDownloading the chain per request is a performance concern (and security concern) that\u2019s why we don\u2019t want to do it by default.",
        "createdAt": "2022-08-31T20:00:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43661#issuecomment-1233363940"
      },
      {
        "id": "IC_kwDOAQzde85Jk3ha",
        "parentId": null,
        "author": "blowdart",
        "content": "_Downloading the chain per request is a performance concern (and security concern) that\u2019s why we don\u2019t want to do it by default._\r\n\r\nThis isn\u0027t downloading the chain though; the client sends the leaf cert _*and optionally*_ any intermediate CAs (but not the root CA that everything chains off).\r\n\r\nI wonder what http.sys does in this regard. It\u0027d be a bit of a rearchitecting, assuming we can get the leaf and intermediate chain. It\u0027d probably be a performance drag, because if we implement a custom chain store, it [replaces the default](https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.x509certificates.x509chainpolicy.customtruststore) one, not supplements it, so there would be a lot of copying there, or caching with concurrency problems when you see a new intermediate.",
        "createdAt": "2022-09-01T14:59:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43661#issuecomment-1234401370"
      },
      {
        "id": "IC_kwDOAQzde85KoFy8",
        "parentId": null,
        "author": "mk185147",
        "content": "\u003E Not follow it the TLS specification? I think it\u2019s fair to say you\u2019d prefer it if there was an easier way to get the full cert chain without writing code but this doesn\u2019t have anything to do with \u201Cthe specification\u201D AFAIK (happy yo be proven wrong).\r\n\r\nSee https://www.rfc-editor.org/rfc/rfc5246 , sections 7.4.6. and 7.4.2.\r\n",
        "createdAt": "2022-09-20T08:35:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43661#issuecomment-1252023484"
      },
      {
        "id": "IC_kwDOAQzde85Rxnkl",
        "parentId": null,
        "author": "MageFroh",
        "content": "Looking at the code behind \u0060AddCertificate\u0060, it looks like it only has access to the leaf certificate to perform chain validation.\r\nSo maybe #2708 is needed to fix this issue?",
        "createdAt": "2023-01-05T09:14:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43661#issuecomment-1371961637"
      },
      {
        "id": "IC_kwDOAQzde86TP56N",
        "parentId": null,
        "author": "Tyrrx",
        "content": "@davidfowl There is no security issue using the intermediate certificates provided by the client. I mean you can create one by treating the intermediate certificates as trusted during the chain building but as long as you don\u0027t do that there is noting wrong about using them.",
        "createdAt": "2024-11-12T12:35:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43661#issuecomment-2470420109"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85SQm4a",
    "title": "Write custom authentication failure information to the response body",
    "url": "https://github.com/dotnet/aspnetcore/issues/44100",
    "createdAt": "2022-09-20T22:57:33Z",
    "lastUpdated": "2024-09-10T19:33:00Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Is your feature request related to a problem? Please describe the problem.\r\n\r\nI have written my Authentication Handler (loosely based on JwtBearHandler). Obviously, I have some \u0060AuthenticateResult.fail(ex)\u0060. All that is good. But,  I would like to extract info from these errors and translate them to the Response body aside from the expected 401.\r\n\r\nOutside the authentication / authentication framework, I\u0027ve written an exception handler that does exactly that for controllers.\r\n\r\nUnfortunately, I\u0027ve failed to find a way to retrieve the \u0060AuthenticateResult\u0060 produced by the authentication Handler. \u0060IAuthorizationMiddlewareResultHandler\u0060 do expose the \u0060AuthenticateResult\u0060 but not when the authentication fails, only when it succeed, through \u0060HttpContext.Features.Get\u003CIAuthenticateResultFeature\u003E()\u0060.\r\n\r\n### Describe the solution you\u0027d like\r\n\r\nI would like some ways to get the \u0060AuthenticationResult\u0060 and generate a response body from it. I suppose I could do that from the \u0060IAuthorizationMiddlewareResultHandler\u0060 assuming I had access to the result, regardless of the authentication state. I would throw from the resultHandler which would be translated by the exception handler.\r\n\r\nOr am I missing something here ? Any Documentation to point me to ?\r\n\r\n### Additional context\r\n\r\n_No response_",
    "upvotes": 7,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85K5wrj",
        "parentId": null,
        "author": "Tratcher",
        "content": "Have you looked at this part of the JwtBearer handler?\r\nhttps://github.com/dotnet/aspnetcore/blob/e13e3facfb26643fe580be56f2d3f466cd5ee009/src/Security/Authentication/JwtBearer/src/JwtBearerHandler.cs#L214\r\n\r\nWhen a user isn\u0027t authorized then Challenge will get invoked and the controller won\u0027t be executed. Challenge is responsible for generating the response. This example sets the status code and headers, but writing to the body is possible. Note we don\u0027t always recommend writing to the body from auth handlers, there are cases where that won\u0027t work such as if you have multiple auth handlers enabled/challenged.",
        "createdAt": "2022-09-23T20:44:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44100#issuecomment-1256655587"
      },
      {
        "id": "IC_kwDOAQzde85K7YJ0",
        "parentId": null,
        "author": "AlexandreBossard",
        "content": "Yes, I\u0027m actually using it, but not to write a response. Let me explain my setup and why I think using the events to write a response is not good enough.\r\nWe use exceptions to report errors through our service, Those errors are all handled by the exception handler and transformed in a JSON body which can be understand by our client. This work reasonably well and have the advantages to enforce a known and limited set of errors which are transformed in only one place. \r\n\r\nWe have authentication setup with JWT with multiple tenants. We want to report 2 different types of error that could happened during authentication (token is invalid and token has expired). The \u0060IAuthorizationMiddlewareResultHandler\u0060 does not expose the \u0060AuthenticateResult\u0060 when the authentication fails either through one \u0060HttpContext\u0060 features (however it does when succeed) or the \u0060PolicyAuthorizationResult\u0060. So the authentication process result is lost to us, the exception(s) raised by the security token validation are not reported. This prevent us to analyze the cause of the authentication failure to report a richer error than a simple 401.\r\n\r\nThe only workaround I have found is to use \u0060JWTBearerEvents.OnChallenged\u0060 to set a custom feature on the HTTPContext, like the one when authentication succeed, that could check in the middleware Result Handler.\r\n\r\nWhile this works, I think it\u0027s rather convoluted, to have to set events and all registered scheme and to insert a custom feature to get access to the authentication exceptions.\r\n\r\nBut again, I may have missed something, this framework is big. \r\n",
        "createdAt": "2022-09-24T23:02:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44100#issuecomment-1257079412"
      },
      {
        "id": "IC_kwDOAQzde85LMSkV",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "cc: @blowdart ",
        "createdAt": "2022-09-28T22:07:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44100#issuecomment-1261512981"
      },
      {
        "id": "IC_kwDOAQzde85LMXsV",
        "parentId": null,
        "author": "blowdart",
        "content": "Feels like a feature request to me, but yea, it\u0027s an odd thing, the body doesn\u0027t really come into play for pretty much every auth type, it\u0027s a status code thing. Even failing with cookie auth ends up with a redirect, not something that renders. Interestingly AAD failures do end up in a failed page, with details, if you\u0027re in the msft domain. But then that\u0027s at the login failed level, during the HTML flow to trigger the auth in the first place.\r\n\r\nWe can look for 8, but I don\u0027t know how clean it would be, or worse, how it\u0027d be misunderstood and misused.",
        "createdAt": "2022-09-28T22:38:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44100#issuecomment-1261533973"
      },
      {
        "id": "IC_kwDOAQzde85LMXuH",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-28T22:38:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44100#issuecomment-1261534087"
      },
      {
        "id": "IC_kwDOAQzde85LMj9z",
        "parentId": null,
        "author": "brockallen",
        "content": "\u003E Feels like a feature request to me, but yea, it\u0027s an odd thing, the body doesn\u0027t really come into play for pretty much every auth type, it\u0027s a status code thing. Even failing with cookie auth ends up with a redirect, not something that renders. Interestingly AAD failures do end up in a failed pa\r\n\r\nIt\u0027s common for bearer token 401/403 responses to need to add to the response headers.\r\n\r\nhttps://www.rfc-editor.org/rfc/rfc6750#section-3\r\n\r\nIIRC this was difficult from authorization policies. Maybe it\u0027s easier now.",
        "createdAt": "2022-09-29T00:01:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44100#issuecomment-1261584243"
      },
      {
        "id": "IC_kwDOAQzde85LQk_P",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E It\u0027s common for bearer token 401/403 responses to need to add to the response headers.\r\n\r\nJwtBearer does that now, but it doesn\u0027t include any AuthZ details.",
        "createdAt": "2022-09-29T18:08:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44100#issuecomment-1262637007"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85UsLmR",
    "title": "Authorization user role is case sensitive",
    "url": "https://github.com/dotnet/aspnetcore/issues/44713",
    "createdAt": "2022-10-24T13:51:16Z",
    "lastUpdated": "2024-02-13T01:59:18Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nIf I declare a required role for an authorization policy with \u0060AuthorizationPolicyBuilder.RequireRole\u0060 or with the \u0060Authorize(Roles=\u0022...\u0022)\u0060 attribute, the role name is taken untransformed.\r\n\r\nIf I add roles to a user with \u0060UserManager\u003C\u003E.AddToRoleAsync\u0060 then the role name is transformed by \u0060ILookupNormalizer\u0060 (actually the transformation is uppercasing) before passing the roles to \u0060IUserRoleStore.AddToRoleAsync\u0060.\r\n\r\nNow, when the policy is evaluated to authorize a user, \u0060ClaimsIdentity.HasClaim\u0060 is called to check if the user have the correct role:\r\n\r\n\u0060\u0060\u0060\r\n        public virtual bool HasClaim(string type, string value)\r\n        {\r\n            if (type == null)\r\n            {\r\n                throw new ArgumentNullException(nameof(type));\r\n            }\r\n\r\n            if (value == null)\r\n            {\r\n                throw new ArgumentNullException(nameof(value));\r\n            }\r\n\r\n            foreach (Claim claim in Claims)\r\n            {\r\n                if (claim != null\r\n                        \u0026\u0026 string.Equals(claim.Type, type, StringComparison.OrdinalIgnoreCase)\r\n                        \u0026\u0026 string.Equals(claim.Value, value, StringComparison.Ordinal))\r\n                {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\u0060\u0060\u0060\r\n\r\nThis function is doing a case sensitive comparison of the claim value.\n\n### Expected Behavior\n\nThe role transformation should be consistent across the API. \u0060AuthorizeAttribute\u0060 and \u0060AuthorizationPolicyBuilder.RequireRole\u0060 should transform the role name.\r\n\r\nIf it\u0027s working as intended then the documentation should be updated to reflect it.\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n6.0.402\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "Docs",
      "area-auth",
      "area-identity"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85M10-6",
        "parentId": null,
        "author": "blowdart",
        "content": "\u0060RequireRole\u0060 works on more role providers than identity, some of which are case sensitive, so it\u0027s working as expected. \r\n\r\nAgreed that the either the authorize attribute and builder docs, or the identity create role, add user to role, get role etc docs need updated. \r\n\r\n@Rick-Anderson which would you think gives more bang per buck? I\u0027m tempted to hand wave over the attribute and build and say something like \u0022Different role providers provide different case guarantees or normalization. Please ensure that you follow the rules for your provider as the check for this attribute/function is case sensitive\u0022, and then call out in the identity apis that they normalize. \r\n\r\n",
        "createdAt": "2022-10-24T15:05:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44713#issuecomment-1289179066"
      },
      {
        "id": "IC_kwDOAQzde85pMu5B",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-10-16T17:29:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44713#issuecomment-1764945473"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85Uwg2y",
    "title": "JwtBearerHandler should check Authority \u0026 Issuer before trying to validate",
    "url": "https://github.com/dotnet/aspnetcore/issues/44724",
    "createdAt": "2022-10-25T07:34:55Z",
    "lastUpdated": "2024-03-05T21:31:26Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nUsing multiple Identity Providers the BearerToken Validation code, validates all Idp\u0027s . This makes no sense and leads to false positives (e.g. hacking) having multiple exceptions on invalid tokens.\r\n\r\nThe problem is described here\r\nhttps://oliviervaillancourt.com/posts/Fixing-IDX10501-MultipleAuthScheme\n\n### Describe the solution you\u0027d like\n\nhttps://github.com/dotnet/aspnetcore/blob/v6.0.3/src/Security/Authentication/JwtBearer/src/JwtBearerHandler.cs\r\nshould unpack the token, check the issuer and authority\r\ncompare it. If the token being and it\u0027s issuer or authority do not match, do not raise an exception (or maybe just a warning).\r\n\r\nIf all validations failed but a token was given, *then* an exception should be raised (to improve security/logging)\r\n\n\n### Additional context\n\n![afbeelding](https://user-images.githubusercontent.com/3471239/197710739-372ac63f-9f3b-4c45-8c52-6446ac3c1e4f.png)\r\n\r\nThere is the property ForwardDefaultSelector in JwtBearerOptions, \r\nservices.AddAuthentication(MobileAuthenticationDefaults.AuthenticationScheme)\r\n\r\nwhich is related but in fact, this option seems unnecessary if token validation is a bit smarter using logic, described above.\r\nTo make this very explicit. If I have a JWT from Cognito, it makes no sense to validate this token against a validator for Azure. This also will lead to exensive downloading of public keys using JWTK.json (remotely)\r\n\r\n",
    "upvotes": 2,
    "labels": [
      "enhancement",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85M78bH",
        "parentId": null,
        "author": "Tratcher",
        "content": "Related: https://github.com/dotnet/aspnetcore/issues/13046, https://github.com/dotnet/aspnetcore/issues/38498",
        "createdAt": "2022-10-25T15:53:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44724#issuecomment-1290782407"
      },
      {
        "id": "IC_kwDOAQzde85NDbvo",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-10-26T22:46:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44724#issuecomment-1292745704"
      },
      {
        "id": "IC_kwDOAQzde85NDb04",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-10-26T22:47:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44724#issuecomment-1292746040"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85VFhMJ",
    "title": "Custom Authorization Attributes on Min APIs",
    "url": "https://github.com/dotnet/aspnetcore/issues/44783",
    "createdAt": "2022-10-28T16:39:11Z",
    "lastUpdated": "2024-02-27T16:39:27Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nOn our legacy ApiControllers, we have our own customer Authorization Attributes, for instance:\r\n\r\n[FeatureAuthorize(Features.ManageRegions]\r\n\r\nWe would like to apply the same to MinAPI, both with attributes and fluent\n\n### Describe the solution you\u0027d like\n\n\r\napp.MapGet(\u0022/login\u0022, [FeatureAuthorize(Features.ManageRegions] () =\u003E \u0022This endpoint is those users with this feature assigned.\u0022);\r\n\r\napp.MapGet(\u0022/login2\u0022, () =\u003E \u0022This endpoint also requires this feature.\u0022)\r\n   .FeatureAuthorize(Features.ManageRegions);\r\n\r\nI guess the former might work out of the box... but how would the latter be accomplished, i.e. a fluent syntax for associating a customer authorization attribute with a Map call (via an extension method).\r\n\r\n\n\n### Additional context\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "area-minimal"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85NNBNC",
        "parentId": null,
        "author": "johnkwaters",
        "content": "Use same approach as for AllowAnonymous:\r\n\r\n\u0060\u0060\u0060\r\npublic static class CustomAuthorizationEndpointConventionBuilderExtensions\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Requires that the caller have access to the specified feature.\r\n    /// \u003C/summary\u003E\r\n    /// \u003Cparam name=\u0022builder\u0022\u003EThe endpoint convention builder.\u003C/param\u003E\r\n    /// \u003Creturns\u003EThe original convention builder parameter.\u003C/returns\u003E\r\n    public static TBuilder RequireFeature\u003CTBuilder\u003E(this TBuilder builder, params Feature[] features)\r\n        where TBuilder : IEndpointConventionBuilder\r\n    {\r\n        builder.Add(endpointBuilder =\u003E { endpointBuilder.Metadata.Add(\r\n            new FeatureAuthorizeAttribute(features)); });\r\n        return builder;\r\n    }\r\n}\r\n\r\n\u0060\u0060\u0060\r\nAnd\r\n\r\n\u0060\u0060\u0060\r\napp.MapGet(\u0022/api/viewusers\u0022, () =\u003E \u0022I have access to ViewUsers!\u0022)\r\n    .RequireFeature(Feature.ViewUsers);\r\n\r\n\r\n\u0060\u0060\u0060\r\n\r\n",
        "createdAt": "2022-10-28T17:22:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1295258434"
      },
      {
        "id": "IC_kwDOAQzde85NN1zH",
        "parentId": null,
        "author": "Tratcher",
        "content": "We don\u0027t recommend custom auth attributes anymore. What component do you expect to run them?\r\n\r\nMost of this logic should move into authorization policies.",
        "createdAt": "2022-10-28T21:14:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1295473863"
      },
      {
        "id": "IC_kwDOAQzde85NOdjy",
        "parentId": null,
        "author": "davidfowl",
        "content": "I\u0027m not 100% sure this is easy to do with authorization policies but will be easier in the next version on .NET. You\u0027ll can do this in multiple ways today but using custom metadata makes using authorization policies challenging. In .NET 7 I would use a filter for this until we get https://github.com/dotnet/aspnetcore/issues/44551",
        "createdAt": "2022-10-28T23:25:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1295636722"
      },
      {
        "id": "IC_kwDOAQzde85NOkQq",
        "parentId": null,
        "author": "davidfowl",
        "content": "I should add, this is easier with minimal APIs because you can now directly add an auth policy directly to endpoints. That would allow you to write one like above inline on the endpoint ",
        "createdAt": "2022-10-29T00:39:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1295664170"
      },
      {
        "id": "IC_kwDOAQzde85NOkYB",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u0060\u0060\u0060C#\r\npublic static TBuilder RequireFeature\u003CTBuilder\u003E(this TBuilder builder, params Feature[] features)\r\n    where TBuilder : IEndpointConventionBuilder\r\n{\r\n    builder.RequireAuthorization(pb =\u003E pb.RequireAssertion(context =\u003E HasFeatures(context, features)));\r\n    return builder;\r\n}\r\n\r\nprivate static bool HasFeatures(AuthorizationHandlerContext context, Feature[] features)\r\n{\r\n    // Write logic here\r\n    return true;\r\n}\r\n\u0060\u0060\u0060\r\n\r\nOR\r\n\r\n\u0060\u0060\u0060C#\r\npublic static TBuilder RequireFeature\u003CTBuilder\u003E(this TBuilder builder, params Feature[] features)\r\n    where TBuilder : IEndpointConventionBuilder\r\n{\r\n    builder.RequireAuthorization(pb =\u003E pb.AddRequirements(new FeatureRequirement(features)));\r\n    return builder;\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThis lets you directly add requirements to an auth policy.",
        "createdAt": "2022-10-29T00:41:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1295664641"
      },
      {
        "id": "IC_kwDOAQzde85NO1Y_",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u0060\u0060\u0060C#\r\napp.MapGet(\u0022/login\u0022, [FeatureAuthorize(Features.ManageRegions)] () =\u003E \u0022This endpoint is those users with this feature assigned.\u0022);\r\n\u0060\u0060\u0060\r\n\r\nThis pattern is much harder to pull off. The attribute will be part of the metadata since that happens automagically but flowing that data to authentication handlers is much harder.\r\n",
        "createdAt": "2022-10-29T04:50:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1295734335"
      },
      {
        "id": "IC_kwDOAQzde85NRBA3",
        "parentId": null,
        "author": "jxwaters",
        "content": "My current implementation of this authorization attribute uses policies under the hood, and automatically generates a policy name based on the list of features enum names, concatenated. How could this more cleanly be expressed using your recommended approach, without the custom attribute?\r\n\r\n1. The custom attribute, which sets the Policy Name:\r\n\r\n\u0060\u0060\u0060\r\ninternal class FeatureAuthorizeAttribute : AuthorizeAttribute\r\n{\r\n    const string FEATURE_POLICY_PREFIX = \u0022Feature\u0022;\r\n\r\n    public FeatureAuthorizeAttribute(params Feature[] features) =\u003E Features = features;\r\n\r\n    public Feature[] Features\r\n    {\r\n        get\r\n        {\r\n            var policyFeature = Policy;\r\n            foreach (var fp in policyFeature.Substring(FEATURE_POLICY_PREFIX.Length \u002B 1).Split(\u0027,\u0027))\r\n            {\r\n                var tryParse = Enum.TryParse\u003CFeature\u003E(fp, out var feature);\r\n                if (tryParse)\r\n                {\r\n                    features.Add(feature);\r\n                }\r\n            }\r\n            return default;\r\n        }\r\n        set =\u003E Policy = $\u0022{FEATURE_POLICY_PREFIX}_{string.Join(\u0027,\u0027, value)}\u0022;\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n2, The custom policy provider that resolves policies with this name pattern to a FeatureRequirement:\r\n\r\n\u0060\u0060\u0060\r\npublic class CustomPolicyProvider : IAuthorizationPolicyProvider\r\n{\r\n\r\n    public Task\u003CAuthorizationPolicy?\u003E GetPolicyAsync(string policyName)\r\n    {\r\n        var isFP = policyName.StartsWith(FEATURE_POLICY_PREFIX, StringComparison.OrdinalIgnoreCase);\r\n        if (isFP)\r\n        {\r\n            var features = new List\u003CFeature\u003E();\r\n            foreach (var fp in policyName.Substring(FEATURE_POLICY_PREFIX.Length \u002B 1).Split(\u0027,\u0027))\r\n            {\r\n                var tryParse = Enum.TryParse\u003CFeature\u003E(fp, out var feature);\r\n                if (tryParse)\r\n                {\r\n                    features.Add(feature);\r\n                }\r\n            }\r\n            var policy = new AuthorizationPolicyBuilder();\r\n            policy.AddRequirements(new FeatureRequirement(features.ToArray()));\r\n            return Task.FromResult(policy.Build());\r\n        }\r\n        return Task.FromResult\u003CAuthorizationPolicy\u003E(null);\r\n    }\r\n\r\n\u0060\u0060\u0060\r\n\r\n3. The Feature Requirement:\r\n\r\n\u0060\u0060\u0060\r\npublic class FeatureRequirement : IAuthorizationRequirement\r\n{\r\n    public Feature[] RequiredFeatures { get; set; }\r\n\r\n    public FeatureRequirement(Feature[] requiredFeatures)\r\n    {\r\n        RequiredFeatures = requiredFeatures;\r\n    }\r\n}\r\n\r\n\u0060\u0060\u0060\r\n\r\n4. The FeatureHandler\r\n\r\nNOTE the IUserContext is populated by middleware that runs before the Auth pipeline, and contains the features that the user has\r\n\r\n\u0060\u0060\u0060\r\npublic class FeatureHandler : AuthorizationHandler\u003CFeatureRequirement\u003E\r\n{\r\n    private readonly IUserContext _userContext;\r\n\r\n    public FeatureHandler(IUserContext userContext)\r\n    {\r\n        _userContext = userContext;\r\n    }\r\n\r\n    protected override async Task HandleRequirementAsync(AuthorizationHandlerContext context,\r\n        FeatureRequirement requirement)\r\n    {\r\n        if (context.User.Identity?.IsAuthenticated ?? false)\r\n        {\r\n            if (_userContext.Features.Any(t =\u003E requirement.RequiredFeatures.Contains(t)))\r\n            {\r\n                context.Succeed(requirement);\r\n            }            \r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nI feel like this is a very laborious way to accomplish what I want!\r\n",
        "createdAt": "2022-10-30T17:16:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1296306231"
      },
      {
        "id": "IC_kwDOAQzde85NRJJZ",
        "parentId": null,
        "author": "davidfowl",
        "content": "@jxwaters this is exactly what we\u0027re going to solve in .NET 8 with https://github.com/dotnet/aspnetcore/issues/44551. It will let you express requirements as attributes. In your example it will eliminate step 2 and in step 1, the attribute would look like this:\r\n\r\n\u0060\u0060\u0060C#\r\ninternal class FeatureAuthorizeAttribute : AuthorizeAttribute, IAuthorizationRequirementData\r\n{\r\n    public FeatureAuthorizeAttribute(params Feature[] features) =\u003E Features = features;\r\n\r\n    public Feature[] Features { get; }\r\n    \r\n    public IEnumerable\u003CIAuthorizationRequirement\u003E GetRequirements()\r\n    {\r\n        yield return new FeatureRequirement(Features);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThis will be enough to flow an \u0060IAuthorizationRequirement\u0060 as attributes without smuggleing them via the policy name (which is what we document today).\r\n\r\nThere are other ways to get at this metadata but it isn\u0027t very easy either so it\u0027s may not be worth expressing here.\r\n\r\n@HaoK the other thing worth following up on here is additional user context (the IUserContext) that needs to flow to authorization handlers. There\u0027s no good way to flow that today other than a scoped service that is first set by middleware. \r\n\r\n@jxwaters it may be possible to create your own derived context by using \u0060IAuthorizationHandlerContextFactory\u0060. That would allow you to pass your \u0060IUserContext\u0060 in the constructor and set it as part of a derived \u0060AuthorizationHandlerContext\u0060.\r\n\r\nWith minimal APIs, you can directly inline the requirement and close over state in the method (in this case the features) https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1295664641. So there\u0027s less indirection.",
        "createdAt": "2022-10-30T20:04:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1296339545"
      },
      {
        "id": "IC_kwDOAQzde85NVC7X",
        "parentId": null,
        "author": "HaoK",
        "content": "\u003Ethe other thing worth following up on here is additional user context (the IUserContext) that needs to flow to authorization handlers. There\u0027s no good way to flow that today other than a scoped service that is first set by middleware.\r\n\r\n@davidfowl Just to clarify what feels weird, the fact that the handler has to get it from the container via constructor?  \r\n\r\nOr are we looking for some mechanism to pass additional arbitrary data in the default context, with a new mechanism to request stuff (as opposed to just pulling it out of the container in the handler?)",
        "createdAt": "2022-10-31T16:36:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1297362647"
      },
      {
        "id": "IC_kwDOAQzde85NX2qQ",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E @davidfowl Just to clarify what feels weird, the fact that the handler has to get it from the container via constructor?\r\n\r\nNo that is pretty clean, but it\u0027s the fact that the IUserContext is popualated by middleware (that code isn\u0027t shown here).\r\n\r\n\u003E Or are we looking for some mechanism to pass additional arbitrary data in the default context, with a new mechanism to request stuff (as opposed to just pulling it out of the container in the handler?)\r\n\r\nI was thinking something along these lines. The factory looks like a great extensibility point but flowing your scoped user context to the call is tricky.",
        "createdAt": "2022-11-01T06:51:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1298098832"
      },
      {
        "id": "IC_kwDOAQzde85NZenD",
        "parentId": null,
        "author": "jxwaters",
        "content": "I do like the idea of being able to inject whatever you need into the handler. In this case, the user context is populated in middleware by a combination of things - some things come from claims, but some things are actually fetched from the database and stored in a server side session state cache, so this needs to be accessed with an async call. So this all happens in a middleware. If this helps you think about the possible scenarios of what kinds of things might need to happen to provide what the handler needs.",
        "createdAt": "2022-11-01T13:39:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1298524611"
      },
      {
        "id": "IC_kwDOAQzde85Nciyk",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-11-01T22:56:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1299328164"
      },
      {
        "id": "IC_kwDOAQzde85NdFIV",
        "parentId": null,
        "author": "davidfowl",
        "content": "@jxwaters can you share pesudo code for your middleware? It might not be worth improving if the solution is already simple enough.",
        "createdAt": "2022-11-02T02:18:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1299468821"
      },
      {
        "id": "IC_kwDOAQzde85NhYGZ",
        "parentId": null,
        "author": "jxwaters",
        "content": "1. Inject IUserContext into the middleware\r\n2. Populate it with information from claims\r\n3. Look up server side state in IMemoryCache - if not found, fetch from DB and add to cache\r\n4. Put some info from the server side state into the IUserContext",
        "createdAt": "2022-11-02T14:55:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1300595097"
      },
      {
        "id": "IC_kwDOAQzde85NhZli",
        "parentId": null,
        "author": "jxwaters",
        "content": "    public async Task InvokeAsync(HttpContext context, IUserContext userContext, ISessionCacheHelper sch)\r\n    {\r\n...",
        "createdAt": "2022-11-02T14:58:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1300601186"
      },
      {
        "id": "IC_kwDOAQzde85NiJSp",
        "parentId": null,
        "author": "HaoK",
        "content": "Another wrinkle for us to make this better is that the main AuthorizationHandlerContext is created inside of AuthorizationService which is at the lowest layer which doesn\u0027t even have the concept of HttpContext/request, so we\u0027d have to likely invent another context which would probably result in something more complicated than the inject/InvokeAsync in middleware",
        "createdAt": "2022-11-02T16:12:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1300796585"
      },
      {
        "id": "IC_kwDOAQzde85te-LX",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-12-01T22:00:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1836835543"
      },
      {
        "id": "IC_kwDOAQzde851Pput",
        "parentId": null,
        "author": "asos-alexhaigh",
        "content": "This appears to be implemented now but poorly documented. Can we get some official docs with better examples?\r\n\r\nThis is the current one (appears to be AI written) and it does not adequately explain all the features available.\r\nhttps://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/security?view=aspnetcore-8.0",
        "createdAt": "2024-02-27T16:39:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44783#issuecomment-1967037357"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85VQFns",
    "title": "[Tracking] JWT requirements",
    "url": "https://github.com/dotnet/aspnetcore/issues/44803",
    "createdAt": "2022-10-31T18:18:06Z",
    "lastUpdated": "2024-02-13T01:58:51Z",
    "body": "Gathering potential requirements for BCL JWT Apis\r\n\r\nfrom @Tratcher \r\n- read JWTs (and have a plan for eventual encrypted EJWTs) \r\n- Create JWTs (\u0026 EJWTs eventually)\r\n- Fetch OIDC metadata(?)\r\n\r\nAn MVP should consider implementing the following signing algorithms: \r\n\r\nHMAC \u002B SHA256\r\nRSASSA-PKCS1-v1_5 \u002B SHA256\r\nECDSA \u002B P-256 \u002B SHA256\r\n\r\n\r\nfrom @blowdart \r\n- Should Validate be separate, or always a function of Parse? (Probably not, but how would you reflect multiple validation errors, or do you stop at the first one)\r\n- Is decrypt a separate step to parse? (Yes from @blowdart)\r\n- Does anyone need to parse an invalid jwt? (someone asked for this if memory serves.) \r\n- Do we support unprotected tokens at all?  (No from @blowdart)\r\n- Do we accept or create tokens with a null cipher? (No from @blowdart)\r\n- Do we enable the use of non-crypto board approved curves? (Probably, but with a way to disable, same with deprecated algoritms)\r\n- Is the Json Web Key support a separate, public class?\r\n- Should the signing functions be a separate, pluggable class to allow the use of things like Azure Key Vault? ",
    "upvotes": 0,
    "labels": [
      "Needs: Design",
      "enhancement",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85OIK8J",
        "parentId": null,
        "author": "rafikiassumani-msft",
        "content": "From an MVP standpoint, should we just start with JWT and then potentially increment to EJWT? I think encryption scenarios can be their own deliverables. @HaoK @davidfowl @blowdart @Tratcher ?",
        "createdAt": "2022-11-10T19:01:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44803#issuecomment-1310764809"
      },
      {
        "id": "IC_kwDOAQzde85OIOsx",
        "parentId": null,
        "author": "Tratcher",
        "content": "That\u0027s fine, so long as we know where it fits in the flow.",
        "createdAt": "2022-11-10T19:15:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44803#issuecomment-1310780209"
      },
      {
        "id": "IC_kwDOAQzde85OIPVr",
        "parentId": null,
        "author": "HaoK",
        "content": "Cool, updated the requirements to move EJWT to have a plan as opposed to a hard requirement",
        "createdAt": "2022-11-10T19:18:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44803#issuecomment-1310782827"
      },
      {
        "id": "IC_kwDOAQzde85te9wg",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-12-01T21:58:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44803#issuecomment-1836833824"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85W8f5S",
    "title": "[Refactoring] Move local authz policies to global authz policies",
    "url": "https://github.com/dotnet/aspnetcore/issues/45220",
    "createdAt": "2022-11-21T22:44:12Z",
    "lastUpdated": "2024-02-13T01:49:53Z",
    "body": "## Background and Motivation\r\n\r\nIn .NET 7, we introduced the \u0060RequireAuthorization\u0060 extension method that allowed a user to construct and add an authorization policy onto an endpoint with on invocation. There are scenarios were users would want to factor these policies out to from endpoint-specific (local) to global policies on the application.\r\n\r\n## Proposed Refactoring\r\n\r\n### Refactoring Behavior and Message\r\n\r\nWhen right-clicking on a line of code with a \u0060RequireAuthorization\u0060 option the refactoring will be provided with the following message:\r\n\r\n\u003E Convert to global authorization policy\r\n\r\n\r\n## Usage Scenarios\r\n\r\n\u0060\u0060\u0060csharp\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\nbuilder.Services.AddAuthorization();\r\n\r\nvar app = builder.Build();\r\n\r\napp.UseAuthorization();\r\n\r\napp.MapGet(\u0022/\u0022, () =\u003E \u0022Hello world!\u0022)\r\n  .RequireAuthorization(policy =\u003E p.RequireClaim(\u0022scope\u0022, \u0022api-access\u0022)));\r\n\r\napp.Run();\r\n\u0060\u0060\u0060\r\n",
    "upvotes": 0,
    "labels": [
      "area-auth",
      "analyzer",
      "help candidate"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85O2pgu",
        "parentId": null,
        "author": "??",
        "content": "Thank you for submitting this for API review. This will be reviewed by @dotnet/aspnet-api-review at the next meeting of the ASP.NET Core API Review group. Please ensure you take a look at [the API review process documentation](https://github.com/dotnet/aspnetcore/blob/main/docs/APIReviewProcess.md) and ensure that:\n\n* The PR contains changes to the reference-assembly that describe the API change. **Or**, you have included a snippet of reference-assembly-style code that illustrates the API change.\n* The PR describes the impact to users, both positive (useful new APIs) and negative (breaking changes).\n* Someone is assigned to \u0022champion\u0022 this change in the meeting, and they understand the impact and design of the change.",
        "createdAt": "2022-11-22T02:45:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45220#issuecomment-1322948654"
      },
      {
        "id": "IC_kwDOAQzde85Tna0x",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-01-24T23:53:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45220#issuecomment-1402842417"
      },
      {
        "id": "IC_kwDOAQzde85Tq9-E",
        "parentId": null,
        "author": "jabellard",
        "content": "@rafikiassumani-msft , @captainsafia : I can take on this.",
        "createdAt": "2023-01-25T15:12:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45220#issuecomment-1403772804"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85bIL0B",
    "title": "Opaque - reference token validation",
    "url": "https://github.com/dotnet/aspnetcore/issues/46026",
    "createdAt": "2023-01-11T11:27:42Z",
    "lastUpdated": "2024-05-06T22:25:00Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nHi,\r\n\r\nI have an identity provider OIDC compliant which issues a JWT ID token and an opaque access token (or reference token).\r\nMicrosoft offers a way to validate a JWT bearer however, I did not see an alternative for opaque tokens.\n\n### Describe the solution you\u0027d like\n\nI would like to have a method extension that works the same as \u0060ServiceCollection.AddJwtBearer()\u0060 extension.  \r\n\r\n\r\nWe would provide almost the same identity provider information such as the issuer uri, user info, and most importantly the **introspect endpoint**, which checks if the access token is valid or not.  \r\n\r\nFinally, we could populate the identity principal with the userinfo endpoint, right after validating the token.\n\n### Additional context\n\n_No response_",
    "upvotes": 3,
    "labels": [
      "Needs: Design",
      "enhancement",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85SNEMx",
        "parentId": null,
        "author": "blowdart",
        "content": "_I am so so wrong_",
        "createdAt": "2023-01-11T16:54:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46026#issuecomment-1379156785"
      },
      {
        "id": "IC_kwDOAQzde85SN5Wh",
        "parentId": null,
        "author": "kevinchalet",
        "content": "@blowdart \u0060reference tokens\u0060 != \u0060refresh tokens\u0060.\r\n\r\n@Simkiw FWIW, OpenIddict has a validation handler that natively supports OAuth 2.0 introspection, which should work with any server implementation as long as it\u0027s standard-compliant. You can see https://github.com/openiddict/openiddict-samples/blob/dev/samples/Zirku/Zirku.Api1/Program.cs for an example.",
        "createdAt": "2023-01-11T19:23:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46026#issuecomment-1379374497"
      },
      {
        "id": "IC_kwDOAQzde85SODsm",
        "parentId": null,
        "author": "blowdart",
        "content": "Aggh doh. This is what I get for opening github when I wake up :)",
        "createdAt": "2023-01-11T20:04:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46026#issuecomment-1379416870"
      },
      {
        "id": "IC_kwDOAQzde85SOENe",
        "parentId": null,
        "author": "blowdart",
        "content": "@Simkiw does a third party option work for you, or are you hampered by corporate rules etc making it hard to use 3rd party code?",
        "createdAt": "2023-01-11T20:05:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46026#issuecomment-1379418974"
      },
      {
        "id": "IC_kwDOAQzde85SQccp",
        "parentId": null,
        "author": "Simkiw",
        "content": "So far, I have freedom to use whatever i want.    \r\nI also came across [this article](https://leastprivilege.com/2020/07/06/flexible-access-token-validation-in-asp-net-core/) written in 2020 which targets the same issue, but involves some code tweeking.  \r\n\r\nAs for the openiddict, no i wasn\u0027t aware of it. I\u0027ll take a look at it and give it a try.  \r\n\r\nThank you all, I\u0027ll keep you posted",
        "createdAt": "2023-01-12T09:31:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46026#issuecomment-1380042537"
      },
      {
        "id": "IC_kwDOAQzde85STsc9",
        "parentId": null,
        "author": "captainsafia",
        "content": "Triage: this is a new feature that we will probably want to support via a callback API of some sort.",
        "createdAt": "2023-01-12T19:17:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46026#issuecomment-1380894525"
      },
      {
        "id": "IC_kwDOAQzde85STsf-",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-01-12T19:17:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46026#issuecomment-1380894718"
      },
      {
        "id": "IC_kwDOAQzde85TSCdV",
        "parentId": null,
        "author": "wrschneider",
        "content": "Same request:\r\n\r\nSpecific scenario is a SPA using OIDC on the front-end\r\nBackend needs to _authenticate_ from the opaque access token, by calling OIDC userinfo endpoint\r\n\r\nhttps://github.com/IdentityModel/IdentityModel.AspNetCore.OAuth2Introspection is close but calls the introspection endpoint rather than userinfo. And the maintainer says he wouldn\u0027t merge a PR to add this support if I created it :-)\r\n(see: https://github.com/IdentityModel/IdentityModel.AspNetCore.OAuth2Introspection/issues/169)\r\n\r\nNote that token introspection and userinfo endpoint are two different things!\r\nToken introspection will tell you the token is valid but may not give you all the claims you need for authentication.\r\nThis is an artifact of opaque access tokens are supposed to be used for _authorization_ and we\u0027re trying to do _authentication_.",
        "createdAt": "2023-01-19T16:18:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46026#issuecomment-1397237589"
      },
      {
        "id": "IC_kwDOAQzde85TVTJd",
        "parentId": null,
        "author": "Simkiw",
        "content": "@wrschneider Hi there,  \r\n\r\nLike you said, both userinfo and introspect serve different purposes.  \r\nUsually if not always, you cannot get userinfo without a valid token, which means, if you get the userinfo details, that implies the token is valid.  \r\n\r\nHowever, it is vital to keep in mind that the introspection endpoint requires authentication as opposed to userinfo endpoint :  \r\n- Anyone could get the userinfo details as long as the http request has a valid token\r\n- Only authenticated requests could check the validity of a token (as if you are sending two tokens, one authenticating the caller and the other one the token you are checking over)  \r\n\r\nIf somehow your access token gets compromised, userinfo endpoint might not be enough to secure the backend.",
        "createdAt": "2023-01-20T09:01:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46026#issuecomment-1398092381"
      },
      {
        "id": "IC_kwDOAQzde85TWrIm",
        "parentId": null,
        "author": "wrschneider",
        "content": "\u003E If somehow your access token gets compromised, userinfo endpoint might not be enough to secure the backend.\r\n\r\nThis is why access tokens tend to be short-lived: If your access token is compromised, then you can call whatever API the access token authorizes you to call.  Userinfo is just one specific example.\r\n\r\nNo different than using \u0060AddJwtBearer\u0060 to authenticate and using public keys to check JWT signature, or if you had some other kind of access token to authorize your back end API explicitly.\r\n",
        "createdAt": "2023-01-20T14:14:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46026#issuecomment-1398452774"
      },
      {
        "id": "IC_kwDOAQzde85YCCIt",
        "parentId": null,
        "author": "iamjplant",
        "content": "Agreed!  This would be nice to have for those of us who don\u0027t get JWT\u0027s back!",
        "createdAt": "2023-03-20T21:00:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46026#issuecomment-1476928045"
      },
      {
        "id": "IC_kwDOAQzde85te570",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-12-01T21:44:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46026#issuecomment-1836818164"
      },
      {
        "id": "IC_kwDOAQzde858_ioI",
        "parentId": null,
        "author": "GNUGradyn",
        "content": "This is a massive shame. There are some inherit security compromises in using JWTs that are NOT worth the reduced database pressure for some use cases. This should be supported. Should have been supported a long time ago.",
        "createdAt": "2024-05-06T22:24:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46026#issuecomment-2097031688"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85be0Vk",
    "title": "IClaimsTransformation do not automagically compose",
    "url": "https://github.com/dotnet/aspnetcore/issues/46120",
    "createdAt": "2023-01-16T11:56:30Z",
    "lastUpdated": "2025-01-23T19:45:45Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nMultiple registrations on IClaimsTransformation should compose. For pete\u0027s sake, the signature for \u0060IClaimsTransformation\u0060 is literally an async reduce function.\r\n\r\n\n\n### Describe the solution you\u0027d like\n\nA \u0060ReducerClaimsTransformer\u0060 should be injected into \u0060AuthenticationService.Transform\u0060\r\n\r\n\u0060\u0060\u0060\r\npublic class ReducerClaimsTransformation : IClaimsTransformation\r\n{\r\n    public async Task\u003CClaimsPrincipal\u003E TransformAsync(ClaimsPrincipal principal)\r\n    {\r\n        foreach (var transformation in _transformations)\r\n        {\r\n            principal = await transformation.TransformAsync(principal);\r\n        }\r\n\r\n        return principal;\r\n    }\r\n}\r\n\u0060\u0060\u0060\n\n### Additional context\n\n_No response_",
    "upvotes": 12,
    "labels": [
      "enhancement",
      "area-auth",
      "untriaged",
      "help candidate",
      "Pillar: Dev Experience"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85Shjs4",
        "parentId": null,
        "author": "pinkfloydx33",
        "content": "I remember being surprised that you could only register one \u0060IClaimsTransformation\u0060. At the time (a few years ago) we had multiple distinct use-cases for the transformation and had to combine it all into one. Not useful either if the transformer is provided by third parties (though no idea how common that is).\r\n\r\nWe no longer need the transformation as our entire Auth flow has changed, just throwing out my 2cp that at the very least it was surprising and hard to reason about without looking at the source that you could only have one. ",
        "createdAt": "2023-01-16T20:37:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46120#issuecomment-1384528696"
      },
      {
        "id": "IC_kwDOAQzde85Si2e8",
        "parentId": null,
        "author": "davidfowl",
        "content": "I think this is a reasonable change to make. @HaoK do you see any problems with this? It is a breaking change that we should document though (if we do make it).",
        "createdAt": "2023-01-17T05:52:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46120#issuecomment-1384867772"
      },
      {
        "id": "IC_kwDOAQzde85Si7ox",
        "parentId": null,
        "author": "arontsang",
        "content": "@pinkfloydx33 You could have raised this issue back then... ",
        "createdAt": "2023-01-17T06:21:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46120#issuecomment-1384888881"
      },
      {
        "id": "IC_kwDOAQzde85Sndi-",
        "parentId": null,
        "author": "HaoK",
        "content": "The breaking change aspect is probably the biggest deal, but since we don\u0027t do any claims transformation by default, this is just providing new behavior when multiple IClaimsTransformations have been registered.  That said, given that historically claims transformation is not a side effect free operation, and in the past we\u0027ve had a lot of historical issues merging ClaimsPrincipals with multiple auth schemes, and this scenario already has a straight forward workaround, how about we keep this issue open in the backlog and see how much desire there is for this behavior before making any decisions?",
        "createdAt": "2023-01-17T21:30:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46120#issuecomment-1386076350"
      },
      {
        "id": "IC_kwDOAQzde85SoGjj",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-01-17T23:40:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46120#issuecomment-1386244323"
      },
      {
        "id": "IC_kwDOAQzde851_1SE",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "Hi. Thanks for contacting us.\r\nWe\u0027re closing this issue as there was not much community interest in this ask for quite a while now.\r\nYou can learn more about our triage process and how we handle issues by reading our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md) writeup.",
        "createdAt": "2024-03-05T21:29:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46120#issuecomment-1979667588"
      },
      {
        "id": "IC_kwDOAQzde858QX9T",
        "parentId": null,
        "author": "sliekens",
        "content": "@mkArtakMSFT  I vote to reopen. After working extensively with [IAuthorizationHandler](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authorization.iauthorizationhandler?view=aspnetcore-8.0), where multiple registrations are the intended design, I was really confused why only one of my \u0060IClaimsTransformation\u0060 was activated. (In my mind, they are closely related because one is used by \u0060IAuthorizationService\u0060, the other by \u0060IAuthenticationService\u0060, so they should have similar behavior.) I also agree with the OP that the reducer-like signature (mis)leads you to believe that multiple registrations are supported.\r\n\r\nIt\u0027s not clear to me how I can add \u0060ReducerClaimsTransformation\u0060 as shown in the first post to my service collection, without creating a circular dependency.\r\n\r\nCurrently, the last registered transformer is used, which could also lead to programming errors, since you might not even realize that adding a new transformer will also render any previous transformer ineffective.\r\n\r\nWhat you see:\r\n\r\n\u0060\u0060\u0060 diff\r\nbuilder.Services.AddTransient\u003CIClaimsTransformation, AuthScheme1Transformer\u003E();\r\n\u002Bbuilder.Services.AddTransient\u003CIClaimsTransformation, AuthScheme2Transformer\u003E();\r\n\u0060\u0060\u0060\r\n\r\nWhat you get:\r\n\r\n\u0060\u0060\u0060 diff\r\n-builder.Services.AddTransient\u003CIClaimsTransformation, AuthScheme1Transformer\u003E();\r\n\u002Bbuilder.Services.AddTransient\u003CIClaimsTransformation, AuthScheme2Transformer\u003E();\r\n\u0060\u0060\u0060\r\n\r\nThat is to say, I support making this breaking change, because supporting multiple registrations will eliminate an entire category of programming mistakes in a security-sensitive context.\r\n\r\nLastly, I would not let this depend on community interest. This is one of those problems that don\u0027t bite often, but do bite hard.",
        "createdAt": "2024-04-30T08:10:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46120#issuecomment-2084667219"
      },
      {
        "id": "IC_kwDOAQzde86A9BlQ",
        "parentId": null,
        "author": "SHAGGAR",
        "content": "Not sure why this was closed without a fix or alternative.  The current design is real bad.",
        "createdAt": "2024-06-12T16:40:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46120#issuecomment-2163480912"
      },
      {
        "id": "IC_kwDOAQzde86QL42I",
        "parentId": null,
        "author": "voroninp",
        "content": "\u002B1 for the feature.",
        "createdAt": "2024-10-17T09:32:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46120#issuecomment-2419035528"
      },
      {
        "id": "IC_kwDOAQzde86QMRs_",
        "parentId": null,
        "author": "voroninp",
        "content": "I\u0027ve recently filed an issue to EF Core:\nIf same migrations history table is reused between different db contexts (default behavior) then \u0060List Applied Migrations\u0060 shows all migrations and not only those relevant for particular db context.\nFunny enough, you will face it immediately if you develop a modular monolith.\n\nSame with the current issue.\nI started with the docs looking for the mechanism to extend authenticated \u0060ClaimsPrincipal\u0060 with the custom claims. \n\u2014 Oh, nice, they have \u0060IClaimsTransformation\u0060. Wait, but what if my modules need their custom transofrmation. Let\u0027s see the source of \u0060AuthenticationService\u0060. Hm... only one instance of \u0060\u0060IClaimsTransformation\u0060. Not good. Let\u0027s look for an Issue on github.\n\nAnd here I am...\n\nIt took me 5 minutes to discover a missing feature. Ok, I\u0027ll probably use Scrutor.\n\nBut do you know what this means?\n\u003E there was not much community interest in this ask for quite a while now\n\nThis effectively means that all those advertisers of best practices, modular monoliths and similar stuff are effectively...bullshitters because they never tried to do it from start to end. Otherwise, there would be an interest in this feature. \n\nP.S. ofc, isolation of transformer in one module from the one in another module is what really needed here, but anyway. \n",
        "createdAt": "2024-10-17T10:20:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46120#issuecomment-2419137343"
      },
      {
        "id": "IC_kwDOAQzde86QMu1b",
        "parentId": null,
        "author": "sliekens",
        "content": "RE:\n\n\u003E The breaking change aspect is probably the biggest deal\n\nAt this point I would probably introduce a new interface and mark the old one Obsolete. That should take care of backwards compatibility.\n\n\u0060\u0060\u0060diff\n\u002B[Obsolete(\u0022IClaimsTransformation does not support multiple registrations\u0022)]\ninterface IClaimsTransformation\n{\n    Task\u003CClaimsPrincipal\u003E TransformAsync (ClaimsPrincipal principal);\n}\n\n\u002Binterface IClaimsReducer\n\u002B{\n\u002B    Task\u003CClaimsPrincipal\u003E TransformAsync (ClaimsPrincipal principal);\n\u002B}\n\u0060\u0060\u0060\n\nI don\u0027t like that this was closed for lack of community interest. Most applications don\u0027t need claims transformation, of course this won\u0027t get thousands of views. It\u0027s also not an obvious problem, there is no error when you register multiple implementations. I suspect many applications have multiple implementations of the interface because the developer doesn\u0027t even realize that it doesn\u0027t actually work. Someone please reopen this and re-triage.",
        "createdAt": "2024-10-17T11:22:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46120#issuecomment-2419256667"
      },
      {
        "id": "IC_kwDOAQzde86bnsdb",
        "parentId": null,
        "author": "voroninp",
        "content": "You are [mean](https://github.com/dotnet/aspnetcore/blob/febd7e8bdf05f17fb4e0e4dd3123e9538fbf7e7b/src/Http/Authentication.Core/src/AuthenticationCoreServiceCollectionExtensions.cs#L24C9-L24C140), gentlemen =)\n\nTried to decorate it with Scrutor, but did not expect it\u0027s registered as a singleton.",
        "createdAt": "2025-01-23T19:45:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46120#issuecomment-2610874203"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85bmYow",
    "title": "Anti Forgery Claim Extractor: option to define claim name",
    "url": "https://github.com/dotnet/aspnetcore/issues/46137",
    "createdAt": "2023-01-17T17:44:33Z",
    "lastUpdated": "2024-02-13T01:45:08Z",
    "body": "## Background and Motivation\r\nIn a project that uses anti forgery features and 3rd party authentication provider, I found you can get anti forgery token validation failures in certain scenarios (auth provider does not use sub, nameidentifier or upn claims, whilst the iat claim value has changed). \r\n\r\nIf we could configure the name(s) of claims we want to use in the [DefaultClaimUidExtractor ](https://github.com/dotnet/aspnetcore/blob/main/src/Antiforgery/src/Internal/DefaultClaimUidExtractor.cs) class, we could fix the issue without having to change the configuration of the auth provider.\r\n\r\n## Proposed API\r\n\r\n\u0060\u0060\u0060diff\r\n\r\nservices.AddAntiForgery(options =\u003E \r\n    options.UidClaimNames = new string[] { \u0022myUniqueUserClaim\u0022 }\r\n);\r\n\r\n\u0060\u0060\u0060\r\n\r\n## Alternative Designs\r\nTell the framework that there is an iat claim, then update [DefaultClaimUidExtractor](https://github.com/dotnet/aspnetcore/blob/ad2f29fcd2540e7c9e73709dcea91280d6f40273/src/Antiforgery/src/Internal/DefaultClaimUidExtractor.cs#L111) to not include the claim in the extraction.\r\n\u0060\u0060\u0060diff\r\n\r\nservices.AddAntiForgery(options =\u003E \r\n    options.IatClaims = new string[] { \u0022iat\u0022 }\r\n);\r\n\r\n\u0060\u0060\u0060\r\n\r\n## Risks\r\nDevelopers could configure a claim that is not unique to the user.\r\n\r\n\r\n",
    "upvotes": 1,
    "labels": [
      "area-auth",
      "api-suggestion"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85Tnc1R",
        "parentId": null,
        "author": "rafikiassumani-msft",
        "content": "@lukecolbourn Can you give us the name of the providers that change the default claim behaviors for antiforgery token validation? Do you mind providing a GitHub repository with a repro for this issue?",
        "createdAt": "2023-01-25T00:03:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46137#issuecomment-1402850641"
      },
      {
        "id": "IC_kwDOAQzde85Tnc5u",
        "parentId": null,
        "author": "??",
        "content": "Hi @lukecolbourn. We have added the \u0022Needs: Author Feedback\u0022 label to this issue, which indicates that we have an open question for you before we can take further action. This issue will be closed automatically in 7 days if we do not hear back from you by then - please feel free to re-open it if you come back to this issue after that time.",
        "createdAt": "2023-01-25T00:03:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46137#issuecomment-1402850926"
      },
      {
        "id": "IC_kwDOAQzde85Tnejm",
        "parentId": null,
        "author": "halter73",
        "content": "Have you considered middleware that runs post-authentication and rewrites the ClaimsPrincipal to include a sub, nameidentifier or upn claim to match the myUniqueUserClaim?",
        "createdAt": "2023-01-25T00:09:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46137#issuecomment-1402857702"
      },
      {
        "id": "IC_kwDOAQzde85ToIyR",
        "parentId": null,
        "author": "lukecolbourn",
        "content": "\u003E @lukecolbourn Can you give us the name of the providers that change the default claim behaviors for antiforgery token validation? Do you mind providing a GitHub repository with a repro for this issue?\r\n\r\nto confirm, the provider doesn\u0027t change the behaviour of the token validation (I don\u0027t believe this is possible). The issue is caused by the claims the auth provider adds (and does not add) to the user.\r\n\r\nHere\u0027s a reproduction, with toggle: https://github.com/lukecolbourn/antiforgery-iat-claim-example/blob/010f5a23c6c8651b1c163c1f8aa252dde9f1351a/Program.cs#L59\r\n\r\nSubmit the form to see token validation failure when iat claim has changed, and there is no sub claim.\r\n\r\nThanks \uD83D\uDC4D",
        "createdAt": "2023-01-25T03:00:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46137#issuecomment-1403030673"
      },
      {
        "id": "IC_kwDOAQzde85ToKy1",
        "parentId": null,
        "author": "lukecolbourn",
        "content": "\u003E Have you considered middleware that runs post-authentication and rewrites the ClaimsPrincipal to include a sub, nameidentifier or upn claim to match the myUniqueUserClaim?\r\n\r\nNice, that would sort it. I would definitely forget why that middleware exists and delete it in a couple of years though \uD83D\uDE1C\r\nWe\u0027re getting the auth service admins to add/remove claims, saves us a few lines of code",
        "createdAt": "2023-01-25T03:10:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46137#issuecomment-1403038901"
      },
      {
        "id": "IC_kwDOAQzde85UHYQo",
        "parentId": null,
        "author": "captainsafia",
        "content": "Triage: This API would be a nice to have given more interest in it. Anyone interested in seeing this can give the issue a thumbs up to help us prioritize.",
        "createdAt": "2023-01-31T23:37:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46137#issuecomment-1411220520"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85ezzRb",
    "title": "(.NET 7.0) Infinite loop with Google authentication library",
    "url": "https://github.com/dotnet/aspnetcore/issues/46743",
    "createdAt": "2023-02-19T10:31:12Z",
    "lastUpdated": "2024-04-01T17:39:08Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nASP.NET Core has an issue with the Google authentication library on startup, where it seems to run into an endless loop which results in the following stack repeating itself until eventually exiting with error coded \u0060-1073741819\u0060:\r\n\u0060\u0060\u0060\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Microsoft.AspNetCore.Authentication.AuthenticationService\u002B\u003CAuthenticateAsync\u003Ed__14, Microsoft.AspNetCore.Authentication.Core, Version=7.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60]](\u003CAuthenticateAsync\u003Ed__14 ByRef)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601[[System.__Canon, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].Start[[Microsoft.AspNetCore.Authentication.AuthenticationService\u002B\u003CAuthenticateAsync\u003Ed__14, Microsoft.AspNetCore.Authentication.Core, Version=7.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60]](\u003CAuthenticateAsync\u003Ed__14 ByRef)\r\nat Microsoft.AspNetCore.Authentication.AuthenticationService.AuthenticateAsync(Microsoft.AspNetCore.Http.HttpContext, System.String)\r\nat Microsoft.AspNetCore.Authentication.RemoteAuthenticationHandler\u00601\u002B\u003CHandleAuthenticateAsync\u003Ed__13[[System.__Canon, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Microsoft.AspNetCore.Authentication.RemoteAuthenticationHandler\u00601\u002B\u003CHandleAuthenticateAsync\u003Ed__13[[System.__Canon, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], Microsoft.AspNetCore.Authentication, Version=7.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60]](\u003CHandleAuthenticateAsync\u003Ed__13\u003CSystem.__Canon\u003E ByRef)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601[[System.__Canon, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].Start[[Microsoft.AspNetCore.Authentication.RemoteAuthenticationHandler\u00601\u002B\u003CHandleAuthenticateAsync\u003Ed__13[[System.__Canon, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], Microsoft.AspNetCore.Authentication, Version=7.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60]](\u003CHandleAuthenticateAsync\u003Ed__13\u003CSystem.__Canon\u003E ByRef)\r\nat Microsoft.AspNetCore.Authentication.RemoteAuthenticationHandler\u00601[[System.__Canon, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].HandleAuthenticateAsync()\r\nat Microsoft.AspNetCore.Authentication.AuthenticationHandler\u00601\u002B\u003CAuthenticateAsync\u003Ed__48[[System.__Canon, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Microsoft.AspNetCore.Authentication.AuthenticationHandler\u00601\u002B\u003CAuthenticateAsync\u003Ed__48[[System.__Canon, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], Microsoft.AspNetCore.Authentication, Version=7.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60]](\u003CAuthenticateAsync\u003Ed__48\u003CSystem.__Canon\u003E ByRef)\r\nat System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601[[System.__Canon, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].Start[[Microsoft.AspNetCore.Authentication.AuthenticationHandler\u00601\u002B\u003CAuthenticateAsync\u003Ed__48[[System.__Canon, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], Microsoft.AspNetCore.Authentication, Version=7.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60]](\u003CAuthenticateAsync\u003Ed__48\u003CSystem.__Canon\u003E ByRef)\r\nat Microsoft.AspNetCore.Authentication.AuthenticationHandler\u00601[[System.__Canon, System.Private.CoreLib, Version=7.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].AuthenticateAsync()\r\nat Microsoft.AspNetCore.Authentication.AuthenticationService\u002B\u003CAuthenticateAsync\u003Ed__14.MoveNext()\r\n\u0060\u0060\u0060\r\n\r\nThe issue is tied to the **projects** framework, not the libraries, as setting the libraries version to below 7.x but keeping the projects framework at 7 cause the issue still.\r\n\r\n### Expected Behavior\r\n\r\nA raised exception if an error has occurred, otherwise not crashing.\r\n\r\n### Steps To Reproduce\r\n\r\n- Create a new ASP.NET Core Web App project, with its framework set to .NET 7.0 (can create the project with a different version and change it to 7.0 later)\r\n- Install \u0060Microsoft.AspNetCore.Authentication.Google\u0060 NuGet package\r\n- Configure authentication to use the Google provider, with valid \u0060ClientId\u0060 and \u0060ClientSecret\u0060 (not necessarily connected to an actual client, the value just needs to be valid)\r\n- Run the project\r\n\r\n**Sample project repository: [\\[Link\\]](https://github.com/zimberzimber/asp.net-core-7.0-google-auth-bug/tree/main)**\r\n\r\n### Exceptions (if any)\r\n\r\nNone, it simply crashes with the error code \u0060-1073741819\u0060\r\n\r\n### .NET Version\r\n\r\n7.0.103\r\n\r\n### Anything else?\r\n\r\n# \u0060dotnet --info\u0060\r\n\u0060\u0060\u0060\r\n.NET SDK:\r\n\tVersion:   7.0.103\r\n\tCommit:    276c71d299\r\n\r\nRuntime Environment:\r\n\tOS Name:     Windows\r\n\tOS Version:  10.0.19043\r\n\tOS Platform: Windows\r\n\tRID:         win10-x64\r\n\tBase Path:   C:\\Program Files\\dotnet\\sdk\\7.0.103\\\r\n\r\nHost:\r\n\tVersion:      7.0.3\r\n\tArchitecture: x64\r\n\tCommit:       0a2bda10e8\r\n\r\n.NET SDKs installed:\r\n\t3.0.103 [C:\\Program Files\\dotnet\\sdk]\r\n\t3.1.422 [C:\\Program Files\\dotnet\\sdk]\r\n\t7.0.103 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET runtimes installed:\r\n\tMicrosoft.AspNetCore.App 3.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n\tMicrosoft.AspNetCore.App 3.1.28 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n\tMicrosoft.AspNetCore.App 6.0.14 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n\tMicrosoft.AspNetCore.App 7.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n\tMicrosoft.NETCore.App 3.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n\tMicrosoft.NETCore.App 3.1.28 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n\tMicrosoft.NETCore.App 6.0.14 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n\tMicrosoft.NETCore.App 7.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n\tMicrosoft.WindowsDesktop.App 3.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\tMicrosoft.WindowsDesktop.App 3.1.28 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\tMicrosoft.WindowsDesktop.App 6.0.14 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\tMicrosoft.WindowsDesktop.App 7.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\nOther architectures found:\r\n\tx86   [C:\\Program Files (x86)\\dotnet]\r\n\t\tregistered at [HKLM\\SOFTWARE\\dotnet\\Setup\\InstalledVersions\\x86\\InstallLocation]\r\n\r\nEnvironment variables:\r\n\tNot set\r\n\r\nglobal.json file:\r\n\tNot found\r\n\u0060\u0060\u0060",
    "upvotes": 1,
    "labels": [
      "bug",
      "investigate",
      "Docs",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85Vl_BB",
        "parentId": null,
        "author": "davidfowl",
        "content": "Normally, you would use social authentication with cookies. What\u0027s your intention only having a single authentication scheme?",
        "createdAt": "2023-02-19T15:41:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46743#issuecomment-1436020801"
      },
      {
        "id": "IC_kwDOAQzde85VoNMY",
        "parentId": null,
        "author": "zimberzimber",
        "content": "\u003E Normally, you would use social authentication with cookies. What\u0027s your intention only having a single authentication scheme?\r\n\r\nI was learning the interaction with Googles authentication alongside a group of people, many of who ran into this issue.",
        "createdAt": "2023-02-20T09:16:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46743#issuecomment-1436603160"
      },
      {
        "id": "IC_kwDOAQzde85Vw1ur",
        "parentId": null,
        "author": "Tratcher",
        "content": "Add the following code snippets for cookie auth:\r\nhttps://learn.microsoft.com/en-us/aspnet/core/security/authentication/cookie?view=aspnetcore-7.0\r\n\r\nOur Google auth docs don\u0027t clearly state these are required when you\u0027re not using the Identity framework.\r\nhttps://learn.microsoft.com/en-us/aspnet/core/security/authentication/social/google-logins?view=aspnetcore-7.0",
        "createdAt": "2023-02-21T17:39:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46743#issuecomment-1438866347"
      },
      {
        "id": "IC_kwDOAQzde85V2zWA",
        "parentId": null,
        "author": "zimberzimber",
        "content": "Thank you, it has solved the crashing.\r\n\r\nHowever, the primary issue here is that the program simply crashes instead of raising an exception to point the developer in the right direction.",
        "createdAt": "2023-02-22T17:01:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46743#issuecomment-1440429440"
      },
      {
        "id": "IC_kwDOAQzde85V3jGZ",
        "parentId": null,
        "author": "Tratcher",
        "content": "Hmm, -1073741819 is 0xC0000005, or Access Violation. It shouldn\u0027t do that... we\u0027ll investigate.",
        "createdAt": "2023-02-22T18:55:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46743#issuecomment-1440625049"
      },
      {
        "id": "IC_kwDOAQzde85V-D2j",
        "parentId": null,
        "author": "??",
        "content": "To learn more about what this message means, what to expect next, and how this issue will be handled you can read our [Triage Process document](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).\nWe\u0027re moving this issue to the .NET 8 Planning milestone for future evaluation / consideration. Because it\u0027s not immediately obvious what is causing this behavior, we would like to keep this around to collect more feedback, which can later help us determine how to handle this. We will re-evaluate this issue, during our next planning meeting(s).\nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact work.",
        "createdAt": "2023-02-23T19:43:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46743#issuecomment-1442332067"
      },
      {
        "id": "IC_kwDOAQzde85te23V",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "\u003E Add the following code snippets for cookie auth: https://learn.microsoft.com/en-us/aspnet/core/security/authentication/cookie?view=aspnetcore-7.0\r\n\u003E \r\n\u003E Our Google auth docs don\u0027t clearly state these are required when you\u0027re not using the Identity framework. https://learn.microsoft.com/en-us/aspnet/core/security/authentication/social/google-logins?view=aspnetcore-7.0\r\n\r\n@Rick-Anderson can you guys please address this gap? Thanks!",
        "createdAt": "2023-12-01T21:31:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46743#issuecomment-1836805589"
      },
      {
        "id": "IC_kwDOAQzde85te3Fi",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "As for the crashing aspect, given that we didn\u0027t get more reports of this I\u0027m going to backlog this for now to accumulate more feedback.",
        "createdAt": "2023-12-01T21:32:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46743#issuecomment-1836806498"
      },
      {
        "id": "IC_kwDOAQzde85te3Jg",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-12-01T21:32:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46743#issuecomment-1836806752"
      },
      {
        "id": "IC_kwDOAQzde855Asbj",
        "parentId": null,
        "author": "ignj",
        "content": "I\u0027m having the same problem with Facebook\u0027s authentication library in .NET v9.0.100-preview.2.24157.14",
        "createdAt": "2024-04-01T17:39:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46743#issuecomment-2030225123"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85fcE2o",
    "title": "Kestrel windows authentication prompts for the credentials",
    "url": "https://github.com/dotnet/aspnetcore/issues/46905",
    "createdAt": "2023-02-27T13:30:24Z",
    "lastUpdated": "2024-02-13T01:41:26Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nRepro: \r\nServer is Windows 10 Enterprise 22H2 with .NET 6 (6.0.14)\r\n\r\nCreate simple WebApp with the Windows Authentication hosted on the Kestrel.\r\nSetup same as in the https://github.com/dotnet/aspnetcore/issues/37556.\r\nSetspn set, Kestrel Running on my domain user account on a server.\r\n\r\nI VPN to the remote server.\r\n\r\n**Remote server:**\r\nBrowser: Edge version 110.0.1587.57 64bit.\r\nInternet options set to trust http://computername and http://computername.mydomain.com and \u0022Automatic logon only in Intranet zone\u0022\r\nWhen browser is reopened: \r\n- For addresses: 127.0.0.1 and 192.168.XX.YY then I need to provide the credentials\r\n- By computer domain name or FQDN: http://computername and http://computername.mydomain.com **I do not** need to provide the credentials.\r\nIn the application welcome screen I see for all cases \u0022NTLM\u0022 for {@Model.User.Identity?.AuthenticationType}\r\n\r\n**Local machine (or similarly co-worker\u0027s machine):**\r\nBrowser: Edge version: 110.0.1587.56 64bit\r\nInternet options set as in the server.\r\nDomain account credentials added to the Windows Credentials Manager.\r\nFor all addresses:\r\n- 192.168.XX.YY\r\n- http://computername\r\n- http://computername.mydomain.com\r\nI am forced to provide the credentials each time I reopen the browser. \r\nWelcome page shows \u0022NTLM\u0022 in all the mentioned cases.\n\n### Expected Behavior\n\nCredentials prompt does not appear for trusted intranet sites.\n\n### Steps To Reproduce\n\n* Create the app from the template\r\n* Execute setspn on domain account\r\n* set internet options\r\n* add credentials to the windows credentials mnanager\r\n* run the app in Kestrel\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n6.0.14\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-auth",
      "needs-further-triage"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85WX3cY",
        "parentId": null,
        "author": "blowdart",
        "content": "I\u0027m not entirely sure Edge obeys internet zones, that was an IE feature. \r\n\r\nCan you reproduce this if the app is under IIS? That would help discover if it\u0027s a kestrel problem, or an Edge problem?",
        "createdAt": "2023-02-28T23:47:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46905#issuecomment-1449096984"
      },
      {
        "id": "IC_kwDOAQzde85WX3fP",
        "parentId": null,
        "author": "??",
        "content": "Hi @kliszaq. We have added the \u0022Needs: Author Feedback\u0022 label to this issue, which indicates that we have an open question for you before we can take further action. This issue will be closed automatically in 7 days if we do not hear back from you by then - please feel free to re-open it if you come back to this issue after that time.",
        "createdAt": "2023-02-28T23:47:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46905#issuecomment-1449097167"
      },
      {
        "id": "IC_kwDOAQzde85WvWRv",
        "parentId": null,
        "author": "??",
        "content": "This issue has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **4 days**. It will be closed if no further activity occurs **within 3 days of this comment**. If it *is* closed, feel free to comment when you are able to provide the additional information and we will re-investigate.\n\nSee [our Issue Management Policies](https://aka.ms/aspnet/issue-policies) for more information.",
        "createdAt": "2023-03-06T00:00:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46905#issuecomment-1455252591"
      },
      {
        "id": "IC_kwDOAQzde85Wwuv3",
        "parentId": null,
        "author": "kliszaq",
        "content": "@blowdart \r\nI set up the app on the IIS on remote. When Edge is reopened and accessed from both remote and local machine, for the\r\n* http://computername/\r\n* http://computername.mydomain.com/\r\nautomatically logs me in with the authentication type \u0022Negotiate\u0022.\r\nWhen accessing by 192.168.XX.YY then I need to provide the credentials each time.\r\n\r\nIt looks like it is something wrong on the Kestrel side than on the Edge as IIS behaves correct.",
        "createdAt": "2023-03-06T07:40:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46905#issuecomment-1455614967"
      },
      {
        "id": "IC_kwDOAQzde85Wzu-w",
        "parentId": null,
        "author": "blowdart",
        "content": "By IP address it always makes sense for the prompt, as local intranet is decided based on host name. \r\n\r\nI notice that you said that on the coworkers machine \u0022Domain account credentials added to the Windows Credentials Manager.\u0022\r\n\r\nSo the coworker isn\u0027t logged on to the domain at all? Whereas you are?",
        "createdAt": "2023-03-06T15:58:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46905#issuecomment-1456402352"
      },
      {
        "id": "IC_kwDOAQzde85WzvJP",
        "parentId": null,
        "author": "??",
        "content": "Hi @kliszaq. We have added the \u0022Needs: Author Feedback\u0022 label to this issue, which indicates that we have an open question for you before we can take further action. This issue will be closed automatically in 7 days if we do not hear back from you by then - please feel free to re-open it if you come back to this issue after that time.",
        "createdAt": "2023-03-06T15:58:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46905#issuecomment-1456403023"
      },
      {
        "id": "IC_kwDOAQzde85W5wUL",
        "parentId": null,
        "author": "kliszaq",
        "content": "\u003E By IP address it always makes sense for the prompt, as local intranet is decided based on host name.\r\n\u003E \r\nNo doubt.\r\n\r\n\u003E I notice that you said that on the coworkers machine \u0022Domain account credentials added to the Windows Credentials Manager.\u0022\r\n\u003E \r\n\u003E So the coworker isn\u0027t logged on to the domain at all? Whereas you are?\r\n\r\nWe both VPN to te remote server/desktop and work there. Co-worker is logged the same way as I do. The test case was that he is using his account as the Kestrel is running on my domain account (user mode for Kestrel). Coworker was logged to the domain. ",
        "createdAt": "2023-03-07T11:09:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46905#issuecomment-1457980683"
      },
      {
        "id": "IC_kwDOAQzde85XDPUg",
        "parentId": null,
        "author": "blowdart",
        "content": "Hmm if the co-worker is logged into the domain. and using the fqdn, I would expect it to work, falling back to NTLM wouldn\u0027t be expected either (except when addressing via IP which will always fall back to NTLM, which is why you shouldn\u0027t do it)\r\n\r\nOK, @captainsafia which dev would this fall to?\r\n\r\n",
        "createdAt": "2023-03-08T16:34:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46905#issuecomment-1460466976"
      },
      {
        "id": "IC_kwDOAQzde85XGW_Z",
        "parentId": null,
        "author": "captainsafia",
        "content": "\u003E OK, @captainsafia which dev would this fall to?\r\n\r\nPerhaps @halter73 for Kestrel \u002B auth insights.\r\n\r\nRumor has it that @Tratcher also has some knowledge in the space.",
        "createdAt": "2023-03-09T05:05:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46905#issuecomment-1461284825"
      },
      {
        "id": "IC_kwDOAQzde85YBVGp",
        "parentId": null,
        "author": "Tratcher",
        "content": "Can you clarify if IIS was set up using user mode or kernel mode auth?\r\n\r\nIn all of these cases was the SPN added to the machine account or to your user account? It would need to be on your user account since you\u0027re the one running Kestrel in user mode. For IIS, if you use kernel mode then the SPN goes on the machine account, otherwise it goes on the worker pool account.",
        "createdAt": "2023-03-20T18:34:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46905#issuecomment-1476743593"
      },
      {
        "id": "IC_kwDOAQzde85YD33F",
        "parentId": null,
        "author": "kliszaq",
        "content": "Hi @Tratcher,\r\nas I stated in the original repro, \u0060setspn\u0060 was set following instructions from this [article section](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/windowsauth?view=aspnetcore-7.0\u0026tabs=visual-studio#windows-environment-configuration). In one word: the SPN was added to my user account.\r\n\r\n\u003EFor IIS, if you use kernel mode then the SPN goes on the machine account, otherwise it goes on the worker pool account.\r\n\r\nIt looks like the prompt works fine with the IIS. Why do you focus on the IIS as the IMHO the problem is with the Kestrel? \r\n@blowdart asked for IIS repro to state if it is a general problem or Kestrel specific. I am not interested in the IIS but Kestrel only. Let\u0027s focus on it please.\r\n\r\n",
        "createdAt": "2023-03-21T08:01:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46905#issuecomment-1477410245"
      },
      {
        "id": "IC_kwDOAQzde85Z3A8u",
        "parentId": null,
        "author": "Tratcher",
        "content": "Triage: I won\u0027t be able to look into this further, un-assigning.",
        "createdAt": "2023-04-13T20:50:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46905#issuecomment-1507594030"
      },
      {
        "id": "IC_kwDOAQzde85a0gET",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-04-26T16:27:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46905#issuecomment-1523712275"
      },
      {
        "id": "IC_kwDOAQzde85te2MM",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-12-01T21:29:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46905#issuecomment-1836802828"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85gEs01",
    "title": "Updating to .NET 8 Preview 1 breaks AuthorizationEndpoint query on AddGoogle",
    "url": "https://github.com/dotnet/aspnetcore/issues/47054",
    "createdAt": "2023-03-06T16:57:57Z",
    "lastUpdated": "2024-10-31T21:42:14Z",
    "body": "The following web application correctly shows a Google sign in page when it is built with \u0060net7.0\u0060 and version \u00607.0.3\u0060 of \u0060Microsoft.AspNetCore.Authentication.Google\u0060. Note that a \u0060prompt\u0060 query parameter is added to the authorization endpoint to force an account selection dialog to appear, rather than automatically signing in with the current Google account.\r\n\r\nIn \u0060net8.0\u0060 (Preview 1), the same app shows an error page on accounts.google.com:\r\n\r\n\u003E **Access blocked: authorisation error**\r\n\u003E OAuth 2 parameters can only have a single value: prompt\r\n\u003E Error 400: invalid_request\r\n\r\nThis is a breaking change, but I couldn\u0027t find it on the [Breaking Changes in .NET 8](https://learn.microsoft.com/en-us/dotnet/core/compatibility/8.0) page. It might be enough of an edge case that it doesn\u0027t matter, but I thought I\u0027d raise an issue just in case.\r\n\r\n**WebApplication1.csproj**\r\n\u0060\u0060\u0060xml\r\n\u003CProject Sdk=\u0022Microsoft.NET.Sdk.Web\u0022\u003E\r\n  \u003CPropertyGroup\u003E\r\n    \u003CTargetFramework\u003Enet8.0\u003C/TargetFramework\u003E\r\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\r\n  \u003C/PropertyGroup\u003E\r\n  \u003CItemGroup\u003E\r\n    \u003CPackageReference Include=\u0022Microsoft.AspNetCore.Authentication.Google\u0022 Version=\u00228.0.0-preview.1.23112.2\u0022 /\u003E\r\n  \u003C/ItemGroup\u003E\r\n\u003C/Project\u003E\r\n\u0060\u0060\u0060\r\n\r\n**Program.cs**\r\n\u0060\u0060\u0060c#\r\nusing Microsoft.AspNetCore.Authentication.Cookies;\r\nusing Microsoft.AspNetCore.Authentication.Google;\r\n\r\nvar builder = WebApplication.CreateBuilder(args);\r\nbuilder.Services\r\n  .AddAuthentication(o =\u003E {\r\n    o.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;\r\n    o.DefaultChallengeScheme = GoogleDefaults.AuthenticationScheme;\r\n  })\r\n  .AddCookie()\r\n  .AddGoogle(o =\u003E\r\n  {\r\n    o.ClientId = builder.Configuration[\u0022Google:ClientId\u0022];\r\n    o.ClientSecret = builder.Configuration[\u0022Google:ClientSecret\u0022];\r\n    o.AuthorizationEndpoint \u002B= \u0022?prompt=select_account\u0022; // \u003C-- Broken in .NET 8\r\n  });\r\nvar app = builder.Build();\r\napp.UseAuthentication();\r\napp.MapGet(\u0022/\u0022, () =\u003E Results.Challenge());\r\napp.Run();\r\n\u0060\u0060\u0060\r\n\r\n**dotnet --version**\r\n\u003E 8.0.100-preview.1.23115.2\r\n\r\n**Summary Comment** : https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-1786192809",
    "upvotes": 1,
    "labels": [
      "bug",
      "help wanted",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85XjaUn",
        "parentId": null,
        "author": "Tratcher",
        "content": "What did the resulting url look like? It sounds like the options callback is being invoked twice for the same instance which would be bad. There was a bug in lazy options caching like that recently.",
        "createdAt": "2023-03-14T22:02:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-1468900647"
      },
      {
        "id": "IC_kwDOAQzde85XjpPT",
        "parentId": null,
        "author": "jamesgurung",
        "content": "@Tratcher The URL is:\r\n\r\n\u003E https://accounts.google.com/o/oauth2/v2/auth?prompt=select_account\u0026prompt=select_account\u0026client_id=REDACTED.apps.googleusercontent.com\u0026scope=openid%20profile%20email\u0026response_type=code\u0026redirect_uri=https%3A%2F%2Flocalhost%3A5001%2Fsignin-google\u0026code_challenge=REDACTED\u0026code_challenge_method=S256\u0026state=REDACTED",
        "createdAt": "2023-03-14T22:38:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-1468961747"
      },
      {
        "id": "IC_kwDOAQzde85Y2S_y",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "@Tratcher do you think this is a bug we\u0027ve introduced that we need to address?",
        "createdAt": "2023-03-30T16:57:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-1490628594"
      },
      {
        "id": "IC_kwDOAQzde85ZHKsr",
        "parentId": null,
        "author": "Tratcher",
        "content": "@mkArtakMSFT yes, this needs to be investigated.",
        "createdAt": "2023-04-03T22:08:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-1495051051"
      },
      {
        "id": "IC_kwDOAQzde85oyapz",
        "parentId": null,
        "author": "??",
        "content": "To learn more about what this message means, what to expect next, and how this issue will be handled you can read our [Triage Process document](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).\nWe\u0027re moving this issue to the .NET 9 Planning milestone for future evaluation / consideration. Because it\u0027s not immediately obvious what is causing this behavior, we would like to keep this around to collect more feedback, which can later help us determine how to handle this. We will re-evaluate this issue, during our next planning meeting(s).\nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact work.",
        "createdAt": "2023-10-11T16:16:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-1758046835"
      },
      {
        "id": "IC_kwDOAQzde85p5ouo",
        "parentId": null,
        "author": "PowerSaka",
        "content": "The last line of BuildChallengeUrl() function causes duplicate parameters:\r\n?prompt=select_account\u0026prompt=select_account",
        "createdAt": "2023-10-24T08:01:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-1776716712"
      },
      {
        "id": "IC_kwDOAQzde85qdyOp",
        "parentId": null,
        "author": "Tratcher",
        "content": "Found the regression: https://github.com/dotnet/aspnetcore/commit/afb6ec434fe319676d290b778e85468261c2bc7f#diff-dbfbf20eedf9c001d9d7848400c42e852216354b81f651f5bc82dbf42632475cR63 (thanks @PowerSaka)\r\n\r\nTo enable PKCE in 8.0 the Google auth handler was changed to call \u0060base.BuildChallengeUrl\u0060,\r\n\u0060var queryStrings = QueryHelpers.ParseQuery(new Uri(base.BuildChallengeUrl(properties, redirectUri)).Query);\u0060\r\n\r\nwhich calls \r\nhttps://github.com/dotnet/aspnetcore/blob/c15938bb5f23fd3ad2374bde554a6b492a36ecde/src/Security/Authentication/OAuth/src/OAuthHandler.cs#L331\r\n\r\nThis results in a query param list that contains the original parameters from AuthorizationEndpoint. Once google adds it\u0027s extra properties to the list it calls this again:\r\nhttps://github.com/dotnet/aspnetcore/blob/c15938bb5f23fd3ad2374bde554a6b492a36ecde/src/Security/Authentication/Google/src/GoogleHandler.cs#L84\r\n\r\npulling the original parameters from the AuthorizationEndpoint again, causing duplication.\r\n\r\nWorkaround:\r\n- Add the parameter in the RedirectToAuthorizationEndpoint event.\r\n\u0060\u0060\u0060diff  \r\n  .AddGoogle(o =\u003E\r\n  {\r\n    o.ClientId = builder.Configuration[\u0022Google:ClientId\u0022];\r\n    o.ClientSecret = builder.Configuration[\u0022Google:ClientSecret\u0022];\r\n-    o.AuthorizationEndpoint \u002B= \u0022?prompt=select_account\u0022; // \u003C-- Broken in .NET 8\r\n\u002B    o.Events = new OAuthEvents()\r\n\u002B    {\r\n\u002B        OnRedirectToAuthorizationEndpoint = c =\u003E\r\n\u002B        {\r\n\u002B          c.RedirectUri \u002B= \u0022\u0026prompt=consent\u0022;\r\n\u002B          c.Response.Redirect(c.RedirectUri);\r\n\u002B          return Task.CompletedTask;\r\n\u002B        }\r\n\u002B    };\r\n  });\r\n\u0060\u0060\u0060\r\n\r\nPossible fix: Since we know that \u0060base.BuildChallengeUrl\u0060 already includes the original query params from AuthorizationEndpoint, drop them from the AuthorizationEndpoint before adding the final set of query params here. \r\nhttps://github.com/dotnet/aspnetcore/blob/c15938bb5f23fd3ad2374bde554a6b492a36ecde/src/Security/Authentication/Google/src/GoogleHandler.cs#L84\r\n\r\nNote this is more complex than what other handlers support because they only support append, not per-challenge replacement of base parameters like scope.\r\nhttps://github.com/dotnet/aspnetcore/blob/c15938bb5f23fd3ad2374bde554a6b492a36ecde/src/Security/Authentication/Google/src/GoogleHandler.cs#L74\r\n\r\nAlso, adding \u0060GoogleOptions.PromptParamter\u0060 like we have for other parameters would make direct manipulation of the AuthorizationEndpoint less necessary. Also consider ApprovalPrompt.",
        "createdAt": "2023-10-30T23:17:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-1786192809"
      },
      {
        "id": "IC_kwDOAQzde85qd2gt",
        "parentId": null,
        "author": "Tratcher",
        "content": "@kevinchalet @martincostello I see a similar issue here:\r\nhttps://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/blob/163a006c3b3ec38a82da4cb0949c209ae4e04fd3/src/AspNet.Security.OAuth.VisualStudio/VisualStudioAuthenticationHandler.cs#L90-L100",
        "createdAt": "2023-10-30T23:39:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-1786210349"
      },
      {
        "id": "IC_kwDOAQzde85qgM4t",
        "parentId": null,
        "author": "martincostello",
        "content": "Thanks - I\u0027ll take a look at this some time in the next week to resolve that for our v8 release.",
        "createdAt": "2023-10-31T09:26:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-1786826285"
      },
      {
        "id": "IC_kwDOAQzde85qq1AJ",
        "parentId": null,
        "author": "kevinchalet",
        "content": "\u003E @kevinchalet @martincostello I see a similar issue here:\r\n\u003E https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/blob/163a006c3b3ec38a82da4cb0949c209ae4e04fd3/src/AspNet.Security.OAuth.VisualStudio/VisualStudioAuthenticationHandler.cs#L90-L100\r\n\r\nThanks for letting us know. Did you see any other provider that may be affected?\r\n\r\nIf it\u0027s only VSO, then it\u0027s probably not a huge deal as it\u0027s almost a legacy thing: pretty much all APIs that use this provider can now be used with Azure AD directly (and Azure AD offers a much more OIDC-compliant implementation).",
        "createdAt": "2023-11-01T20:15:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-1789612041"
      },
      {
        "id": "IC_kwDOAQzde85qq1YI",
        "parentId": null,
        "author": "Tratcher",
        "content": "I didn\u0027t see any other providers with issues, they all append rather than try to replace parameters.",
        "createdAt": "2023-11-01T20:16:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-1789613576"
      },
      {
        "id": "IC_kwDOAQzde85rMHur",
        "parentId": null,
        "author": "martincostello",
        "content": "Looking at the [docs](https://learn.microsoft.com/azure/devops/integrate/get-started/authentication/azure-devops-oauth?#2-authorize-your-app), I\u0027m not sure if we really need to do anything in our VisualStudioOnline provider.\r\n\r\nIt seems that the only value recognised for \u0060response_type\u0060 is \u0060Assertion\u0060, so if you were overriding it in \u0060AuthorizationEndpoint\u0060 you would be either setting to to the same value we set for you already, so it would be redundant/duplicated, or you\u0027d be setting it to something that isn\u0027t supported.\r\n\r\nI can\u0027t see a use case for someone genuinely needing to set it themselves and getting the duplication issue, unless I\u0027m misunderstanding something about how the original issue applies in our case.\r\n",
        "createdAt": "2023-11-07T11:41:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-1798339499"
      },
      {
        "id": "IC_kwDOAQzde85rPUzU",
        "parentId": null,
        "author": "Tratcher",
        "content": "@martincostello if someone added _any_ query parameter to AuthorizationEndpoint it would get duplicated by the current code because of the pattern used to allow replacing an existing parameter. If nobody ever adds to AuthorizationEndpoint then you might never notice.",
        "createdAt": "2023-11-07T16:45:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-1799179476"
      },
      {
        "id": "IC_kwDOAQzde85rPoHY",
        "parentId": null,
        "author": "martincostello",
        "content": "Ah right, I see. Thanks - I\u0027ll take another look tomorrow.",
        "createdAt": "2023-11-07T17:08:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-1799258584"
      },
      {
        "id": "IC_kwDOAQzde855IrQ6",
        "parentId": null,
        "author": "knopa",
        "content": "Any update on this?",
        "createdAt": "2024-04-02T15:10:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-2032317498"
      },
      {
        "id": "IC_kwDOAQzde85-qEas",
        "parentId": null,
        "author": "MattyLeslie",
        "content": "Should this be closed after the merged fixes ?",
        "createdAt": "2024-05-22T14:32:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47054#issuecomment-2124957356"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85gFw74",
    "title": "PolicyEvaluator mutates AuthenticateResult, deletes AuthenticationProperties when policy uses AuthenticationSchemes",
    "url": "https://github.com/dotnet/aspnetcore/issues/47059",
    "createdAt": "2023-03-06T20:06:57Z",
    "lastUpdated": "2024-02-13T01:40:52Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nIf you set \u0060AuthenticationSchemes\u0060 on a policy, the \u0060PolicyEvaluator\u0060 will remove \u0060AuthenticationProperties\u0060 on the \u0060AuthenticateResult\u0060 and return only an \u0060ExpiresUtc\u0060 property.\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/v7.0.3/src/Security/Authorization/Policy/src/PolicyEvaluator.cs#L36-L57\r\n\r\nThis makes \u0060SaveToken\u0060 on \u0060AddJwtBearer\u0060 useless if you try to retrieve/forward the \u0060access_token\u0060 property for upstream requests.\r\n\r\nThis is with dotnet \u00606.0.405\u0060 but seems to still be present in .net7.\n\n### Expected Behavior\n\nI wouldn\u0027t expect authorization pipeline to mutate the \u0060AuthenticateResult\u0060. \r\n\r\nNot sure I understand the design of this well enough to know why the \u0060ClaimsPrincipal\u0060 is a merged result from \u0060SecurityHelper.MergeUserPrincipal\u0060. But it might make sense to attempt to merge the \u0060AuthenticationProperties\u0060 rather than remove them entirely.\n\n### Steps To Reproduce\n\nAdd a JwtHandler with \u0060SaveToken = true\u0060:\r\n\u0060\u0060\u0060\r\nservices.AddAuthentication()\r\n            .AddJwtBearer(JwtBearerDefaults.AuthenticationScheme, opts =\u003E\r\n            {\r\n                opts.SaveToken = true;\r\n            });\r\n\u0060\u0060\u0060\r\n\r\nCreate a policy with \u0060AuthenticationSchemes\u0060 set, even if there are not multiple schemes defined:\r\n\u0060\u0060\u0060\r\n            .AddAuthorization(options =\u003E\r\n            {\r\n                options.AddPolicy(\u0022some-policy\u0022, policy =\u003E\r\n                {\r\n                    policy.AuthenticationSchemes.Add(JwtBearerDefaults.AuthenticationScheme);\r\n                    policy.RequireAuthenticatedUser();\r\n                });\r\n            });\r\n\u0060\u0060\u0060\r\n\r\nTry to retrieve the saved tokens, in our case we\u0027re trying to use a delegating handler:\r\n\u0060\u0060\u0060\r\ninternal class AccessTokenHttpMessageHandler : DelegatingHandler\r\n{\r\n    private readonly IHttpContextAccessor _contextAccessor;\r\n\r\n    public AccessTokenHttpMessageHandler(IHttpContextAccessor contextAccessor)\r\n    {\r\n        _contextAccessor = contextAccessor;\r\n    }\r\n\r\n    protected override async Task\u003CHttpResponseMessage\u003E SendAsync(\r\n        HttpRequestMessage request,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        var feature = _contextAccessor.HttpContext.Features.Get\u003CIAuthenticateResultFeature\u003E();\r\n        var token = feature?.AuthenticateResult.Properties.GetTokenValue(\u0022access_token\u0022);\r\n        if (!string.IsNullOrEmpty(token))\r\n        {\r\n            request.Headers.Authorization =\r\n                new AuthenticationHeaderValue(JwtBearerDefaults.AuthenticationScheme, token);\r\n        }\r\n        return await base.SendAsync(request, cancellationToken);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThe \u0060access_token\u0060 will never be available on the \u0060IAuthenticateResultFeature\u0060 in the handler.\r\n\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n6.0.405\n\n### Anything else?\n\n_No response_",
    "upvotes": 4,
    "labels": [
      "enhancement",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85Y2SPF",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-03-30T16:54:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47059#issuecomment-1490625477"
      },
      {
        "id": "IC_kwDOAQzde85i9yjj",
        "parentId": null,
        "author": "Kahbazi",
        "content": "I hit this issue too. Is there any plan to fix this?",
        "createdAt": "2023-08-01T13:44:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47059#issuecomment-1660365027"
      },
      {
        "id": "IC_kwDOAQzde85i-Stv",
        "parentId": null,
        "author": "scharnyw",
        "content": "Seems to be a duplicate of #6518 (which dates back 4 years ago).\r\n\r\nBack then it was claimed that this is by-design. Not sure if MS has changed its mind.",
        "createdAt": "2023-08-01T14:56:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47059#issuecomment-1660496751"
      },
      {
        "id": "IC_kwDOAQzde85s0kQ7",
        "parentId": null,
        "author": "hwoodiwiss",
        "content": "I\u0027ve also recently run into this. I think merging, maybe with the scheme prepended to the property keys, makes sense.\r\n\r\nOtherwise, I think this behavior should at least be better documented in XML docs on, for example, \u0060JwtBearerOptions.SaveToken\u0060, as this can cause the token to be unexpectedly unavailable in properties.",
        "createdAt": "2023-11-24T14:02:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47059#issuecomment-1825719355"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85gVsB7",
    "title": "[Authorize(AuthenticationSchemes = TheOnlyAuthScheme)] also runs default scheme AuthenticationHandler",
    "url": "https://github.com/dotnet/aspnetcore/issues/47105",
    "createdAt": "2023-03-09T02:41:12Z",
    "lastUpdated": "2024-05-31T18:13:12Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nThe documentation https://learn.microsoft.com/en-us/aspnet/core/security/authorization/limitingidentitybyscheme?view=aspnetcore-7.0 says:\r\n\r\n\u003E The [[Authorize]](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authorization.authorizeattribute) attribute specifies the authentication scheme or schemes to use **regardless of whether a default is configured**.\r\n\r\n\u0060\u0060\u0060\r\n[Authorize(AuthenticationSchemes=JwtBearerDefaults.AuthenticationScheme)]\r\npublic class Mixed2Controller : Controller\r\n{\r\n    public ContentResult Index() =\u003E Content(MyWidgets.GetMyContent());\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\u003E In the preceding code, only the handler with the \u0022Bearer\u0022 scheme runs. Any cookie-based identities are ignored.\r\nNote: \u0060JwtBearerDefaults.AuthenticationScheme\u0060 is the \u0022Bearer\u0022 string constant here.\r\n\r\nThis is not true for me.\r\nWhen a default authentication scheme is registered, its authentication handler will be executed upon success of the \u0022only\u0022 authentication scheme which is requested by the annotation \u0060[Authorize(AuthenticationSchemes=JwtBearerDefaults.AuthenticationScheme)]\u0060 on the REST API controller or REST API controller method.\r\n\r\n\r\n\r\nRepro project:\r\nhttps://github.com/janseris/ASPNetCoreMultipleAuthentications\r\n\r\nHow to repro:\r\n1) run project\r\n2) in Swagger UI, click green Authorize button which enables you to enter HTTP Authorization header content to be passed in to the controller\r\n![image](https://user-images.githubusercontent.com/64279914/223900712-6ca0624c-043d-4057-b0d2-7bb38462d2ff.png)\r\n\r\n3) In the Session ID form, enter in value \u0060SessionID 123\u0060 which passes the validation in the SessionID \u0060AuthenticationHandler\u0060 and click green Authorize button to apply\r\n- this will add HTTP Authorization header value \u0060SessionID 123\u0060 to all the HTTP requests executed via the Swagger UI\r\n![image](https://user-images.githubusercontent.com/64279914/223900638-18fb48fc-e31f-412b-bb25-51bf11413340.png)\r\n\r\n4) execute a controller method via Swagger UI by clicking the method, then Try it Out and then blue Execute button\r\n![image](https://user-images.githubusercontent.com/64279914/223900967-787e43d0-983d-4c90-9380-8ddd7e3cc0d9.png)\r\n\r\n5) see debug output in Visual Studio - you will see that the Session ID authentication handler executed and finished and then HTTP Basic authentication handler executed (**unexpected**) _which you can also observe in the browser because the a prompt for HTTP Basic authentication credentials will show as a result of failed HTTP Basic authentication (because the authentication/authorization header did not contain a valid HTTP Basic authentication value because it was \u0060SessionID 123\u0060_)\r\n![image](https://user-images.githubusercontent.com/64279914/223901101-725b937d-dab3-4e9a-a0f1-0efedb7a4db6.png)\r\n\r\n\r\n\r\n\r\n### Expected Behavior\r\n\r\nWhen \u0060[Authorize(AuthenticationSchemes=JwtBearerDefaults.AuthenticationScheme)]\u0060 annotation is used, only that single AuthenticationHandler (registered under the authentication scheme name \u0060JwtBearerDefaults.AuthenticationScheme\u0060 is executed).\r\n\r\nThat in my case would be the session ID authentication handler specified on the controller method:\r\n\u0060\u0060\u0060\r\n\r\npublic class ItemsController : ControllerBase\r\n{\r\n    //only \u0022SessionID\u0022 authentication schema handler should be executed.\r\n    [Authorize(AuthenticationSchemes = SessionIDAuthenticationHandler.AuthenticationSchemeName)] \r\n    [HttpGet(\u0022\u0022, Name = \u0022GetAllItems\u0022)]\r\n    [ProducesResponseType(typeof(IEnumerable\u003CItem\u003E), StatusCodes.Status200OK)]\r\n    public Task\u003CIEnumerable\u003CItem\u003E\u003E GetAll()\r\n    {\r\n        var items = new List\u003CItem\u003E\r\n        {\r\n            new Item\r\n            {\r\n                Name = \u0022item1\u0022\r\n            },\r\n            new Item\r\n            {\r\n                Name = \u0022item2\u0022\r\n            }\r\n        };\r\n        return Task.FromResult(items.AsEnumerable());\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n### Steps To Reproduce\r\n\r\nRepro project:\r\nhttps://github.com/janseris/ASPNetCoreMultipleAuthentications\r\n\r\nRepro steps:\r\n1) run project\r\n2) in Swagger UI, click green Authorize button which enables you to enter HTTP Authorization header content to be passed in to the controller\r\n![image](https://user-images.githubusercontent.com/64279914/223900712-6ca0624c-043d-4057-b0d2-7bb38462d2ff.png)\r\n\r\n3) In the Session ID form, enter in value \u0060SessionID 123\u0060 which passes the validation in the SessionID \u0060AuthenticationHandler\u0060 and click green Authorize button to apply\r\n- this will add HTTP Authorization header value \u0060SessionID 123\u0060 to all the HTTP requests executed via the Swagger UI\r\n![image](https://user-images.githubusercontent.com/64279914/223900638-18fb48fc-e31f-412b-bb25-51bf11413340.png)\r\n\r\n4) execute a controller method via Swagger UI by clicking the method, then Try it Out and then blue Execute button\r\n![image](https://user-images.githubusercontent.com/64279914/223900967-787e43d0-983d-4c90-9380-8ddd7e3cc0d9.png)\r\n\r\n5) see debug output in Visual Studio - you will see that the Session ID authentication handler executed and finished and the HTTP Basic authentication handler executed (**unexpected**) which you can also observe in the browser because the default browser dialog for HTTP Basic authentication will show\r\n![image](https://user-images.githubusercontent.com/64279914/223901101-725b937d-dab3-4e9a-a0f1-0efedb7a4db6.png)\r\n\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n.NET SDK 7.0.200 commit 534117727b\r\n\r\n### Anything else?\r\n\r\n_No response_",
    "upvotes": 6,
    "labels": [
      "Docs",
      "area-auth",
      "Pillar: Technical Debt"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85Y2OsC",
        "parentId": null,
        "author": "??",
        "content": "To learn more about what this message means, what to expect next, and how this issue will be handled you can read our [Triage Process document](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).\nWe\u0027re moving this issue to the .NET 8 Planning milestone for future evaluation / consideration. Because it\u0027s not immediately obvious what is causing this behavior, we would like to keep this around to collect more feedback, which can later help us determine how to handle this. We will re-evaluate this issue, during our next planning meeting(s).\nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact work.",
        "createdAt": "2023-03-30T16:43:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47105#issuecomment-1490610946"
      },
      {
        "id": "IC_kwDOAQzde85Y28St",
        "parentId": null,
        "author": "halter73",
        "content": "It\u0027s true that the default scheme\u0027s \u0060AuthenticateAsync\u0060/\u0060HandleAuthenticateAsync\u0060 methods get called by the authentication middleware regardless of what\u0027s set by \u0060[Authorize(AuthenticationSchemes=...)]\u0060. The docs should be clearer about this.\r\n\r\nHowever, this shouldn\u0027t be a problem if \u0060AuthenticateAsync\u0060 does not mutate the response. You might have noticed than in your sample, the Controller action still gets run and writes the response body despite the basic auth handler setting the 401 response and \u0060WWW-Authenticate\u0060 response header. That\u0027s because the failed default \u0060AuthenticateResult\u0060 from \u0060HttpBasicAuthenticationHandler\u0060 is being ignored by the authorization middleware since a specific scheme was specified.\r\n\r\nIf you delete all the calls to \u0060AddAuthenticationFailedInfoToResponse\u0060 from \u0060HttpBasicAuthenticationHandler.HandleAuthenticateAsync\u0060 and instead move it to \u0060HandleChallengeAsync\u0060 everything should work because \u0060HandleChallengeAsync\u0060 will only be called if the scheme is not overridden despite \u0060HandleAuthenticateAsync\u0060 returning a failed \u0060AuthenticateResult\u0060.\r\n\r\n\u0060\u0060\u0060csharp\r\nprotected override Task HandleChallengeAsync(AuthenticationProperties properties)\r\n{\r\n    Response.Headers.Add(HeaderNames.WWWAuthenticate, $\u0022{AuthenticationSchemeName} realm=\\\u0022{Realm}\\\u0022\u0022 /* realm is special info added in HTTP Basic auth fail */);\r\n    return base.HandleChallengeAsync(properties);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nAlso, \u0060UseAuthentication\u0060 should always be called before \u0060UseAuthorization\u0060. It might not matter if you specify the scheme using \u0060[Authorize]\u0060 since the authorization middleware runs the authentication handler inline, but it matters in other scenarios.\r\n\r\nI think in .NET 7 we warn about this, but in .NET 7 you can also just omit those calls. \u0060WebApplicationBuilder\u0060 will add both auth middlewares by default if you\u0027ve configured authentication. @captainsafia\r\n\r\n\u0060\u0060\u0060\r\napp.UseAuthentication();\r\napp.UseAuthorization();\r\n\u0060\u0060\u0060",
        "createdAt": "2023-03-30T19:10:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47105#issuecomment-1490797741"
      },
      {
        "id": "IC_kwDOAQzde85Y3lR1",
        "parentId": null,
        "author": "janseris",
        "content": "@halter73 thank you I will investigate that in the following days ",
        "createdAt": "2023-03-30T21:08:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47105#issuecomment-1490965621"
      },
      {
        "id": "IC_kwDOAQzde85aT-SO",
        "parentId": null,
        "author": "janseris",
        "content": "\u003E It\u0027s true that the default scheme\u0027s AuthenticateAsync/HandleAuthenticateAsync methods get called by the authentication middleware regardless of what\u0027s set by [Authorize(AuthenticationSchemes=...)]. The docs should be clearer about this.\r\n\r\nThe docs say the exact contrary, so I think the framework is not working as intended because the behavior documented in docs makes perfect sense but is not followed by the framework.\r\nI don\u0027t want the default authentication handler executed when it doesn\u0027t need to. \r\nWhy should the default handler be executed when it\u0027s explicitly not supposed to be executed?\r\n\r\n\r\n\r\n\u003E However, this shouldn\u0027t be a problem if \u0060AuthenticateAsync\u0060 does not mutate the response\r\n\r\nI have an issue that I check in database in authentication handler. This slows down the application when unwanted authentication handlers are executed and breaks the intended authentication flow.\r\n\r\nThe intended authentication and authorization mechanism is:\r\n1) Login endpoint - should run APIKey authentication handler. This assures only allowed application clients (e.g. only the latest mobile app version) can call the REST API.\r\n2) Public endpoint - can be called by anyone. Does not require APIKey authentication.\r\n3) Any other endpoint - requires authentication of the caller by APIKey and SessionID. \r\nSessionID identifies the user and is later used to load user rights and authorizes the request after authentication passes.\r\nAPIKey makes sure only selected application clients can call the endpoint (e.g. only latest mobile app version or only all mobile app versions etc.) as in case 1.",
        "createdAt": "2023-04-19T18:29:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47105#issuecomment-1515185294"
      },
      {
        "id": "IC_kwDOAQzde85aUCvY",
        "parentId": null,
        "author": "janseris",
        "content": "\u003EAlso, UseAuthentication should always be called before UseAuthorization. It might not matter if you specify the scheme using [Authorize] since the authorization middleware runs the authentication handler inline, but it matters in other scenarios.\r\n\u003EI think in .NET 7 we warn about this\r\n\r\n\r\nI have changed target framework to .NET 7 and reopened VS and rebuilt the solution.\r\nI cannot see any warning in the IDE code editor or any compile-time warning/error.\r\n",
        "createdAt": "2023-04-19T18:44:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47105#issuecomment-1515203544"
      },
      {
        "id": "IC_kwDOAQzde85ajSFJ",
        "parentId": null,
        "author": "janseris",
        "content": "@halter73 \r\nWhen HTTP Basic authentication handler (my custom) and Session ID Authentication handler (my custom) are regsitered and HTTP Basic Authentication handler\u0027s scheme name is set as default in \u0060AddScheme()\u0060 and both are registered using \u0060AddScheme()\u0060, then if \u0060[Authorize(AuthenticationSchemes = \u0022SessionID\u0022)]\u0060 is written on method, the HTTP Basic authentication handler still gets executed (and succeds or fails in the background and that\u0027s ignored but it\u0027s executed while **is not supposed to be executed**).\r\n\r\n---\r\n\r\nThis has for example an unwanted side-effect that \u0060WWW-Authenticate\u0060 HTTP header is unexpectedly added to the response (as it would have been set if HTTP Basic or any other authentication failed). \r\n\r\nExample: \r\nEndpoint is supposed to only support and check for SessionID authentication.\r\nThe user passes in SessionID in HTTP Authorize header and the authentication succeeds. Then the backend finds out that the user is unauthorized.\r\nIn this case, 403 is returned (OK) _with WWW-Authenticate header set from failed HTTP Basic authentication handler (unexpected)_. \r\n\r\n![image](https://user-images.githubusercontent.com/64279914/233873835-31589a8f-8e02-4444-b915-c8e11ef7d983.png)\r\n\r\nBtw. this is even more wrong because the purpose/semantics of sending \u0060WWW-Authenticate\u0060 header in a HTTP response is to inform user about available actions to authenticate themselves. \r\nThat makes no sense here because:\r\n- the user was authenticated succesfully\r\n- the endpoint doesn\u0027t even support HTTP Basic authentication\r\n\r\n",
        "createdAt": "2023-04-23T23:51:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47105#issuecomment-1519198537"
      },
      {
        "id": "IC_kwDOAQzde85ao4LN",
        "parentId": null,
        "author": "captainsafia",
        "content": "\u003E I have changed target framework to .NET 7 and reopened VS and rebuilt the solution.\r\n\u003E I cannot see any warning in the IDE code editor or any compile-time warning/error.\r\n\r\nInteresting note. We added support for minimal APIs in the startup analyzers (like the auth-middleware ordering one [here](https://source.dot.net/#Microsoft.AspNetCore.Analyzers/UseAuthorizationAnalyzer.cs,2d0fe10ee4ab67db)) in .NET 6 but I\u0027m able to repro what you\u0027re seeing so there might be something going on behind the scenes.\r\n\r\nDo you mind filing a separate issue for the problem of not seeing the analyzer warnings?",
        "createdAt": "2023-04-24T18:54:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47105#issuecomment-1520665293"
      },
      {
        "id": "IC_kwDOAQzde85apaTX",
        "parentId": null,
        "author": "halter73",
        "content": "\u003E then if \u0060[Authorize(AuthenticationSchemes = \u0022SessionID\u0022)]\u0060 is written on method, the HTTP Basic authentication handler still gets executed (and succeds or fails in the background and that\u0027s ignored but it\u0027s executed while **is not supposed to be executed**).\r\n\r\nI agree that it\u0027s surprising that the \u0060HttpBasicAuthenticationHandler.AuthenticateAsync\u0060 gets called in this case, but it\u0027s existing behavior that\u0027s not likely to change in a patch, because apps may rely on it. I\u0027m even hesitant to change the behavior in .NET 8 for fear of breaking apps, but I\u0027m sympathetic to not wanting to waste resources, so it\u0027s worth considering as long as we don\u0027t think it will be *too* breaking.\r\n\r\n\u003E This has for example an unwanted side-effect that \u0060WWW-Authenticate\u0060 HTTP header is unexpectedly added to the response (as it would have been set if HTTP Basic or any other authentication failed).\r\n\r\nThe good news is that if you add the header in \u0060HttpBasicAuthenticationHandler.HandleChallengeAsync\u0060 instead of \u0060AuthenticateAsync\u0060 as I suggested above, the header will only be sent for authentication failures when the scheme is selected. Setting the 401 manually is also unnessary if you call \u0060base\u0060.\r\n\r\n\u003E \u0060\u0060\u0060cs\r\n\u003E protected override Task HandleChallengeAsync(AuthenticationProperties properties)\r\n\u003E {\r\n\u003E     Response.Headers.Add(HeaderNames.WWWAuthenticate, $\u0022{AuthenticationSchemeName} realm=\\\u0022{Realm}\\\u0022\u0022 /* realm is special info added in HTTP Basic auth fail */);\r\n\u003E     return base.HandleChallengeAsync(properties);\r\n\u003E }\r\n\u003E \u0060\u0060\u0060\r\n\r\nYou should never modify the response in \u0060AuthenticateAsync\u0060. Even the \u0060CookieAuthenticationHandler\u0060 does not do this, and it needs to modify non-challenge responses. It hooks \u0060OnStarting\u0060 inside of \u0060InitializeHandlerAsync\u0060.\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/10a343bbcb7a6d5013a6057620f74aef039964c0/src/Security/Authentication/Cookies/src/CookieAuthenticationHandler.cs#L58-L61\r\n\r\n",
        "createdAt": "2023-04-24T20:48:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47105#issuecomment-1520805079"
      },
      {
        "id": "IC_kwDOAQzde85eb3xB",
        "parentId": null,
        "author": "floge07",
        "content": "I also have problems with this behavior. \r\nIn my case, I have two different JwtBearer handlers.\r\nOne of them is the default/fallback. They both use different signing credentials, so because the default one is always executed, it\u0027s throwing an exception that it can\u0027t read the token.\r\nThis doesn\u0027t fail the authentication because it continues with the second handler, which is successful.\r\nIt just causes unnecessary error logs. \r\n",
        "createdAt": "2023-06-09T10:37:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47105#issuecomment-1584364609"
      },
      {
        "id": "IC_kwDOAQzde85zrc6O",
        "parentId": null,
        "author": "Sonic198",
        "content": "I also have problem with this. In my case I have two bearer authentication schemes which are also configured as default policy\r\n\u0060\u0060\u0060csharp\r\nservices.AddAuthorization(options =\u003E\r\n{\r\n    var defaultAuthorizationPolicyBuilder = new AuthorizationPolicyBuilder(\r\n        AuthenticationSchemes.Azure,\r\n        AuthenticationSchemes.Cognito);\r\n    defaultAuthorizationPolicyBuilder = defaultAuthorizationPolicyBuilder.RequireAuthenticatedUser();\r\n    options.DefaultPolicy = defaultAuthorizationPolicyBuilder.Build();\r\n});\r\n\u0060\u0060\u0060\r\nBut I also have a third auth scheme for API Key authentication and I would like to secure some of my endpoints to be accessible only using API key. So I did the following:\r\n\u0060\u0060\u0060csharp\r\n[Authorize(AuthenticationSchemes = \u0022ApiKey\u0022)]\r\n[HttpGet(\u0022byApiKey\u0022)]\r\npublic Task\u003CIActionResult\u003E ProtectedByApiKey()\r\n{\r\n    return Task.FromResult\u003CIActionResult\u003E(Ok(\u0022Authorized by ApiKey\u0022));\r\n}\r\n\u0060\u0060\u0060\r\nBut unfortunately I can access this endpoint either with API key or with Azure and Cognito bearer tokens.\r\nIf that is expected behavior I think the docks are not clear about that.",
        "createdAt": "2024-02-13T08:43:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47105#issuecomment-1940770446"
      },
      {
        "id": "IC_kwDOAQzde859kfIX",
        "parentId": null,
        "author": "peter-bertok",
        "content": "I\u0027m getting an issue similar to @Sonic198, I have an API service that also has a Razor page that uses Easy Auth and Entra ID, but the authentication providers can\u0027t be easily split. The documentation is also very unclear and there are no working examples on the web.",
        "createdAt": "2024-05-13T06:01:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47105#issuecomment-2106716695"
      },
      {
        "id": "IC_kwDOAQzde85_t91N",
        "parentId": null,
        "author": "jurajpaska8",
        "content": "same problem, when using default authentication, this handler is executed no matter which handler i spiecify in authorize attribute         \r\n\u0060\u0060\u0060\r\nservices\r\n            .AddAuthentication(o =\u003E\r\n            {\r\n                // Any default scheme will be triggered everytime, no matter if we use different authn scheme in authorize attribute. Therefore is better to use wanted Auth handler explicitly on controller / endpoint\r\n                // This is known microsoft issue\r\n                // https://github.com/dotnet/aspnetcore/issues/47105\r\n                // o.DefaultScheme = nameof(EmptyAuthenticationHandler);\r\n                // o.DefaultScheme = nameof(AnotherAuthenticationHandler);\r\n                // o.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;\r\n            })\r\n\u0060\u0060\u0060",
        "createdAt": "2024-05-31T18:13:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47105#issuecomment-2142756173"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85g5kq-",
    "title": "Missing Dependency in AddAuthorization",
    "url": "https://github.com/dotnet/aspnetcore/issues/47220",
    "createdAt": "2023-03-15T15:04:50Z",
    "lastUpdated": "2024-02-13T01:40:08Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nWhen configuring the services with \u0060AddAuthorization\u0060 and then building the container with \u0060ValidateOnBuild = true\u0060 an \u0060AggregateException\u0060 is thrown because not all dependencies were added to the container.\r\n\r\nCalling \u0060AddRouting\u0060 inside \u0060AddAuthorization\u0060 should fix this.\n\n### Expected Behavior\n\n_No response_\n\n### Steps To Reproduce\n\n\u0060\u0060\u0060csharp\r\npublic class AuthorizationTest\r\n{\r\n    [Fact]\r\n    public void AddAuthorizationWithoutRouting()\r\n    {\r\n        var builder = new HostBuilder()\r\n            .UseServiceProviderFactory(new DefaultServiceProviderFactory(new ServiceProviderOptions { ValidateOnBuild = true }))\r\n            .ConfigureServices(s =\u003E s.AddAuthorization());\r\n\r\n        Assert.Throws\u003CAggregateException\u003E(builder.Build);\r\n    }\r\n\r\n    [Fact]\r\n    public void AddAuthorizationWithRouting()\r\n    {\r\n        var builder = new HostBuilder()\r\n            .UseServiceProviderFactory(new DefaultServiceProviderFactory(new ServiceProviderOptions { ValidateOnBuild = true }))\r\n            .ConfigureServices(s =\u003E s.AddRouting())\r\n            .ConfigureServices(s =\u003E s.AddAuthorization());\r\n\r\n        using var host = builder.Build();\r\n        Assert.NotNull(host);\r\n    }\r\n}\r\n\u0060\u0060\u0060\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n7.0.202\n\n### Anything else?\n\n\u0060\u0060\u0060\r\n.NET SDK:\r\n Version:   7.0.202\r\n Commit:    6c74320bc3\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.22621\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\7.0.202\\\r\n\r\nHost:\r\n  Version:      7.0.4\r\n  Architecture: x64\r\n  Commit:       0a396acafe\r\n\r\n.NET SDKs installed:\r\n  7.0.201 [C:\\Program Files\\dotnet\\sdk]\r\n  7.0.202 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.App 3.1.32 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 6.0.14 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 7.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 7.0.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 3.1.32 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 6.0.14 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 6.0.15 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 7.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 7.0.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 3.1.32 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 6.0.14 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 6.0.15 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 7.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 7.0.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\nOther architectures found:\r\n  x86   [C:\\Program Files (x86)\\dotnet]\r\n    registered at [HKLM\\SOFTWARE\\dotnet\\Setup\\InstalledVersions\\x86\\InstallLocation]\r\n\r\nEnvironment variables:\r\n  Not set\r\n\r\nglobal.json file:\r\n  Not found\r\n\u0060\u0060\u0060",
    "upvotes": 0,
    "labels": [
      "bug",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85Yv6Nk",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-03-29T16:49:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47220#issuecomment-1488954212"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85huiho",
    "title": "JwtBearerHandler.cs hardcoded \u0022Bearer \u0022",
    "url": "https://github.com/dotnet/aspnetcore/issues/47399",
    "createdAt": "2023-03-24T15:19:55Z",
    "lastUpdated": "2024-02-13T01:39:12Z",
    "body": "If someone decides to define their own JWT token scheme that does not use the prefix Bearer, but a different custom scheme name there are issues authenticating the JWT Token while utilizing AzureAD.\r\n\r\nexample:\r\n\u0060\u0060\u0060csharp\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\nbuilder.Services.AddAuthentication(\u0022MyCustomScheme\u0022)\r\n    .AddMicrosoftIdentityWebApi(builder.Configuration, jwtBearerScheme: \u0022MyCustomScheme\u0022);\r\n\r\n/* code removed for brevity */\r\n\r\nvar app = builder.Build();\r\n\r\n/* code removed for brevity */\r\n\r\napp.Run();\r\n\u0060\u0060\u0060\r\n\r\nIn your controller if you use \u0022MyCustomScheme\u0022 to authenticate it will not authenticate the token out of the box because it is not prefixed with \u0022Bearer \u0022, even though you are utilizing \u0022MyCustomScheme \u0022.  This is highlighted on line 78 here:\r\nhttps://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/JwtBearer/src/JwtBearerHandler.cs\r\n\r\nYou can add an event handler to handle this event, and essentially reimplement what is going on in the JwtBearerHandler.cs, but it seems like overkill for a simple rename to the token.\r\n\r\nNow if this may not seem appropriate because [RFC 6750 Section 2.1](https://www.rfc-editor.org/rfc/rfc6750#section-2.1) specifies that the standard for OAuth 2.0 is to use \u0022Bearer \u0022 \u002B base64Token.  But I would argue then that jwtBearerScheme should not exist as an optional parameter in the extension method as the standard for JWT Tokens should never change  in [.AddMicrosoftIdentityWebApi(...)](https://github.com/AzureAD/microsoft-identity-web/blob/master/src/Microsoft.Identity.Web/WebApiExtensions/MicrosoftIdentityWebApiAuthenticationBuilderExtensions.cs).  Additionally postman will allow you to change the header prefix, the prefix feels arbitrary, so I believe it should be defined by the provided Scheme, not by the linked spec.\r\n\r\nDepending on the responses I feel like it could be argued to open this issue on either side, here or in the AzureAD repository.  I figured I can start the discussion here to see if I\u0027m missing anything on my side.",
    "upvotes": 0,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85YZduQ",
        "parentId": null,
        "author": "brockallen",
        "content": "It would be useful to have the scheme passed in the HTTP authorization header to be configurable. DPoP is an example where it is different than Bearer: https://datatracker.ietf.org/doc/html/draft-ietf-oauth-dpop#name-the-dpop-http-header",
        "createdAt": "2023-03-24T16:18:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47399#issuecomment-1483070352"
      },
      {
        "id": "IC_kwDOAQzde85Yp1fF",
        "parentId": null,
        "author": "halter73",
        "content": "Your best option for now is probably to configure [JwtBearerOptions.Events.OnMessageReceived](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.jwtbearer.jwtbearerevents.onmessagereceived?view=aspnetcore-7.0#microsoft-aspnetcore-authentication-jwtbearer-jwtbearerevents-onmessagereceived) and set the token yourself. This seems simple enough considering how rare this feature request is, but if more people start using non-\u0022Bearer \u0022 prefixes, we might consider it down the road.\r\n\r\n\u0060\u0060\u0060csharp\r\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)\r\n    .AddJwtBearer(jwtBearerOptions =\u003E\r\n    {\r\n        jwtBearerOptions.Events ??= new();\r\n        jwtBearerOptions.Events.OnMessageReceived = context =\u003E\r\n        {\r\n            var authHeader = context.Request.Headers.Authorization.ToString();\r\n\r\n            if (authHeader.StartsWith(\u0022DPoP \u0022, StringComparison.Ordinal))\r\n            {\r\n                context.Token = authHeader[\u0022DPoP \u0022.Length..];\r\n            }\r\n            else\r\n            {\r\n                // Skip NoResult() if you want to fall back to trying to read the \u0022Bearer \u0022 token.\r\n                context.NoResult();\r\n            }\r\n\r\n            return Task.CompletedTask;\r\n        };\r\n    });\r\n\u0060\u0060\u0060\r\n\r\nWe document something similar in https://learn.microsoft.com/en-us/aspnet/core/signalr/authn-and-authz?view=aspnetcore-7.0#built-in-jwt-authentication because SignalR is sometimes unable to set the Authorization header when using WebSockets in the browser and instead sends the bearer token as part of the query string (\u0060?access_token=...\u0060).",
        "createdAt": "2023-03-28T17:52:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47399#issuecomment-1487361989"
      },
      {
        "id": "IC_kwDOAQzde85Yp18r",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-03-28T17:54:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47399#issuecomment-1487363883"
      },
      {
        "id": "IC_kwDOAQzde85h1BDV",
        "parentId": null,
        "author": "jeremy-morren",
        "content": "This is a problem if you wish to register multiple JWT handlers i.e. the prefix *has* to be different.  It should be noted that this very non-obvious behavior i.e. I spent time hunting around authorization policies/challenge schemes before I thought to look at \u0060JwtBearerHandler\u0060 source.\r\n\r\nThis is how you would register an arbitrary JWT bearer scheme.\r\n\r\n\u0060\u0060\u0060c#\r\nconst string scheme = \u0022CustomScheme\u0022;\r\n\r\nservices.AddAuthentication(scheme)\r\n    .AddJwtBearer(scheme, o =\u003E\r\n    {\r\n        //See https://github.com/dotnet/aspnetcore/blob/ef07bcb02ae3d7218dbd3dd0358974b2b7e9ddd2/src/Security/Authentication/JwtBearer/src/JwtBearerHandler.cs#L87C39-L87C39\r\n\r\n        var prefix = $\u0022{scheme} \u0022;\r\n        \r\n        o.Events ??= new ();\r\n        \r\n        o.Events.OnMessageReceived = context =\u003E\r\n        {\r\n            string? authorization = context.Request.Headers[HeaderNames.Authorization];\r\n            if (!string.IsNullOrEmpty(authorization) \u0026\u0026 authorization.StartsWith(prefix))\r\n                context.Token = authorization[prefix.Length..]; //JwtBearerHandler will use this token instead\r\n            \r\n            return Task.CompletedTask;\r\n        };\r\n    });\r\n\u0060\u0060\u0060\r\n",
        "createdAt": "2023-07-19T02:26:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47399#issuecomment-1641287893"
      },
      {
        "id": "IC_kwDOAQzde85qbOp0",
        "parentId": null,
        "author": "AlexKubiesa",
        "content": "I came across this issue because I\u0027m updating our APIs to support two JwtBearer authentication schemes. Essentially we are migrating from one token issuer to another but for the transition period (which I suspect will be quite long) we need to support JWTs from both issuers.\r\n\r\n**Update:** I solved this by setting the default authentication scheme to be a policy scheme that reads the JWT and switches between the two JwtBearer schemes depending on the JWT issuer (as per the \u0022iss\u0022 claim). I followed the guide [here](https://learn.microsoft.com/en-us/aspnet/core/security/authorization/limitingidentitybyscheme?view=aspnetcore-7.0).",
        "createdAt": "2023-10-30T15:56:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47399#issuecomment-1785522804"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85hwm9g",
    "title": "Only call AddDataProtection in Authentication Services that require it",
    "url": "https://github.com/dotnet/aspnetcore/issues/47410",
    "createdAt": "2023-03-24T22:28:26Z",
    "lastUpdated": "2024-11-13T22:55:12Z",
    "body": "In .NET 8, we have a goal to enable JWT authentication with Native AOT. See \u0060Stage 2.a\u0060 in https://github.com/dotnet/aspnetcore/issues/45910.\r\n\r\nIn order to use JWT authentication, the app needs to call \u0060builder.Services.AddAuthentication()\u0060. When bringing in \u0060AddAuthentication()\u0060, we are getting trimming / NativeAOT warnings from \u0060System.Security.Cryptography.Xml\u0060. \u0060System.Security.Cryptography.Xml\u0060 is not currently trimming / NativeAOT compatible. See https://github.com/dotnet/runtime/issues/73432. It also appears to be a major amount of work to make it compatible, possibly with many \u0022gotchas\u0022.\r\n\r\nThe reason \u0060System.Security.Cryptography.Xml\u0060 is brought into the app is because this line:\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/9c38b3749a69050e0670b8750d9828cf47a19b41/src/Security/Authentication/Core/src/AuthenticationServiceCollectionExtensions.cs#L24\r\n\r\n\u0060DataProtection\u0060 brings in the dependency on \u0060System.Security.Cryptography.Xml\u0060.\r\n\r\nHowever, to enable JWT bearer authentication, it doesn\u0027t require \u0060DataProtection\u0060. Other types of authentication services do, for example:\r\n\r\n* [Cookies](https://github.com/dotnet/aspnetcore/blob/3265dc6a9b05c74b199aa39351e5413317df9ad5/src/Security/Authentication/Cookies/src/PostConfigureCookieAuthenticationOptions.cs#L43)\r\n* [OpenIdConnect](https://github.com/dotnet/aspnetcore/blob/3265dc6a9b05c74b199aa39351e5413317df9ad5/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectPostConfigureOptions.cs#L47-L58)\r\n* [OAuth](https://github.com/dotnet/aspnetcore/blob/3265dc6a9b05c74b199aa39351e5413317df9ad5/src/Security/Authentication/OAuth/src/OAuthPostConfigureOptions.cs#L46-L48)\r\n* [WsFederation](https://github.com/dotnet/aspnetcore/blob/3265dc6a9b05c74b199aa39351e5413317df9ad5/src/Security/Authentication/WsFederation/src/WsFederationPostConfigureOptions.cs#L38)\r\n* [Twitter](https://github.com/dotnet/aspnetcore/blob/3265dc6a9b05c74b199aa39351e5413317df9ad5/src/Security/Authentication/Twitter/src/TwitterPostConfigureOptions.cs#L35)\r\n* etc\r\n\r\nSo it made sense originally to add \u0060DataProtection\u0060 in a common place, and if the app didn\u0027t use it - no big deal. But now with NativeAOT and trimming, it does affect the app because the unused code can\u0027t be trimmed from the app - making it bigger unnecessarily.\r\n\r\nTo solve both the size issue (being able to trim the unused DataProtection code) and the fact that \u0060System.Security.Cryptography.Xml\u0060 is not compatible with NativeAOT/trimming, we should remove \u0060AddDataProtection()\u0060 from \u0060AddAuthentication()\u0060 and instead move the calls to all the specific authentication services that require it.\r\n\r\nNote that this would be a breaking change because an app could just call \u0060AddAuthentication()\u0060, without calling one of the built-in auth services, and then try to get DataProtection services, it will fail (since they aren\u0027t registered).\r\n\r\n### Alternatives\r\n\r\nOne alternative is to create a new \u0060AddAuthenticationCore()\u0060 method that doesn\u0027t call \u0060AddDataProtection()\u0060, but does everything else \u0060AddAuthentication()\u0060 does today.\r\n\r\n\r\ncc @halter73 @davidfowl @JamesNK @DamianEdwards ",
    "upvotes": 7,
    "labels": [
      "breaking-change",
      "area-auth",
      "feature-trimming"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85YinXB",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-03-27T16:41:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1485469121"
      },
      {
        "id": "IC_kwDOAQzde85Yi4Gb",
        "parentId": null,
        "author": "Tratcher",
        "content": "Yes, this would be breaking for most 3rd party auth providers.\r\n\r\nAddAuthenticationCore would avoid the break, but would have to be used directly in program.cs and the template.",
        "createdAt": "2023-03-27T17:19:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1485537691"
      },
      {
        "id": "IC_kwDOAQzde85Yrjhi",
        "parentId": null,
        "author": "eerhardt",
        "content": "@Tratcher - do you have an opinion on which approach we should take?",
        "createdAt": "2023-03-29T01:19:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1487812706"
      },
      {
        "id": "IC_kwDOAQzde85YwO8M",
        "parentId": null,
        "author": "Tratcher",
        "content": "AddAuthenticationCore has discoverability issues. How about this:\r\n\r\n\u0060\u0060\u0060diff\r\npublic static class AuthenticationServiceCollectionExtensions\r\n{\r\n    public static AuthenticationBuilder AddAuthentication(this IServiceCollection services)\r\n    public static AuthenticationBuilder AddAuthentication(this IServiceCollection services, string defaultScheme)\r\n    public static AuthenticationBuilder AddAuthentication(this IServiceCollection services, Action\u003CAuthenticationOptions\u003E configureOptions)\r\n\u002B   public static AuthenticationBuilder AddAuthentication(this IServiceCollection services, bool withDataProtection)\r\n\u002B   public static AuthenticationBuilder AddAuthentication(this IServiceCollection services, bool withDataProtection, string defaultScheme)\r\n\u002B   public static AuthenticationBuilder AddAuthentication(this IServiceCollection services, bool withDataProtection, Action\u003CAuthenticationOptions\u003E configureOptions)\r\n}\r\n\u0060\u0060\u0060\r\n\r\nI\u0027d also set a bool on AuthenticationBuilder \u0060bool HasDataProtection { get; }\u0060 that callers like AddOpenIdConnect would check and throw if it wasn\u0027t enabled. That way they fail at startup instead of on individual requests.",
        "createdAt": "2023-03-29T17:45:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1489039116"
      },
      {
        "id": "IC_kwDOAQzde85YwRA9",
        "parentId": null,
        "author": "eerhardt",
        "content": "Unfortunately that proposal is not trim friendly. The trimmer is not able to see that \u0060withDataProtection\u0060 is only ever passed \u0060false\u0060. See https://github.com/dotnet/linker/issues/1868.",
        "createdAt": "2023-03-29T17:51:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1489047613"
      },
      {
        "id": "IC_kwDOAQzde85YwZde",
        "parentId": null,
        "author": "Tratcher",
        "content": "Darn. So we end up with:\r\n\r\n\u0060\u0060\u0060diff\r\npublic static class AuthenticationServiceCollectionExtensions\r\n{\r\n    public static AuthenticationBuilder AddAuthentication(this IServiceCollection services)\r\n    public static AuthenticationBuilder AddAuthentication(this IServiceCollection services, string defaultScheme)\r\n    public static AuthenticationBuilder AddAuthentication(this IServiceCollection services, Action\u003CAuthenticationOptions\u003E configureOptions)\r\n\u002B   public static AuthenticationBuilder AddAuthenticationCore(this IServiceCollection services)\r\n\u002B   public static AuthenticationBuilder AddAuthenticationCore(this IServiceCollection services, string defaultScheme)\r\n\u002B   public static AuthenticationBuilder AddAuthenticationCore(this IServiceCollection services, Action\u003CAuthenticationOptions\u003E configureOptions)\r\n}\r\n\u0060\u0060\u0060\r\n\r\nI\u0027d still want that bool on AuthenticationBuilder \u0060bool HasDataProtection { get; }\u0060 that callers like AddOpenIdConnect would check and throw if it wasn\u0027t enabled.",
        "createdAt": "2023-03-29T18:16:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1489082206"
      },
      {
        "id": "IC_kwDOAQzde85YwfJb",
        "parentId": null,
        "author": "eerhardt",
        "content": "\u003E that callers like AddOpenIdConnect would check and throw if it wasn\u0027t enabled.\r\n\r\nWhy wouldn\u0027t \u0060AddOpenIdConnect\u0060 just call \u0060AddDataProtection()\u0060 if it needs it? Why would it require someone else to do it?",
        "createdAt": "2023-03-29T18:32:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1489105499"
      },
      {
        "id": "IC_kwDOAQzde85Ywf_a",
        "parentId": null,
        "author": "Tratcher",
        "content": "Good point \uD83D\uDE06.",
        "createdAt": "2023-03-29T18:35:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1489108954"
      },
      {
        "id": "IC_kwDOAQzde85YyU_W",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E Unfortunately that proposal is not trim friendly. The trimmer is not able to see that withDataProtection is only ever passed false. See https://github.com/dotnet/linker/issues/1868.\r\n\r\n- It tightly couples the method to the implementation\r\n- It doesn\u2019t scale well for other things we may want to exclude ",
        "createdAt": "2023-03-30T02:19:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1489588182"
      },
      {
        "id": "IC_kwDOAQzde85YycL-",
        "parentId": null,
        "author": "eerhardt",
        "content": "I just remembered there already is an AddAuthenticationCore method:\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/3265dc6a9b05c74b199aa39351e5413317df9ad5/src/Http/Authentication.Core/src/AuthenticationCoreServiceCollectionExtensions.cs#L19\r\n\r\nThe issue with it and JwtBearer authentication is that JwtBearer also needs an \u2018IAuthenticationConfigurationProvider\u2019, which is only added by AddAuthentication. \r\n\r\nSo other options would be:\r\n* move the default IAuthenticationConfigurationProvider service registration from AddAuthentication to AddAuthenticationCore.\r\n* Have AddJwtBearer add the default IAuthenticationConfigurationProvider service if it hasn\u2019t already been registered.",
        "createdAt": "2023-03-30T03:04:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1489617662"
      },
      {
        "id": "IC_kwDOAQzde85YydCs",
        "parentId": null,
        "author": "danmoseley",
        "content": "Aside - why do we consider System.Security.Cryptography.Xml legacy/not recommended given so many mainstream auth scenarios apparently depend on it?\nCc @vcsjones ",
        "createdAt": "2023-03-30T03:09:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1489621164"
      },
      {
        "id": "IC_kwDOAQzde85YyeBm",
        "parentId": null,
        "author": "eerhardt",
        "content": "\u003E why do we consider System.Security.Cryptography.Xml legacy/not recommended\r\n\r\n@danmoseley - I\u2019m not sure where you got that impression. Can you post a link?\r\n\r\nThe core of this issue is that:\r\n\r\n1. The goal for .Net 8 is to enable JWT token auth.\r\n2. JWT token auth doesn\u2019t need System.Security.Cryptography.Xml\r\n3. There\u2019s currently no way to cut the System.Security.Cryptography.Xml code out.\r\n4. System.Security.Cryptography.Xml has not been made compatible with trimming and native AOT. Because it is mostly by design not trim friendly. See https://github.com/dotnet/runtime/issues/73432#issuecomment-1206604301",
        "createdAt": "2023-03-30T03:16:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1489625190"
      },
      {
        "id": "IC_kwDOAQzde85YyfAE",
        "parentId": null,
        "author": "eerhardt",
        "content": "\u003E why do we consider System.Security.Cryptography.Xml legacy/not recommended\r\n\r\nCheck out https://github.com/dotnet/runtime/tree/main/src/libraries/System.Security.Cryptography.Xml#readme",
        "createdAt": "2023-03-30T03:23:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1489629188"
      },
      {
        "id": "IC_kwDOAQzde85YyhVv",
        "parentId": null,
        "author": "JamesNK",
        "content": "I\u0027m guessing the problem with System.Security.Cryptography.Xml is there can be type names embedded in XML. For example, \u0060Type.GetType(typeNameFromXml)\u0060 then is destined to fail.\r\n\r\nDataProtection has the same kind of issues. The [initial trimming annotations](https://github.com/dotnet/aspnetcore/pull/41118) basically made the whole thing unsafe. Because of how fundamental DataProtection is, I [refactored DataProtection annotations](https://github.com/dotnet/aspnetcore/pull/41650) to a more pragmatic approach. The library works out of the box with all the applicable built-in .NET types. If there is a custom type defined in XML and it can\u0027t be found, then the error message mentions that it could have been trimmed. It didn\u0027t feel like a huge amount of work and it looks like it was successful. At least some people have been using trimming with it (they [logged a bug](https://github.com/dotnet/aspnetcore/issues/43187) about one place I missed \uD83D\uDE2C).\r\n\r\nIMO System.Security.Cryptography.Xml should be annotated the same way. It works for the vast majority of people and for those doing custom things and AOT (another small number), then provide a good runtime error experience.\r\n\r\nI brought this up before, but I think it is better to just fix the underlying cause here. At the very least, look at what is involved in fixing the underlying cause, and estimate its cost vs the cost of workaround it.\r\n\r\nDataProtection isn\u0027t going anywhere, and for AOT to be a real thing for ASP.NET Core (i.e. generally work and not just a couple of scenarios), we\u0027ll need it to work.",
        "createdAt": "2023-03-30T03:40:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1489638767"
      },
      {
        "id": "IC_kwDOAQzde85Yyiv2",
        "parentId": null,
        "author": "vcsjones",
        "content": "Looks like @eerhardt found the most relevant link. A more opinionated answer is found here: https://github.com/dotnet/runtime/issues/28599#issuecomment-460382856\r\n\r\n\u003E System.Security.Cryptography.Xml is in a state of \u0022as dead as can be while still being technically supported\u0022. Further, the W3C shut down the XML Security WG in 2016.\r\n\r\n\u003E I\u0027m guessing the problem with System.Security.Cryptography.Xml is there can be type names embedded in XML\r\n\r\nKind of. S.S.C.Xml relies heavily on \u0060CryptoConfig\u0060, which basically maps URLs and URNs that are identifiers to types. CryptoConfig is known not to be trimming friendly:\r\n\r\nhttps://github.com/dotnet/runtime/blob/ef15cfbbcebbfd8bcef2664bd6dad5c34ce66108/src/libraries/System.Security.Cryptography/src/System/Security/Cryptography/CryptoConfig.cs#L334\r\n\r\n",
        "createdAt": "2023-03-30T03:52:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1489644534"
      },
      {
        "id": "IC_kwDOAQzde85YzDAC",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E I brought this up before, but I think it is better to just fix the underlying cause here. At the very least, look at what is involved in fixing the underlying cause, and estimate its cost vs the cost of workaround it.\r\n\u003E DataProtection isn\u0027t going anywhere, and for AOT to be a real thing for ASP.NET Core (i.e. generally work and not just a couple of scenarios), we\u0027ll need it to work.\r\n\r\nAlso, our new token story is currently dependent on data protection so...... \u002B1 to what James said.",
        "createdAt": "2023-03-30T06:41:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1489776642"
      },
      {
        "id": "IC_kwDOAQzde85Y1PZD",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "@JamesNK @davidfowl, to be clear, are you advocating we don\u0027t do this layering/dependencies fix for Data Protection and instead make Data Protection work for trimming/native AOT? In the case of JWT it still has size implications (JWT doesn\u0027t need it).",
        "createdAt": "2023-03-30T13:56:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1490351683"
      },
      {
        "id": "IC_kwDOAQzde85Y1nau",
        "parentId": null,
        "author": "JamesNK",
        "content": "Yes. Put a pin on new work optimizing publish size and focus on AOT functionality.",
        "createdAt": "2023-03-30T14:54:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1490450094"
      },
      {
        "id": "IC_kwDOAQzde85Y12Hv",
        "parentId": null,
        "author": "eerhardt",
        "content": "Maybe another question to ask here (and maybe the one that @danmoseley is asking), why is DataProtection using a component that is \u0060in a state of \u0022as dead as can be while still being technically supported\u0022\u0060? Should we be re-thinking how DataProtection is designed?\r\n\r\n",
        "createdAt": "2023-03-30T15:31:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1490510319"
      },
      {
        "id": "IC_kwDOAQzde85Y14xD",
        "parentId": null,
        "author": "eerhardt",
        "content": "\u003E At the very least, look at what is involved in fixing the underlying cause, and estimate its cost vs the cost of workaround it.\r\n\r\n@jeffhandley - is it possible to get an estimate of its cost?\r\n",
        "createdAt": "2023-03-30T15:38:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1490521155"
      },
      {
        "id": "IC_kwDOAQzde85ZN5s5",
        "parentId": null,
        "author": "eerhardt",
        "content": "@JamesNK, I took a first crack at annotating the library:\r\n\r\nhttps://github.com/dotnet/runtime/compare/main...eerhardt:runtime:AnnotateSSCXml\r\n\r\nBasically, almost all the APIs have added \u0060[RequiresUnreferencedCode]\u0060 on them. This will let any developer who calls these APIs know that they may not (probably won\u0027t) work in a trimmed app.\r\n\r\nThere is more work to be done in that change:\r\n\r\n* Make a good warning message\r\n* Annotate Microsoft.Extensions.Configuration.Xml as RequiresUnreferencedCode, since it uses these APIs\r\n* (potentially) update all the places that call \u0060CryptoHelpers.CreateFromName\u0060 and throw an exception to say something like \u0022if you are trimming an application, ensure the necessary algorithms are preserved in the app\u0022. Note there are a couple places that call \u0060CreateFromName\u0060, but just return \u0060false\u0060 if \u0060null\u0060 was returned. Those won\u0027t be possible to update an exception message.\r\n\r\nWhat would you suggest to do with the warnings that will now be emitted from the ASP.NET code? For example:\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/0b10e1349063b1b5b39dd0435509abb52cc81d90/src/DataProtection/DataProtection/src/XmlEncryption/EncryptedXmlDecryptor.cs#L46-L68\r\n\r\nis now going to warn because it is using \u0060EncryptedXml.DecryptDocument()\u0060 which is marked as \u0060RequiresUnreferencedCode\u0060. Are we just going to suppress these warnings in ASP.NET? It would either be that or re-mark \u0060AddDataProtection\u0060 as \u0060RequiresUnreferencedCode\u0060 again.",
        "createdAt": "2023-04-05T01:57:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1496816441"
      },
      {
        "id": "IC_kwDOAQzde85ZN_Nm",
        "parentId": null,
        "author": "JamesNK",
        "content": "Marking \u0060AddDataProtection\u0060 with \u0060RequiresUnreferencedCode\u0060 isn\u0027t a good solution. It\u0027s used in so many places that huge parts of ASP.NET Core would also need to be annotated with \u0060RequiresUnreferencedCode\u0060: session, most (all?) of auth, Blazor, host builder (I believe the create default method uses it).\r\n\r\nPeople have been using trimming with DataProtection in .NET 7. Whatever we do today works.\r\n\r\nCan situations like the example below be turned into runtime errors? If \u0060DeformatterAlgorithm\u0060 can\u0027t be found, then throw an error saying the name might be wrong or the type might have been trimmed.\r\n\r\n\u0060\u0060\u0060cs\r\n#if NETCOREAPP\r\n        [RequiresUnreferencedCode(\u0022CreateDeformatter is not trim compatible because the algorithm implementation referenced by DeformatterAlgorithm might be removed.\u0022)]\r\n#endif\r\n        public sealed override AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key)\r\n        {\r\n            var item = (AsymmetricSignatureDeformatter)CryptoConfig.CreateFromName(DeformatterAlgorithm!)!;\r\n            item.SetKey(key);\r\n            item.SetHashAlgorithm(DigestAlgorithm!);\r\n            return item;\r\n        }\r\n\u0060\u0060\u0060\r\n\r\nThis is what I did in \u0060DataProtection\u0060:\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/419065590260e6597a994007512d03736e744da1/src/DataProtection/DataProtection/src/TypeExtensions.cs#L30-L41\r\n\r\nI\u0027d like a situation like DataProtection where all the built-in crypto types always work and then provide runtime errors if someone customizes the crypto types and they enable trimming.",
        "createdAt": "2023-04-05T02:35:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1496839014"
      },
      {
        "id": "IC_kwDOAQzde85ZON14",
        "parentId": null,
        "author": "eerhardt",
        "content": "\u003E People have been using trimming with DataProtection in .NET 7. Whatever we do today works.\r\n\r\nWe aren\u2019t doing full trimming in ASP.NET apps. By default it uses \u201Cpartial\u201D in .NET 7.\r\n\r\n\u003E Can situations like the example below be turned into runtime errors? \r\n\r\nThis isn\u2019t the intent of how we are enabling AOT and trimming. If the apps behavior can change after trimming, our intention is to give the dev a warning to let them know. There are some situations where the behavior is edge case and it would be too hard (like the DI case), but here the whole library\u2019s design is incompatible. So suppressing these warnings in dotnet/runtime isn\u2019t going to be approved.\r\n\r\nWould it be possible to remove EncryptedXml in DataProtection when in trimmed / NativeAOT? We could use a feature switch which devs could turn back on to add it back (with a single warning)? Or is EncryptedXml used too often for this approach to be feasible?",
        "createdAt": "2023-04-05T04:23:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1496898936"
      },
      {
        "id": "IC_kwDOAQzde85ZOPy1",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E Would it be possible to remove EncryptedXml in DataProtection when in trimmed / NativeAOT? We could use a feature switch which devs could turn back on to add it back (with a single warning)? Or is EncryptedXml used too often for this approach to be feasible?\r\n\r\nIt\u0027s currently fundamental to the implementation. I agree with James that DataProtection needs to work with trimming. It seems like we need to take a step back and figure out exactly how much of this needs to work. This is one of the only subsystems that does things like \u0022loads types from configuration\u0022, so it\u0027ll require more special treatment.",
        "createdAt": "2023-04-05T04:38:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1496906933"
      },
      {
        "id": "IC_kwDOAQzde85ZP4hd",
        "parentId": null,
        "author": "eerhardt",
        "content": "\u003E  It seems like we need to take a step back and figure out exactly how much of this needs to work. \r\n\r\nFor our current goals for .NET 8, which is just JWT Bearer token authentication, none of it needs to work. The issue is that just calling AddAuthentication() pulls DataProtection in, and then you get warnings - in code your app doesn\u2019t use.",
        "createdAt": "2023-04-05T11:32:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1497335901"
      },
      {
        "id": "IC_kwDOAQzde85ZQN7z",
        "parentId": null,
        "author": "eerhardt",
        "content": "A potential workable solution for the warnings:\r\n\r\n1. Annotate \u0060System.Security.Cryptography.Xml\u0060 as \u0060RequiresUnreferencedCode\u0060 as in https://github.com/dotnet/runtime/compare/main...eerhardt:runtime:AnnotateSSCXml.\r\n2. We also add some more information to the exception messages that are thrown from \u0060System.Security.Cryptography.Xml\u0060 regarding trimming. Ex. \u0022If you are trimming your application, ensure the types being used are being preserved.\u0022\r\n3. We figure out the list of commonly used crypto algorithms used by DataProtection, and add \u0060[DynamicDependency]\u0060 attributes for them. We also add some trimming/aot tests to ensure the attributes are working.\r\n4. DataProtection then suppresses the warnings coming from \u0060System.Security.Cryptography.Xml\u0060 \r\n\r\nThis solution at least solves the warnings. It doesn\u0027t solve the size problem, but that is less important (but still important, since one of the main reasons you are trimming is so your app is smaller). The main thing blocking a user from using \u0060AddAuthenticationCore()\u0060 themselves is that \u0060DefaultAuthenticationConfigurationProvider\u0060 is internal. Of the things \u0060AddAuthentication()\u0060 does:\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/419065590260e6597a994007512d03736e744da1/src/Security/Authentication/Core/src/AuthenticationServiceCollectionExtensions.cs#L19-L29\r\n\r\n\u0060AddDataProtection()\u0060 is the only thing that JWT Bearer auth doesn\u0027t need. It needs the other 4 things to be done. A user could manually do 3 of the things (AddAuthenticationCore, AddWebEncoders, Add SystemClock) but the last DefaultAuthenticationConfigurationProvider is internal.\r\n\r\nWe could make a new \u0060AddAuthentication\u0060 method that doesn\u0027t AddDataProtection, but naming that method is going to be really hard - since AddAuthenticationCore is already used.",
        "createdAt": "2023-04-05T12:41:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1497423603"
      },
      {
        "id": "IC_kwDOAQzde85ZTWYl",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E \u003E It seems like we need to take a step back and figure out exactly how much of this needs to work.\r\n\u003E \r\n\u003E For our current goals for .NET 8, which is just JWT Bearer token authentication, none of it needs to work. The issue is that just calling AddAuthentication() pulls DataProtection in, and then you get warnings - in code your app doesn\u2019t use.\r\n\r\nExcept we\u0027re encrypting the bearer tokens?",
        "createdAt": "2023-04-05T22:38:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1498244645"
      },
      {
        "id": "IC_kwDOAQzde85ZTdhR",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "\u003E Except we\u0027re encrypting the bearer tokens?\r\n\r\nHe means the existing JWT auth handler, not the token support we\u0027re adding to Identity. The JWT auth handler doesn\u0027t use Data Protection.",
        "createdAt": "2023-04-05T23:19:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1498273873"
      },
      {
        "id": "IC_kwDOAQzde85ZTdil",
        "parentId": null,
        "author": "eerhardt",
        "content": "\u003E Except we\u0027re encrypting the bearer tokens?\r\n\r\nCan you show me where?\r\n\r\nFor .NET 8, my understanding is we only need to make [this code](https://github.com/aspnet/Benchmarks/blob/7419aa092dd8ced33b61784fd00d283c25ecb78f/src/BenchmarksApps/TodosApi/Program.cs#L26-L27) work.\r\n\r\n\u0060\u0060\u0060C#\r\nbuilder.Services.AddAuthentication()\r\n    .AddJwtBearer();\r\n\u0060\u0060\u0060\r\n\r\nThat only needs to decrypt the tokens, and Microsoft.IdentityModel is doing that, as far as I know.\r\n",
        "createdAt": "2023-04-05T23:20:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1498273957"
      },
      {
        "id": "IC_kwDOAQzde85aUH0W",
        "parentId": null,
        "author": "halter73",
        "content": "Correct. JWT bearer tokens are verified using IdentityModel rather than DataProtection and AddJwtBearer is not in the business of creating tokens, but the new opaque identity tokens created by #47414 use DataProtection just like cookies.",
        "createdAt": "2023-04-19T18:59:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1515224342"
      },
      {
        "id": "IC_kwDOAQzde85myb8d",
        "parentId": null,
        "author": "jamiewinder",
        "content": "I\u0027m struggling to get a feel for where AddJwtBearer support is when using NativeAOT, especially with .NET 8 GA looming. Is there a workable solution for this now, or will one be  available by GA?",
        "createdAt": "2023-09-18T21:43:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1724497693"
      },
      {
        "id": "IC_kwDOAQzde85myqQS",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "@jamiewinder that support should land as part of an upcoming RC release.",
        "createdAt": "2023-09-18T22:37:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1724556306"
      },
      {
        "id": "IC_kwDOAQzde85og1JQ",
        "parentId": null,
        "author": "jamiewinder",
        "content": "Sorry to pester, but can we still expect this prior to release? It feels like it\u0027d be a big omission if we can\u0027t practically use JWT with NativeAOT web apps.",
        "createdAt": "2023-10-09T18:04:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1753436752"
      },
      {
        "id": "IC_kwDOAQzde85og26m",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "@eerhardt for confirmation of the status of JWT support for native AOT. My understanding is we\u0027re still on track to have this land for 8.0",
        "createdAt": "2023-10-09T18:11:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1753444006"
      },
      {
        "id": "IC_kwDOAQzde85ozRw4",
        "parentId": null,
        "author": "eerhardt",
        "content": "With the release of .NET 8 RC2 yesterday (see https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-rc-2/), JWT Bearer authentication is fully supported in Native AOT. Please update to use the 8.0 RC2 SDK and update your PackageReference to https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.JwtBearer/8.0.0-rc.2.23480.2. When publishing for NativeAOT you will no longer get warnings from inside the Microsoft.IdentityModel.* libraries.\r\n\r\nNote that this issue isn\u0027t about AOT-compatibility, but instead about size reduction. JWT Bearer auth doesn\u0027t require DataProtection in order to work. But in order to add JWT Bearer auth to your app, you need to call \u0060builder.Services.AddAuthentication()\u0060 which brings in DataProtection. This issue is tracking a way to remove the dependency on DataProtection when it isn\u0027t needed (like in the case of JWT Bearer auth).",
        "createdAt": "2023-10-11T18:32:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1758272568"
      },
      {
        "id": "IC_kwDOAQzde85te0-z",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-12-01T21:24:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-1836797875"
      },
      {
        "id": "IC_kwDOAQzde86BGx8q",
        "parentId": null,
        "author": "mcallaghan-geotab",
        "content": "What is the workaround here? For non-AOT builds, that ONLY use JWT for authentication, on .NET8.\r\n\r\nWe have log spam with this warning\r\n\u0060\u0060\u0060\r\nwarn: Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository[60]\r\n      Storing keys in a directory \u0027/home/\u003Cuser\u003E/.aspnet/DataProtection-Keys\u0027 that may not be persisted outside of the container. Protected data will be unavailable when container is destroyed. For more information go to https://aka.ms/aspnet/dataprotectionwarning\r\n\u0060\u0060\u0060",
        "createdAt": "2024-06-13T15:40:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2166038314"
      },
      {
        "id": "IC_kwDOAQzde86BG-CR",
        "parentId": null,
        "author": "martincostello",
        "content": "One workaround would be to set the log level of \u0060Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository\u0060 to \u0060Error\u0060.",
        "createdAt": "2024-06-13T15:58:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2166087825"
      },
      {
        "id": "IC_kwDOAQzde86BHDmw",
        "parentId": null,
        "author": "mcallaghan-geotab",
        "content": "\u003E One workaround would be to set the log level of \u0060Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository\u0060 to \u0060Error\u0060.\r\n\r\nTrue (definitely valid point) - that should work;\r\n\r\nI was thinking about a mechanism to disable **DataProtection** entirely via an explicit call to \u0060AddDataProtection\u0060 in DI with options to disable.",
        "createdAt": "2024-06-13T16:05:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2166110640"
      },
      {
        "id": "IC_kwDOAQzde86BkdNt",
        "parentId": null,
        "author": "eerhardt",
        "content": "@amcasey - any thoughts on the above scenario and warning?",
        "createdAt": "2024-06-17T16:13:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2173817709"
      },
      {
        "id": "IC_kwDOAQzde86CZDX9",
        "parentId": null,
        "author": "amcasey",
        "content": "I can\u0027t tell what the goal is.  If you just don\u0027t want to get the log message, I\u0027d agree with @martincostello that you can just disable it.  If your goal is to make it not run, you\u0027d have to experiment, since there\u0027s no designed/recommended way to do that.  For example, you could register your own dummy repository and encryptor that no-op or throw, depending on your scenario.  Alternatively, you might be able to go upstream and replace the data protection provider.",
        "createdAt": "2024-06-24T23:32:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2187605501"
      },
      {
        "id": "IC_kwDOAQzde86CZ26d",
        "parentId": null,
        "author": "mcallaghan-geotab",
        "content": "I will ask plainly perhaps:  why did we change the DI to add a dependency that spams the logs with a warning when configured using a very common authentication method (\u0060JwtBearer\u0060) when the log message isn\u0027t even applicable?\r\n\r\nThat warning message is very confusing and at first seems very concerning until we spend time to understand what is going on (since .NET8) and eventually find this upstream issue. Of course the warning _MAY_ actually be important for other use cases (but it is difficult to know if it is relevant).\r\n\r\nHiding the log message is a workaround for most just to keep production systems ticking without raising false alarm bells in operations. (and it poses the risk that if some point in the future \u0060DataProtection\u0060 is actually put into use (explicitly or implicitly) we wouldn\u0027t get any other warnings from that).\r\n\r\nAs I understand it, the purpose of this ticket is to come up with a solution that allows either better control over the DI (either implicit dependencies or configurability perhaps?).",
        "createdAt": "2024-06-25T02:11:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2187816605"
      },
      {
        "id": "IC_kwDOAQzde86Cfwx0",
        "parentId": null,
        "author": "amcasey",
        "content": "Sorry, @mcallaghan-geotab, I didn\u0027t mean to imply that your question was unclear - just that I was coming in late without full context.  Thanks for clarifying!\r\n\r\nThat log message has been produced by data protection for many years, so something has probably changed in the way data protection is being configured.  I think I understand from your description that your app worked properly (i.e. without logging) on a previous version of aspnetcore (6.0? 7.0?) and, after upgrading to 8.0 - without code changes - has started producing this confusing log message.  Is that correct?  If so, my guess would be that some change within 8.0, perhaps to improve AOT/trimming support - removed a data protection configuration call that used to make that log warning unnecessary (e.g. setting a different storage location).\r\n\r\nTo provide a little context, that log message is intended to be displayed (primarily) when the app is running in a docker container and the keys are stored in a location that won\u0027t survive container restarts (e.g. a directory that isn\u0027t mounted from the host).",
        "createdAt": "2024-06-25T16:06:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2189364340"
      },
      {
        "id": "IC_kwDOAQzde86Cg34I",
        "parentId": null,
        "author": "mcallaghan-geotab",
        "content": "No problem @amcasey  :) - yes you have roughly described the situation.  To add:\r\n* k8s application (yes runs in a docker container)\r\n* using only JwtBearer authentication\r\n* previously fine through .NET6, .NET7\r\n* warning logs started after .NET8 upgrade",
        "createdAt": "2024-06-25T18:11:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2189655560"
      },
      {
        "id": "IC_kwDOAQzde86ChehR",
        "parentId": null,
        "author": "amcasey",
        "content": "So, from Data Protection\u0027s perspective, everything is (and was) working correctly - the app is running in a container and the storage folder isn\u0027t on a mounted file system, so it logs a warning.  Obviously, it has no way to know that its keys will never actually be used.\r\n\r\nThat doesn\u0027t mean we can\u0027t improve the user experience though.  I looked through some of the ways to explicitly configure data protection to not store keys in a persistent manner, but they basically exist as fallbacks, so they all log warnings.  It\u0027s not hard to configure your own dummy storage system, but I agree that that shouldn\u0027t be necessary.\r\n\r\n@eerhardt Do you already know what changed in 8.0 in this area?  My guess would be that we used to explicitly configure some other xml repository and now we don\u0027t?  Having said that, it\u0027s not really clear to me what that configuration could have been - where would you store the keys that you know, a priori, is persistent?\r\n\r\n",
        "createdAt": "2024-06-25T19:28:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2189813841"
      },
      {
        "id": "IC_kwDOAQzde86ChfLe",
        "parentId": null,
        "author": "amcasey",
        "content": "@mcallaghan-geotab Would you be able to collect trace-level logs for Microsoft.AspNetCore.DataProtection from your pre-8.0 app?  That would tell us where the keys are being stored.",
        "createdAt": "2024-06-25T19:30:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2189816542"
      },
      {
        "id": "IC_kwDOAQzde86Chf9f",
        "parentId": null,
        "author": "amcasey",
        "content": "FWIW, [this](https://github.com/dotnet/aspnetcore/blob/ce80910dbb3c662e309b6eeeab775e8134010786/src/DataProtection/DataProtection/src/Repositories/FileSystemXmlRepository.cs#L39) is the log statement.",
        "createdAt": "2024-06-25T19:32:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2189819743"
      },
      {
        "id": "IC_kwDOAQzde86ChgwD",
        "parentId": null,
        "author": "eerhardt",
        "content": "\u003E @eerhardt Do you already know what changed in 8.0 in this area?\r\n\r\nNot off the top of my head, no. https://github.com/dotnet/aspnetcore/pull/48082 is the change I made to make DataProtection as trim-compatible as I could.",
        "createdAt": "2024-06-25T19:33:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2189822979"
      },
      {
        "id": "IC_kwDOAQzde86Chpk_",
        "parentId": null,
        "author": "amcasey",
        "content": "\u003E \u003E @eerhardt Do you already know what changed in 8.0 in this area?\r\n\u003E \r\n\u003E Not off the top of my head, no. #48082 is the change I made to make DataProtection as trim-compatible as I could.\r\n\r\nThose look like changes _to_ data protection and they look fine.  I was wondering about changes to how data protection is called.",
        "createdAt": "2024-06-25T19:56:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2189859135"
      },
      {
        "id": "IC_kwDOAQzde86ChrXD",
        "parentId": null,
        "author": "eerhardt",
        "content": "\u003E I was wondering about changes to how data protection is called.\r\n\r\nI didn\u0027t make any changes like that in .NET 8. I wanted to (which is why I opened this issue), but we never agreed on how to design it.",
        "createdAt": "2024-06-25T20:01:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2189866435"
      },
      {
        "id": "IC_kwDOAQzde86ChscS",
        "parentId": null,
        "author": "amcasey",
        "content": "Yeah, the current state seems expected to me - it\u0027s the fact that there was apparently no log message in 7.0 that seems strange.  [This](https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2189816542) seems like the next step, if you can spare the time, @mcallaghan-geotab. ",
        "createdAt": "2024-06-25T20:04:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2189870866"
      },
      {
        "id": "IC_kwDOAQzde86ChuGX",
        "parentId": null,
        "author": "mcallaghan-geotab",
        "content": "\u003E @mcallaghan-geotab Would you be able to collect trace-level logs for Microsoft.AspNetCore.DataProtection from your pre-8.0 app? That would tell us where the keys are being stored.\r\n\r\nwe\u0027re not storing any keys for anything (I dug deeply to confirm this - which led to the conclusion that we can omit/hide the warning logs for now)\r\n\r\nCorrection: It _IS_ possible actually that the logs started in .NET7; (several software systems at play) ",
        "createdAt": "2024-06-25T20:07:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2189877655"
      },
      {
        "id": "IC_kwDOAQzde86ChxRy",
        "parentId": null,
        "author": "amcasey",
        "content": "\u003E we\u0027re not storing any keys for anything (I dug deeply to confirm this - which led to the conclusion that we can omit/hide the warning logs for now)\r\n\r\nI think it will generate one on your behalf and log where it puts it, but I\u0027m not certain.\r\n\r\n\u003E Correction: It IS possible actually that the logs started in .NET7; (several software systems at play)\r\n\r\nNo worries - apples to apples comparisons across upgrades are virtually impossible.\r\n\r\nIf I can summarize then: your user experience is suboptimal but probably not a regression and you have a workaround?  This issue tracks making a real fix, which will probably involve making it possible to omit data protection entirely in scenarios like this.\r\n\r\nAssuming I\u0027ve got that correct, can you please thumbs-up the description of this issue?  That makes it easier for us to assess the user impact of issues like these and prioritize them appropriately.\r\n\r\nThanks for your patience and sorry for the wasted time!",
        "createdAt": "2024-06-25T20:16:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2189890674"
      },
      {
        "id": "IC_kwDOAQzde86Inuvd",
        "parentId": null,
        "author": "amcasey",
        "content": "I\u0027ve seen this question several times, so we should revisit it during 10 planning.",
        "createdAt": "2024-08-15T20:04:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47410#issuecomment-2292116445"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85iPRhn",
    "title": "Cookie session ID cannot be regenerated when using a custom ticket store",
    "url": "https://github.com/dotnet/aspnetcore/issues/47503",
    "createdAt": "2023-03-30T19:12:47Z",
    "lastUpdated": "2024-02-13T01:38:30Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\n[OWASP\u0027s session management cheat sheet requires that a session id is regenerated after any privilege level change](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#renew-the-session-id-after-any-privilege-level-change). This is required to prevent session fixation attacks.\r\n\r\nIf an application wants to change the privilege level of a user (e.g. switching from user role to admin role), currently there is no way to implement this without introducing a session fixation vulnerability when an application is configured for cookie authentication with a [SessionStore](https://github.com/dotnet/aspnetcore/blob/c0acf059eddd7e70498804dcc99a7c7b33732417/src/Security/Authentication/Cookies/src/CookieAuthenticationOptions.cs#L122).\r\n\r\nWhen trying to use \u0060SignInAsync\u0060 with the updated principal that has elevated claims, the previous session id is reused.\r\n\r\nAttempted workarounds by first calling \u0060SignOutAsync\u0060 does remove the session from the ticket store, but the session id is still cached in \u0060CookieAuthenticationHandler\u0060. So, if \u0060SignInAsync\u0060 is called later in the same request, the previously cached session id is reused.\r\n\r\nThe behavior was introduced as part of #22135 (MR #22732) that renewed the session id rather than storing a new one.\n\n### Expected Behavior\n\nCalling \u0060SignInAsync\u0060 should not make creating session-fixation bugs so easy.\n\n### Steps To Reproduce\n\nRepro xunit test is here: https://github.com/ccurrens/session-fixation-repro\r\n\r\nThe same code runs twice for cookie authentication, once with a custom SessionStore (failure) and once without (succeeds).\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n.NET 5\u002B\n\n### Anything else?\n\nAt the very least, \u0060SignOutAsync\u0060 should remove clear the cached \u0060sessionKey\u0060 so that subsequent calls in the same request to \u0060SignInAsync\u0060 can switch users roles and store with a separate session id.\r\n\r\nIt would be great if \u0060SignInAsync\u0060 would always issue a new session id. Of course, this causes the issue in #22135, which happens when the session is being refreshed. If there was a way to pass along state perhaps in \u0060AuthenticationProperties\u0060 to tell the handler to generate a new session key, that could also work.\r\n\r\nI think ideally \u0060SignInAsync\u0060 should only reuse the session id if its coming from the authentication handler (e.g., the session is being refreshed). If the call is coming from user code, it should generate a new session so that developers don\u0027t have to explicitly opt-in to behavior that would prevent session fixation (it should behave that way by default).",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85zFi1G",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2024-02-06T22:07:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47503#issuecomment-1930833222"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85i17FJ",
    "title": "Investigate AuthN/AuthZ metrics in ASP.NET Core",
    "url": "https://github.com/dotnet/aspnetcore/issues/47603",
    "createdAt": "2023-04-07T03:11:43Z",
    "lastUpdated": "2025-01-06T18:08:22Z",
    "body": "Issue https://github.com/dotnet/aspnetcore/issues/47536 adds metrics for existing counters.\r\n\r\nWe should investigate where adding new metrics makes sense in ASP.NET Core. Metrics are easier to add and test than old event counters. And tags make them more powerful.\r\n\r\nInitial ideas:\r\n\r\n* [x] **Rate limiting** - queue counts\r\n* [x] **Routing** - match/fallback/no match counts\r\n* [ ] **AuthN/AuthZ** - success/failure counts\r\n\r\n---\r\n\r\nAuthZ\r\n- Number of requests that require authz\r\n   - Policy name\r\n   - Result (success/failure)\r\n\r\n---\r\n\r\nAuthN\r\n- Challenge count\r\n   - Scheme name\r\n- Authenticated requests count - don\u0027t record for result\r\n   - Scheme name\r\n   - Result (success/failure/noop) \r\n\r\nSign in handler\r\n- Sign in count\r\n   - Scheme name\r\n\r\nSign out handler\r\n- Sign out count\r\n   - Scheme name\r\n",
    "upvotes": 1,
    "labels": [
      "enhancement",
      "area-auth",
      "feature-observability"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85bPBX-",
        "parentId": null,
        "author": "mitchdenny",
        "content": "Output Caching metrics might be another good idea. I\u0027m also wondering whether anything makes sense around health checks - although they can probably be seen within the scope of the existing metrics.",
        "createdAt": "2023-05-02T00:23:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47603#issuecomment-1530664446"
      },
      {
        "id": "IC_kwDOAQzde85bmRpS",
        "parentId": null,
        "author": "amcasey",
        "content": "This is mostly for outside kestrel, right?  #47831 covers the remaining work there?",
        "createdAt": "2023-05-05T20:43:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47603#issuecomment-1536760402"
      },
      {
        "id": "IC_kwDOAQzde85bncA5",
        "parentId": null,
        "author": "JamesNK",
        "content": "Yes",
        "createdAt": "2023-05-06T06:21:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47603#issuecomment-1537065017"
      },
      {
        "id": "IC_kwDOAQzde85ekJam",
        "parentId": null,
        "author": "JamesNK",
        "content": "cc @halter73 @JeremyLikness ",
        "createdAt": "2023-06-12T03:56:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47603#issuecomment-1586534054"
      },
      {
        "id": "IC_kwDOAQzde85tixy0",
        "parentId": null,
        "author": "SeanFarrow",
        "content": "As someone working in the authentication space and looking at metrics currently, I\u0027d be interested in helping out with this.",
        "createdAt": "2023-12-04T04:43:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47603#issuecomment-1837833396"
      },
      {
        "id": "IC_kwDOAQzde85tqlEq",
        "parentId": null,
        "author": "JamesNK",
        "content": "The first step is to figure out what the metrics are. The issue includes some notes from discussing metrics with @halter73 @JeremyLikness. I think they\u0027re the folks that need to come up with what the spec is we want in .NET 9.",
        "createdAt": "2023-12-05T02:08:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47603#issuecomment-1839878442"
      },
      {
        "id": "IC_kwDOAQzde86Gwkac",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "We ended up cutting this out from .NET 9 as we don\u0027t have capacity to tackle this in time.",
        "createdAt": "2024-07-31T16:09:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47603#issuecomment-2260879004"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85lOmGo",
    "title": "How to accept a client certificate signed by an untrusted CA in Asp .netcore?",
    "url": "https://github.com/dotnet/aspnetcore/issues/48099",
    "createdAt": "2023-05-06T00:13:51Z",
    "lastUpdated": "2024-09-04T08:31:27Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nI have created a client and a server application to demonstrate Mutual TLS (mTLS). I generated a client certificate and had it signed by a local CA. However, the CA is not trusted by the server. I want to bypass any certificate validation on the server.\r\n\r\nI can confirm that the server has received the client certificate, but the\r\nOnAuthenticationFailed is fired and the attached exception is Client certificate failed validation.\r\n\r\nUpon debugging, I found that it is CertificateAuthenticationHandler (source code [here](https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Certificate/src/CertificateAuthenticationHandler.cs)) that rejects the certificate. Also, I think it is due the failed certificate chain validation ([here](https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authentication/Certificate/src/CertificateAuthenticationHandler.cs#L143)).\r\n\r\n\r\n### Expected Behavior\r\n\r\n\u0060AllowAnyClientCertificate\u0060 disables further validation a client certificate.\r\n\r\n### Steps To Reproduce\r\n\r\n\u0060\u0060\u0060csharp\r\n public class Program\r\n    {\r\n        public static void Main(string[] args)\r\n        {\r\n            var builder = WebApplication.CreateBuilder(args);\r\n\r\n            builder.Services.Configure\u003CKestrelServerOptions\u003E(options =\u003E\r\n            {\r\n                options.ConfigureHttpsDefaults(options =\u003E\r\n                {\r\n                    options.AllowAnyClientCertificate();\r\n                    options.CheckCertificateRevocation = false;\r\n                    options.ClientCertificateValidation = ClientCertificateValidation;\r\n                    options.ClientCertificateMode = ClientCertificateMode.AllowCertificate;\r\n                });\r\n            });\r\n\r\n            // Add services to the container.\r\n\r\n            builder.Services.AddControllers();\r\n\r\n            ConfigureServices(builder.Services);\r\n\r\n            var app = builder.Build();\r\n\r\n            // Configure the HTTP request pipeline.\r\n\r\n            app.UseHttpsRedirection();\r\n\r\n            app.UseAuthentication();\r\n\r\n            app.MapControllers();\r\n\r\n            app.Run();\r\n        }\r\n\r\n        private static bool ClientCertificateValidation(X509Certificate2 arg1, X509Chain? arg2, SslPolicyErrors arg3)\r\n        {\r\n            return true;\r\n        }\r\n\r\n        private static void ConfigureServices(IServiceCollection services)\r\n        {\r\n            services\r\n               .AddAuthentication(CertificateAuthenticationDefaults.AuthenticationScheme)\r\n               .AddCertificate(options =\u003E\r\n               {\r\n                   options.RevocationMode = X509RevocationMode.NoCheck;\r\n                   options.ChainTrustValidationMode = X509ChainTrustMode.CustomRootTrust;\r\n                   options.AllowedCertificateTypes = CertificateTypes.All;\r\n                   options.ValidateCertificateUse = false;\r\n                   options.ValidateValidityPeriod = false;\r\n\r\n                   options.Events = new CertificateAuthenticationEvents\r\n                   {\r\n                       OnAuthenticationFailed = p =\u003E\r\n                       {\r\n                           Console.WriteLine(p.Exception);\r\n                           return Task.CompletedTask;\r\n\r\n                       },\r\n                       OnCertificateValidated = context =\u003E\r\n                       {\r\n                           // Add certificate to HttpContext.Items\r\n                           context.HttpContext.Items[\u0022ClientCertificate\u0022] = context.ClientCertificate;\r\n                           return Task.CompletedTask;\r\n                       }\r\n                   };\r\n               });\r\n        }\r\n    }\r\n\u0060\u0060\u0060\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n7.0.100\r\n\r\n### Anything else?\r\n\r\n_No response_",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85b0qPc",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "@alexiwonder please share the logs so that we can see what is going on here. Thanks!",
        "createdAt": "2023-05-09T16:53:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-1540531164"
      },
      {
        "id": "IC_kwDOAQzde85b0qiX",
        "parentId": null,
        "author": "halter73",
        "content": "Can you enable (preferably trace-level) [ASP.NET Core Logging](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-5.0) and provide the logs from when the issue occurs?",
        "createdAt": "2023-05-09T16:54:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-1540532375"
      },
      {
        "id": "IC_kwDOAQzde85b0qk7",
        "parentId": null,
        "author": "??",
        "content": "Hi @alexiwonder. We have added the \u0022Needs: Author Feedback\u0022 label to this issue, which indicates that we have an open question for you before we can take further action. This issue will be closed automatically in 7 days if we do not hear back from you by then - please feel free to re-open it if you come back to this issue after that time.",
        "createdAt": "2023-05-09T16:54:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-1540532539"
      },
      {
        "id": "IC_kwDOAQzde85cNeOV",
        "parentId": null,
        "author": "??",
        "content": "This issue has been automatically marked as stale because it has been marked as requiring author feedback but has not had any activity for **4 days**. It will be closed if no further activity occurs **within 3 days of this comment**. If it *is* closed, feel free to comment when you are able to provide the additional information and we will re-investigate.\n\nSee [our Issue Management Policies](https://aka.ms/aspnet/issue-policies) for more information.",
        "createdAt": "2023-05-15T00:00:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-1547035541"
      },
      {
        "id": "IC_kwDOAQzde85cOoUk",
        "parentId": null,
        "author": "alexiwonder",
        "content": "Sorry @halter73 and @mkArtakMSFT for late reply.\r\nHere\u0027s the logs:\r\n\r\n\u0060\u0060\u0060\r\ndbug: Microsoft.Extensions.Hosting.Internal.Host[1]\r\n      Hosting starting\r\ninfo: Microsoft.Hosting.Lifetime[14]\r\n      Now listening on: https://localhost:54321\r\ninfo: Microsoft.Hosting.Lifetime[0]\r\n      Application started. Press Ctrl\u002BC to shut down.\r\ninfo: Microsoft.Hosting.Lifetime[0]\r\n      Hosting environment: Development\r\ninfo: Microsoft.Hosting.Lifetime[0]\r\n      Content root path: C:\\Projects\\Demo\\Server\\\r\ndbug: Microsoft.Extensions.Hosting.Internal.Host[2]\r\n      Hosting started\r\nwarn: Microsoft.AspNetCore.Authentication.Certificate.CertificateAuthenticationHandler[2]\r\n      Certificate validation failed, subject was CN=localhost. PartialChain A certificate chain could not be built to a trusted root authority.\r\nSystem.Exception: Client certificate failed validation.\r\nwarn: Microsoft.AspNetCore.Authentication.Certificate.CertificateAuthenticationHandler[2]\r\n      Certificate validation failed, subject was CN=localhost. PartialChain A certificate chain could not be built to a trusted root authority.\r\nSystem.Exception: Client certificate failed validation.\r\n\u0060\u0060\u0060",
        "createdAt": "2023-05-15T07:37:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-1547339044"
      },
      {
        "id": "IC_kwDOAQzde85cTJlq",
        "parentId": null,
        "author": "halter73",
        "content": "@blowdart @Tratcher Do either of you know whether this is a supported scenario for \u0060AddCertificate\u0060? This sets \u0060options.ValidateCertificateUse = false\u0060, but that just disables the EKU check.\r\n\r\nI don\u0027t see a way to completely disable validating the chain. Do you need to add the root or self-signed certificate to \u0060CertificateAuthenticationOptions.CustomTrustStore\u0060? That\u0027d be my guess. We probably don\u0027t want to make it too easy to accept literally any certificate with the \u0060CertificateAuthenticationHandler\u0060 even if Kestrel allows it during the TLS handshake.",
        "createdAt": "2023-05-15T20:23:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-1548523882"
      },
      {
        "id": "IC_kwDOAQzde85clhny",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "@blowdart, @Tratcher can you confirm the above ? Thanks!",
        "createdAt": "2023-05-18T16:54:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-1553340914"
      },
      {
        "id": "IC_kwDOAQzde85cncg5",
        "parentId": null,
        "author": "blowdart",
        "content": "I\u0027d still be guessing like Stephen, but ValidateCertificateUse is definitely only limited to EKU checks, as that\u0027s what the use refers to. Completely separate to chain trusts or anything of that ilk. The CustomTrustStore would be the way to go",
        "createdAt": "2023-05-19T00:21:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-1553844281"
      },
      {
        "id": "IC_kwDOAQzde85dE4pX",
        "parentId": null,
        "author": "halter73",
        "content": "@blowdart Would we consider adding something like \u0060CertificateAuthenticationOptions.ClientCertificateValidation\u0060 that allows you to have complete control over cert validation using a bool-returning delegate? And bypass any default cert chain or EKU checks?\r\n\r\nThis would be similar to what Kestrel (\u0060ClientCertificateValidation\u0060), HttpClient (\u0060ServerCertificateValidationCallback\u0060) and SslStream (\u0060RemoteCertificateValidationCallback\u0060) already expose. @javiercn sounds like he\u0027d be in favor of this.",
        "createdAt": "2023-05-24T16:39:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-1561561687"
      },
      {
        "id": "IC_kwDOAQzde85dE6Zl",
        "parentId": null,
        "author": "javiercn",
        "content": "Yeah, it\u0027s very aggressive that we don\u0027t leave a backdoor for development in these cases. Forces people into a non-trivial dev setup.",
        "createdAt": "2023-05-24T16:43:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-1561568869"
      },
      {
        "id": "IC_kwDOAQzde85dE6el",
        "parentId": null,
        "author": "Tratcher",
        "content": "At that point why even use the cert auth handler?",
        "createdAt": "2023-05-24T16:43:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-1561569189"
      },
      {
        "id": "IC_kwDOAQzde85dE9Tw",
        "parentId": null,
        "author": "blowdart",
        "content": "I have no problem with it, as long as it\u0027s off by default.\r\n\r\nYou should mirror HttpClientHandler.DangerousAcceptAnyServerCertificateValidator\u0027s approach and ensure there\u0027s one named the same way that will work for cert auth.",
        "createdAt": "2023-05-24T16:48:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-1561580784"
      },
      {
        "id": "IC_kwDOAQzde85dJKor",
        "parentId": null,
        "author": "alexiwonder",
        "content": "Hello all,\r\nSorry for interrupting your conversation. \r\nJust wanted to update you that I made a small change by removing \r\n\u0060options.ChainTrustValidationMode = X509ChainTrustMode.CustomRootTrust;\u0060 line and now the server is accepting the presented client certificate. Plus, \u0060OnAuthenticationFailed\u0060 callback is not invoked anymore:\r\n\u0060\u0060\u0060\r\n.AddCertificate(options =\u003E\r\n{\r\n   options.RevocationMode = X509RevocationMode.NoCheck;\r\n   options.AllowedCertificateTypes = CertificateTypes.All;\r\n}\r\n\u0060\u0060\u0060\r\nI also cleaned up some of the configs that appeared to have no impact on both Kestrel and certificate authentication in the scenario of disabling all the client certificate validations.\r\n\r\nSo the final working version of the server is:\r\n\u0060\u0060\u0060\r\npublic class Program\r\n{\r\n    public static void Main(string[] args)\r\n    {\r\n        var builder = WebApplication.CreateBuilder(args);\r\n\r\n        builder.Services.Configure\u003CKestrelServerOptions\u003E(options =\u003E\r\n        {\r\n            options.ConfigureHttpsDefaults(options =\u003E\r\n            {\r\n                options.AllowAnyClientCertificate();\r\n                options.ClientCertificateMode = ClientCertificateMode.AllowCertificate;\r\n            });\r\n        });\r\n\r\n        // Add services to the container.\r\n\r\n        builder.Services.AddControllers();\r\n\r\n        ConfigureServices(builder.Services);\r\n\r\n        var app = builder.Build();\r\n\r\n        // Configure the HTTP request pipeline.\r\n\r\n        app.UseHttpsRedirection();\r\n\r\n        app.UseAuthentication();\r\n\r\n        app.MapControllers();\r\n\r\n        app.Run();\r\n    }\r\n\r\n    private static void ConfigureServices(IServiceCollection services)\r\n    {\r\n        services\r\n           .AddAuthentication(CertificateAuthenticationDefaults.AuthenticationScheme)\r\n           .AddCertificate(options =\u003E\r\n           {\r\n               options.RevocationMode = X509RevocationMode.NoCheck;\r\n               options.AllowedCertificateTypes = CertificateTypes.All;\r\n\r\n               options.Events = new CertificateAuthenticationEvents\r\n               {\r\n                   OnAuthenticationFailed = p =\u003E\r\n                   {\r\n                       Console.WriteLine(p.Exception);\r\n                       return Task.CompletedTask;\r\n\r\n                   },\r\n                   OnCertificateValidated = context =\u003E\r\n                   {\r\n                       // Add certificate to HttpContext.Items\r\n                       context.HttpContext.Items[\u0022ClientCertificate\u0022] = context.ClientCertificate;\r\n                       return Task.CompletedTask;\r\n                   }\r\n               };\r\n           });\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\nI have no solid explanation why this is working. Any clarification is highly appreciated.\r\n\r\nThanks all for your attention.",
        "createdAt": "2023-05-25T10:43:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-1562683947"
      },
      {
        "id": "IC_kwDOAQzde85mn2Hq",
        "parentId": null,
        "author": "Vaccano",
        "content": "I too would love an explanation as to why this worked for alexiwonder.  I have been stuck with this same issue for a while and I cannot seem to find a way around it.\r\n\r\nI tried alexiwonder\u0027s code and I still hit the \u0060OnAuthenticationFailed\u0060 event.\r\n\r\nI struggle on how to implement the \u0027CustomTrustStore\u0060, as I don\u0027t own certificate that our company uses to sign all of our internal certificates...",
        "createdAt": "2023-09-15T19:06:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-1721721322"
      },
      {
        "id": "IC_kwDOAQzde85mn8xD",
        "parentId": null,
        "author": "Vaccano",
        "content": "I was able to get a copy of our root cert for the \u0060CustomTrustStore\u0060.  Adding that in got it working! Here is some sample code:\r\n\r\n\u0060\u0060\u0060\r\nvar certString = \u0022-----BEGIN CERTIFICATE-----\\r\\nIMI     \u003EYour Cert Data Here\u003C   humv\\r\\n-----END CERTIFICATE-----\u0022;\r\nReadOnlySpan\u003Cchar\u003E rootCert = new ReadOnlySpan\u003Cchar\u003E(certString .ToCharArray());\r\nvar rootCertificate2 = X509Certificate2.CreateFromPem(rootCert);\r\noptions.CustomTrustStore.Add(rootCertificate2);\r\noptions.ChainTrustValidationMode = X509ChainTrustMode.CustomRootTrust;\r\n\u0060\u0060\u0060\r\n\r\nThis is added in the \u0060AddCertificate\u0060 lambda method.",
        "createdAt": "2023-09-15T19:34:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-1721748547"
      },
      {
        "id": "IC_kwDOAQzde85zFmvC",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2024-02-06T22:16:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-1930849218"
      },
      {
        "id": "IC_kwDOAQzde86A9jAf",
        "parentId": null,
        "author": "stephannn",
        "content": "Hi @Vaccano ,\r\nI am struggling with the same issue. I modified my code like that:\r\n\r\n\u0060\u0060\u0060\r\n            options.RevocationMode = X509RevocationMode.NoCheck;\r\n            options.AllowedCertificateTypes = CertificateTypes.All;\r\n\r\n            List\u003Cstring\u003E customTrust = builder.Configuration.GetSection(\u0022Certificate\u0022).GetSection(\u0022TrustStore\u0022).Get\u003CList\u003Cstring\u003E\u003E() ?? new List\u003Cstring\u003E();  \r\n            if (customTrust != null \u0026\u0026 customTrust.Count != 0)\r\n            {\r\n                foreach (var customTrustSingle in customTrust) {\r\n                    try\r\n                    {\r\n                        options.CustomTrustStore.Add(new X509Certificate2(Path.Combine(customTrustSingle)));\r\n                        Console.WriteLine($\u0022Added custom trust certificate: {customTrustSingle}\u0022);\r\n                    }\r\n                    catch (Exception ex)\r\n                    {\r\n                        Console.WriteLine($\u0022Failed to add custom trust certificate: {customTrustSingle}, Error: {ex.Message}\u0022);\r\n                    }\r\n                }\r\n                options.ChainTrustValidationMode = X509ChainTrustMode.CustomRootTrust;\r\n            }\r\n           \r\n            options.ValidateCertificateUse = false;\r\n            options.ValidateValidityPeriod = false;\r\n\u0060\u0060\u0060\r\n\r\nin the customTrust list I load my root and intermediate certificate but getting still the warning about it:\r\n\u0060\u0060\u0060\r\nCertificate validation failed, subject was CN=PC1.contoso.com. PartialChain unable to get local issuer certificate\r\nMicrosoft.AspNetCore.Authentication.Certificate.CertificateAuthenticationHandler: Warning: Certificate validation failed, subject was CN=PC1.contoso.org. PartialChain unable to get local issuer certificate\r\n\u0060\u0060\u0060\r\nand it hits the OnAuthenticationFailed event.\r\n\r\nI also uploaded it to an Azure Web App and I also cannot use the certificate authentication. I have to say, I do not know how to add the root and intermediate cert to the Web App, but this is actually the CustomRootStore for, isn\u0027t it?\r\n\r\nEdit:\r\nIssue was a new intermediate cert that I did not put. After that it hits the OnCertificateValidated event. Please ignore!",
        "createdAt": "2024-06-12T18:00:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-2163617823"
      },
      {
        "id": "IC_kwDOAQzde86KxiwG",
        "parentId": null,
        "author": "Varorbc",
        "content": "I wonder what the CustomRootStore does and it doesn\u0027t work for me either",
        "createdAt": "2024-09-04T08:31:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48099#issuecomment-2328243206"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85qdSCw",
    "title": "Suggested improvements to RevalidatingServerAuthenticationStateProvider",
    "url": "https://github.com/dotnet/aspnetcore/issues/49176",
    "createdAt": "2023-07-03T12:16:08Z",
    "lastUpdated": "2024-02-13T01:31:29Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Is your feature request related to a problem? Please describe the problem.\r\n\r\nI wish to have RevalidatingServerAuthenticationStateProvider improved to accomplish the following:\r\n\r\n1. Revalidate immediately upon the start of a new circuit/session as the retained AuthenticationState that is used upon establishing the circuit is from a cookie (as I understand it) that may be from a session 5 seconds ago, but also 5 days ago.\r\n2. When revalidating, update the user so it has the latest claims as those have just been read from the DB. You have it - use it.\r\n3. Provide a call to revalidate immediately. If my code is updating the user account and gets a DbUpdateConcurrencyException for the update (due to that record not existing), then need to revalidate immediately.\r\n\r\n### Describe the solution you\u0027d like\r\n\r\nItems 1 \u0026 3 above can be solved by changing Task.Delay() to a ManualResetEvent that has a timeout of RevalidationInterval but can also be signaled. And move the location of that to the bottom of the \u0060while (!cancellationToken.IsCancellationRequested)\u0060 loop so when the task is first started, it revalidates immediately.\r\n\r\nItem 2 can be resolved easiest in RevalidatingIdentityAuthenticationStateProvider where it calls base.SetAuthenticationState() with the user it read in. That\u0027s easiest. \r\n\r\nWith that said, I think a better solution is for RevalidatingServerAuthenticationStateProvider.ValidateAuthenticationStateAsync to be defined as returning a \u0060Task\u003CAuthenticationState\u003E\u0060 where null means not valid and non-null is then set. However, that would break the API and as such is probably not a good idea.\r\n\r\n### Additional context\r\n\r\n**Update:** For item 2 above, I misunderstood something. This is not easy unless there\u0027s a call somewhere I am not aware of. It remains a very useful goal. But is there a way to get a ClaimsPrincipal rebuilt anew from what\u0027s in the Identity database? Or takes the existing AuthenticationState and updates the Claims and whatever else to create a ClaimsPrincipal that matches the database?\r\n\r\n_No response_",
    "upvotes": 1,
    "labels": [
      "enhancement",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85gr9sE",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "Thanks for contacting us.\r\nThe RevalidatingServerAuthenticationStateProvider type is expected to be overridden, as it\u0027s [done in the template](https://github.com/dotnet/aspnetcore/blob/release/7.0/src/ProjectTemplates/Web.ProjectTemplates/content/BlazorServerWeb-CSharp/Areas/Identity/RevalidatingIdentityAuthenticationStateProvider.cs).\r\nYou can customize the logic as you wish in the child class. If you believe this is impossible, please clarify why.",
        "createdAt": "2023-07-05T16:54:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49176#issuecomment-1622137604"
      },
      {
        "id": "IC_kwDOAQzde85gr9vs",
        "parentId": null,
        "author": "??",
        "content": "Hi @DavidThielen. We have added the \u0022Needs: Author Feedback\u0022 label to this issue, which indicates that we have an open question for you before we can take further action. This issue will be closed automatically in 7 days if we do not hear back from you by then - please feel free to re-open it if you come back to this issue after that time.",
        "createdAt": "2023-07-05T16:54:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49176#issuecomment-1622137836"
      },
      {
        "id": "IC_kwDOAQzde85gsjA3",
        "parentId": null,
        "author": "DavidThielen",
        "content": "@mkArtakMSFT  - right, the suggested approach is to implement my own ValidateAuthenticationStateAsync. The thing is, to accomplish the above I would need to replace RevalidatingServerAuthenticationStateProvider. Not extend, but replace it (which is what I have done).\r\n\r\nThe template suggests extending RevalidatingServerAuthenticationStateProvider and only implementing ValidateAuthenticationStateAsync retaining RevalidatingServerAuthenticationStateProvider.GetAuthenticationStateAsync.\r\n\r\nWhat I did was extend ServerAuthenticationStateProvider and implement the above three features. But I think it would be helpful/useful for other programmers if they did not have to implement ServerAuthenticationStateProvider.GetAuthenticationStateAsync.\r\n\r\nIs this sufficient explanation?\r\n\r\nthanks - dave",
        "createdAt": "2023-07-05T18:46:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49176#issuecomment-1622290487"
      },
      {
        "id": "IC_kwDOAQzde85gzBid",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-07-06T16:41:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49176#issuecomment-1623988381"
      },
      {
        "id": "IC_kwDOAQzde85ofBLP",
        "parentId": null,
        "author": "ThinkElevenDave",
        "content": "Hi @DavidThielen \r\nI believe we also have an open [post relating](https://github.com/dotnet/aspnetcore/issues/50858) to this challenge.  I\u0027m following this post as you\u0027ve already gone that extra step and it\u0027s interesting to read your thoughts.",
        "createdAt": "2023-10-09T12:56:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49176#issuecomment-1752961743"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85qqQXS",
    "title": "Blazor RemoteAuthenticatorView stuck in \u0022Completing login...\u0022 after \u0022No matching state found\u0022 error",
    "url": "https://github.com/dotnet/aspnetcore/issues/49221",
    "createdAt": "2023-07-05T12:34:36Z",
    "lastUpdated": "2024-07-25T10:28:45Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nHello I have a Blazor WASM application that implements OIDC authentication using [authentication library](https://learn.microsoft.com/en-us/aspnet/core/blazor/security/webassembly/standalone-with-authentication-library?view=aspnetcore-7.0\u0026tabs=visual-studio). I\u0027m having a problem when users return back to the previous login URL by pressing the browser back button. This issue is described in more detail here: https://github.com/IdentityModel/oidc-client-js/issues/940. Doing some debugging I noticed that indeed I\u0027m getting a \u0022No matching state found in storage\u0022 error from Microsoft.AspNetCore.Components.WebAssembly.Authentication/AuthenticationService.js. \r\n\r\n![No matching state](https://github.com/dotnet/aspnetcore/assets/34100964/b5109a62-280a-4763-911e-63ad652ca967)\r\n\r\nThis is expected behavior because the state is deleted from storage after successful login. What I would like to ask is a way to better handle this error. Right now it gets stuck Completing login... without showing any error to the user or the browser console. I would expect \u0060RemoteAuthenticatorView\u0060 to switch to the \u0060LogInFailed\u0060 RenderFragment and show the error that occurred.\r\n\r\nWhat is the best way to handle this error?\r\n\r\n\r\n### Expected Behavior\r\n\r\n_No response_\r\n\r\n### Steps To Reproduce\r\n\r\n_No response_\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n_No response_\r\n\r\n### Anything else?\r\n\r\n_No response_",
    "upvotes": 2,
    "labels": [
      "investigate",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85gqPC1",
        "parentId": null,
        "author": "javiercn",
        "content": "@Jimmys20 thanks for contacting us.\r\n\r\nCan you describe the sequence of pages you visit/actions you perform as part of the flow?",
        "createdAt": "2023-07-05T12:43:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49221#issuecomment-1621684405"
      },
      {
        "id": "IC_kwDOAQzde85gqju_",
        "parentId": null,
        "author": "Jimmys20",
        "content": "Sure, \u0060https://localhost:3375/\u0060 is the Blazor WASM application and \u0060https://localhost:3371/\u0060 is the OIDC provider (IdentityServer 4) and authorization code flow is implemented between them.\r\n\r\n1. User visits \u0060https://localhost:3375\u0060\r\n1. User is not authenticated so he gets redirected to the \u0060Authentication.razor\u0060 page (\u0060NavigationManager.NavigateToLogin($\u0022authentication/login\u0022);\u0060).\r\n1. \u0060Authentication.razor\u0060 starts the the login process and redirects the user to the Identity Provider. \u0060https://localhost:3371/Account/Login?ReturnUrl=...\u0060\r\n2. User enters credentials, submits login form and gets redirected back to \u0060https://localhost:3375/authentication/login-callback?code=...\u0060\r\n3. \u0060Authentication.razor\u0060 completes the login process successfully and redirects the user to \u0060https://localhost:3375\u0060 (\u0060Index.razor\u0060).\r\n4. Now the user presses the browser back button and goes back to the Identity Provider \u0060https://localhost:3371/Account/Login?ReturnUrl=...\u0060.\r\n5. Submits login form second time and is redirected to \u0060https://localhost:3375/authentication/login-callback?code=...\u0060\r\n6. \u0060Authentication.razor\u0060 tries to process login callback but gets stuck on \u0060Completing login...\u0060 because \u0022No matching state found in storage\u0022 occurs.",
        "createdAt": "2023-07-05T13:33:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49221#issuecomment-1621769151"
      },
      {
        "id": "IC_kwDOAQzde85gr6jz",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-07-05T16:45:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49221#issuecomment-1622124787"
      },
      {
        "id": "IC_kwDOAQzde85toJkC",
        "parentId": null,
        "author": "DigitalSauce",
        "content": "Is there any workaround here?",
        "createdAt": "2023-12-04T18:35:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49221#issuecomment-1839241474"
      },
      {
        "id": "IC_kwDOAQzde86BPPQi",
        "parentId": null,
        "author": "hjrb",
        "content": "I get the same issue",
        "createdAt": "2024-06-14T15:17:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49221#issuecomment-2168255522"
      },
      {
        "id": "IC_kwDOAQzde86BPU7c",
        "parentId": null,
        "author": "Jimmys20",
        "content": "In my case, I worked around this by changing the behavior of Identity Server so that it doesn\u0027t show the Login page if the user is already logged in. Instead it shows an \u0022already logged in\u0022 message and instructs the user to return to the app.\r\n\r\nIn \u0060AccountController.cs\u0060 I changed the Login action to:\r\n\r\n\u0060\u0060\u0060\r\n[HttpGet]\r\npublic async Task\u003CIActionResult\u003E Login(string returnUrl)\r\n{\r\n    // added these lines\r\n    if (User.Identity.IsAuthenticated)\r\n    {\r\n        return View(\u0022LoggedIn\u0022, returnUrl);\r\n    }\r\n\r\n    var vm = await BuildLoginViewModelAsync(returnUrl);\r\n\r\n    return View(vm);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nand the \u0060LoggedIn.cshtml\u0060:\r\n\r\n\u0060\u0060\u0060\r\n@using IdentityServer4.Services\r\n@inject IIdentityServerInteractionService InteractionService\r\n\r\n@model string\r\n@{\r\n    ViewData[\u0022Title\u0022] = \u0022Logged In\u0022;\r\n}\r\n\u003Ch1\u003E@ViewData[\u0022Title\u0022]\u003C/h1\u003E\r\n\r\n\u003Ch4\u003EYou are already logged in.\u003C/h4\u003E\r\n\r\n@{\r\n    var context = await InteractionService.GetAuthorizationContextAsync(Model);\r\n\r\n    if (context?.Client != null \u0026\u0026 context.Client.Properties.TryGetValue(\u0022ClientUri\u0022, out string clientUri))\r\n    {\r\n        \u003Ca class=\u0022btn btn-primary\u0022 href=\u0022@clientUri\u0022\u003EReturn to @context.Client.ClientName\u003C/a\u003E\r\n    }\r\n}\r\n\r\n\u003Ca class=\u0022btn btn-outline-secondary\u0022 asp-controller=\u0022Account\u0022 asp-action=\u0022Logout\u0022\u003ELogout\u003C/a\u003E\r\n\u0060\u0060\u0060",
        "createdAt": "2024-06-14T15:31:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49221#issuecomment-2168278748"
      },
      {
        "id": "IC_kwDOAQzde86BPW7-",
        "parentId": null,
        "author": "hjrb",
        "content": "\u003E I get the same issue\r\n\r\nIn my case I can reproduce what is causing the issue. A component is calling some API requiring an access token (authenticated) - while the user authentication has not finished. This will throw an Exception which is being caught in the JS code. Theoretically this should not cause any issues. But is does. Obviously catching the exception causes that other steps that should be executed will not be executed. If you care (not so sure with MS these days) I can give you more details.\r\n",
        "createdAt": "2024-06-14T15:35:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49221#issuecomment-2168286974"
      },
      {
        "id": "IC_kwDOAQzde86BPXxJ",
        "parentId": null,
        "author": "hjrb",
        "content": "\u003E I get the same issue\r\n\r\nIn my case the I can reproduce what is causing the issue. A component is calling some API - while the user authentication is not finished. This will throw an Exception which is being caught in the JS code. Theoretically this should not cause any issues. But is does. Obviously catching the excpetion causes that other steps that should be executed will not be executed. If you care (not so sure with MS these days) I can give you ",
        "createdAt": "2024-06-14T15:38:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49221#issuecomment-2168290377"
      },
      {
        "id": "IC_kwDOAQzde86GHECe",
        "parentId": null,
        "author": "iambigred",
        "content": "I am experiencing the same error, although slightly different circumstances.  In my case the \u0022state\u0022 query parameter is not being extracted from the URL correctly.  The URLSearchParams returns null for the \u0022e\u0022 (state) variable as the url is in the format /authentication/login-callback**#**error=..., rather than /authentication/login-callback**?**error=...,\r\n\r\nWith this being a blazor app it uses the hash syntax rather than question mark.\r\n\r\n![image](https://github.com/user-attachments/assets/228756d2-099d-4f3d-9891-14c4018e2811)\r\n\r\nAny ideas on how this can be amended?\r\n",
        "createdAt": "2024-07-25T10:27:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49221#issuecomment-2249998494"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85rQFUn",
    "title": "Microsoft Security Advisory CVE-2023-33170: .NET Security Feature Bypass Vulnerability",
    "url": "https://github.com/dotnet/aspnetcore/issues/49334",
    "createdAt": "2023-07-11T17:09:11Z",
    "lastUpdated": "2024-02-13T01:30:45Z",
    "body": "# Microsoft Security Advisory CVE-2023-33170: .NET Security Feature Bypass Vulnerability\r\n\r\n## \u003Ca name=\u0022executive-summary\u0022\u003E\u003C/a\u003EExecutive summary\r\n\r\nMicrosoft is releasing this security advisory to provide information about a vulnerability in ASP.NET Core 2.1 and above. This advisory also provides guidance on what developers can do to update their applications to remove this vulnerability.\r\n\r\nA vulnerability exist in ASP.NET  Core applications where account lockout maximum failed attempts may not be immediately updated, allowing an attacker to try more passwords.\r\n\r\n## Announcement\r\n\r\nAnnouncement for this issue can be found at https://github.com/dotnet/announcements/issues/264\r\n\r\n### \u003Ca name=\u0022mitigation-factors\u0022\u003E\u003C/a\u003EMitigation factors\r\n\r\nMicrosoft has not identified any mitigating factors for this vulnerability.\r\n\r\n## \u003Ca name=\u0022affected-software\u0022\u003E\u003C/a\u003EAffected software\r\n\r\n* Any ASP.NET 7.0 application running on .NET 7.0.8 or earlier.\r\n* Any ASP.NET 6.0 application running on .NET 6.0.19 or earlier.\r\n* Any ASP.NET Core 2.1 application consuming the package Microsoft.AspNetCore.Identity version 2.1.31 or earlier.\r\n\r\nIf your application uses the following package versions, ensure you update to the latest version of .NET.\r\n\r\n### \u003Ca name=\u0022ASP.NET Core 2.1\u0022\u003E\u003C/a\u003EASP.NET Core 2.1\r\n\r\nPackage name | Affected version | Patched version\r\n------------ | ---------------- | -------------------------\r\n[ Microsoft.AspNetCore.Identity](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity/2.1.39)      | \u003C=2.1.39 | 2.1.39\r\n\r\n### \u003Ca name=\u0022Microsoft.AspNet.Identity.Owin\u0022\u003E\u003C/a\u003EMicrosoft.AspNet.Identity.Owin\r\nPackage name | Affected version | Patched version\r\n------------ | ---------------- | -------------------------\r\n[ Microsoft.AspNet.Identity.Owin](https://www.nuget.org/packages/Microsoft.AspNet.Identity.Owin)    |  \u003C= 2.2.3 | 2.2.4\r\n\r\n\r\n### \u003Ca name=\u0022ASP.NET 6\u0022\u003E\u003C/a\u003EASP.NET 6.0\r\n\r\nPackage name | Affected version | Patched version\r\n------------ | ---------------- | -------------------------\r\n\r\n[Microsoft.AspNetCore.App.Runtime.linux-arm](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.linux-arm)               |  \u003C= 6.0.19 | 6.0.20\r\n[Microsoft.AspNetCore.App.Runtime.linux-arm64](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.linux-arm64)           |  \u003C= 6.0.19 | 6.0.20\r\n[Microsoft.AspNetCore.App.Runtime.linux-musl-arm](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.linux-musl-arm)     |  \u003C= 6.0.19 | 6.0.20\r\n[Microsoft.AspNetCore.App.Runtime.linux-musl-arm64](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.linux-musl-arm64) |  \u003C= 6.0.19 | 6.0.20\r\n[Microsoft.AspNetCore.App.Runtime.linux-musl-x64](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.linux-musl-x64)     |  \u003C= 6.0.19 | 6.0.20\r\n[Microsoft.AspNetCore.App.Runtime.linux-x64](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.linux-x64)               |  \u003C= 6.0.19 | 6.0.20\r\n[Microsoft.AspNetCore.App.Runtime.osx-arm64](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.osx-arm64)               |  \u003C= 6.0.19 | 6.0.20\r\n[Microsoft.AspNetCore.App.Runtime.osx-x64](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.osx-x64)                   |  \u003C= 6.0.19 | 6.0.20\r\n[Microsoft.AspNetCore.App.Runtime.win-arm](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.win-arm)                   |  \u003C= 6.0.19 | 6.0.20\r\n[Microsoft.AspNetCore.App.Runtime.win-arm64](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.win-arm64)               |  \u003C= 6.0.19 | 6.0.20\r\n[Microsoft.AspNetCore.App.Runtime.win-x64](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.win-x64)                   |  \u003C= 6.0.19 | 6.0.20\r\n[Microsoft.AspNetCore.App.Runtime.win-x86](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.win-x86)                   |  \u003C= 6.0.19 | 6.0.20\r\n\r\n\r\n### \u003Ca name=\u0022ASP.NET 7\u0022\u003E\u003C/a\u003EASP.NET 7.0\r\n\r\nPackage name | Affected version | Patched version\r\n------------ | ---------------- | -------------------------\r\n[Microsoft.AspNetCore.App.Runtime.linux-arm](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.linux-arm)               |  \u003C= 7.0.9 | 7.0.9\r\n[Microsoft.AspNetCore.App.Runtime.linux-arm64](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.linux-arm64)           |  \u003C= 7.0.9 | 7.0.9\r\n[Microsoft.AspNetCore.App.Runtime.linux-musl-arm](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.linux-musl-arm)     |  \u003C= 7.0.9 | 7.0.9\r\n[Microsoft.AspNetCore.App.Runtime.linux-musl-arm64](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.linux-musl-arm64) |  \u003C= 7.0.9 | 7.0.9\r\n[Microsoft.AspNetCore.App.Runtime.linux-musl-x64](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.linux-musl-x64)     |  \u003C= 7.0.9 | 7.0.9\r\n[Microsoft.AspNetCore.App.Runtime.linux-x64](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.linux-x64)               |  \u003C= 7.0.9 | 7.0.9\r\n[Microsoft.AspNetCore.App.Runtime.osx-arm64](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.osx-arm64)               |  \u003C= 7.0.9 | 7.0.9\r\n[Microsoft.AspNetCore.App.Runtime.osx-x64](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.osx-x64)                   |  \u003C= 7.0.9 | 7.0.9\r\n[Microsoft.AspNetCore.App.Runtime.win-arm](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.win-arm)                   |  \u003C= 7.0.9 | 7.0.9\r\n[Microsoft.AspNetCore.App.Runtime.win-arm64](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.win-arm64)               |  \u003C= 7.0.9 | 7.0.9\r\n[Microsoft.AspNetCore.App.Runtime.win-x64](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.win-x64)                   |  \u003C= 7.0.9 | 7.0.9\r\n[Microsoft.AspNetCore.App.Runtime.win-x86](https://www.nuget.org/packages/Microsoft.AspNetCore.App.Runtime.win-x86)                   |  \u003C= 7.0.9 | 7.0.9\r\n\r\n\r\n\r\n## Advisory FAQ\r\n\r\n### \u003Ca name=\u0022how-affected\u0022\u003E\u003C/a\u003EHow do I know if I am affected?\r\n\r\nIf you have a runtime or SDK with a version listed, or an affected package listed in [affected software](#affected-software), you\u0027re exposed to the vulnerability.\r\n\r\n### \u003Ca name=\u0022how-fix\u0022\u003E\u003C/a\u003EHow do I fix the issue?\r\n\r\n* To fix the issue please install the latest version of .NET 6.0 or .NET 7.0. If you have installed one or more .NET SDKs through Visual Studio, Visual Studio will prompt you to update Visual Studio, which will also update your .NET  SDKs.\r\n* If you are using one of the affected packages, please update to the patched version listed above.\r\n* If you have .NET 6.0 or greater installed, you can list the versions you have installed by running the \u0060dotnet --info\u0060 command. You will see output like the following;\r\n\r\n\u0060\u0060\u0060\r\n.NET Core SDK (reflecting any global.json):\r\n\r\n Version:   6.0.300\r\n Commit:    8473146e7d\r\n\r\nRuntime Environment:\r\n\r\n OS Name:     Windows\r\n OS Version:  10.0.18363\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\6.0.300\\\r\n\r\nHost (useful for support):\r\n\r\n  Version: 6.0.5\r\n  Commit:  8473146e7d\r\n\r\n.NET Core SDKs installed:\r\n\r\n  6.0.300 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n\r\n  Microsoft.AspNetCore.App 6.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 6.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 6.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\nTo install additional .NET Core runtimes or SDKs:\r\n  https://aka.ms/dotnet-download\r\n\u0060\u0060\u0060\r\n\r\n* If you\u0027re using .NET 7.0, you should download and install Runtime 7.0.9 or SDK 7.0.109 (for Visual Studio 2022 v17.4) from https://dotnet.microsoft.com/download/dotnet-core/7.0.\r\n* If you\u0027re using .NET 6.0, you should download and install Runtime 6.0.20 or SDK 6.0.315 (for Visual Studio 2022 v17.2) from https://dotnet.microsoft.com/download/dotnet-core/6.0.\r\n* If you\u0027re using ASP.NET Core 2.1 and consuming the Microsoft.AspNetCore.Identity package, update that package to version [2.1.39](https://www.nuget.org/packages/Microsoft.AspNetCore.Identity/2.1.39)\r\n\r\n.NET 6.0 and and .NET 7.0 updates are also available from Microsoft Update. To access this either type \u0022Check for updates\u0022 in your Windows search, or open Settings, choose Update \u0026 Security and then click Check for Updates.\r\n\r\nOnce you have installed the updated runtime or SDK, restart your apps for the update to take effect.\r\n\r\nAdditionally, if you\u0027ve deployed [self-contained applications](https://docs.microsoft.com/dotnet/core/deploying/#self-contained-deployments-scd) targeting any of the impacted versions, these applications are also vulnerable and must be recompiled and redeployed.\r\n\r\n## Other Information\r\n\r\n### Reporting Security Issues\r\n\r\nIf you have found a potential security issue in .NET 6.0 or .NET 7.0, please email details to secure@microsoft.com. Reports may qualify for the Microsoft .NET Core \u0026 .NET 5 Bounty. Details of the Microsoft .NET Bounty Program including terms and conditions are at \u003Chttps://aka.ms/corebounty\u003E.\r\n\r\n### Support\r\n\r\nYou can ask questions about this issue on GitHub in the .NET GitHub organization. The main repos are located at https://github.com/dotnet/runtime and https://github.com/dotnet/aspnet/. The Announcements repo (https://github.com/dotnet/Announcements) will contain this bulletin as an issue and will include a link to a discussion issue. You can ask questions in the linked discussion issue.\r\n\r\n### Disclaimer\r\n\r\nThe information provided in this advisory is provided \u0022as is\u0022 without warranty of any kind. Microsoft disclaims all warranties, either express or implied, including the warranties of merchantability and fitness for a particular purpose. In no event shall Microsoft Corporation or its suppliers be liable for any damages whatsoever including direct, indirect, incidental, consequential, loss of business profits or special damages, even if Microsoft Corporation or its suppliers have been advised of the possibility of such damages. Some states do not allow the exclusion or limitation of liability for consequential or incidental damages so the foregoing limitation may not apply.\r\n\r\n### External Links\r\n\r\n[CVE-2023-33170]( https://www.cve.org/CVERecord?id=CVE-2023-33170)\r\n\r\n### Revisions\r\n\r\nV1.0 (July 11, 2023): Advisory published.\r\n\r\n_Version 1.0_\r\n\r\n_Last Updated 2023-07-11_",
    "upvotes": 0,
    "labels": [
      "area-auth",
      "announcement"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85hQC4o",
        "parentId": null,
        "author": "johnkors",
        "content": "\u003EAffected software\r\n\r\n\u003EAny ASP.NET 7.0 application running on .NET 7.0.8 or earlier.\r\n\r\n\u003EIf you\u0027re using .NET 7.0, you should download and install Runtime 7.0.7\r\n\r\n\uD83E\uDD14\r\n\r\n",
        "createdAt": "2023-07-11T22:36:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49334#issuecomment-1631596072"
      },
      {
        "id": "IC_kwDOAQzde85hQaIp",
        "parentId": null,
        "author": "danmoseley",
        "content": "\u003E \uD83E\uDD14\r\n\r\nI believe I corrected the post -- @rbhanda please confirm.",
        "createdAt": "2023-07-12T00:48:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49334#issuecomment-1631691305"
      },
      {
        "id": "IC_kwDOAQzde85hUDSi",
        "parentId": null,
        "author": "Kahbazi",
        "content": "@rbhanda The link for the announcement is the wrong issue. I believe this is the correct one. https://github.com/dotnet/announcements/issues/264",
        "createdAt": "2023-07-12T14:35:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49334#issuecomment-1632646306"
      },
      {
        "id": "IC_kwDOAQzde85hUe3B",
        "parentId": null,
        "author": "rbhanda",
        "content": "\u003E @rbhanda The link for the announcement is the wrong issue. I believe this is the correct one. [dotnet/announcements#264](https://github.com/dotnet/announcements/issues/264)\r\n\r\nSorry about that. I corrected the links and the text in the [announcement ](https://github.com/dotnet/announcements/issues/264) and this issue",
        "createdAt": "2023-07-12T15:31:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49334#issuecomment-1632759233"
      },
      {
        "id": "IC_kwDOAQzde85hVoWw",
        "parentId": null,
        "author": "phenning",
        "content": "@rbhanda Can you confirm whether this vulnerability exists in [Microsoft.AspNet.Identity.Owin](https://www.nuget.org/packages/Microsoft.AspNet.Identity.Owin) when targeting .NET Framework TFMS (non NET Core)?\r\n\r\nIt\u0027s not super clear in the bullet points under affected software, even though it is listed in the table below.",
        "createdAt": "2023-07-12T19:05:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49334#issuecomment-1633060272"
      },
      {
        "id": "IC_kwDOAQzde85hVr0M",
        "parentId": null,
        "author": "rbhanda",
        "content": "\u003E @rbhanda Can you confirm whether this vulnerability exists in [Microsoft.AspNet.Identity.Owin](https://www.nuget.org/packages/Microsoft.AspNet.Identity.Owin) when targeting .NET Framework TFMS (non NET Core)?\r\n\u003E \r\n\u003E It\u0027s not super clear in the bullet points under affected software, even though it is listed in the table below.\r\n\r\n@GrabYourPitchforks @halter73 ",
        "createdAt": "2023-07-12T19:15:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49334#issuecomment-1633074444"
      },
      {
        "id": "IC_kwDOAQzde85hXnnR",
        "parentId": null,
        "author": "halter73",
        "content": "Yes. It affects any consumer of Microsoft.AspNet.Identity.Owin using the account lockout feature including but not limited to full framework.",
        "createdAt": "2023-07-13T05:40:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49334#issuecomment-1633581521"
      },
      {
        "id": "IC_kwDOAQzde85hgmrR",
        "parentId": null,
        "author": "phenning",
        "content": "\u003E Yes. It affects any consumer of Microsoft.AspNet.Identity.Owin using the account lockout feature including but not limited to full framework.\r\n\r\nThanks Stephen, wanted to make sure before we started updating the .NET Framework templates in Visual Studio to use the new version.",
        "createdAt": "2023-07-14T14:21:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49334#issuecomment-1635936977"
      },
      {
        "id": "IC_kwDOAQzde85iEq2j",
        "parentId": null,
        "author": "11qqaazzqwerty",
        "content": "Is it really fixed in version 6.0.20?\r\nMicrosoft Defender for Cloud treat this version as affected:\r\n![image](https://github.com/dotnet/aspnetcore/assets/121670476/33597acd-5f9e-4e18-8e58-7d285e90947f)\r\n\r\n\r\n",
        "createdAt": "2023-07-21T10:53:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49334#issuecomment-1645391267"
      },
      {
        "id": "IC_kwDOAQzde85jF8k7",
        "parentId": null,
        "author": "peterlukerow",
        "content": "@halter73 \r\n\u003E Yes. It affects any consumer of Microsoft.AspNet.Identity.Owin using the account lockout feature including but not limited to full framework.\r\n\r\nI\u0027m still not clear on this, it\u0027s all a little confusing. I\u0027m using .NET 4.8 which is not listed as one of the affect .NETs. Here you state it doesn\u0027t matter which framework you are on it\u0027s the version of Microsoft.AspNet.Identity.Owin.\r\n\r\nHowever, on [(https://github.com/github/advisory-database/pull/2496)] it says that for Microsoft.AspNet.Identity.Owin you need at least version 7.0.9, however in VS 2019 when managing nugets for the solution we are using v2.2.3 and it says that v2.2.4 is the latest stable, there is no v7.0.9 to upgrade to, thus my confusion.\r\n\r\nIn a recent external pen test of our web app and on anecdotal evidence an account is always locked out after the number of times configured in our SQL DB, i.e. after 5 invalid attempts, 6th attempt fails even if you use valid credentials. ",
        "createdAt": "2023-08-02T16:11:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49334#issuecomment-1662503227"
      },
      {
        "id": "IC_kwDOAQzde85jIM6x",
        "parentId": null,
        "author": "halter73",
        "content": "v2.2.4 is the latest stable. https://github.com/https://github.com/github/advisory-database/pull/2496 is an outdated PR between feature branches. If you take a look at [what\u0027s currently in the \u0060main\u0060 branch](https://github.com/github/advisory-database/blob/df30e8a3304bb2887c17f2b63a5c57131b527966/advisories/github-reviewed/2023/07/GHSA-25c8-p796-jg6r/GHSA-25c8-p796-jg6r.json#L37-L55), that indicates 2.2.4 is the patched version just like the announcement at https://github.com/dotnet/announcements/issues/264.",
        "createdAt": "2023-08-02T23:30:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49334#issuecomment-1663094449"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85rpaDM",
    "title": "Claim-Based Authorization For MVC Actions",
    "url": "https://github.com/dotnet/aspnetcore/issues/49431",
    "createdAt": "2023-07-15T10:53:06Z",
    "lastUpdated": "2024-09-12T21:19:43Z",
    "body": "Note: the original suggestion is moot - there\u0027s a new proposal [further down](https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1636977890).\r\n\r\n## Background and Motivation\r\n\r\nHey guys.\r\n\r\nAs you know, there are several ways of \u0060Authorization\u0060 in Aspnetcore. \u0060Policy\u0060, \u0060Role\u0060, and \u0060Claim\u0060 based authorization.\r\nConsider a situation that I want to protect a specific action (either in\u0060MinimalApi\u0060 or \u0060Controller\u0060 based style) depending on some specific user \u0060Permissions\u0060 with the following considerations:\r\n* Permissions are simply located in the user claims with ClaimType=permission\r\n* Claims are available in either JWT, SAML token or even intercepted through \u0060IClaimsTransformation\u0060 before entering the authorization process\r\n\r\nAs an example, the user claims look like sth like this:\r\n\u0060\u0060\u0060json\r\n{\r\n \u0022sub\u0022: \u0022user_id\u0022,\r\n \u0022permission\u0022: [\u0022P1\u0022, \u0022P2\u0022]\r\n}\r\n\u0060\u0060\u0060 \r\n\r\nThere is an easy way to have this in **MinimalApis**:\r\n\r\n\u0060\u0060\u0060c#\r\napp.MapGet(\u0022/\u0022, () =\u003E \u0022Granted\u0022).RequireAuthorization(policy =\u003E policy.RequireClaim(\u0022permission\u0022, \u0022P1\u0022));\r\n\u0060\u0060\u0060 \r\nBut what about \u0060Controller Actions\u0060? The developer must hack all of the following steps!\r\n\r\n\u0060\u0060\u0060c#\r\nbuilder.Services.AddAuthorization(options =\u003E\r\n{\r\n    options.AddPolicy(\u0022RequiresPermission\u0022, policy =\u003E policy.AddRequirements(new MustHavePermissionRequirement()));\r\n});\r\n\r\n\u0060\u0060\u0060\r\n\u0060\u0060\u0060c#\r\n[RequiresPermission(\u0022P1\u0022)]\r\npublic async Task\u003Cstring\u003E Index()\r\n{\r\n    return \u0022Granted\u0022;\r\n}\r\n\u0060\u0060\u0060 \r\n\u0060\u0060\u0060c#\r\n[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method)]\r\ninternal sealed class RequiresPermissionAttribute : Attribute, IAuthorizeData\r\n{\r\n    public string Permissions { get; }\r\n    public RequiresPermissionAttribute(string permissions)\r\n    {\r\n        Permissions = permissions;\r\n        Policy = \u0022RequiresPermission\u0022;\r\n    }\r\n\r\n    //\r\n    // Summary:\r\n    //     Gets or sets the policy name that determines access to the resource.\r\n    public string? Policy { get; set; }\r\n\r\n    //\r\n    // Summary:\r\n    //     Gets or sets a comma delimited list of roles that are allowed to access the resource.\r\n    public string? Roles { get; set; }\r\n\r\n    //\r\n    // Summary:\r\n    //     Gets or sets a comma delimited list of schemes from which user information is\r\n    //     constructed.\r\n    public string? AuthenticationSchemes { get; set; }\r\n}\r\n\u0060\u0060\u0060 \r\nThe self-handling (Please see [this](https://source.dot.net/#Microsoft.AspNetCore.Authorization/PassThroughAuthorizationHandler.cs)) \u0060MustHavePermissionRequirement\u0060 should look like sth like this: \r\n\u0060\u0060\u0060c#\r\npublic Task HandleAsync(AuthorizationHandlerContext context)\r\n{\r\n    if (context.Resource is HttpContext httpContext)\r\n    {\r\n        var endpoint = httpContext.GetEndpoint();\r\n        var authDatum = endpoint?.Metadata.GetOrderedMetadata\u003CRequiresPermissionAttribute\u003E() ?? Array.Empty\u003CRequiresPermissionAttribute\u003E();\r\n        var permissionsString = authDatum.Select(x =\u003E x.Permissions).FirstOrDefault();\r\n        var requiredPermissions = permissionsString?.Split(\u0022,\u0022).Select(x =\u003E x.Trim()) ?? Array.Empty\u003Cstring\u003E();\r\n        var userPermissions = context.User.Claims.Where(x =\u003E x.Type == \u0022permission\u0022).ToList();\r\n\r\n        //To check if the user has the specific permission or not\r\n\r\n        context.Succeed(this);\r\n    }\r\n\r\n    return Task.CompletedTask;\r\n}\r\n\u0060\u0060\u0060 \r\n**But why?**\r\nThe reason is if you take a look at [AuthorizationMiddlware](https://source.dot.net/#Microsoft.AspNetCore.Authorization.Policy/AuthorizationMiddleware.cs,109), there is a [CombineAsync](https://source.dot.net/#Microsoft.AspNetCore.Authorization/AuthorizationPolicy.cs,152) method which only cares about \u0060RoleBased\u0060 authorization and also the \u0060IAuthorizeData\u0060 interface does not support \u0060AllowedClaimType\u0060 and \u0060AllowedClaimValues\u0060 out-of-the-box.\r\nThere is a piece of \u0060CombineAsync\u0060 method code that tries to extract the \u0060allowedRoles\u0060 from \u0060[Authorize]\u0060 attribute which is inherited from \u0060IAuthorizeData\u0060:\r\n\r\n\u0060\u0060\u0060c#\r\nvar rolesSplit = authorizeDatum.Roles?.Split(\u0027,\u0027);\r\nif (rolesSplit?.Length \u003E 0)\r\n{\r\n    var trimmedRolesSplit = rolesSplit.Where(r =\u003E !string.IsNullOrWhiteSpace(r)).Select(r =\u003E r.Trim());\r\n    policyBuilder.RequireRole(trimmedRolesSplit);\r\n    useDefaultPolicy = false;\r\n}\r\n\u0060\u0060\u0060 \r\nBut what I guess that can be done is:\r\n\r\n## Proposed API\r\n\r\nThe \u0060IAuthorizeData\u0060 and consequently \u0060AuthorizeAttribute\u0060 can support \u0060AllowedClaimType\u0060 and \u0060AllowedClaimValues\u0060 in order to be used in \u0060CombineAsync\u0060 method like this:\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.AspNetCore.Authorization;\r\n\r\npublic interface IAuthorizeData\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Gets or sets the policy name that determines access to the resource.\r\n    /// \u003C/summary\u003E\r\n    string? Policy { get; set; }\r\n    /// \u003Csummary\u003E\r\n    /// Gets or sets a comma delimited list of roles that are allowed to access the resource.\r\n    /// \u003C/summary\u003E\r\n    string? Roles { get; set; }\r\n\r\n\u002B  /// \u003Csummary\u003E\r\n\u002B  /// Gets or sets the claim type name that is allowed to access the resource\r\n\u002B  /// \u003C/summary\u003E\r\n\u002B  string? AllowedClaim { get; set; }\r\n\u002B \r\n\u002B  /// \u003Csummary\u003E\r\n\u002B  /// Gets or sets a comma delimited list of claims that are allowed to access the resource.\r\n\u002B  /// \u003C/summary\u003E\r\n\u002B  string? AllowedClaimValues { get; set; }\r\n\u002B \r\n    /// \u003Csummary\u003E\r\n    /// Gets or sets a comma delimited list of schemes from which user information is constructed.\r\n    /// \u003C/summary\u003E\r\n    string? AuthenticationSchemes { get; set; }\r\n}\r\n\u0060\u0060\u0060\r\nSo that we can explicitly combine allowed claims with the other policies in \u0060CombineAsync\u0060 method like this:\r\n\r\n\u0060\u0060\u0060c#\r\nvar allowedClaim = authorizeDatum.AllowedClaim;\r\nvar claimSplit = authorizeDatum.AllowedClaimValues?.Split(\u0027,\u0027);\r\n\r\nif (string.IsNullOrWhiteSpace(allowedClaim) \u0026\u0026 claimSplit?.Length \u003E 0)\r\n{\r\n    var trimmedClaimSplit = claimSplit.Where(r =\u003E !string.IsNullOrWhiteSpace(r)).Select(r =\u003E r.Trim());\r\n    policyBuilder.RequireClaim(allowedClaim!, trimmedClaimSplit);\r\n    useDefaultPolicy = false;\r\n}\r\n\u0060\u0060\u0060 \r\nAnd all of the code hacks can be removed!\r\n\r\n## Usage Examples\r\n\r\n\u0060\u0060\u0060c#\r\n[Authorize(AllowedClaimType=\u0022permission\u0022, AllowedClaimValues=\u0022p1, p2\u0022)]\r\npublic async Task\u003Cstring\u003E Index()\r\n{\r\n    return \u0022Granted\u0022;\r\n}\r\n\u0060\u0060\u0060 \r\n\r\n## Risks\r\n* Razor pages and components\u0027 authorization integration (\u0060AuthorizeRouteView\u0060, \u0060AuthorizeView\u0060, \u0060AuthorizeDataAdapter\u0060)\r\n* This is a public API change that is widely used, so any kinda breaking change can be also a risk \r\n* For the sake of multiple Claim support, can have multiple [Authorize] on the same action\r\n\r\nP.S. I\u0027ve already implemented this in my own GitHub repo. So fill free to check if it\u0027s feasible enough to submit a pull request: [link-to-the-changes](https://github.com/dotnet/aspnetcore/compare/main...amiru3f:aspnetcore:main)",
    "upvotes": 2,
    "labels": [
      "enhancement",
      "area-auth",
      "api-needs-work"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85hjvx3",
        "parentId": null,
        "author": "davidfowl",
        "content": "Take a look at the new feature we added in .NET 8 https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-4/#improved-support-for-custom-authorization-policies-with-iauthorizationrequirementdata. This should solve the problem for MVC apps without the need to hack around with strings. This feature allows your attribute to express requirements directly.\r\n\r\n\r\n\r\n",
        "createdAt": "2023-07-15T13:06:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1636760695"
      },
      {
        "id": "IC_kwDOAQzde85hj1FA",
        "parentId": null,
        "author": "amiru3f",
        "content": "Awesome. Totally agree that it solves the problem",
        "createdAt": "2023-07-15T14:19:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1636782400"
      },
      {
        "id": "IC_kwDOAQzde85hkNqr",
        "parentId": null,
        "author": "davidfowl",
        "content": "To follow up, here\u0027s what the above proposal would look like with the new functionality:\r\n\r\n\u0060\u0060\u0060C#\r\n[AttributeUsage(AttributeTargets.Method, Inherited = false, AllowMultiple = true)]\r\nsealed class RequireClaimsAttribute(string Name, string AllowedValues) : Attribute, IAuthorizationRequirementData\r\n{\r\n    public IEnumerable\u003CIAuthorizationRequirement\u003E GetRequirements()\r\n    {\r\n        yield return new ClaimsAuthorizationRequirement(Name, AllowedValues.Split(\u0027,\u0027));\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060C#\r\n[Authorize]\r\n[RequiredClaims(\u0022permission\u0022, \u0022p1, p2\u0022)]\r\npublic async Task\u003Cstring\u003E Index()\r\n{\r\n    return \u0022Granted\u0022;\r\n}\r\n\u0060\u0060\u0060",
        "createdAt": "2023-07-15T20:43:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1636883115"
      },
      {
        "id": "IC_kwDOAQzde85hkNwo",
        "parentId": null,
        "author": "davidfowl",
        "content": "Maybe we should ship this attribute in the box? It would be the equivalent of https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authorization.authorizationpolicybuilder.requireclaim?view=aspnetcore-7.0.\r\n\r\nThoughts @Tratcher @halter73 ?",
        "createdAt": "2023-07-15T20:46:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1636883496"
      },
      {
        "id": "IC_kwDOAQzde85hkbwY",
        "parentId": null,
        "author": "amiru3f",
        "content": "@davidfowl Thanks for the follow up. Actually, I\u0027ve implemented that exactly like the one you mentioned, in our codes.\r\nThrilled to submit a pull request if it\u0027s considered by you",
        "createdAt": "2023-07-16T01:24:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1636940824"
      },
      {
        "id": "IC_kwDOAQzde85hkhJf",
        "parentId": null,
        "author": "davidfowl",
        "content": "@amiru3f Can you reopen this issue and propose this new API instead? That would be a reasonable thing for us to add (considering all of the overloads as well).",
        "createdAt": "2023-07-16T02:33:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1636962911"
      },
      {
        "id": "IC_kwDOAQzde85hkkzi",
        "parentId": null,
        "author": "amiru3f",
        "content": "@davidfowl  sure!\r\n\r\n## Background and Motivation\r\nConsidering the problem defined [above](https://github.com/dotnet/aspnetcore/issues/49431#issue-1806016716) \u261D\uFE0F, and a user with following sample claims\r\n\r\n\u0060\u0060\u0060json\r\n{\r\n \u0022sub\u0022: \u0022user_id\u0022,\r\n \u0022permission\u0022: [\u0022P1\u0022, \u0022P2\u0022]\r\n}\r\n\u0060\u0060\u0060 \r\n\r\nThere is an easy way to solve that in **MinimalApis**:\r\n\r\n\u0060\u0060\u0060c#\r\napp.MapGet(\u0022/\u0022, () =\u003E \u0022Granted\u0022).RequireAuthorization(policy =\u003E policy.RequireClaim(\u0022permission\u0022, \u0022P1\u0022));\r\n\u0060\u0060\u0060 \r\nBut for the sake of **MVC apps**, using [.NET 8 Preview 4](https://devblogs.microsoft.com/dotnet/asp-net-core-updates-in-dotnet-8-preview-4/#improved-support-for-custom-authorization-policies-with-iauthorizationrequirementdata) feature, can be solved like this:\r\n\u0060\u0060\u0060c#\r\n[AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, Inherited = false, AllowMultiple = true)]\r\n[DebuggerDisplay(\u0022{ToString(),nq}\u0022)]\r\npublic class RequiresClaimAttribute(string Name, string AllowedValues) : Attribute, IAuthorizationRequirementData\r\n{\r\n    public IEnumerable\u003CIAuthorizationRequirement\u003E GetRequirements()\r\n    {\r\n        yield return new ClaimsAuthorizationRequirement(Name, AllowedValues?.Split(\u0027,\u0027)?.Select(value =\u003E value.Trim()));\r\n    }\r\n}\r\n\r\n\u0060\u0060\u0060\r\n\u0060\u0060\u0060c#\r\n\r\n[Authorize] //even this can be removed by inheritance\r\n[RequiresClaim(\u0022permission\u0022, \u0022P1\u0022, \u0022P2\u0022)]\r\n//principal has to have \u0022P1\u0022 or \u0022P2\u0022 permission in his claims\r\npublic string Index() =\u003E \u0022Granted\u0022;\r\n\u0060\u0060\u0060 \r\n\r\n## Proposed API\r\nThe \u0060RequireClaim\u0060 attribute can be supported by\u0060Aspnetcore\u0060 OOTB\r\n\u0060\u0060\u0060c#\r\n[AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, Inherited = false, AllowMultiple = true)]\r\n[DebuggerDisplay(\u0022{ToString(),nq}\u0022)]\r\npublic class RequiresClaimAttribute : Attribute, IAuthorizationRequirementData\r\n{\r\n    public RequiresClaimAttribute(string claimType, params string[] allowedValues)\r\n    {\r\n        _claimType = claimType;\r\n        _allowedValues = allowedValues;\r\n    }\r\n\r\n    private readonly string _claimType;\r\n\r\n    private readonly IEnumerable\u003Cstring\u003E? _allowedValues;\r\n\r\n    public IEnumerable\u003CIAuthorizationRequirement\u003E GetRequirements()\r\n    {\r\n        yield return new ClaimsAuthorizationRequirement(_claimType, _allowedValues);\r\n    }\r\n\r\n    /// \u003Cinheritdoc/\u003E\u003E\r\n    public override string ToString()\r\n    {\r\n        return DebuggerHelpers.GetDebugText(nameof(_claimType), _claimType, nameof(_allowedValues), _allowedValues);\r\n    }\r\n}\r\n\u0060\u0060\u0060 \r\nP.S. By inheriting \u0060RequireClaimAttribute\u0060 from \u0060AuthorizeAttribute\u0060 there would be less code in action but less readable and consistent (glad to know your opinion as well)\r\n\r\nP.S. With respect to https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1971886272 we can also simplify the usage of \r\n\u0060\u0060\u0060 C#\r\napp.MapGet(\u0022/\u0022, () =\u003E \u0022Granted\u0022).RequireAuthorization(policy =\u003E policy.RequireClaim(\u0022permission\u0022, \u0022P1\u0022));\r\n\u0060\u0060\u0060 \r\nby adding \u0060RequireClaim\u0060 extension directly to \u0060EndpointConventionBuilder\u0060 which can be used like:\r\n\u0060\u0060\u0060 C#\r\napp.MapGet(\u0022/\u0022, () =\u003E \u0022Granted\u0022).RequireClaim(\u0022permission\u0022, \u0022P1\u0022);\r\n\u0060\u0060\u0060\r\n\r\n\r\n\r\n\r\n## Usage Examples\r\n\r\n\u0060\u0060\u0060c#\r\n[Authorize]\r\n[RequiresClaim(\u0022permission\u0022, \u0022P1\u0022, \u0022P2\u0022)] //Also can be used in controller/class level\r\npublic string Index() =\u003E \u0022Granted\u0022;\r\n\u0060\u0060\u0060 \r\n\r\n## Risks\r\n* \u0060Role\u0060 and \u0060Claims\u0060 based authorization may look different in implementation:\r\n=\u003E  \u0060[Authorize(Role=bla)]\u0060 and \u0060[Authorize]\u0060 \u002B \u0060[RequiresClaim]\u0060. \r\n* Maybe sth like\u0060[AuthorizeClaimAttribute]\u0060 could be a case!\r\n* Not sure about  making the attribute \u0060sealed\u0060",
        "createdAt": "2023-07-16T04:26:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1636977890"
      },
      {
        "id": "IC_kwDOAQzde85hlGYg",
        "parentId": null,
        "author": "brockallen",
        "content": "\u003E [RequiredClaims(\u0022permission\u0022, \u0022p1, p2\u0022)]\r\n\r\nFWIW, hard coding these sorts of things in a string in metadata is exactly what the ASP.NET Core policy based authorization system was was trying to get away from when ASP.NET Core v1.0 was developed. Might as well go back to using the Authorize attribute with roles.",
        "createdAt": "2023-07-16T15:05:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1637115424"
      },
      {
        "id": "IC_kwDOAQzde85hlHrG",
        "parentId": null,
        "author": "amiru3f",
        "content": "@brockallen \r\nIMO, [policy](https://learn.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-7.0) is a building block of \u0060authorization\u0060 which may contain **more** than one \u0060customized-requirement\u0060.\r\nCurrently \u0060Claims\u0060 and \u0060Role\u0060 -based authorization are widely-used, pre-configured, reusable policies that are supported by \u0060Aspnetcore\u0060 OOTB. So the case is to support [claims-based](https://learn.microsoft.com/en-us/aspnet/core/security/authorization/claims?view=aspnetcore-7.0) in the simplest form, for MVC apps as well as Minimal APIs",
        "createdAt": "2023-07-16T15:31:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1637120710"
      },
      {
        "id": "IC_kwDOAQzde85hlI91",
        "parentId": null,
        "author": "brockallen",
        "content": "How do you unit test the logic in the \u0022p1, p2\u0022 string?\r\nHow do you re-use that logic elsewhere in the app?\r\nHow do you dynamically use the logic (e.g. hide/show a button based on the result of the logic, or include/exclude a link in your REST hypermedia)?\r\n\r\nI appreciate your desire to use claims, but there\u0027s more to it. I was in the room when the idea for a more modern policy based approach was pitched to the ASP.NET team for inclusion in ASP.NET Core as a solution to the above issues. So I was trying to lend some historical perspective on why some things were deprecated in the past (like the hard coded strings in the old role based Authorize attribute and IsInRole checks from days past).",
        "createdAt": "2023-07-16T15:56:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1637126005"
      },
      {
        "id": "IC_kwDOAQzde85hlKHm",
        "parentId": null,
        "author": "amiru3f",
        "content": "As you know better than me, there are many cases to handle authorization in the app based on the business use-case.\r\nIn my specific case (and many other cases as well), business works like this:\r\n* Each action is single responsible like (Http Delete: User) \r\n* User can **act** based on his **permission**. There is no need to change the permission of an action in the future\r\n* Buttons are not tightly coupled to the APIs (They have their own claims or at least a combination of claims based on the user-experience and domain)\r\n* Permissions are not \u0060Logic\u0060 to be reused. They are claims of the **principal** coming to the endpoint \r\n\r\nSo I will have this action:\r\n\u0060\u0060\u0060c#\r\nconst string PermissionConstString = \u0022permission\u0022;\r\n\r\n[Authorize]\r\n[RequireClaim(PermissionConstString, nameof(DeleteUser)]\r\npublic AnyKindOfResponse DeleteUser() =\u003E \u0022Deleted\u0022;\r\n\u0060\u0060\u0060 \r\n\r\nSo that, I will unit/integration test it by Asserting a simple equality check\r\nThere are many cases that using \u0060Roles\u0060, \u0060Policies\u0060 can be complex, or even over engineering.\r\n\r\nGuess that\u0027s the reason that [ClaimsAuthorizationRequirement](https://source.dot.net/#Microsoft.AspNetCore.Authorization/ClaimsAuthorizationRequirement.cs) is still there in Aspnetcore\r\n\r\nP.S. Role and Policy based authorization are powerful and useful. But not for all cases\r\n",
        "createdAt": "2023-07-16T16:17:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1637130726"
      },
      {
        "id": "IC_kwDOAQzde85hqLbm",
        "parentId": null,
        "author": "Tratcher",
        "content": "@blowdart ",
        "createdAt": "2023-07-17T16:08:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1638446822"
      },
      {
        "id": "IC_kwDOAQzde85hqb4S",
        "parentId": null,
        "author": "blowdart",
        "content": "As you can guess I\u0027m with brock here, scattering values in attributes moves far away from the centralised, only have to change in one place that we worked so hard to implement.\n\nA single place to update makes the world safer as no random controllers get missed \uD83E\uDD37\u200D\u2642\uFE0F",
        "createdAt": "2023-07-17T16:51:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1638514194"
      },
      {
        "id": "IC_kwDOAQzde85hrgWz",
        "parentId": null,
        "author": "davidfowl",
        "content": "It\u2019s a bit odd because maybe the example is not motivating because don\u2019t use claims as permissions but the attribute maps directly to the requirement we have built in today. This is a way of expressing those requirements via attributes ",
        "createdAt": "2023-07-17T20:06:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1638794675"
      },
      {
        "id": "IC_kwDOAQzde85hr5Zp",
        "parentId": null,
        "author": "brockallen",
        "content": "\u003E This is a way of expressing those requirements via attributes\r\n\r\nThe difference being that it\u0027s not used via the level indirection of a policy name (thus suffers from the aforementioned limitations). But whatever -- if your team\u0027s stance has changed on preferred/good practices, then it has changed.",
        "createdAt": "2023-07-17T21:18:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1638897257"
      },
      {
        "id": "IC_kwDOAQzde85hr_tB",
        "parentId": null,
        "author": "davidfowl",
        "content": "The authZ system (and I know you know this) works well today if you have authorization requirements that are static, as static as the policy. As soon as those requirements can change based on the endpoint, the current system was *really* hard to use (this post explains it well https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1636760695).\r\n\r\n\u003E But whatever -- if your team\u0027s stance has changed on preferred/good practices, then it has changed.\r\n\r\nPolicies are recommended, and if you are in a situation where the authorization handler needs extra data, specifying them via a requirement that can be expressed via the attribute is a better alternative to expressing 2^n policies with different combinations of values or building dynamic policy names based on data.\r\n\r\nNow back to the claims based solution. I can understand if we think exposing \u0060RequiresClaimAttribute\u0060 might send people down the \u0022claims are permissions\u0022 path, maybe that\u0027s the push back here? (I\u0027m making sure I\u0027m not missing anything).",
        "createdAt": "2023-07-17T21:39:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1638923073"
      },
      {
        "id": "IC_kwDOAQzde85hsHnf",
        "parentId": null,
        "author": "brockallen",
        "content": "\u003E might send people down the \u0022claims are permissions\u0022 path\r\n\r\n\u0022Claims as permissions\u0022 is more nuanced than that (it\u0027s more like don\u0027t put permissions as claims in cookies or tokens). But to answer your question, \u0022yes a bit\u0022, but also for the other reasons I mentioned. Is IsInRole or [AuthorizeAttribute(Roles=\u0022Admin, Manager\u0022)] recommended as well? They have the same issues.\r\n\r\nAnyway, like I said -- I was more reminding folks that at one point there was a significant push away from this style. Doing work to make it easy to use it again seems counter to that original goal. I just know that is it\u0027s added then down the road at some point I\u0027ll be having the conversation with a customer explaining why it\u0027s not ideal to use, and recanting this whole history again (including fond memories of this thread :)).",
        "createdAt": "2023-07-17T22:11:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1638955487"
      },
      {
        "id": "IC_kwDOAQzde85hs1ZS",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E \u0022Claims as permissions\u0022 is more nuanced than that (it\u0027s more like don\u0027t put permissions as claims in cookies or tokens). \r\n\r\nUnfortunately, we use ClaimsPrincipal for both authentication *and* authorization, and we have claims transformation that lets you add more claims that don\u0027t get persisted into the HTTP response (so they are never put in a cookie or a token but they still exists in memory as claims as part of a ClaimsIdentity). That\u0027s hard to even talk about because \u0022claims\u0022 here might be conflating 2 different things.\r\n\r\n\u003E But to answer your question, \u0022yes a bit\u0022, but also for the other reasons I mentioned. Is IsInRole or [AuthorizeAttribute(Roles=\u0022Admin, Manager\u0022)] recommended as well? They have the same issues.\r\n\r\nI don\u0027t know what is \u0022recommended\u0022, only what we support (the APIs still do support roles in a first class way).\r\n\r\n\u003E I just know that is it\u0027s added then down the road at some point I\u0027ll be having the conversation with a customer explaining why it\u0027s not ideal to use, and recanting this whole history again (including fond memories of this thread :)).\r\n\r\nI understand \uD83D\uDE04 ",
        "createdAt": "2023-07-18T01:34:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1639142994"
      },
      {
        "id": "IC_kwDOAQzde85h6tGb",
        "parentId": null,
        "author": "amiru3f",
        "content": "Hi guys,\r\nAs you put this in the backlog, am I permitted to submit a pull request? I\u0027m not sure, that\u0027s my first time.\r\n@davidfowl ",
        "createdAt": "2023-07-19T21:25:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1642779035"
      },
      {
        "id": "IC_kwDOAQzde85h64R4",
        "parentId": null,
        "author": "??",
        "content": "Thank you for submitting this for API review. This will be reviewed by @dotnet/aspnet-api-review at the next meeting of the ASP.NET Core API Review group. Please ensure you take a look at [the API review process documentation](https://github.com/dotnet/aspnetcore/blob/main/docs/APIReviewProcess.md) and ensure that:\n\n* The PR contains changes to the reference-assembly that describe the API change. **Or**, you have included a snippet of reference-assembly-style code that illustrates the API change.\n* The PR describes the impact to users, both positive (useful new APIs) and negative (breaking changes).\n* Someone is assigned to \u0022champion\u0022 this change in the meeting, and they understand the impact and design of the change.",
        "createdAt": "2023-07-19T22:11:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1642824824"
      },
      {
        "id": "IC_kwDOAQzde85h65UO",
        "parentId": null,
        "author": "davidfowl",
        "content": "I\u0027ll mark it for API review so the team can look at it, if the API gets approved then you can submit a PR",
        "createdAt": "2023-07-19T22:13:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1642829070"
      },
      {
        "id": "IC_kwDOAQzde851iJjA",
        "parentId": null,
        "author": "halter73",
        "content": "@amiru3f Are you still around? Sorry for the delay. This does look like a convenient API. You mention that:\r\n\r\n\u003E There is an easy way to have this in **MinimalApis**:\r\n\u003E \r\n\u003E \u0060\u0060\u0060cs\r\n\u003E app.MapGet(\u0022/\u0022, () =\u003E \u0022Granted\u0022).RequireAuthorization(policy =\u003E policy.RequireClaim(\u0022permission\u0022, \u0022P1\u0022));\r\n\u003E \u0060\u0060\u0060\r\n\r\nI agree that defining an inline policy is more convenient than being forced to configure a named policy in \u0060AddAuthorization\u0060 particularly for one-off requirements. However, do we think it would be worth it to make even the minimal API version even simpler? Given a \u0060[RequiresClaim(\u0022permission\u0022, \u0022P1\u0022)]\u0060 API, I could easily see people wanting and expecting to be able to do the following:\r\n\r\n\u0060\u0060\u0060cs\r\napp.MapGet(\u0022/\u0022, () =\u003E \u0022Granted\u0022).RequireClaim(\u0022permission\u0022, \u0022P1\u0022);\r\n\u0060\u0060\u0060\r\n\r\nDo you think that sounds reasonable?\r\n\r\nI think the \u0060[RequiresClaim(...)]\u0060 attribute should be able to target both classes and methods like \u0060[Authorize]\u0060 does rather than just targeting \u0060AttributeTargets.Method\u0060. I\u0027m also not sure I like this:\r\n\r\n\u003E\u0060\u0060\u0060cs\r\n\u003E         _allowedValues = allowedValues?.Split(\u0027,\u0027)?.Select(value =\u003E value.Trim());\r\n\u003E \u0060\u0060\u0060\r\n\r\nWhat happens if an allowed value is supposed to contain a \u0060,\u0060? Even if you knew about this footgun, it\u0027d be hard to work around because \u0060[RequiresClaim(\u0022permission\u0022, \u0022my,single,comma,seperated,value\u0022)]\u0060 will prefer the \u0060string claimType, string allowedValues\u0060 overload over the \u0060string claimType, params string[] allowedValues\u0060 overload. While \u0060[RequiresClaim(\u0022permission\u0022, new[] { \u0022my,single,comma,seperated,value\u0022 })]\u0060 is valid C# (to my surprise), I\u0027m not sure how many people will think try that.\r\n\r\nI recommend just copying the [AuthorizationPolicyBuilder.RequireClaim overloads](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authorization.authorizationpolicybuilder.requireclaim?view=aspnetcore-8.0) overloads minus the \u0060string claimType, IEnumerable\u003Cstring\u003E allowedValues\u0060 one since it\u0027s impossible to call when declaring a static attribute.",
        "createdAt": "2024-02-29T20:16:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1971886272"
      },
      {
        "id": "IC_kwDOAQzde851vNPq",
        "parentId": null,
        "author": "amiru3f",
        "content": "Hi @halter73, no worries and thanks for the response.\r\n\r\n\u003E do we think it would be worth it to make even the minimal API version even simpler? \r\n\r\nYes, I do think it\u0027s much more easier to use \u0060\u0060\u0060 app.MapGet(...).RequireClaim() \u0060\u0060\u0060 instead.\r\n\r\n\u003E I think the [RequiresClaim(...)] attribute should be able to target both classes and methods\r\n\r\n\u003E I recommend just copying the [AuthorizationPolicyBuilder.RequireClaim overloads](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authorization.authorizationpolicybuilder.requireclaim?view=aspnetcore-8.0) overloads minus the string claimType, IEnumerable\u003Cstring\u003E allowedValues one since it\u0027s impossible to call when declaring a static attribute.\r\n\r\nThose ones also sound logical. Will update the proposal\r\n",
        "createdAt": "2024-03-03T20:32:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1975309290"
      },
      {
        "id": "IC_kwDOAQzde851vQOv",
        "parentId": null,
        "author": "amiru3f",
        "content": "@halter73 Also \u0060[RequireClaim(String)]\u0060 overload is not needed, since \u0060ClaimsAuthorizationRequirement\u0060 supports empty allowed values.\r\n\r\nAnd one more thing about \u0060\u0022comma, seperated, values\u0022\u0060. It rings a bell but honestly I can\u0027t remember why I\u0027ve put there like that. Right now, I could just find \u0060AuthorizeAttribute\u0060 implementation for roles like:\r\n\r\n\u0060\u0060\u0060 C#\r\n/// \u003Csummary\u003E\r\n/// Gets or sets a comma delimited list of roles that are allowed to access the resource.\r\n/// \u003C/summary\u003E\r\npublic string? Roles { get; set; }\r\n\u0060\u0060\u0060",
        "createdAt": "2024-03-03T20:48:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49431#issuecomment-1975321519"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85srGLp",
    "title": "Use resource strings in IdentityApiEndpointRouteBuilderExtensions for localization",
    "url": "https://github.com/dotnet/aspnetcore/issues/49664",
    "createdAt": "2023-07-26T21:51:42Z",
    "lastUpdated": "2025-01-26T01:14:56Z",
    "body": "              I assume we\u0027ll want to localize these strings in the future?\r\n\r\n_Originally posted by @BrennanConroy in https://github.com/dotnet/aspnetcore/pull/49498#discussion_r1270876858_\r\n            ",
    "upvotes": 0,
    "labels": [
      "area-auth",
      "feature-localization"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85i9gQ4",
        "parentId": null,
        "author": "hishamco",
        "content": "@halter73 In such a case can I start the PR immediately because there are no proposed APIs or do you follow a specific flow?",
        "createdAt": "2023-08-01T13:13:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49664#issuecomment-1660290104"
      },
      {
        "id": "IC_kwDOAQzde85jITnh",
        "parentId": null,
        "author": "halter73",
        "content": "Were you just planning on moving strings unchanged into a \u0060Resources.resx\u0060 file? If so, I say go for it.",
        "createdAt": "2023-08-03T00:14:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49664#issuecomment-1663121889"
      },
      {
        "id": "IC_kwDOAQzde85jNn6J",
        "parentId": null,
        "author": "hishamco",
        "content": "What if we want to add localized strings?",
        "createdAt": "2023-08-03T19:27:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49664#issuecomment-1664515721"
      },
      {
        "id": "IC_kwDOAQzde859Iqi2",
        "parentId": null,
        "author": "hishamco",
        "content": "@halter73 is this fixed in #49498?",
        "createdAt": "2024-05-07T22:34:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49664#issuecomment-2099423414"
      },
      {
        "id": "IC_kwDOAQzde86b0O1d",
        "parentId": null,
        "author": "hishamco",
        "content": "@halter73 if this is fixed in #49498 we need to close this one",
        "createdAt": "2025-01-26T01:14:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49664#issuecomment-2614160733"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85tOSw3",
    "title": "Enable Automatic Rotation of Trusted Client Certificate Chain Components",
    "url": "https://github.com/dotnet/aspnetcore/issues/49788",
    "createdAt": "2023-08-02T05:33:46Z",
    "lastUpdated": "2024-10-31T21:41:27Z",
    "body": "## Background and Motivation\r\n\r\nWhile developers can use a combination of \u0060ServerCertificateSelector\u0060 and \u0060IFileProvider\u0060 today to automatically reload a server\u0027s TLS certificate (as mentioned in https://github.com/dotnet/aspnetcore/issues/32351), developers cannot as easily reload the certificate(s) used to validate the client\u0027s certificate chain. Developers can of course write their own \u0060ClientCertificateValidation\u0060 delegate, but I think that also means re-performing much of the logic that already exists within the [\u0060Microsoft.AspNetCore.Authentication.Certificate\u0060](https://www.nuget.org/packages/Microsoft.AspNetCore.Authentication.Certificate) package.\r\n\r\nI propose adding a new API that allow developers to leverage the convenience of the \u0060Microsoft.AspNetCore.Authentication.Certificate\u0060 while also enabling more dynamic scenarios, like the automatic reload of trusted components in the client certificate chain.\r\n\r\n## Proposed API\r\n\r\nBased on some initial feedback from @Tratcher to consider the existing events, I propose adding a new event that triggers just before validation (as opposed to the existing event \u0060OnCertificateValidated\u0060 that triggers just afterwards). This event\u0027s input context contains information about the HTTP request from the \u0060BaseContext\u003CT\u003E\u0060, as well as properties that may aid in further customizing the \u0060X509ChainPolicy\u0060.\r\n\r\nThe new event and its input are below:\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.AspNetCore.Authentication.Certificate;\r\n\r\npublic class CertificateAuthenticationEvents\r\n{\r\n\u002B    public Func\u003CCertificateValidatingContext, Task\u003E OnCertificateValidating { get; set; } = context =\u003E Task.CompletedTask;\r\n    public Func\u003CCertificateValidatedContext, Task\u003E OnCertificateValidated { get; set; } = context =\u003E Task.CompletedTask;\r\n    public Func\u003CCertificateChallengeContext, Task\u003E OnChallenge { get; set; } = context =\u003E Task.CompletedTask;\r\n}\r\n\r\n\u002Bpublic class CertificateValidatingContext : BaseContext\u003CCertificateAuthenticationOptions\u003E\r\n\u002B{\r\n\u002B    public X509ChainPolicy ChainPolicy { get; set; } = default!;\r\n\u002B    public X509Certificate2 ClientCertificate { get; set; } = default!;\r\n\u002B    public bool IsSelfSigned { get; set; }\r\n\u002B}\r\n\u0060\u0060\u0060\r\n\r\nThis new event is then used by the \u0060CertificateAuthenticationHandler\u0060 when validating:\r\n\u0060\u0060\u0060diff\r\n        var chainPolicy = BuildChainPolicy(clientCertificate, isCertificateSelfSigned);\r\n\u002B        var certificateValidatingContext = new CertificateValidatingContext(Context, Scheme, Options)\r\n\u002B        {\r\n\u002B            ChainPolicy = chainPolicy,\r\n\u002B            ClientCertificate = clientCertificate,\r\n\u002B            IsSelfSigned = isCertificateSelfSigned,\r\n\u002B        };\r\n\u002B\r\n\u002B        await Events.CertificateValidating(certificateValidatingContext);\r\n\r\n        using var chain = new X509Chain\r\n        {\r\n            ChainPolicy = chainPolicy\r\n        };\r\n        var certificateIsValid = chain.Build(clientCertificate);\r\n\u0060\u0060\u0060\r\n\r\nI tried to model the new event as the others exist today, such that they do not return any data and instead rely on the context as a sort of communication medium. \u0060ChainPolicy\u0060 (whose property name is used by [\u0060X509Chain.ChainPolicy\u0060](https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.x509certificates.x509chain.chainpolicy?view=net-7.0) too) can be used by developers to make changes to the validation. \u0060ClientCertificate\u0060 and \u0060IsSelfSigned\u0060 are used internally to generate the policy (in addition to the options), and I thought they could be helpful. I am not opposed to removing them though.\r\n\r\n## Usage Examples\r\nBased on the docs [here](https://learn.microsoft.com/en-us/aspnet/core/security/authentication/certauth?view=aspnetcore-7.0#get-started).\r\n\r\n\u0060\u0060\u0060csharp\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\nbuilder.Services\r\n    .AddAuthentication(CertificateAuthenticationDefaults.AuthenticationScheme)\r\n    .AddCertificate(options =\u003E\r\n    {\r\n        options.Events = new CertificateAuthenticationEvents\r\n        {\r\n            OnCertificateValidating = context =\u003E\r\n            {\r\n                var caCertProvider = context.HttpContext.RequestServices.GetRequiredService\u003CICaCertProvider\u003E();\r\n\r\n                context.ChainPolicty.CustomTrustStore.Clear();\r\n                context.ChainPolicty.Add(caCertProvider.Certificate);\r\n\r\n                return Task.CompletedTask;\r\n            },\r\n        },\r\n    };\r\n\r\nvar app = builder.Build();\r\n\r\napp.UseAuthentication();\r\n\r\napp.MapGet(\u0022/\u0022, () =\u003E \u0022Hello World!\u0022);\r\n\r\napp.Run();\r\n\u0060\u0060\u0060\r\n\r\n## Alternative Designs\r\n\r\n### Event Context Properties\r\nInstead of access to the entire \u0060X509ChainPolicy\u0060, developers could be simply given the \u0060CustomTrustStore\u0060 and \u0060AdditionalChainCertificates\u0060 collections thereby limiting the scope of changes that could be made.\r\n\r\n\u0060\u0060\u0060diff\r\n\u002Bpublic class CertificateValidatingContext : BaseContext\u003CCertificateAuthenticationOptions\u003E\r\n\u002B{\r\n\u002B    public X509CertificateCollection CustomTrustStore { get; set } = default!;\r\n\u002B    public X509CertificateCollection AdditionalChainCertificates { get; set; } = default!;\r\n\u002B}\r\n\u0060\u0060\u0060\r\n\r\n### Selector Properties\r\nAt first, I was first imaging this API to be a parallel of [\u0060HttpsConnectionAdapterOptions.ServerCertificateSelector\u0060](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.server.kestrel.https.httpsconnectionadapteroptions.servercertificateselector?view=aspnetcore-7.0#microsoft-aspnetcore-server-kestrel-https-httpsconnectionadapteroptions-servercertificateselector) with new selector properties for the [\u0060CertificateAuthenticationOptions\u0060](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.certificate.certificateauthenticationoptions?view=aspnetcore-7.0) class.\r\n\r\n\u0060\u0060\u0060diff\r\npublic class CertificateAuthenticationOptions : AuthenticationSchemeOptions\r\n{\r\n    public X509Certificate2Collection AdditionalChainCertificates { get; set; }\r\n\u002B    public Func\u003CX509Certificate2Collection\u003E AdditionalChainCertificatesSelector { get; set; }\r\n    public X509Certificate2Collection CustomTrustStore { get; set; }\r\n\u002B    public Func\u003CX509Certificate2Collection\u003E CustomTrustStoreSelector { get; set; }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThere should be some input to the delegates, and the names could be a lot more creative, but I think this adds too much bloat to the class. It may also be confusing. Although I do appreciate the symmetry for client CA certificates.\r\n\r\n## Risks\r\n\r\nThe biggest problem I see with the proposal is that it may expose too much in the new event; it could be overwhelming and/or simply unnecessary for developers. In fact, developers could completely overwrite the entire \u0060509ChainPolicy\u0060! Is exposing the \u0060X509Certificate2\u0060 object before validation also risky business?",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "api-suggestion",
      "area-networking"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85jieA9",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-08-08T16:54:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49788#issuecomment-1669980221"
      },
      {
        "id": "IC_kwDOAQzde85jipT-",
        "parentId": null,
        "author": "wsugarman",
        "content": "I am going to update this issue and PR based on the comments soon. I\u0027ve just gotten distracted by other commitments.",
        "createdAt": "2023-08-08T17:30:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49788#issuecomment-1670026494"
      },
      {
        "id": "IC_kwDOAQzde85keGu0",
        "parentId": null,
        "author": "wsugarman",
        "content": "I have updated this proposal to be... better \uD83D\uDE05 ",
        "createdAt": "2023-08-21T04:14:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49788#issuecomment-1685613492"
      },
      {
        "id": "IC_kwDOAQzde85pVX3v",
        "parentId": null,
        "author": "??",
        "content": "Thank you for submitting this for API review. This will be reviewed by @dotnet/aspnet-api-review at the next meeting of the ASP.NET Core API Review group. Please ensure you take a look at [the API review process documentation](https://github.com/dotnet/aspnetcore/blob/main/docs/APIReviewProcess.md) and ensure that:\n\n* The PR contains changes to the reference-assembly that describe the API change. **Or**, you have included a snippet of reference-assembly-style code that illustrates the API change.\n* The PR describes the impact to users, both positive (useful new APIs) and negative (breaking changes).\n* Someone is assigned to \u0022champion\u0022 this change in the meeting, and they understand the impact and design of the change.",
        "createdAt": "2023-10-17T21:23:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49788#issuecomment-1767210479"
      },
      {
        "id": "IC_kwDOAQzde85pVbhG",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 9 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-10-17T21:33:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49788#issuecomment-1767225414"
      },
      {
        "id": "IC_kwDOAQzde85rk-pW",
        "parentId": null,
        "author": "halter73",
        "content": "API Review Notes:\r\n\r\n- Why does the event expose a \u0060X509ChainPolicy\u0060 rather than the \u0060X509CertificateCollection\u0060?\r\n  - The \u0060X509ChainPolicy\u0060 is built per request and depends on whether the incoming certificate is self-signed. It should be more flexible than just specifying an \u0060X509CertificateCollection\u0060 for \u0060CustomTrustStore\u0060.\r\n- Should we expose \u0060IsSelfSigned\u0060 and \u0060ClientCertificate\u0060?\r\n  - It makes sense to be able to read it, but why does it need to be settable?\r\n- Do the properties need to be settable?\r\n  - The current PR does not read the context after firing the event, so anything set to a new instance will be missed.\r\n  - We do not currently see a use case for setting the \u0060ClientCertificate\u0060 or \u0060IsSelfSigned\u0060 properties.\r\n  - Everything on \u0060X509ChainPolicy\u0060 seems to be mutable, and it\u0027s not reused, so we think that can stay non-settable as well.\r\n- Should we use \u0060ResultContext\u0060 rather than \u0060BaseContext\u0060?\r\n  - Yes. This matches the validat*ed* event and makes the event a little more powerful since it can short circuit with a helpful failure exception.\r\n- We need to add a constructor. We\u0027ll make all the non-ctor properties required init properties.\r\n\r\n- Is the event bad for performance after you rotate certs?\r\n  - After cert rotation, the handler would first populate the \u0060X509ChainPolicy\u0060 with outdated certs from \u0060CertificateAuthenticationOptions.CustomTrustStore\u0060, then the new \u0060OnCertificateValidating\u0060 would be forced to clear the outdated certs and add the newly rotated ones during each validation.\r\n\r\nIf we decide that we\u0027re not concerned about the performance of clearing and reconfiguring \u0060X509ChainPolicy.CustomTrustStore\u0060, and should stick to the event, this is how we think the API should look:\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.AspNetCore.Authentication.Certificate;\r\n\r\npublic class CertificateAuthenticationEvents\r\n{\r\n\u002B    public Func\u003CCertificateValidatingContext, Task\u003E OnCertificateValidating { get; set; } = context =\u003E Task.CompletedTask;\r\n    public Func\u003CCertificateValidatedContext, Task\u003E OnCertificateValidated { get; set; } = context =\u003E Task.CompletedTask;\r\n    public Func\u003CCertificateChallengeContext, Task\u003E OnChallenge { get; set; } = context =\u003E Task.CompletedTask;\r\n}\r\n\r\n\u002Bpublic class CertificateValidatingContext : ResultContext\u003CCertificateAuthenticationOptions\u003E\r\n\u002B{\r\n\u002B       public CertificateValidatingContext(HttpContext context, AuthenticationScheme scheme, CertificateAuthenticationOptions options);\r\n\u002B    public required X509ChainPolicy ChainPolicy { get; init; }\r\n\u002B    public required X509Certificate2 ClientCertificate { get; init; }\r\n\u002B    public required bool IsSelfSigned { get; init; }\r\n\u002B}\r\n\u0060\u0060\u0060",
        "createdAt": "2023-11-09T23:50:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49788#issuecomment-1804855894"
      },
      {
        "id": "IC_kwDOAQzde85rlHoH",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E * Is the event bad for performance after you rotate certs?\r\n\u003E   \r\n\u003E   * After cert rotation, the handler would first populate the \u0060X509ChainPolicy\u0060 with outdated certs from \u0060CertificateAuthenticationOptions.CustomTrustStore\u0060, then the new \u0060OnCertificateValidating\u0060 would be forced to clear the outdated certs and add the newly rotated ones during each validation.\r\n\r\nIf you\u0027re using the event to provide certs then I don\u0027t think you\u0027d be setting \u0060CertificateAuthenticationOptions.CustomTrustStore\u0060 at all, so you wouldn\u0027t have to add and then clear them.\r\n\r\nThe perf doesn\u0027t change after a rotation, the certs are always provided dynamically.",
        "createdAt": "2023-11-10T00:36:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49788#issuecomment-1804892679"
      },
      {
        "id": "IC_kwDOAQzde85sOEkN",
        "parentId": null,
        "author": "wsugarman",
        "content": "Actually, in the middle of writing this response, I noticed that there may be an even easier way to solve this problem...! I\u0027ll keep my thoughts/responses to the earlier proposal after this new idea.\r\n\r\n@halter73, @Tratcher - I see that the underlying [\u0060AuthenticationHandler\u003CTOptions\u003E\u0060](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.authenticationhandler-1?view=aspnetcore-8.0) exposes an [\u0060OptionsMonitor\u0060](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.authenticationhandler-1.optionsmonitor?view=aspnetcore-8.0) property. We could \u0022snapshot\u0022 it via \u0060OptionsMonitor.Get(Scheme.Name)\u0060 at the start of \u0060HandleAuthenticateAsync\u0060 and pass it through the other helper methods. That would enable users to use the options pattern to trigger a reload of the settings when the issuer certificate changes.\r\n\r\nWhat do you both think?\r\n\r\n## Extra notes\r\n@halter73 - Thanks for taking a look! When it comes to the aforementioned review, are these questions and subsequent answers/thoughts from that review? I\u0027ll comment on them assuming that to be the case.\r\n\r\n\u003E * Why does the event expose a \u0060X509ChainPolicy\u0060 rather than the \u0060X509CertificateCollection\u0060?\r\n\u003E   \r\n\u003E   * The \u0060X509ChainPolicy\u0060 is built per request and depends on whether the incoming certificate is self-signed. It should be more flexible than just specifying an \u0060X509CertificateCollection\u0060 for \u0060CustomTrustStore\u0060.\r\n\r\nI went back-and-forth on this when formulating the proposal. I agree that ultimately exposing the \u0060X509ChainPolicy\u0060 provides more flexibility instead of exposing portions of the policy, via the context, piecemeal as requested by users.\r\n\r\n\u003E * Should we expose \u0060IsSelfSigned\u0060 and \u0060ClientCertificate\u0060?\r\n\u003E   \r\n\u003E   * It makes sense to be able to read it, but why does it need to be settable?\r\n\r\nI agree. These fields should not be settable.\r\n\r\n\u003E * Do the properties need to be settable?\r\n\u003E   \r\n\u003E   * The current PR does not read the context after firing the event, so anything set to a new instance will be missed.\r\n\u003E   * We do not currently see a use case for setting the \u0060ClientCertificate\u0060 or \u0060IsSelfSigned\u0060 properties.\r\n\u003E   * Everything on \u0060X509ChainPolicy\u0060 seems to be mutable, and it\u0027s not reused, so we think that can stay non-settable as well.\r\n\r\nI agree that these properties should not be mutable. The \u0060X509ChainPolicy\u0060 itself its mutable (e.g. adding certificates to the \u0060CustomTrustStore\u0060), so that should be sufficient. No need to support replacing it wholesale.\r\n\r\n\u003E * Should we use \u0060ResultContext\u0060 rather than \u0060BaseContext\u0060?\r\n\u003E   \r\n\u003E   * Yes. This matches the validat_ed_ event and makes the event a little more powerful since it can short circuit with a helpful failure exception.\r\n\r\nWhat would be the purpose of the \u0060Result\u0060 property on the \u0022validating\u0022 event? Could it be set by users to skip validation? E.g. a user could pre-emptively fail validation based on some criteria?\r\n\r\n\u003E * We need to add a constructor. We\u0027ll make all the non-ctor properties required init properties.\r\n\r\nMakes sense!\r\n\r\n\u003E * Is the event bad for performance after you rotate certs?\r\n\u003E   \r\n\u003E   * After cert rotation, the handler would first populate the \u0060X509ChainPolicy\u0060 with outdated certs from \u0060CertificateAuthenticationOptions.CustomTrustStore\u0060, then the new \u0060OnCertificateValidating\u0060 would be forced to clear the outdated certs and add the newly rotated ones during each validation.\r\n\r\nYeah, I\u0027ve also been thinking about this too. The server certificate already has established a pattern with [\u0060HttpsConnectionAdapterOptions.ServerCertificateSelector\u0060](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.server.kestrel.https.httpsconnectionadapteroptions.servercertificateselector?view=aspnetcore-8.0), but it may not be relevant given:\r\n1. The server certificate API is located in a different project/assembly\r\n2. While there is only one server certificate, there may be a variable number of issuer certificates\r\n\r\nSo, I see a few approaches for the client certificates trusted components:\r\n1. Double-down on this sort of \u0022selector\u0022 approach and similarly allow users to provide an \u0060X509CertificateCollection\u0060 for the issuer(s) via some delegate (e.g. \u0060Func\u003CX509CertificateCollection\u003E\u0060)\r\n    - Honestly, this approach seems pretty ugly \uD83D\uDE05 \r\n2.  Expand the existing events to logically fire before validation, like in the current proposal where components, including the \u0060CustomTrustStore\u0060, may be augmented.\r\n    - Unfortunately, while this API fits nicely into the existing space, the handler for the above scenario would look like the following where the policy\u0027s \u0060X509CertificateCollection\u0060 would be presumably be reset each time. On the other hand, we may be making mountains out of molehills; if the user does not supply \u0060CertificateAuthenticationOptions.CustomTrustStore\u0060, then invoking \u0060Clear()\u0060 is unnecessary, and the adding the certificate to the store via the event is no different than via the options.\r\n\u0060\u0060\u0060csharp\r\noptions.Events = new CertificateAuthenticationEvents\r\n{\r\n    OnCertificateValidating = context =\u003E\r\n    {\r\n        var caCertProvider = context.HttpContext.RequestServices.GetRequiredService\u003CICaCertProvider\u003E();\r\n\r\n        context.ChainPolicty.CustomTrustStore.Clear(); // This may be superfluous\r\n        context.ChainPolicty.Add(caCertProvider.Certificate);\r\n\r\n        return Task.CompletedTask;\r\n    },\r\n},\r\n\u0060\u0060\u0060\u0060\r\n\r\n",
        "createdAt": "2023-11-17T02:00:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49788#issuecomment-1815628045"
      },
      {
        "id": "IC_kwDOAQzde85sSVfQ",
        "parentId": null,
        "author": "Tratcher",
        "content": "Options are already snapshotted at the start of a request here:\r\nhttps://github.com/dotnet/aspnetcore/blob/f8f03ea3764826d009f7ceb9bb91e482ce4a3fa9/src/Security/Authentication/Core/src/AuthenticationHandler.cs#L155\r\n\r\nNote a handler\u0027s lifetime is per-request.\r\n\r\nThat leaves the question of how to trigger an options reload. This would happen automatically if we were binding to IConfiguration, but we\u0027re not in this case. However we should be able to implement a IOptionsChangeTokenSource that tracks file changes and triggers the options reload. Then the original config lambda would run again and get the latest content. That could be a lot nicer than the developer managing the caching.\r\nhttps://github.com/dotnet/runtime/blob/d2c7d8ea3bbd59215ac4689734d440bdeaf570e1/src/libraries/Microsoft.Extensions.Options.ConfigurationExtensions/src/ConfigurationChangeTokenSource.cs#L15C61-L15C86\r\n\r\nI think the base mechanic would be something like:\r\n\u0060services.Configure\u003CClientCertificateOptions\u003E(authScheme, configure).MonitorFile(filePath);\u0060",
        "createdAt": "2023-11-17T16:41:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49788#issuecomment-1816745936"
      },
      {
        "id": "IC_kwDOAQzde85sTdFF",
        "parentId": null,
        "author": "wsugarman",
        "content": "Oh! I\u0027m sorry -- I missed that this service is transient.\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/76b5785b4ca4d6107baad792e2fe4d7b6f938b9b/src/Security/Authentication/Core/src/AuthenticationBuilder.cs#L51\r\n\r\nI agree that there should be some easy way for users to easily monitor the file like you suggested.",
        "createdAt": "2023-11-17T20:11:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49788#issuecomment-1817039173"
      },
      {
        "id": "IC_kwDOAQzde85uCg1Q",
        "parentId": null,
        "author": "halter73",
        "content": "\u003E I agree that there should be some easy way for users to easily monitor the file like you suggested.\r\n\r\nI also agree, but this would need more design. @adityamandaleeka @amcasey Can one of you look into this and mark it \u0060api-ready-for-review\u0060 again if/when it gets to a point where we should look at it in API review again?\r\n\r\nIf you\u0027re happy going with just the updated event proposal in https://github.com/dotnet/aspnetcore/issues/49788#issuecomment-1804855894 for now, just say so and reapply the label, but I\u0027m thinking we can probably make it both easier and faster.",
        "createdAt": "2023-12-07T21:39:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49788#issuecomment-1846152528"
      },
      {
        "id": "IC_kwDOAQzde85vtKWK",
        "parentId": null,
        "author": "wsugarman",
        "content": "@halter73 - I am unsure if I really like my own proposal given the potential of a perhaps more idiomatic approach with \u0060IOptionsMonitor\u003CT\u003E\u0060 \uD83D\uDE05 \r\n\r\nI\u0027ll try to noodle on a design. I think whatever is built for the client CA certificate also should work for configuring the server certificate as well. I was recently writing TLS support for a gRPC service and had to come up with some sort of abstraction for automatically reloading both certificates, and I would have loved some built-in support: https://github.com/wsugarman/durabletask-azurestorage-scaler/blob/Chart_2.0.0/src/Keda.Scaler.DurableTask.AzureStorage/Security/TlsConfigure.cs",
        "createdAt": "2024-01-02T14:40:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49788#issuecomment-1874109834"
      },
      {
        "id": "IC_kwDOAQzde85ydbU1",
        "parentId": null,
        "author": "amcasey",
        "content": "Sorry, I haven\u0027t had a chance to look into client certs yet - too many other cert problems. :wink:  Are we working towards a deadline other than 9.0?",
        "createdAt": "2024-02-01T01:34:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49788#issuecomment-1920316725"
      },
      {
        "id": "IC_kwDOAQzde859hqq5",
        "parentId": null,
        "author": "wsugarman",
        "content": "I finally found some time to play around with a design, and I looked at the [\u0060FileConfigurationProvider\u0060](https://github.com/dotnet/runtime/blob/bdfbed6de953957fd4dbba9c8cba0a3c47dde1f8/src/libraries/Microsoft.Extensions.Configuration.FileExtensions/src/FileConfigurationProvider.cs) as an inspiration.\r\n\r\nI would propose some new extension methods on \u0060IOptionsBuilder\u003CCertificateAuthenticationOptions\u003E\u0060, like so:\r\n\r\n\u0060\u0060\u0060csharp\r\npublic static class OptionsBuilderExtensions\r\n{\r\n    public static OptionsBuilder\u003CCertificateAuthenticationOptions\u003E WithAdditionalChainCertificate(this OptionsBuilder\u003CCertificateAuthenticationOptions\u003E builder, Action\u003CCertificateLoadOptions\u003E configureLoad)\r\n\r\n    public static OptionsBuilder\u003CCertificateAuthenticationOptions\u003E WithCustomTrustedAuthority(this OptionsBuilder\u003CCertificateAuthenticationOptions\u003E builder, Action\u003CCertificateLoadOptions\u003E configureLoad);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThis would register a \u0060IConfigureNamedOptions\u003CTOptions\u003E\u0060 in the service collection that would load the certificate into memory based on the given options. Much of the API is based on \u0060Microsoft.Extensions.Configuration.FileExtensions\u0060:\r\n\r\n\u0060\u0060\u0060csharp\r\npublic class CertificateLoadOptions\r\n{\r\n    public IFileProvider? FileProvider { get; set; }\r\n\r\n    public CertificateFileFormat Format { get; set; }\r\n\r\n    public string? KeyPath { get; set; }\r\n\r\n    public Action\u003CFileLoadExceptionContext\u003E? OnLoadException { get; set; }\r\n\r\n    [DisallowNull]\r\n    public string? Path { get; set; }\r\n\r\n    [Range(0, int.MaxValue)]\r\n    public int ReloadDelay { get; set; } = 250;\r\n\r\n    public bool ReloadOnChange { get; set; }\r\n}\r\n\r\npublic enum CertificateFileFormat\r\n{\r\n    PFX,\r\n    PEM,\r\n}\r\n\r\npublic class FileLoadExceptionContext\r\n{\r\n    public Exception Exception { get; set; } = null!;\r\n\r\n    public string Path { get; set; } = null!\r\n}\r\n\u0060\u0060\u0060\r\n\r\nWith this API, users can simply use the existing options pattern to further configure their authentication:\r\n\r\n\u0060\u0060\u0060csharp\r\nservices\r\n    .AddOptions\u003CCertificateAuthenticationOptions\u003E()\r\n    .WithCustomTrustedAuthority(o =\u003E\r\n    {\r\n        o.Path = \u0022/mnt/secrets/cert.pem\u0022,\r\n        o.Key = \u0022/mnt/secrets/key.pem\u0022,\r\n        o.Format = CertificateFileFormat.PEM,\r\n        o.ReloadOnChange = true,\r\n    });\r\n\u0060\u0060\u0060\r\n\r\nThe trickiest part I noticed when writing an initial implementation is that it may be tricky to cache the certificate as it\u0027s changing. Maintaining a reference to the same \u0060X509Certificate2\u0060 object used by the middleware could be tricky, as we would presumably want to \u0060Dispose\u0060 it upon detecting a change in the certificate file; however, there may be concurrent requests using that certificate. Alternatively, we probably do not want to keep creating the \u0060X509Certificate2\u0060 objects from a cached \u0060byte[]\u0060 because we\u0027d just keep creating new objects without disposing. Ideally, we\u0027d probably have some sort of idiomatic reader/writer lock in the certificate auth middleware in which we can use to safely dispose of an obsolete certificate.",
        "createdAt": "2024-05-11T18:03:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49788#issuecomment-2105977529"
      },
      {
        "id": "IC_kwDOAQzde859hqv-",
        "parentId": null,
        "author": "wsugarman",
        "content": "One more aspect to consider would be reusing this API for configuring the server TLS certificate used by Kestrel.",
        "createdAt": "2024-05-11T18:04:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49788#issuecomment-2105977854"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85uFvDy",
    "title": "Session timeout on external OAuth OIDC provider causes internal server error: message.State is null or empty",
    "url": "https://github.com/dotnet/aspnetcore/issues/50026",
    "createdAt": "2023-08-11T15:12:47Z",
    "lastUpdated": "2024-02-13T01:27:18Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nWe have two separate apps, a Blazor WASM app using .NET 7 and an ASP.NET Core Web App using .NET 6. Both are using an external OIDC provider that uses OAuth V2 and use the Microsoft.AspNetCore.Authentication.OpenIdConnect assembly to register the authenticator.\r\n\r\nIn these scenarios:\r\n- If initiate a login, stay on the login page for more than 20 minutes to cause a session timeout within the OIDC provider, then continue to try to log in\r\n- If I open two login windows for the same app and log in with two different users at the same time\r\n- After I log in via this external OIDC provider and am redirected back to my app, if I click the back button on the browser\r\n\r\nthen the app is redirected to https://localhost:44338/authentication/callback?error=sessionexpired and it causes an internal server error: System.Exception: OpenIdConnectAuthenticationHandler: message.State is null or empty.\r\n\r\n![image](https://github.com/dotnet/aspnetcore/assets/83760641/b43db7c6-eb32-4794-93a0-5c37f957923c)\r\n\r\n\r\nWe\u0027ve tried using these existing events to handle the error, but none seem to fire\r\n- OnTokenValidated\r\n- OnRedirectToIdentityProvider\r\n- OnAuthenticationFailed\r\n- OnRemoteFailure\r\n\r\nWe also tried\r\n- to use this property SkipUnrecognizedRequests but it didn\u0027t help with this issue. ([OpenIdConnectOptions.SkipUnrecognizedRequests Property (Microsoft.AspNetCore.Authentication.OpenIdConnect) | Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authentication.openidconnect.openidconnectoptions.skipunrecognizedrequests?view=aspnetcore-7.0))\r\n- to create an Authentication controller with a Callback action (because the callbackurl we have set is /authentication/callback) but it was not reaching the controller.\r\n- to change the callback url to a location we already have but I couldn\u0027t get it to reach that controller either.\r\n\r\n### Expected Behavior\r\n\r\nProvide a way to handle the error scenario\r\n\r\n### Steps To Reproduce\r\n\r\n1.\tCreate a Blazor WASM app with server side authentication using .NET 7 or an MVC ASP.NET Core Web App using .NET 6.\r\n2.\tImplement OIDC with an 0Auth V2 provider using the Microsoft.AspNetCore.Authentication.OpenIdConnect assembly, e.g.\r\n\u0060\u0060\u0060\r\nservices.AddAuthentication(sharedOptions =\u003E\r\n{\r\n    sharedOptions.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;\r\n    sharedOptions.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;\r\n    sharedOptions.DefaultChallengeScheme = OpenIdConnectDefaults.AuthenticationScheme;\r\n})\r\n.AddOpenIdConnect(options =\u003E\r\n{\r\n    // Redacted\r\n})\r\n.AddCookie(options =\u003E\r\n{\r\n    // Redacted\r\n});\r\n\u0060\u0060\u0060\r\n\r\n\r\n\r\n### Exceptions (if any)\r\n\r\nSystem.Exception: An error was encountered while handling the remote login.\r\n ---\u003E System.Exception: OpenIdConnectAuthenticationHandler: message.State is null or empty.\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.AspNetCore.Authentication.RemoteAuthenticationHandler\u00601.HandleRequestAsync()\r\n   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)\r\n   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware.Invoke(HttpContext context)\r\n\r\n### .NET Version\r\n\r\n7.0.400\r\n\r\n### Anything else?\r\n\r\n\r\n\r\ndotnet --info\r\n.NET SDK:\r\n Version:   7.0.400\r\n Commit:    73bf45718d\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.22000\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\7.0.400\\\r\n\r\nHost:\r\n  Version:      7.0.10\r\n  Architecture: x64\r\n  Commit:       a6dbb800a4\r\n\r\n.NET SDKs installed:\r\n  2.2.207 [C:\\Program Files\\dotnet\\sdk]\r\n  3.1.426 [C:\\Program Files\\dotnet\\sdk]\r\n  5.0.406 [C:\\Program Files\\dotnet\\sdk]\r\n  5.0.408 [C:\\Program Files\\dotnet\\sdk]\r\n  7.0.105 [C:\\Program Files\\dotnet\\sdk]\r\n  7.0.400 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.All 2.2.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.2.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.1.23 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.1.32 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 5.0.15 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 5.0.17 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 6.0.21 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 7.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 7.0.10 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.2.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.1.23 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.1.32 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 5.0.15 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 5.0.17 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 6.0.16 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 6.0.21 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 7.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 7.0.10 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 3.1.23 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 3.1.32 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 5.0.15 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 5.0.17 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 6.0.16 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 6.0.21 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 7.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 7.0.10 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\nOther architectures found:\r\n  x86   [C:\\Program Files (x86)\\dotnet]\r\n    registered at [HKLM\\SOFTWARE\\dotnet\\Setup\\InstalledVersions\\x86\\InstallLocation]\r\n\r\nEnvironment variables:\r\n  Not set\r\n\r\nglobal.json file:\r\n  Not found\r\n\r\nLearn more:\r\n  https://aka.ms/dotnet/info\r\n\r\nDownload .NET:\r\n  https://aka.ms/dotnet/download",
    "upvotes": 0,
    "labels": [
      "investigate",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85l8_Uq",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-09-07T16:51:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50026#issuecomment-1710486826"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85ucWQU",
    "title": "Add a DefaultPolicy property on AuthorizeRouteView to be used when no Policies are set on a component",
    "url": "https://github.com/dotnet/aspnetcore/issues/50111",
    "createdAt": "2023-08-16T10:09:57Z",
    "lastUpdated": "2024-11-14T17:37:03Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nAssume I have a requirement that forces people to enable 2FA when it\u0027s not enabled.\r\nI want users not to be able to access anything in the Blazor application except the page where the user can Enable 2FA.\r\nSo instead of setting an authorization policy on all pages except the \u0022Enable 2FA page,\u0022 I would like the reverse.\r\nAdding a default policy to pages that have no authorization policies set.\r\n\r\n\n\n### Describe the solution you\u0027d like\n\nBy adding \r\n\u0060\u0060\u0060cs\r\n[Parameter] public IAuthorizeData[]? DefaultPolicy { get; set; }\r\n\u0060\u0060\u0060\r\nTo the \u0060\u0060AuthorizeRouteView\u0060\u0060 component\r\n\r\nand cascading that down to \r\n\r\n\u0060\u0060\u0060cs\r\nprivate static IAuthorizeData[]? ComputeAuthorizeDataForType(Type type, IAuthorizeData[]? defaultPolicy)\r\n{\r\n       //...\r\n\treturn authorizeDatas?.ToArray() ?? defaultPolicy;\r\n}\r\n\u0060\u0060\u0060\r\n the \u0060\u0060DefaultPolicy\u0060\u0060 could be used for all components that have no\u0060\u0060IAuthorizeData\u0060\u0060 set. This reduces the risk of not setting a \u0022default\u0022 policy on a page\r\n\r\nThe alternative is to set a Policy on all components except the page you need to enable that requirement (in my example the  \u0022Enable 2FA page\u0022)\r\n\r\nThe other alternative is to create a custom \u0060\u0060AuthorizeRouteView\u0060\u0060 component that implements this feature (this is the route I have gone so far)\r\n\n\n### Additional context\n\n_No response_",
    "upvotes": 2,
    "labels": [
      "enhancement",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85vvnu6",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 9 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2024-01-03T01:38:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50111#issuecomment-1874754490"
      },
      {
        "id": "IC_kwDOAQzde86TpINT",
        "parentId": null,
        "author": "halter73",
        "content": "Would setting \u0060AuthorizationOptions.DefaultPolicy\u0060 work? Or is it important the default *only* applies to a given \u0060AuthorizeRouteView\u0060? If so, would adding \u0060[Authorize(\u0022PolicyName\u0022)]\u0060 to an \u0060_Imports.razor\u0060 be a viable alternative?",
        "createdAt": "2024-11-14T17:37:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50111#issuecomment-2477032275"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85uf6cd",
    "title": "Blazor multiple authentication schemes do not play nice with RenderModeServer",
    "url": "https://github.com/dotnet/aspnetcore/issues/50122",
    "createdAt": "2023-08-16T20:27:02Z",
    "lastUpdated": "2024-10-31T21:41:27Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nConsider the following scenario:\r\n\r\nAn app is running inside an org that is using on prem AD which syncs with Azure, you want to be able to host your blazor app inside IIS server on prem, but you also want to be able to configure specific route(component) inside blazor to be protected by Microsoft.Identity.Web package.\r\n\r\nIt partially works until you specify render mode to be \u0060RenderModeServer\u0060.\n\n### Expected Behavior\n\nMy understanding that it should fulfill Authorize attribute completely and if you say you want the user to be authorized with \u0060OpenIdConnectDefaults.AuthenticationScheme\u0060 via \u0060EntraId\u0060 policy then it should use that and not Windows auth and vice versa,\n\n### Steps To Reproduce\n\nProgram.cs\r\n\u0060\u0060\u0060\r\n//you can supply OpenIdConnectDefaults.AuthenticationScheme as default scheme\r\n//the behaviour wont change, it will only change the user \u0022Name\u0022 that is returned inside component.\r\n\r\nbuilder.Services.AddAuthentication(NegotiateDefaults.AuthenticationScheme)\r\n.AddNegotiate()\r\n.AddMicrosoftIdentityWebApp(cfg =\u003E\r\n{\r\n    cfg.Instance = globalConfig.AzureAd.Instance;\r\n    cfg.TenantId = globalConfig.AzureAd.TenantId;\r\n    cfg.ClientId = globalConfig.AzureAd.ClientId;\r\n    cfg.CallbackPath = globalConfig.AzureAd.CallbackPath;\r\n    ...\r\n});\r\n...\r\nbuilder.Services.AddAuthorization(options =\u003E\r\n{\r\n    var entraId = new AuthorizationPolicyBuilder()\r\n    .AddAuthenticationSchemes(OpenIdConnectDefaults.AuthenticationScheme)\r\n    .RequireAuthenticatedUser()\r\n    .Build();\r\n\r\n    options.AddPolicy(\u0022EntraId\u0022, entraId);\r\n\r\n    var kerb = new AuthorizationPolicyBuilder()\r\n    .AddAuthenticationSchemes(NegotiateDefaults.AuthenticationScheme)\r\n    .RequireAuthenticatedUser()\r\n    .Build();\r\n    options.AddPolicy(\u0022Kerberos\u0022, kerb);\r\n\r\n    // By default, all incoming requests will be authorized according to the default policy.\r\n    options.FallbackPolicy = options.DefaultPolicy;\r\n});\r\n\u0060\u0060\u0060\r\n\r\nComponent.razor\r\n\u0060\u0060\u0060\r\n@using Microsoft.AspNetCore.Authorization;\r\n@using Microsoft.Identity.Web;\r\n@using System.Diagnostics;\r\n@page \u0022/authbugssr\u0022\r\n@attribute [Authorize(\u0022EntraId\u0022)]\r\n@* Uncomment line bellow and observe OnInitializedAsync firing at least couple of time while providing different user each time first is the user required by configured policy, last is the user configured by default policy*@\r\n@* @attribute [RenderModeServer] *@\r\n@inject AuthenticationStateProvider AuthProvider\r\n\r\n\u003CCascadingAuthenticationState\u003E\r\n    \uFEFF\u003CAuthorizeView Policy=\u0022EntraId\u0022\u003E\r\n        \u003CAuthorized\u003E\r\n            Hello, @context.User.Identity.Name!\r\n        \u003C/Authorized\u003E\r\n        \u003CNotAuthorized\u003E\r\n            Not authed\r\n        \u003C/NotAuthorized\u003E\r\n    \u003C/AuthorizeView\u003E\r\n\u003C/CascadingAuthenticationState\u003E\r\n@code {\r\n\r\n    protected async override Task OnInitializedAsync()\r\n    {\r\n        base.OnInitialized();\r\n        var user = (await AuthProvider.GetAuthenticationStateAsync()).User;\r\n        Debugger.Break();\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nAuthorize to your App (so it saves id token to your cookies) then try accessing \u0060/authbugssr\u0060 with RenderModeServer and without it.\n\n### Exceptions (if any)\n\nNone\n\n### .NET Version\n\n8.0.100-preview.7.23376.3\n\n### Anything else?\n\n.NET SDK:\r\n Version:   8.0.100-preview.7.23376.3\r\n Commit:    daebeea8ea\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.19044\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\8.0.100-preview.7.23376.3\\\r\n\r\n.NET workloads installed:\r\nThere are no installed workloads to display.\r\n\r\nHost:\r\n  Version:      8.0.0-preview.7.23375.6\r\n  Architecture: x64\r\n  Commit:       65b696cf5e\r\n  RID:          win-x64\r\n\r\n.NET SDKs installed:\r\n  6.0.301 [C:\\Program Files\\dotnet\\sdk]\r\n  8.0.100-preview.7.23376.3 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.App 6.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 6.0.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 6.0.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 7.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 8.0.0-preview.7.23375.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 6.0.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 6.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 6.0.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 6.0.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 6.0.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 7.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 8.0.0-preview.7.23375.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 6.0.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 6.0.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 7.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 8.0.0-preview.7.23376.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\nOther architectures found:\r\n  x86   [C:\\Program Files (x86)\\dotnet]\r\n    registered at [HKLM\\SOFTWARE\\dotnet\\Setup\\InstalledVersions\\x86\\InstallLocation]\r\n\r\nEnvironment variables:\r\n  Not set\r\n\r\nglobal.json file:\r\n  Not found\r\n\r\nLearn more:\r\n  https://aka.ms/dotnet/info\r\n\r\nDownload .NET:\r\n  https://aka.ms/dotnet/download",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "Blazor \u2665 SignalR"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85kTDUy",
        "parentId": null,
        "author": "SPWizard01",
        "content": "After further investigation it seems that this is a bug with Blazor hub (i.e. the SignalR Client/Server is not configurable to specify auth scheme) therefore the Web request(1st request coming through) is using correct auth method while the SignalR connection (2nd request once \u0060RenderModeServer\u0060 is specified) reverts to default scheme.\r\n\r\nIt would most likely be possible to manually workaround this issue once the \u0060configureSignalR\u0060 would be accounted for inside the \u0060Blazor.start\u0060 method.\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/31a26e080ae5652cd3c9b414078d1b61a0b89010/src/Components/Web.JS/src/Platform/Circuits/CircuitStartOptions.ts#L15C12\r\n\r\nHowever it seems that this version of [blazor.web.js](https://github.com/dotnet/aspnetcore/blob/31a26e080ae5652cd3c9b414078d1b61a0b89010/src/Components/Web.JS/dist/Release/blazor.web.js) is not yet in the preview build.\r\n\r\nOf course it would be best if the SignalR client for Blazor hub \u0022knew\u0022 what type of auth it should use :)",
        "createdAt": "2023-08-17T17:49:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50122#issuecomment-1682715954"
      },
      {
        "id": "IC_kwDOAQzde85k2vkN",
        "parentId": null,
        "author": "SteveSandersonMS",
        "content": "Thanks for the report. Are you able to supply a minimal repro project, as a public GitHub repo? We will then investigate.",
        "createdAt": "2023-08-24T16:53:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50122#issuecomment-1692072205"
      },
      {
        "id": "IC_kwDOAQzde85k2vpJ",
        "parentId": null,
        "author": "??",
        "content": "Hi @SPWizard01. We have added the \u0022Needs: Author Feedback\u0022 label to this issue, which indicates that we have an open question for you before we can take further action. This issue will be closed automatically in 7 days if we do not hear back from you by then - please feel free to re-open it if you come back to this issue after that time.",
        "createdAt": "2023-08-24T16:53:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50122#issuecomment-1692072521"
      },
      {
        "id": "IC_kwDOAQzde85k2vqW",
        "parentId": null,
        "author": "??",
        "content": "Thank you for filing this issue. In order for us to investigate this issue, please provide [a minimalistic repro project](https://github.com/dotnet/aspnetcore/blob/main/docs/repro.md) that illustrates the problem.",
        "createdAt": "2023-08-24T16:54:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50122#issuecomment-1692072598"
      },
      {
        "id": "IC_kwDOAQzde85k3__n",
        "parentId": null,
        "author": "SPWizard01",
        "content": "\u003E Thanks for the report. Are you able to supply a minimal repro project, as a public GitHub repo? We will then investigate.\r\n\r\nHi Steve,\r\n\r\nHere you go: https://github.com/SPWizard01/MultiAuthBug\r\n\r\nMake sure to change https://github.com/SPWizard01/MultiAuthBug/blob/7913909ee576c4f9adec633e61b545f1c6583cf5/Program.cs#L12 with appropriate values once you registered your app in Azure :)\r\n",
        "createdAt": "2023-08-24T21:01:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50122#issuecomment-1692401639"
      },
      {
        "id": "IC_kwDOAQzde85rEUBl",
        "parentId": null,
        "author": "??",
        "content": "Thank you for contacting us. Due to a lack of activity on this discussion issue we\u0027re closing it in an effort to keep our backlog clean. If you believe there is a concern related to the ASP.NET Core framework, which hasn\u0027t been addressed yet, please file a new issue.\n\nThis issue will be locked after 30 more days of inactivity. If you still wish to discuss this subject after then, please create a new issue!",
        "createdAt": "2023-11-06T20:00:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50122#issuecomment-1796292709"
      },
      {
        "id": "IC_kwDOAQzde85sVm0g",
        "parentId": null,
        "author": "SPWizard01",
        "content": "still an issue with blazor server rendering because the websocket uses the default auth supplied and not the one requested in the Authorize attribute",
        "createdAt": "2023-11-18T19:20:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50122#issuecomment-1817603360"
      },
      {
        "id": "IC_kwDOAQzde86ECbcL",
        "parentId": null,
        "author": "halter73",
        "content": "I\u0027m reopening this because unlike the \u0060AuthorizationMiddleware\u0060 and the default \u0060PolicyEvaluator\u0060 it uses, \u0060AuthorizeViewCore\u0060 does not take into account \u0060AuthorizationPolicy.AuthenticationSchemes\u0060 at all and instead uses the \u0060IAuthorizationService\u0060 directly.\r\n\r\nThis is a pretty fundamental limitation, because \u0060AuthorizeViewCore\u0060/\u0060AuthorizeRouteView\u0060 has no reference to Http.Abstraction and \u0060HttpContext\u0060 which is necessary to reauthenticate, but we could probably do a better job of warning in this scenario. We already throw when an authentication scheme is specified via an attribute (e.g. \u0060[Authorize(AuthenticationScheme \u0022Cookies\u0022)]\u0060, but we do not when you specify a policy that that configures and authentication scheme via \u0060AuthorizationPolicyBuilder.AddAuthenticationSchemes\u0060 as demonstrated in this issue.\r\n\r\nSee \u0060PolicyEvaluator\u0060:\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/afc520c49d9857c68d2faae5ae89821ae671bb1b/src/Security/Authorization/Policy/src/PolicyEvaluator.cs#L34-L42\r\n\r\nvs \u0060AuthorizeViewCore\u0060:\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/afc520c49d9857c68d2faae5ae89821ae671bb1b/src/Components/Authorization/src/AuthorizeViewCore.cs#L108-L130\r\n\r\nSignalR has a similar issue when it evaluates auth policies for hub invocations (@BrennanConroy):\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/afc520c49d9857c68d2faae5ae89821ae671bb1b/src/SignalR/server/Core/src/Internal/DefaultHubDispatcher.cs#L653-L662\r\n\r\nAt the very least we should throw the same way no matter how you try to specify a per-page (or hub method) authentication scheme. Ideally, we could make it just work no matter how you try to specify a per-page authentication scheme if you only have per-page interactivity, but this would require using the specified authentication scheme to authenticate the per-page circuit.",
        "createdAt": "2024-07-08T20:34:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50122#issuecomment-2215229195"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85u3UxE",
    "title": "WsFederation Wtrealm is required but it is a nullable string on WsFederationOptions",
    "url": "https://github.com/dotnet/aspnetcore/issues/50242",
    "createdAt": "2023-08-21T19:22:19Z",
    "lastUpdated": "2024-02-13T01:26:32Z",
    "body": "              @halter73 @Tratcher - any thoughts here? Why is \u0060Options.Wtrealm\u0060 annotated as \u0060string?\u0060 when \u0060WsFederationMessage.Wtrealm\u0060 is a non-nullable \u0060string\u0060? Do we have our nullable annotations incorrect in ASP.NET?\r\n\r\n_Originally posted by @eerhardt in https://github.com/dotnet/aspnetcore/pull/50218#discussion_r1300412103_\r\n            ",
    "upvotes": 0,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85kqeaz",
        "parentId": null,
        "author": "halter73",
        "content": "Should we close this now that https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/2240 has been opened?",
        "createdAt": "2023-08-22T20:10:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50242#issuecomment-1688856243"
      },
      {
        "id": "IC_kwDOAQzde85kqgKU",
        "parentId": null,
        "author": "eerhardt",
        "content": "I think we can use this to track removing the \u0060!\u0060s added in #50218. All three of them should be able to be removed once we get a build with https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/pull/2241 in it.",
        "createdAt": "2023-08-22T20:16:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50242#issuecomment-1688863380"
      },
      {
        "id": "IC_kwDOAQzde85k2oAD",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-08-24T16:37:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50242#issuecomment-1692041219"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85wHbSL",
    "title": "Add the ability to view the authentication server session identifier returned from ITicketStore.",
    "url": "https://github.com/dotnet/aspnetcore/issues/50517",
    "createdAt": "2023-09-05T00:31:59Z",
    "lastUpdated": "2024-02-13T01:25:25Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nDevelopers who use ASP.NET Core to create OAuth/OpenID Connect providers often require a mechanism to work with server-side sessions. For instance, they may need to implement a deferred Back Channel Logout Notification, which involves placing the identifier of the ended user session in a queue by the provider when the user logs out from the Identity Provider (IDP). This allows all client applications to be notified of the session termination in the background, ensuring that the logout operation doesn\u0027t take up too much time.\r\n\r\n\r\nIn the standard CookieAuthenticationHandler, there is an [ITicketStore](https://github.com/dotnet/aspnetcore/blob/00d0038f937f0059a847fde504649fe33ec935e0/src/Security/Authentication/Cookies/src/CookieAuthenticationOptions.cs#L118-L122) designed for working with server-side sessions. However, the session identifier it returns is only stored in the cookie and there are no convenient ways to retrieve it directly.\r\n\r\nIf I need a server session identifier, the following options are available to me:\r\n- Generate a separate \u0022actual\u0022 surrogate session identifier before invoking the save operation in the database through ITicketStore, save it in ClaimsPrincipal or AuthenticationProperties, and subsequently access it appropriately.\r\n- Write an implementation of ITicketStore that will use the key from the provided parameters as such an identifier and dynamically add it during reading, mutating the passed AuthenticationTicket, and remove it during writing (as this parameter serves as the key by which the AuthenticationTicket should be stored).\r\n- Create a custom CookieAuthenticationHandler that enables dynamic addition and concealment of this identifier, similar to the previous approach, but at the authentication handler level without transferring this logic to the ITicketStore.\r\n- In case the session identifier is generated by the database itself and I need to store it, and none of the previous options suit me, I am forced to first create a record in the database, then save the obtained identifier in ClaimsPrincipal or Authentication Properties, and then update the newly created record as well as mutate the passed AuthenticationTicket so that the code following the authentication handler can access this identifier.\r\n- Create a separate cookie to store the server session identifier.\r\n- Using the same DataProtection settings as the original authentication handler, independently read and decrypt the session identifier from the cookie using a separate extension method for HttpContext.\r\n\r\nAll these options seem fragile and inconvenient. Having a mechanism that would allow \u0022pulling\u0022 the identifier, which is [created here](https://github.com/dotnet/aspnetcore/blob/00d0038f937f0059a847fde504649fe33ec935e0/src/Security/Authentication/Cookies/src/ITicketStore.cs#L37), retrieved from the cookie and [stored in runtime here](https://github.com/dotnet/aspnetcore/blob/00d0038f937f0059a847fde504649fe33ec935e0/src/Security/Authentication/Cookies/src/CookieAuthenticationHandler.cs#L32), and [passed as a \u0022key\u0022 parameter here](https://github.com/dotnet/aspnetcore/blob/00d0038f937f0059a847fde504649fe33ec935e0/src/Security/Authentication/Cookies/src/ITicketStore.cs#L88), would enable much more convenient handling of server sessions.\r\n\n\n### Describe the solution you\u0027d like\n\n1) Add a separate public property to AuthenticationProperties for a non-serializable dictionary, similar to the Parameters property, but instead of input parameters, it will store output parameters of the authentication handler. Then, place the session identifier into this dictionary within the CookieAuthenticationHandler.\r\n2) Add a separate nullable string property to [\u0060AuthenticationProperties\u0060](https://github.com/dotnet/aspnetcore/blob/00d0038f937f0059a847fde504649fe33ec935e0/src/Http/Authentication.Abstractions/src/AuthenticationProperties.cs) and make it non-serializable. This property would hold the value of the server session identifier after retrieving it from [\u0060ITicketStore\u0060](https://github.com/dotnet/aspnetcore/blob/00d0038f937f0059a847fde504649fe33ec935e0/src/Security/Authentication/Cookies/src/ITicketStore.cs). For example, near the code that sets the value in the private field [\u0060_sessionKey\u0060](https://github.com/dotnet/aspnetcore/blob/00d0038f937f0059a847fde504649fe33ec935e0/src/Security/Authentication/Cookies/src/CookieAuthenticationHandler.cs#L32) in CookieAuthenticationHandler, a method call can be added to set the value of this property in AuthenticationProperties. \r\n3) Use the [\u0060Parameters\u0060](https://github.com/dotnet/aspnetcore/blob/00d0038f937f0059a847fde504649fe33ec935e0/src/Http/Authentication.Abstractions/src/AuthenticationProperties.cs#L67) dictionary in AuthenticationProperties for these purposes. But I like this option less because \u0060Parameters\u0060 is used for passing input parameters. On the other hand, [\u0060Items\u0060](https://github.com/dotnet/aspnetcore/blob/00d0038f937f0059a847fde504649fe33ec935e0/src/Http/Authentication.Abstractions/src/AuthenticationProperties.cs#L60) seems like a good candidate based on the description, but it is a serializable value that needs to be stored in a database. The scenario where we only learn the actual identifier after writing to the database is valid, and we shouldn\u0027t exclude it, so \u0060Items\u0060 won\u0027t be suitable.\n\n### Additional context\n\nIn this issue, I am indeed discussing authentication sessions implemented through ITicketStore. It is not related to regular sessions used for storing intermediate data, such as items in a shopping cart.",
    "upvotes": 3,
    "labels": [
      "enhancement",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85lwDkD",
        "parentId": null,
        "author": "Tratcher",
        "content": "~~The ticket store key is not guaranteed to be a unique value per auth session. In fact, if a session expires but the cookie is still in use, the key could be re-used.~~\r\n\r\nI think you need your own value added to claims or AuthenticationProperties by the application that you can use to track sessions.",
        "createdAt": "2023-09-05T18:16:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50517#issuecomment-1707096323"
      },
      {
        "id": "IC_kwDOAQzde85l859V",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-09-07T16:36:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50517#issuecomment-1710464853"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85xu3Eh",
    "title": "IAuthorizationMiddlewareResultHandler not called",
    "url": "https://github.com/dotnet/aspnetcore/issues/50867",
    "createdAt": "2023-09-22T03:08:56Z",
    "lastUpdated": "2024-02-13T01:23:37Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nA custom IAuthorizationMiddlewareResultHandler is not called if a controller/action is not decorated with Authorize-Attribute but instead enriched via a IControllerModelConvention, e.g.\r\n\u0060\r\ncontroller.Filters.Add(new AuthorizeFilter(AuthConstants.PolicyMembershipFull));\r\n\u0060\n\n### Expected Behavior\n\nThe IAuthorizationMiddlewareResultHandler.HandleAsync needs to get called not matter how the controller/action gets it\u0027s Authorization settings.\n\n### Steps To Reproduce\n\nsee description\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n.net 7\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85uDgGr",
        "parentId": null,
        "author": "jossean-rivera",
        "content": "### Here are the steps for a minimal reproduction\r\n- Create a custom authentication handler that always validates every Http request with a hard-coded claims principal for a user named John Doe.\r\n- Create a custom week day policy requirement and policy handler that validates if a request was being made on a specific day of the week (say Monday)\r\n- Using the week day policy handler, create a policy that only validates requests on Monday named \u0022MondayPolicy\u0022.\r\n- Create a custom implementation of [IAuthorizationMiddlewareResultHandler](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authorization.iauthorizationmiddlewareresulthandler?view=aspnetcore-7.0) that will get the error message from any failed policies and write them on the body of the Http response. \r\n- Add the AuthorizeFilter globally using the \u0022MondayPolicy\u0022.\r\n- Add a controller action for the route \u0022/monday\u0022.\r\n- Run the app, send an Http request to /monday and check the response. If the day is not Monday, the response will have a status of 403 but the response body will be empty because [IAuthorizationMiddlewareResultHandler](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authorization.iauthorizationmiddlewareresulthandler?view=aspnetcore-7.0) was not called. \r\n- Comment the line 35 where we set the [AuthorizeFilter](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.authorization.authorizefilter?view=aspnetcore-7.0) globally and uncomment line 144 where we use the [AuthorizeAttribute](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authorization.authorizeattribute?view=aspnetcore-7.0). \r\n- Run the app, send an Http request to /monday and check the response. If the day is not Monday, you will see the following error on the body of the request: \u0022Authorization failed because the request was made on the wrong day of the week. Please, come back on Monday.\u0022\r\n\r\n\u0060\u0060\u0060c#\r\nusing System.Security.Claims;\r\nusing System.Text.Encodings.Web;\r\nusing Microsoft.AspNetCore.Authentication;\r\nusing Microsoft.AspNetCore.Authorization;\r\nusing Microsoft.AspNetCore.Authorization.Policy;\r\nusing Microsoft.AspNetCore.Mvc;\r\nusing Microsoft.AspNetCore.Mvc.Authorization;\r\nusing Microsoft.Extensions.Options;\r\n\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\n// Add services to the container.\r\nbuilder.Services.AddAuthentication()\r\n    .AddScheme\u003CAuthenticationSchemeOptions, ConstantAuthenticationHandler\u003E(\u0022ConstantAuthScheme\u0022, options =\u003E { });\r\n\r\nbuilder.Services.AddAuthorization(options =\u003E\r\n{\r\n    AuthorizationPolicy policy = new AuthorizationPolicyBuilder()\r\n        .RequireAuthenticatedUser()\r\n        .RequireDayOfWeek(DayOfWeek.Monday)\r\n        .AddAuthenticationSchemes(\u0022ConstantAuthScheme\u0022)\r\n        .Build();\r\n    options.AddPolicy(\u0022MondayPolicy\u0022, policy);\r\n});\r\n\r\nbuilder.Services.AddSingleton\u003CIAuthorizationMiddlewareResultHandler, MyAuthorizationMiddlewareResultHandler\u003E();\r\nbuilder.Services.AddSingleton\u003CIAuthorizationHandler, WeekRequirementHandler\u003E();\r\n\r\n//  Add controllers\r\n//  Add the AuthorizeFilter and run the MondayPolicy globaly\r\nbuilder.Services.AddControllers(options =\u003E\r\n{\r\n    //  COMMENT THE FOLLOWING LINE TO SEE HOW IAuthorizationMiddlewareResultHandler\r\n    //  GETS CALLED WHEN YOU USE THE [Authorize(\u0022MondayPolicy\u0022)] ATTRIBUTE ON THE CONTROLLER ACTION\r\n    options.Filters.Add(new AuthorizeFilter(\u0022MondayPolicy\u0022));\r\n});\r\n\r\nWebApplication app = builder.Build();\r\n\r\n// Configure the HTTP request pipeline.\r\napp.UseAuthentication();\r\napp.UseAuthorization();\r\napp.MapControllers();\r\n\r\napp.Run();\r\n\r\n\r\n//  A custom authentication handler that always validates an Http request with a hard-coded parsed token for John Doe\r\nclass ConstantAuthenticationHandler : AuthenticationHandler\u003CAuthenticationSchemeOptions\u003E\r\n{\r\n    public ConstantAuthenticationHandler(\r\n        IOptionsMonitor\u003CAuthenticationSchemeOptions\u003E options,\r\n        ILoggerFactory logger,\r\n        UrlEncoder encoder,\r\n        ISystemClock clock) : base(options, logger, encoder, clock)\r\n    {\r\n\r\n    }\r\n\r\n    protected override Task\u003CAuthenticateResult\u003E HandleAuthenticateAsync()\r\n    {\r\n        //  Hard-code a parsed token and always set the authentication result to success\r\n        Claim[] claims = new[]\r\n        {\r\n            new Claim(ClaimTypes.Upn, \u0022johndoe@example.com\u0022),\r\n            new Claim(ClaimTypes.Email, \u0022johndoe@example.com\u0022),\r\n            new Claim(ClaimTypes.GivenName, \u0022John\u0022),\r\n            new Claim(ClaimTypes.GivenName, \u0022Doe\u0022),\r\n            new Claim(ClaimTypes.Name, \u0022John Doe\u0022),\r\n            new Claim(ClaimTypes.Role, \u0022base_user\u0022),\r\n        };\r\n        ClaimsIdentity identity = new(claims, Scheme.Name, nameType: ClaimTypes.Name, roleType: ClaimTypes.Role);\r\n        ClaimsPrincipal principal = new(identity);\r\n        AuthenticationTicket ticket = new(principal, Scheme.Name);\r\n        AuthenticateResult success = AuthenticateResult.Success(ticket);\r\n        return Task.FromResult(success);\r\n    }\r\n}\r\n\r\n//  A policy requirment to validate requests on a specific day of the week\r\nclass WeekRequirement : IAuthorizationRequirement\r\n{\r\n    public DayOfWeek ValidDayOfWeek { get; }\r\n\r\n    public WeekRequirement(DayOfWeek validDayOfWeek) =\u003E ValidDayOfWeek = validDayOfWeek;\r\n}\r\n\r\n//  The policy handler for validating requests on a specific day of the week\r\nclass WeekRequirementHandler : AuthorizationHandler\u003CWeekRequirement\u003E\r\n{\r\n    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context, WeekRequirement requirement)\r\n    {\r\n        //  Check if the request is being made on the day of the week\r\n        if (requirement.ValidDayOfWeek == DateTime.Now.DayOfWeek)\r\n        {\r\n            context.Succeed(requirement);\r\n        }\r\n        else\r\n        {\r\n            string message = \u0022Authorization failed because the request was made on the wrong day of the week. \u0022 \u002B\r\n                $\u0022Please, come back on {requirement.ValidDayOfWeek}.\u0022;\r\n            context.Fail(new AuthorizationFailureReason(this, message));\r\n        }\r\n\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n\r\nstatic class WeekRequirementExtensions\r\n{\r\n    public static AuthorizationPolicyBuilder RequireDayOfWeek(this AuthorizationPolicyBuilder policyBuilder, DayOfWeek dayOfWeek)\r\n    {\r\n        return policyBuilder.AddRequirements(new WeekRequirement(dayOfWeek));\r\n    }\r\n}\r\n\r\n\r\n//  A custom authorization middleware that takes the error message from a failed policy\r\nclass MyAuthorizationMiddlewareResultHandler : IAuthorizationMiddlewareResultHandler\r\n{\r\n    private readonly AuthorizationMiddlewareResultHandler _defaultHandler = new();\r\n\r\n    public Task HandleAsync(RequestDelegate next, HttpContext context, AuthorizationPolicy policy, PolicyAuthorizationResult authorizeResult)\r\n    {\r\n        if (!authorizeResult.Succeeded \u0026\u0026 authorizeResult.AuthorizationFailure?.FailureReasons?.Any() == true)\r\n        {\r\n            //  Use the error message from a failed policy and write it on the body of the request\r\n            string errorMessage = string.Join(\u0022; \u0022, authorizeResult.AuthorizationFailure.FailureReasons.Select(fr =\u003E fr.Message));\r\n            context.Response.StatusCode = StatusCodes.Status403Forbidden;\r\n            return context.Response.WriteAsync(errorMessage);\r\n        }\r\n\r\n        //  Use the default handler implementation\r\n        return _defaultHandler.HandleAsync(next, context, policy, authorizeResult);\r\n    }\r\n}\r\n\r\n[ApiController]\r\npublic class WeekController : ControllerBase\r\n{\r\n    //  UNCOMMENT THE FOLLOWING LINE TO SEE HOW IAuthorizationMiddlewareResultHandler\r\n    //  GETS CALLED WHEN YOU USE THE [Authorize(\u0022MondayPolicy\u0022)] ATTRIBUTE ON THE CONTROLLER ACTION\r\n    //[Authorize(\u0022MondayPolicy\u0022)]\r\n    [HttpGet(\u0022monday\u0022)]\r\n    public string Monday() =\u003E \u0022Hello, \u0022 \u002B (User.Identity?.Name ?? \u0022MISSING_NAME\u0022);\r\n}\r\n\u0060\u0060\u0060\r\n\r\n### Output using AuthorizeFilter globally\r\n\u003Cimg width=\u0022608\u0022 alt=\u0022Screenshot 2023-12-07 at 5 18 04 PM\u0022 src=\u0022https://github.com/dotnet/aspnetcore/assets/32784144/57371afc-1e0f-4ad1-9a99-8f1265c07a63\u0022\u003E\r\n\r\n### Output using AuthorizeAttribute\r\n\u003Cimg width=\u0022599\u0022 alt=\u0022Screenshot 2023-12-07 at 5 18 42 PM\u0022 src=\u0022https://github.com/dotnet/aspnetcore/assets/32784144/5f373c9c-7563-4ea6-9a0a-260edadf30ca\u0022\u003E\r\n\r\nThanks for creating this issue, I couldn\u0027t find why IAuthorizationMiddlewareResultHandler wasn\u0027t being called until I found this ticket. I thought that it was happening because we were using multiple authentication schemes, but after I created the reproduce from above with multiple authentication schemes, I realized that wasn\u0027t the real problem.",
        "createdAt": "2023-12-08T01:25:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50867#issuecomment-1846411691"
      },
      {
        "id": "IC_kwDOAQzde85zEu5a",
        "parentId": null,
        "author": "michiproep",
        "content": "I haven\u0027t tested with . net 8 yet but if this is still an issue it should not get closed",
        "createdAt": "2024-02-06T19:32:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50867#issuecomment-1930620506"
      },
      {
        "id": "IC_kwDOAQzde85zFtkW",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2024-02-06T22:28:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50867#issuecomment-1930877206"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85y94l9",
    "title": "Add logging in SecureDataFormat",
    "url": "https://github.com/dotnet/aspnetcore/issues/51169",
    "createdAt": "2023-10-05T18:22:10Z",
    "lastUpdated": "2024-09-17T18:10:22Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nErrors from Unprotect are currently suppressed, making them difficult to debug.\r\nhttps://github.com/dotnet/aspnetcore/blob/933bc8447e10e3e4a327e8ac1c598935ddd294ae/src/Security/Authentication/Core/src/SecureDataFormat.cs#L85-L89\n\n### Describe the solution you\u0027d like\n\nLog these Exceptions.\n\n### Additional context\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "task",
      "area-auth",
      "feature-observability"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde851vJS1",
    "title": "MapRazorComponents broken with FallbackPolicy RequireAuthenticatedUser",
    "url": "https://github.com/dotnet/aspnetcore/issues/51836",
    "createdAt": "2023-11-03T01:22:24Z",
    "lastUpdated": "2025-01-05T15:59:13Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nIt seems fallback policy is broken for all blazor modes.\r\n\r\n\u0060\u0060\u0060\r\nservices.AddAuthorization(o =\u003E o.FallbackPolicy = new AuthorizationPolicyBuilder().RequireAuthenticatedUser().Build());\r\n...\r\napp.UseStaticFiles();\r\napp.UseAuth...();\r\napp.MapRazorComponents\u003CApp\u003E()\r\n   .AddInteractiveServerRenderMode();\r\n\u0060\u0060\u0060\r\n\r\nresults in a redirect to login when requesting \u0060/_framework/blazor.web.js\u0060.\r\n\r\n\u0060\u0060\u0060\r\nservices.AddAuthorization(o =\u003E o.FallbackPolicy = new AuthorizationPolicyBuilder().RequireAuthenticatedUser().Build());\r\n...\r\napp.UseStaticFiles();\r\napp.MapRazorComponents\u003CApp\u003E()\r\n   .AddInteractiveServerRenderMode();\r\napp.UseAuth...();\r\n\u0060\u0060\u0060\r\n\r\nALSO results in a redirect to login when requesting \u0060/_framework/blazor.web.js\u0060.\r\n\n\n### Expected Behavior\n\nPutting Maps before UseAuth... =\u003E no auth check\r\nPutting Maps after UseAuth... =\u003E auth check for pages, but not for staticfiles\r\n\n\n### Steps To Reproduce\n\nSee above\n\n### Exceptions (if any)\n\nNo\n\n### .NET Version\n\n8.0.100-rc.2.23502.2\n\n### Anything else?\n\n_No response_",
    "upvotes": 5,
    "labels": [
      "Docs",
      "area-auth",
      "feature-blazor-server-auth",
      "Pillar: Complete Blazor Web"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85vmEm3",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 9 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-12-29T18:03:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51836#issuecomment-1872251319"
      },
      {
        "id": "IC_kwDOAQzde85zZr0H",
        "parentId": null,
        "author": "codymullins",
        "content": "Is there any kind of workaround here or timeline to a fix?",
        "createdAt": "2024-02-09T15:17:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51836#issuecomment-1936112903"
      },
      {
        "id": "IC_kwDOAQzde85zeszw",
        "parentId": null,
        "author": "bmarkovic17",
        "content": "I\u0027ve ended up putting \u0060@attribute {Authorize]\u0060 which will use the default policy on all of my blazor components which by default is that a user needs to be authenticated, but can be adjusted if needed.\r\n\r\n![image](https://github.com/dotnet/aspnetcore/assets/13367265/90e0c244-8cc8-4167-a363-78a15b037ad6)\r\n",
        "createdAt": "2024-02-11T05:04:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51836#issuecomment-1937427696"
      },
      {
        "id": "IC_kwDOAQzde851b5jB",
        "parentId": null,
        "author": "halter73",
        "content": "https://github.com/dotnet/AspNetCore.Docs/issues/31931 shows another example of someone else running into the same issue but for \u0060blazor.server.js\u0060 which is a regression. Previously, it was much easier to just add the \u0060UseStaticFiles()\u0060 before \u0060UseAuthorization()\u0060 if you didn\u0027t want to require authentication for Blazor\u0027s static resources.\r\n\r\nThe [workarounds I suggest](https://github.com/dotnet/AspNetCore.Docs/issues/31931#issuecomment-1970240747) could be used such as applying the \u0060[Authorize]\u0060 attribute in the \u0060_Imports.razor\u0060 file all have shortcomings. It makes me think that maybe we should add a simple boolean option to add \u0060[AllowAnonymous]\u0060 to all of Blazor\u0027s static endpoints.",
        "createdAt": "2024-02-29T01:49:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51836#issuecomment-1970247873"
      },
      {
        "id": "IC_kwDOAQzde851fVYz",
        "parentId": null,
        "author": "codymullins",
        "content": "@halter73 I ran into this - was getting 302 redirected on the \u0060_framework\u0060 path. The solution you commented in the other issue is good as a workaround, but note that all the \u0060_framework\u0060 paths will have the same issue. \r\n\r\nI initially only checked for the specific path that was triggering the challenge but quickly discovered it needed to be a starts-with check.\r\n\r\n![image](https://github.com/dotnet/aspnetcore/assets/1738479/8e95d4c4-21c4-4924-beb6-7302ae4aedc3)\r\n\r\nI worked around it with a handler (have since disabled the \u0022global auth\u0022 setting due to other issues, though.)\r\n\r\n\u0060\u0060\u0060\r\npublic class BlazorFrameworkAuthorizationMiddlewareResultHandler(ILogger\u003CBlazorFrameworkAuthorizationMiddlewareResultHandler\u003E log) : IAuthorizationMiddlewareResultHandler\r\n{\r\n    private readonly AuthorizationMiddlewareResultHandler handler = new();\r\n\r\n    public async Task HandleAsync(\r\n        RequestDelegate next,\r\n        HttpContext context,\r\n        AuthorizationPolicy policy,\r\n        PolicyAuthorizationResult authorizeResult)\r\n    {\r\n        if (IsFrameworkPath(context.Request.Path) \u0026\u0026 authorizeResult.Challenged)\r\n        {\r\n            log.LogInformation(\u0022Bypassing challenge for _framework files\u0022);\r\n            // allow required framework paths to be accessible anonymously\r\n            await handler.HandleAsync(next, context, policy, PolicyAuthorizationResult.Success());\r\n            return;\r\n        }\r\n\r\n        await handler.HandleAsync(next, context, policy, authorizeResult);\r\n    }\r\n\r\n    private bool IsFrameworkPath(string path)\r\n    {\r\n        return path.StartsWith(\u0022/_framework\u0022);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n",
        "createdAt": "2024-02-29T13:30:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51836#issuecomment-1971148339"
      },
      {
        "id": "IC_kwDOAQzde86E3GQP",
        "parentId": null,
        "author": "seanterry",
        "content": "This is my workaround for a static SSR project:\r\n\u0060\u0060\u0060\r\nAuthorizationPolicy defaultDeny = new AuthorizationPolicyBuilder()\r\n    .RequireAssertion( context =\u003E context.Resource is HttpContext { Request : { Method: \u0022GET\u0022, Path.Value: \u0022/_framework/blazor.web.js\u0022 } } )\r\n    .Build();\r\n\r\nbuilder.Services.AddAuthorizationBuilder()\r\n    .SetFallbackPolicy( defaultDeny )\r\n    // other authz stuff\r\n;\r\n\u0060\u0060\u0060\r\n\r\nThis seems to work well, and loudly reminds me when I have forgotten to explicitly set the authorization policy for an endpoint.",
        "createdAt": "2024-07-15T17:33:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51836#issuecomment-2229036047"
      },
      {
        "id": "IC_kwDOAQzde86KBfcX",
        "parentId": null,
        "author": "gragundier",
        "content": "What follows is yet another way to work around the problem. Defining the Fallback policy caused a lot of weird undesirable behavior, but we still wanted to protect our static files. I built what is essentially a wrapper for the StaticFilesMiddleware to ensure authentication before delivering the files.\n\n\u0060\u0060\u0060\npublic class CustomStaticFileMiddleware(RequestDelegate next, IWebHostEnvironment hostingEnv, \nIOptions\u003CStaticFileOptions\u003E options, ILoggerFactory loggerFactory, IAuthorizationService authorizationService)\n{\n    private readonly RequestDelegate _next = next;\n\n    private readonly StaticFileMiddleware _staticFileMiddleware = new(next, hostingEnv, options, loggerFactory);\n\n    private readonly IAuthorizationService _authorizationService = authorizationService;\n\n    public Task Invoke(HttpContext context)\n    {\n        var result = _authorizationService.AuthorizeAsync(context.User, null, new OurUserRequirement()).Result;\n        if (result.Succeeded)\n        {\n            return _staticFileMiddleware.Invoke(context);\n        }\n        else\n        {\n            return _next(context);\n        }\n    }\n}\n\n\u0060\u0060\u0060\n\nThe UseStaticFile() call is just a wrapper around a UseMiddleWare call to the StaticFileMiddleware so the replacement was luckily very simple.\n\n\u0060\u0060\u0060\n            app.UseMiddleware\u003CCustomStaticFileMiddleware\u003E(Options.Create(new StaticFileOptions\n            {\n                FileProvider = new PhysicalFileProvider(Path.Combine(env.ContentRootPath, \u0022Static\u0022)),\n                RequestPath = $\u0022/static\u0022\n            }));\n\u0060\u0060\u0060\n::EDIT::\nChanged code to reflect better implementation. Older suggestion used async which could cause the app to crash.\n::END EDIT::",
        "createdAt": "2024-08-28T15:15:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51836#issuecomment-2315646743"
      },
      {
        "id": "IC_kwDOAQzde86QVA2s",
        "parentId": null,
        "author": "boomalator",
        "content": "\u003E I\u0027ve ended up putting \u0060@attribute {Authorize]\u0060 which will use the default policy on all of my blazor components which by default is that a user needs to be authenticated, but can be adjusted if needed.\n\u003E \n\u003E ![image](https://github.com/dotnet/aspnetcore/assets/13367265/90e0c244-8cc8-4167-a363-78a15b037ad6)\n\nThis sounds like it works, but defeats the purpose of having a fallback policy. Sheesh.\n\nAm i the only one who wants to protect all pages except a few?",
        "createdAt": "2024-10-18T05:20:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51836#issuecomment-2421427628"
      },
      {
        "id": "IC_kwDOAQzde86QelMv",
        "parentId": null,
        "author": "codymullins",
        "content": "@boomalator no, you are certainly not.",
        "createdAt": "2024-10-19T14:57:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51836#issuecomment-2423935791"
      },
      {
        "id": "IC_kwDOAQzde86WD3Tn",
        "parentId": null,
        "author": "lasbrojen",
        "content": "Does anyone know if this was fixed in .net 9 ?\n\nI tried I upgraded my solution to .net 9.0 and looked through this: https://learn.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-9.0?view=aspnetcore-9.0#blazor without any luck in figuring it out",
        "createdAt": "2024-12-04T14:26:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51836#issuecomment-2517595367"
      },
      {
        "id": "IC_kwDOAQzde86WD4_U",
        "parentId": null,
        "author": "jonas-nordtorp",
        "content": "\u003E Does anyone know if this was fixed in .net 9 ?\n\u003E \n\u003E I tried I upgraded my solution to .net 9.0 and looked through this: https://learn.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-9.0?view=aspnetcore-9.0#blazor without any luck in figuring it out\n\nI have upgraded and deployed our solution using .net 9 and we still have to create workarounds for this\nIssue has milestone as .net10 planning, so there is that",
        "createdAt": "2024-12-04T14:29:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51836#issuecomment-2517602260"
      },
      {
        "id": "IC_kwDOAQzde86WEf7X",
        "parentId": null,
        "author": "lasbrojen",
        "content": "Thank you @jonas-nordtorp \uD83D\uDC4C\uD83D\uDE0A\n\nI ended up adding specific _Imports.razor files to different areas or folders.\n\nHere\u0027s an illustration of what I mean:\n\n![Image](https://github.com/user-attachments/assets/cff6cabe-7522-4efb-9f5d-3461277c58e5)\n",
        "createdAt": "2024-12-04T15:21:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51836#issuecomment-2517761751"
      },
      {
        "id": "IC_kwDOAQzde86Y3reU",
        "parentId": null,
        "author": "UsersHaveNames",
        "content": "\u003E This is my workaround for a static SSR project:\n\u003E \n\u003E \u0060\u0060\u0060\n\u003E AuthorizationPolicy defaultDeny = new AuthorizationPolicyBuilder()\n\u003E     .RequireAssertion( context =\u003E context.Resource is HttpContext { Request : { Method: \u0022GET\u0022, Path.Value: \u0022/_framework/blazor.web.js\u0022 } } )\n\u003E     .Build();\n\u003E \n\u003E builder.Services.AddAuthorizationBuilder()\n\u003E     .SetFallbackPolicy( defaultDeny )\n\u003E     // other authz stuff\n\u003E ;\n\u003E \u0060\u0060\u0060\n\u003E \n\u003E This seems to work well, and loudly reminds me when I have forgotten to explicitly set the authorization policy for an endpoint.\n\nthis is actually the best workaround our of all, simply check in the browser debugger what files get a 302 (Found) code, and add their file path into the new AuthorizationPolicy\n\n**But you might encounter an issue where you will suddenly lose access to everything after this so don;t forget to add an exception that the user is allowed to have access to other files either based on the fact that they are logged in** (or ideally in the future based on custom claims) here is my real-life fix in Blazor (Server Side) Web App - using .NET9 (still broken in .NET9).\n\u0060\u0060\u0060c#\n// Define a default deny policy with an exception for the \u0060_framework/blazor.web.js\u0060 file\nvar defaultDeny = new AuthorizationPolicyBuilder()\n    .RequireAssertion(context =\u003E\n        context.User.Identity != null \u0026\u0026 (context.User.Identity.IsAuthenticated ||\n                                          // Allow specific GET requests for static assets\n                                          context.Resource is HttpContext\n                                          {\n                                              Request:\n                                              {\n                                                  Method: \u0022GET\u0022, Path.Value:\n                                              \u0022/_framework/blazor.web.js\u0022 or\n                                              \u0022/lib/bootstrap/dist/css/bootstrap.min.xxx.css\u0022 or\n                                              \u0022/app.xxx.css\u0022 or\n                                              \u0022/RiskAssessmentApp.Web.xxx.styles.css\u0022 or\n                                              \u0022/favicon.png\u0022\n                                              }\n                                          } ||\n\n                                          // Allow POST requests to the authentication endpoints\n                                          context.Resource is HttpContext\n                                          {\n                                              Request:\n                                              {\n                                                  Method: \u0022POST\u0022, Path.Value:\n                                              \u0022/YourExternalLoginUrl\u0022 or\n                                              \u0022/YourLogoutUrl\u0022\n                                              }\n                                          } ||\n\n                                          // Allow anonymous access to the authentication callback URL\n                                          context.Resource is HttpContext { Request: { Method: \u0022GET\u0022, Path.Value: \u0022/signin-microsoft\u0022 } }))\n    .Build();\n\nservices.AddAuthorizationBuilder()\n    .SetFallbackPolicy(defaultDeny);\n\u0060\u0060\u0060 \n\nYou want to call the above before calling:\n\u0060\u0060\u0060c#\nvar app = builder.Build();\n\u0060\u0060\u0060 \n\n",
        "createdAt": "2024-12-29T13:53:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51836#issuecomment-2564732820"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde8522lSD",
    "title": "Blazor Authorization - AuthorizeRouteView and RedirectToLogin not working.",
    "url": "https://github.com/dotnet/aspnetcore/issues/52063",
    "createdAt": "2023-11-15T04:30:52Z",
    "lastUpdated": "2024-11-18T17:05:49Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nI\u0027ve created Blazor WebApp via VS 2022 template with individual identity.\r\nNo matter what I do, \u0060\u0060\u0060\u003CAuthorizeRouteView\u003E\u0060\u0060\u0060 and \u0060\u0060\u0060\u003CNotAuthorized\u003E\u0060\u0060\u0060 are not working and redirect any request to /Account/Login. putting \u0060\u0060\u0060\u003Cp\u003Enot working\u003C/p\u003E\u0060\u0060\u0060 doesn\u0027t help.\r\n\r\n### Expected Behavior\r\n\u0060\u0060\u0060\r\n\u003CRouter AppAssembly=\u0022@typeof(Program).Assembly\u0022\u003E\r\n    \u003CFound Context=\u0022routeData\u0022\u003E\r\n        \u003CAuthorizeRouteView RouteData=\u0022@routeData\u0022 DefaultLayout=\u0022@typeof(Layout.MainLayout)\u0022\u003E\r\n            \u003CNotAuthorized\u003E\r\n                \u003Cp\u003Enot authorized\u003C/p\u003E\r\n            \u003C/NotAuthorized\u003E\r\n        \u003C/AuthorizeRouteView\u003E\r\n        \u003CFocusOnNavigate RouteData=\u0022@routeData\u0022 Selector=\u0022h1\u0022 /\u003E\r\n    \u003C/Found\u003E\r\n\u003C/Router\u003E\r\n\u0060\u0060\u0060\r\nPrints \u0022not authorized\u0022 when you click \u0022Auth Required\u0022 in the template app\r\n\r\n\u003Cimg width=\u0022689\u0022 alt=\u0022image\u0022 src=\u0022https://github.com/dotnet/aspnetcore/assets/1384630/90647652-bf34-43e9-bb82-b84ad896d8dd\u0022\u003E\r\n\r\n\r\n### Steps To Reproduce\r\n\r\n1) Create Blazor Web App with Server Interactive render mode, and with Individual Account Authentication type.\r\n2) Replace from \u0022\u0060\u0060\u0060\u003CRedirectToLogin /\u003E\u0060\u0060\u0060\u0022 to \u0022\u0060\u0060\u0060\u003Cp\u003Enot authorized\u003C/p\u003E\u0060\u0060\u0060\u0022 in Routes.razor (to see if your redirection is from RedirectToLogin component)\r\n3) Click \u0022Auth Required\u0022 in template app.\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n8.0.100\r\n\r\n### Anything else?\r\n\r\nThis is a blocker since I was migrating .NET 7.0 app to .NET 8.0, but It behaves very differently.",
    "upvotes": 36,
    "labels": [
      "Docs",
      "area-auth",
      "feature-identity-ui"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85sB5Ym",
        "parentId": null,
        "author": "appsolab",
        "content": "Same here. Since RC1 I can\u0027t migrate without this issue.",
        "createdAt": "2023-11-15T12:16:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1812436518"
      },
      {
        "id": "IC_kwDOAQzde85sED8t",
        "parentId": null,
        "author": "MackinnonBuck",
        "content": "@halter73 Would you be able to look into this?",
        "createdAt": "2023-11-15T17:58:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1813004077"
      },
      {
        "id": "IC_kwDOAQzde85sJIH4",
        "parentId": null,
        "author": "christallire",
        "content": "Another thing I noticed Is that an authorization check (the route with [Authorize] Attribute) is done before the component lifecycle or Routing. \r\nFor an example. I used to put OnInitialized and handle some logic in what we now call Routes.razor. When I refresh the page, no routing or component lifecycle logic runs. Is this where we have the bug?\r\n\r\n.NET 7.0\r\nNo auth - Route OnInitialized = YES\r\nReq Auth- Route OnInitialized = YES\r\n\r\n.NET 8.0\r\nNo auth - Route Oninitialized = YES\r\nReq Auth - Route OnInitialized = NO\r\n\r\nUpon investigating all other interactivity - the same thing happens when refresh. It looks like there\u0027s something with pipeline.",
        "createdAt": "2023-11-16T12:17:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1814331896"
      },
      {
        "id": "IC_kwDOAQzde85sJouv",
        "parentId": null,
        "author": "christallire",
        "content": "it seems the new 8.0 routing adds pages with [Authorization] to route, so that they have authorization metadata and can be checked with AuthorizationMiddleware if we prerender or first render (when we have HttpContext)\r\n\r\nThe request runs through pipelines, Invoking Authentication middleware first, and if this fails (no login, so always) - doing redirection defined in middleware.\r\nBut this is different, especially when we navigate with SPA and there\u0027s no Authentication middleware (obviously), and AuthenticationStateProvider is invoked instead of the middleware.\r\n\r\nI think someone really messed this up.\r\n\r\nedit: When I add JwtBearer authentication to the application they just throw 401 so authorization middleware it is.",
        "createdAt": "2023-11-16T13:46:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1814465455"
      },
      {
        "id": "IC_kwDOAQzde85sJsPH",
        "parentId": null,
        "author": "christallire",
        "content": "@MackinnonBuck can we urgently have a look into this? this seems serious because Authorization in blazor is basically broken.",
        "createdAt": "2023-11-16T13:54:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1814479815"
      },
      {
        "id": "IC_kwDOAQzde85sMfMR",
        "parentId": null,
        "author": "joecuevasjr",
        "content": "I\u0027m experiencing the same issue as @christallire. This was working as expected in NET 7. In my case I\u0027m using a Cookie for auth but I don\u0027t utilize the Cookie\u0027s \u0060options.LoginPath\u0060 configuration. I prefer to use the \u0060\u003CNotAuthorized\u003E\u0060 template directive.",
        "createdAt": "2023-11-16T19:50:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1815212817"
      },
      {
        "id": "IC_kwDOAQzde85sNIg9",
        "parentId": null,
        "author": "augustevn",
        "content": "@halter73 @MackinnonBuck @mkArtakMSFT\r\n\r\nI did some digging, it seems like the user Claims are no longer returned from \u0060/manage/info\u0060 from the \u0060.MapIdentityApi\u003CUser\u003E()\u0060.\r\n\r\nThis change broke my app, worked in RC2 not in RTM. Is this intentional? Possibly related.\r\n\r\n\u0060IdentityApiEndpointRouteBuilderExtensions.cs\u0060, line 455:\r\n\r\n\u0060\u0060\u0060\r\n\r\n    private static async Task\u003CInfoResponse\u003E CreateInfoResponseAsync\u003CTUser\u003E(TUser user, UserManager\u003CTUser\u003E userManager)\r\n        where TUser : class\r\n    {\r\n        return new()\r\n        {\r\n            Email = await userManager.GetEmailAsync(user) ?? throw new NotSupportedException(\u0022Users must have an email.\u0022),\r\n            IsEmailConfirmed = await userManager.IsEmailConfirmedAsync(user),\r\n        };\r\n    }\r\n\r\n\u0060\u0060\u0060",
        "createdAt": "2023-11-16T21:59:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1815382077"
      },
      {
        "id": "IC_kwDOAQzde85sQt6r",
        "parentId": null,
        "author": "augustevn",
        "content": "@christallire How do you implement the \u0060AuthenticationStateProvider\u0060 and do you pass your claims to it? If so, could you check whether your claims are empty or not?",
        "createdAt": "2023-11-17T12:24:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1816321707"
      },
      {
        "id": "IC_kwDOAQzde85sQxVe",
        "parentId": null,
        "author": "christallire",
        "content": "\u003E @christallire How do you implement the \u0060AuthenticationStateProvider\u0060 and do you pass your claims to it? If so, could you check whether your claims are empty or not?\r\n\r\n(edit: oh shoot sorry I thought you\u0027re asking me about my \u0022original\u0022 implementation)\r\n\r\nI haven\u0027t changed anything from the template project except \u0060RedirectToLogin\u0060 part.",
        "createdAt": "2023-11-17T12:33:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1816335710"
      },
      {
        "id": "IC_kwDOAQzde85sU6Ng",
        "parentId": null,
        "author": "christallire",
        "content": "Well, I found a workaround by:\r\ndefine following class and register it where server initializes\r\n\r\n\u0060\u0060\u0060\r\npublic class BlazorAuthorizationMiddlewareResultHandler : IAuthorizationMiddlewareResultHandler\r\n{\r\n    public Task HandleAsync(RequestDelegate next, HttpContext context, AuthorizationPolicy policy, PolicyAuthorizationResult authorizeResult)\r\n    {\r\n        return next(context);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\nand handler:\r\n\u0060\u0060\u0060\r\nservices.AddSingleton\u003CIAuthorizationMiddlewareResultHandler, BlazorAuthorizationMiddlewareResultHandler\u003E();\r\n\u0060\u0060\u0060\r\n\r\nThis class will prevent redirection from the new .net 8 authorization middleware response.\r\nThe problem still exists, but we can at least we can use .NET 8 new feature the way we used to in Blazor and .NET 7.\r\n\r\nYou may need to separate endpoint routing other than blazor routes since it basically renders serverside authorization (via \u0060.AddAuthentication(...).AddJwtBearer(...)\u0060) ineffective.\r\n\r\nhope this helps, enjoy .net 8. while the team fixes the problem.",
        "createdAt": "2023-11-18T07:13:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1817420640"
      },
      {
        "id": "IC_kwDOAQzde85sbE-D",
        "parentId": null,
        "author": "Kumima",
        "content": "After investigation, I can understand it\u0027s by design now. But this is still a **very** weird behavior of navigation. \r\nIf the interactive is not ready, the app is matching \u0060Static Stuff Routes\u0060, the request route is managed by the pipeline. It will be redirected by \u0060CookieAuthentication*\u0060 stuff. Only after the app is ready to be interactive, the interactive \u0060Routes\u0060 component takes over the routing. If you refresh the browser manually, there is no ready interactive component.\r\n\r\nThis is just one of the problems that may arise. A worse scenario is the pages may flicker caused by this. Because the \u0060Static Response\u0060 during Prerender may significantly differ from the \u0060Interactive Content\u0060. Check #51203 to see the behavior.\r\n\r\nA deeper investigation is under #52176 ",
        "createdAt": "2023-11-20T13:10:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1819037571"
      },
      {
        "id": "IC_kwDOAQzde85s57jw",
        "parentId": null,
        "author": "christallire",
        "content": "I\u0027m afraid I have to disagree that this problem can be solved with documentation.",
        "createdAt": "2023-11-27T04:56:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1827125488"
      },
      {
        "id": "IC_kwDOAQzde85wHzuZ",
        "parentId": null,
        "author": "eholman",
        "content": "\u003E Well, I found a workaround by: define following class and register it where server initializes\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E public class BlazorAuthorizationMiddlewareResultHandler : IAuthorizationMiddlewareResultHandler\r\n\u003E {\r\n\u003E     public Task HandleAsync(RequestDelegate next, HttpContext context, AuthorizationPolicy policy, PolicyAuthorizationResult authorizeResult)\r\n\u003E     {\r\n\u003E         return next(context);\r\n\u003E     }\r\n\u003E }\r\n\u003E \u0060\u0060\u0060\r\n\u003E \r\n\u003E and handler:\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E services.AddSingleton\u003CIAuthorizationMiddlewareResultHandler, BlazorAuthorizationMiddlewareResultHandler\u003E();\r\n\u003E \u0060\u0060\u0060\r\n\u003E \r\n\u003E This class will prevent redirection from the new .net 8 authorization middleware response. The problem still exists, but we can at least we can use .NET 8 new feature the way we used to in Blazor and .NET 7.\r\n\u003E \r\n\u003E You may need to separate endpoint routing other than blazor routes since it basically renders serverside authorization (via \u0060.AddAuthentication(...).AddJwtBearer(...)\u0060) ineffective.\r\n\u003E \r\n\u003E hope this helps, enjoy .net 8. while the team fixes the problem.\r\n\r\nThe Blazor Server template with .Net 8 and Identity worked fine out of the box for me. But with the Jwt-Bearer as authentication the symptoms where exactly the same. The 401 http response code was thrown instead, before the AuthorizeRouteView component kicked in and isn\u0027t able to redirect to login this way. \r\n\r\nThe workaround of above works like a charm. I unfortunately don\u0027t have time to dig in further why this works.\r\n\r\nThis is my program minimal api authentication code:\r\n\u0060\u0060\u0060c#\r\nbuilder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(options =\u003E\r\n{\r\n    options.Events = new JwtBearerEvents\r\n    {\r\n        OnMessageReceived = context =\u003E\r\n        {\r\n            if (context.Request.Cookies.TryGetValue(\u0022token\u0022, out var token))\r\n            {\r\n                context.Token = token;\r\n            }\r\n\r\n            return Task.CompletedTask;\r\n        }\r\n    };\r\n\r\n    options.TokenValidationParameters = new TokenValidationParameters\r\n    {\r\n        ValidateAudience = false,\r\n        ValidateIssuerSigningKey = false,\r\n        ValidateIssuer = false,\r\n        SignatureValidator = (token, parameters) =\u003E new Microsoft.IdentityModel.JsonWebTokens.JsonWebToken(token)\r\n    };\r\n});\r\n\u0060\u0060\u0060",
        "createdAt": "2024-01-08T14:16:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1881095065"
      },
      {
        "id": "IC_kwDOAQzde85wLL6_",
        "parentId": null,
        "author": "jorg3roch4",
        "content": "\u003E \u003E Well, I found a workaround by: define following class and register it where server initializes\r\n\u003E \u003E \u0060\u0060\u0060\r\n\u003E \u003E public class BlazorAuthorizationMiddlewareResultHandler : IAuthorizationMiddlewareResultHandler\r\n\u003E \u003E {\r\n\u003E \u003E     public Task HandleAsync(RequestDelegate next, HttpContext context, AuthorizationPolicy policy, PolicyAuthorizationResult authorizeResult)\r\n\u003E \u003E     {\r\n\u003E \u003E         return next(context);\r\n\u003E \u003E     }\r\n\u003E \u003E }\r\n\u003E \u003E \u0060\u0060\u0060\r\n\u003E \u003E \r\n\u003E \u003E \r\n\u003E \u003E     \r\n\u003E \u003E       \r\n\u003E \u003E     \r\n\u003E \u003E \r\n\u003E \u003E       \r\n\u003E \u003E     \r\n\u003E \u003E \r\n\u003E \u003E     \r\n\u003E \u003E   \r\n\u003E \u003E and handler:\r\n\u003E \u003E \u0060\u0060\u0060\r\n\u003E \u003E services.AddSingleton\u003CIAuthorizationMiddlewareResultHandler, BlazorAuthorizationMiddlewareResultHandler\u003E();\r\n\u003E \u003E \u0060\u0060\u0060\r\n\u003E \u003E \r\n\u003E \u003E \r\n\u003E \u003E     \r\n\u003E \u003E       \r\n\u003E \u003E     \r\n\u003E \u003E \r\n\u003E \u003E       \r\n\u003E \u003E     \r\n\u003E \u003E \r\n\u003E \u003E     \r\n\u003E \u003E   \r\n\u003E \u003E This class will prevent redirection from the new .net 8 authorization middleware response. The problem still exists, but we can at least we can use .NET 8 new feature the way we used to in Blazor and .NET 7.\r\n\u003E \u003E You may need to separate endpoint routing other than blazor routes since it basically renders serverside authorization (via \u0060.AddAuthentication(...).AddJwtBearer(...)\u0060) ineffective.\r\n\u003E \u003E hope this helps, enjoy .net 8. while the team fixes the problem.\r\n\u003E \r\n\u003E The Blazor Server template with .Net 8 and Identity worked fine out of the box for me. But with the Jwt-Bearer as authentication the symptoms where exactly the same. The 401 http response code was thrown instead, before the AuthorizeRouteView component kicked in and isn\u0027t able to redirect to login this way.\r\n\u003E \r\n\u003E The workaround of above works like a charm. I unfortunately don\u0027t have time to dig in further why this works.\r\n\u003E \r\n\u003E This is my program minimal api authentication code:\r\n\u003E \r\n\u003E \u0060\u0060\u0060cs\r\n\u003E builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(options =\u003E\r\n\u003E {\r\n\u003E     options.Events = new JwtBearerEvents\r\n\u003E     {\r\n\u003E         OnMessageReceived = context =\u003E\r\n\u003E         {\r\n\u003E             if (context.Request.Cookies.TryGetValue(\u0022token\u0022, out var token))\r\n\u003E             {\r\n\u003E                 context.Token = token;\r\n\u003E             }\r\n\u003E \r\n\u003E             return Task.CompletedTask;\r\n\u003E         }\r\n\u003E     };\r\n\u003E \r\n\u003E     options.TokenValidationParameters = new TokenValidationParameters\r\n\u003E     {\r\n\u003E         ValidateAudience = false,\r\n\u003E         ValidateIssuerSigningKey = false,\r\n\u003E         ValidateIssuer = false,\r\n\u003E         SignatureValidator = (token, parameters) =\u003E new Microsoft.IdentityModel.JsonWebTokens.JsonWebToken(token)\r\n\u003E     };\r\n\u003E });\r\n\u003E \u0060\u0060\u0060\r\n\r\nYou don\u0027t need that on the client side; the same happened to me. I removed it, and it worked perfectly. It\u0027s only used in the API code.",
        "createdAt": "2024-01-08T23:28:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1881980607"
      },
      {
        "id": "IC_kwDOAQzde85xnWa4",
        "parentId": null,
        "author": "dustrat",
        "content": "We have a similar issue with Blazor Webassembly (hosted) and I tried applying the workaround in the Host API, but it didn\u0027t work. Anyone have any idea how to solve it in WASM?",
        "createdAt": "2024-01-23T14:11:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1906140856"
      },
      {
        "id": "IC_kwDOAQzde85xuBPG",
        "parentId": null,
        "author": "pablofrommars",
        "content": "Same problem as @dustrat reported",
        "createdAt": "2024-01-24T10:54:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1907889094"
      },
      {
        "id": "IC_kwDOAQzde85yh6AZ",
        "parentId": null,
        "author": "gyurisicSSPS",
        "content": "Running into the same issue with Blazor WASM as @dustrat  and @pablofrommars \r\n",
        "createdAt": "2024-02-01T14:40:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1921490969"
      },
      {
        "id": "IC_kwDOAQzde850G-kd",
        "parentId": null,
        "author": "flennic",
        "content": "\u003E Well, I found a workaround by: define following class and register it where server initializes\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E public class BlazorAuthorizationMiddlewareResultHandler : IAuthorizationMiddlewareResultHandler\r\n\u003E {\r\n\u003E     public Task HandleAsync(RequestDelegate next, HttpContext context, AuthorizationPolicy policy, PolicyAuthorizationResult authorizeResult)\r\n\u003E     {\r\n\u003E         return next(context);\r\n\u003E     }\r\n\u003E }\r\n\u003E \u0060\u0060\u0060\r\n\u003E \r\n\u003E and handler:\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E services.AddSingleton\u003CIAuthorizationMiddlewareResultHandler, BlazorAuthorizationMiddlewareResultHandler\u003E();\r\n\u003E \u0060\u0060\u0060\r\n\u003E \r\n\u003E This class will prevent redirection from the new .net 8 authorization middleware response. The problem still exists, but we can at least we can use .NET 8 new feature the way we used to in Blazor and .NET 7.\r\n\u003E \r\n\u003E You may need to separate endpoint routing other than blazor routes since it basically renders server-side authorization (via \u0060.AddAuthentication(...).AddJwtBearer(...)\u0060) ineffective.\r\n\u003E \r\n\u003E hope this helps, enjoy .net 8. while the team fixes the problem.\r\n\r\nEncountering the same problem and ended up using your recommended workaround, so thanks a lot for the hint. This unfortunately has some implications. The project I am working on using OIDC for logging in users, so the authorization result \u0060Challenged\u0060 still needs to intercept to call for the OAuth 2.0 redirect to the identity provider. I have solved this by making this adjustment:\r\n\r\n\u0060\u0060\u0060c#\r\npublic async Task HandleAsync(RequestDelegate next, HttpContext context, AuthorizationPolicy policy, PolicyAuthorizationResult authorizeResult)\r\n{\r\n    if (authorizeResult.Challenged)\r\n        await _defaultHandler.HandleAsync(next, context, policy, authorizeResult);\r\n    else\r\n        await next(context);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nHowever, my biggest concern is the implication which you already mentioned. This more or less disables the ASP.NET authorization layer, so if you have an API you must move that one to another project. I would like to re-use the cookie session but this is not as straight forward anymore. I will look into using a shared state for the cookie data protection and might be able to re-use the cookie when Blazor project and API are running under the same domain. Another way would be to either re-use the \u0060id_token\u0060 or \u0060access_token\u0060 for the API. Probably the \u0060id_token\u0060 because this is the token meant to be for the application and not the underlying APIs (so a different API layer). So to say the JWT bearer.\r\n\r\nNevertheless\u2014even assuming finding a good solution\u2014this definitely does not seem optimal and might be difficult for not so experienced programmers. It would be nice if the ASP.NET middleware somehow knows when a request is meant to be routed to Blazor. I have not looked too much into it yet, but as \u0060HttpContext\u0060, \u0060AuthorizationPolicy\u0060 and \u0060PolicyAuthorizationResult\u0060 are available one could probably build something here.\r\n\r\nThe main thing is, it does not really feel \u0022round\u0022, it would be nice if Blazor projects with authentication and authorization would be carved into one stone. I do not have a good solution here, but hope that I could lay out the problem a bit more in detail.\r\n\r\n__Edit:__ On another note, I also noticed another issue if you use Blazor SSR and WebAssembly only for interactivity. In this case, no \u0060AuthenticationStateProvider\u0060 is registered, which means that you will get a runtime exception when using \u0060builder.Services.AddCascadingAuthenticationState();\u0060. It feels that a default implementation mapping the authentication state, the same way at the Blazor server project uses, would suffice as a good starting point. It feels that there are so many \u0022manual\u0022 tweaks one has to do to get a standard setup \u0022Blazor with OIDC\u0022 to work properly.\r\n\r\nThanks for reading!",
        "createdAt": "2024-02-16T08:54:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1947986205"
      },
      {
        "id": "IC_kwDOAQzde8503XMG",
        "parentId": null,
        "author": "halter73",
        "content": "\u003E Running into the same issue with Blazor WASM as @dustrat and @pablofrommars\r\n\r\nAre you using the new \u0060MapRazorComponents\u003CApp\u003E()\u0060 with \u0060AddInteractiveWebAssemblyRenderMode()\u0060, or are you trying to keep a hosted Blazor WebAssembly app working with \u0060\u003Ccomponent type=\u0022typeof(App)\u0022 render-mode=\u0022WebAssembly\u0022\u003E\u0060 in a \u0060_Host.cshtml\u0060? Can someone please provide a copy of what they\u0027ve tried so far to get Blazor WASM working?",
        "createdAt": "2024-02-23T03:04:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1960669958"
      },
      {
        "id": "IC_kwDOAQzde851GAht",
        "parentId": null,
        "author": "flatproject",
        "content": "Latest visual studio, starting a new blazor project, no interactivity (just SSR), the \u0060\u003CRedirectToLogin/\u003E\u0060 never gets hit when clicking on the \u0022Auth Required\u0022 link. When navigating to Account/Manage/Index without being authenticated it redirects me to InvalidUser which is a redirection hapenning in the IdentityUserAccessor. The _imports file has an [Authorize] attribute. Shouldn\u0027t the authorize attribute work first before the IdentityUserAccessor used inside the component? Bug or by design?",
        "createdAt": "2024-02-26T16:03:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1964509293"
      },
      {
        "id": "IC_kwDOAQzde852SmLH",
        "parentId": null,
        "author": "jdbahnick",
        "content": "I\u0027m currently working on a .NET 8 Blazor PWA implenting Auth0 B2C and am having the same issue. In the \u0060\u003CAuthorizeRouteView\u003E\u0060, the \u0060\u003CAuthorizing\u003E\u0060 component is hit. However, the \u0060\u003CNotAuthorized\u003E\u0060 component is just straight up ignored. What\u0027s worse, it\u0027s not until I have an exception thrown by my API and bubbled up to the browser due to a lack of access token that a call to \u0060authentication/login\u0060 actually does what it\u0027s supposed to. Adding \u0060[Authorize]\u0027 to the _Imports file does absolutely nothing.\r\n\r\nI am also following best practice and not using Cookie Authentication.\r\n\r\nI\u0027m not sure if I\u0027m missing something or what the issue is. Some guidance would be appreciated.\r\n\r\nEDIT:\r\nSo I finally figured out that I have to explicitly put the \u0060[Authorize]\u0060 attribute on top of each page I want to secure. So placing an attribute in _Imports has no affect, using an AuthorizeView in my main layout just created an infinite loop of authentication requests.\r\n\r\nPerhaps I\u0027m not securing my entire client app correctly? I would think I should just be able to specify that my app can only be used by authorized users.",
        "createdAt": "2024-03-07T22:07:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1984586439"
      },
      {
        "id": "IC_kwDOAQzde8529yUZ",
        "parentId": null,
        "author": "andy250",
        "content": "It\u0027s been 4 months, the problem is still there. The docs are wrong saying that the \u0060RedirectToLogin\u0060 component is doing the redirection (https://learn.microsoft.com/en-us/aspnet/core/blazor/security/?view=aspnetcore-8.0\u0026preserve-view=true#customize-unauthorized-content-with-the-router-component). This is not true, the component is never fired. It can be reproduced by:\r\n* creating a fresh Blazor Web App project from the template in VS2022 (with authentication)\r\n* putting a breakpoint in \u0060RedirectToLogin.razor\u0060 inside \u0060OnInitialized\u0060\r\n* running the project and clicking \u0022Auth Required\u0022 menu item in the navbar\r\n* the breakpoint is not hit (so \u0060\u003CNotAuthorized\u003E\u0060 section inside \u0060Routes.razor\u0060 was not triggered) but user is redirected to login page by some other means\r\n\r\nHere is the \u0060Routes.razor\u0060 for reference from this project:\r\n\u0060\u0060\u0060\r\n@using IndetityAuth.Components.Account.Shared\r\n\u003CRouter AppAssembly=\u0022typeof(Program).Assembly\u0022\u003E\r\n    \u003CFound Context=\u0022routeData\u0022\u003E\r\n        \u003CAuthorizeRouteView RouteData=\u0022routeData\u0022 DefaultLayout=\u0022typeof(Layout.MainLayout)\u0022\u003E\r\n            \u003CNotAuthorized\u003E\r\n                \u003CRedirectToLogin /\u003E\r\n            \u003C/NotAuthorized\u003E\r\n        \u003C/AuthorizeRouteView\u003E\r\n        \u003CFocusOnNavigate RouteData=\u0022routeData\u0022 Selector=\u0022h1\u0022 /\u003E\r\n    \u003C/Found\u003E\r\n\u003C/Router\u003E\r\n\u0060\u0060\u0060\r\n\r\nSome comments here indicate this is by design, but it\u0027s really a puzzle to understand what is going on with all the auth and redirection magic. It is really disappointing such a basic security mechanism seems to be broken since Nov 2023. I am working on a custom setup with external auth provider and making blazor part work is a nightmare. I think I will resort to \u0060AuthorizeView\u0060 in the MainLayout and other pages probably for now.",
        "createdAt": "2024-03-13T21:37:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-1995908377"
      },
      {
        "id": "IC_kwDOAQzde853mEvU",
        "parentId": null,
        "author": "Maetness",
        "content": "I have a smiliar problem where the basic authentication and redirects are working but as soon as I implement any further authorization rules on a page (role or policy based) it just infinitly loops between the redirectToLogin component and tries to authenticated the already logged-in user. \r\n\r\nrealted issue: https://github.com/dotnet/aspnetcore/issues/19855",
        "createdAt": "2024-03-19T09:22:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2006469588"
      },
      {
        "id": "IC_kwDOAQzde853r_xf",
        "parentId": null,
        "author": "jdbahnick",
        "content": "I abandoned the AuthorizeRouteView all together since I could only get it to properly trigger the NotAuthorized portion after trying to render a page that had the Authorize attribute on it. I decided to do an AuthorizeView in the main layout with the RedirectToLogin component in the NotAuthorized portion. This seems to work as the AuthorizeRouteView should. And I guess technically since at the App.razor level you\u0027re working with the routes and not with the pages directly, routes are not what is being secured but the actual page. However, at the AuthorizeRouteView level, I would think there should be an explicit check to see if the current user has Identity.IsAuthenticated be true. If not, then you\u0027re not authorized. \r\n\r\nNone of this seems to function as I think it should. Templating the App.razor in this fashion seems like an oversite if this is not the way Blazor Wasm is intended to work. Sure I currently have a work around for the issue, but it feels wrong to handle the state of authentication from a layout.",
        "createdAt": "2024-03-19T20:03:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2008022111"
      },
      {
        "id": "IC_kwDOAQzde854Z6cd",
        "parentId": null,
        "author": "NathanVG",
        "content": "I am having a related problem (I think): https://github.com/dotnet/aspnetcore/issues/54666\r\n\r\nI\u0027m fairly new to Blazor and .net as a whole and it has been a nightmare trying to figure this out. \r\nI\u0027ve read all sorts of docs but it\u0027s a maze if you\u0027re not at home in this ecosystem. \r\n\r\nI scaffolded the app using the template provided, and set up everyting in Azure AD, authentication for the API works fine when just normally navigating the app, but when the user refreshes all authorization for the api is lost. ",
        "createdAt": "2024-03-26T10:28:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2020058909"
      },
      {
        "id": "IC_kwDOAQzde855ON7O",
        "parentId": null,
        "author": "HuaFangYun",
        "content": "Would you like to ask if the current problem has been solved? Thank you!",
        "createdAt": "2024-04-03T07:34:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2033770190"
      },
      {
        "id": "IC_kwDOAQzde85-Bh7y",
        "parentId": null,
        "author": "Appli4Ever",
        "content": "I have a hosted Blazor WASM app in Asp.Net Core. I have prerendering enabled. My problem was, that builder.Services.AddCascadingAuthenticationState(); is not the same as CascadingAuthenticationState Componente in the Routes.razor despite being described as such. The differenz is while prerendering, the GetAuthenticationStateAsync() method is not called when adding the CascadingAuthenticationState via the ServiceCollection. \r\n\r\nSince I have some specially authentication (anonymous user are being logged in with cookies) this was an essential part of my solution. ",
        "createdAt": "2024-05-16T07:56:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2114330354"
      },
      {
        "id": "IC_kwDOAQzde85_x-2C",
        "parentId": null,
        "author": "Liandrel",
        "content": "If someone still struggles with this problem I found another workaround.\r\n\r\n\u0060services.ConfigureApplicationCookie(opts =\u003E\r\n{\r\n    opts.LoginPath = new PathString(\u0022/authorize/login\u0022);\r\n});\u0060\r\n\r\nWith this workaround when accessing page with [Authorize] attribute it redirects to \u0022/autorize/login\u0022 instead of \u0022Account/Login\u0022\r\n\r\nStill it would be better if this was fixed on blazor framework level and AuthorizeRouteView worked like it should do",
        "createdAt": "2024-06-02T11:21:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2143808898"
      },
      {
        "id": "IC_kwDOAQzde85_5HJu",
        "parentId": null,
        "author": "cn-ml",
        "content": "I also just wasted a couple hours on debugging my requests until i found this. I just wanted to do some experimentations with blazor, but this is a real bummer.",
        "createdAt": "2024-06-03T16:44:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2145677934"
      },
      {
        "id": "IC_kwDOAQzde86BJyrw",
        "parentId": null,
        "author": "sinoergin",
        "content": "it was working from me below that but #19855 is good idea. \r\n\r\n\u0060..AddCookie(IdentityConstants.ApplicationScheme, opt =\u003E opt.LoginPath = \u0022routeUrl\u0022)\u0060\r\n",
        "createdAt": "2024-06-13T21:30:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2166827760"
      },
      {
        "id": "IC_kwDOAQzde86DkOGY",
        "parentId": null,
        "author": "Usergitbit",
        "content": "@flennic I\u0027m also doing OIDC with IdentityServer and I don\u0027t seem to need anything more than\r\n\u0060\u0060\u0060\r\npublic class BlazorAuthorizationMiddlewareResultHandler() : IAuthorizationMiddlewareResultHandler\r\n{\r\n    public async Task HandleAsync(RequestDelegate next, HttpContext context, AuthorizationPolicy policy, PolicyAuthorizationResult authorizeResult)\r\n    {\r\n        await next(context);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\nIn which case did you need that? User not logged in trying to access a page that requires authorization? How do you have the redirect to login provider implemented?\r\n\r\nAlso, is there any plan on making Blazor Server easier to integrate with OIDC? I\u0027m doing some hacky stuff in order to refresh the access token and then get it updated in the cookie.",
        "createdAt": "2024-07-03T21:13:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2207310232"
      },
      {
        "id": "IC_kwDOAQzde86Eeef0",
        "parentId": null,
        "author": "flennic",
        "content": "@Usergitbit When combining an API and Blazor in the same project. I now do not remember the exact setup, but the API layer middleware comes before the request gets to Blazor. So e.g. \u0022Unauthorized\u0022 should not be blocked by the API, but should be forwarded to Blazor to show a \u0022Hey, you do not have permission to see this page\u0022 message. But \u0022Challanged\u0022 _should_ respond with the correct OAuth 2.0 / OIDC flow and not forward the request to Blazor.\r\n\r\nSo the redirect to the identity provider is the default OIDC ASP.NET implementation, it is not handled by Blazor.\r\n\r\nAnd regarding you last point, I agree. The integration for projects where API and Blazor are mixed should be improved. Also I do not understand why refresh token generation is not enabled (or at least implemented) by default as there actually exist Microsoft examples which can be copy and pasted, maybe with minor adjustments which cloud be put into an \u0060Action\u003CRefreshOptions\u003E\u0060 extension method.\r\n\r\nThere are even more quirks, e.g. only OAuth 2.0 (for example for an API) where only the JWKS endpoint is used, is also not supported by default. A friendly user provides his own library for fixing that, I think it should be part of the stack the same as OIDC. But there are probably more reasons for it why decisions are made as they are, I only see it from my perspective.",
        "createdAt": "2024-07-11T10:30:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2222581748"
      },
      {
        "id": "IC_kwDOAQzde86FGet0",
        "parentId": null,
        "author": "Joaomfcarmo",
        "content": "\u003E \u003E Well, I found a workaround by: define following class and register it where server initializes\r\n\u003E \u003E \u0060\u0060\u0060\r\n\u003E \u003E public class BlazorAuthorizationMiddlewareResultHandler : IAuthorizationMiddlewareResultHandler\r\n\u003E \u003E {\r\n\u003E \u003E     public Task HandleAsync(RequestDelegate next, HttpContext context, AuthorizationPolicy policy, PolicyAuthorizationResult authorizeResult)\r\n\u003E \u003E     {\r\n\u003E \u003E         return next(context);\r\n\u003E \u003E     }\r\n\u003E \u003E }\r\n\u003E \u003E \u0060\u0060\u0060\r\n\u003E \u003E \r\n\u003E \u003E \r\n\u003E \u003E     \r\n\u003E \u003E       \r\n\u003E \u003E     \r\n\u003E \u003E \r\n\u003E \u003E       \r\n\u003E \u003E     \r\n\u003E \u003E \r\n\u003E \u003E     \r\n\u003E \u003E   \r\n\u003E \u003E and handler:\r\n\u003E \u003E \u0060\u0060\u0060\r\n\u003E \u003E services.AddSingleton\u003CIAuthorizationMiddlewareResultHandler, BlazorAuthorizationMiddlewareResultHandler\u003E();\r\n\u003E \u003E \u0060\u0060\u0060\r\n\u003E \u003E \r\n\u003E \u003E \r\n\u003E \u003E     \r\n\u003E \u003E       \r\n\u003E \u003E     \r\n\u003E \u003E \r\n\u003E \u003E       \r\n\u003E \u003E     \r\n\u003E \u003E \r\n\u003E \u003E     \r\n\u003E \u003E   \r\n\u003E \u003E This class will prevent redirection from the new .net 8 authorization middleware response. The problem still exists, but we can at least we can use .NET 8 new feature the way we used to in Blazor and .NET 7.\r\n\u003E \u003E You may need to separate endpoint routing other than blazor routes since it basically renders server-side authorization (via \u0060.AddAuthentication(...).AddJwtBearer(...)\u0060) ineffective.\r\n\u003E \u003E hope this helps, enjoy .net 8. while the team fixes the problem.\r\n\u003E \r\n\u003E Encountering the same problem and ended up using your recommended workaround, so thanks a lot for the hint. This unfortunately has some implications. The project I am working on using OIDC for logging in users, so the authorization result \u0060Challenged\u0060 still needs to intercept to call for the OAuth 2.0 redirect to the identity provider. I have solved this by making this adjustment:\r\n\u003E \r\n\u003E \u0060\u0060\u0060cs\r\n\u003E public async Task HandleAsync(RequestDelegate next, HttpContext context, AuthorizationPolicy policy, PolicyAuthorizationResult authorizeResult)\r\n\u003E {\r\n\u003E     if (authorizeResult.Challenged)\r\n\u003E         await _defaultHandler.HandleAsync(next, context, policy, authorizeResult);\r\n\u003E     else\r\n\u003E         await next(context);\r\n\u003E }\r\n\u003E \u0060\u0060\u0060\r\n\u003E \r\n\u003E However, my biggest concern is the implication which you already mentioned. This more or less disables the ASP.NET authorization layer, so if you have an API you must move that one to another project. I would like to re-use the cookie session but this is not as straight forward anymore. I will look into using a shared state for the cookie data protection and might be able to re-use the cookie when Blazor project and API are running under the same domain. Another way would be to either re-use the \u0060id_token\u0060 or \u0060access_token\u0060 for the API. Probably the \u0060id_token\u0060 because this is the token meant to be for the application and not the underlying APIs (so a different API layer). So to say the JWT bearer.\r\n\u003E \r\n\u003E Nevertheless\u2014even assuming finding a good solution\u2014this definitely does not seem optimal and might be difficult for not so experienced programmers. It would be nice if the ASP.NET middleware somehow knows when a request is meant to be routed to Blazor. I have not looked too much into it yet, but as \u0060HttpContext\u0060, \u0060AuthorizationPolicy\u0060 and \u0060PolicyAuthorizationResult\u0060 are available one could probably build something here.\r\n\u003E \r\n\u003E The main thing is, it does not really feel \u0022round\u0022, it would be nice if Blazor projects with authentication and authorization would be carved into one stone. I do not have a good solution here, but hope that I could lay out the problem a bit more in detail.\r\n\u003E \r\n\u003E **Edit:** On another note, I also noticed another issue if you use Blazor SSR and WebAssembly only for interactivity. In this case, no \u0060AuthenticationStateProvider\u0060 is registered, which means that you will get a runtime exception when using \u0060builder.Services.AddCascadingAuthenticationState();\u0060. It feels that a default implementation mapping the authentication state, the same way at the Blazor server project uses, would suffice as a good starting point. It feels that there are so many \u0022manual\u0022 tweaks one has to do to get a standard setup \u0022Blazor with OIDC\u0022 to work properly.\r\n\u003E \r\n\u003E Thanks for reading!\r\n\r\nHi, can you show me your _defaultHandler declaration, please.\r\n\r\n",
        "createdAt": "2024-07-17T11:21:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2233068404"
      },
      {
        "id": "IC_kwDOAQzde86FR6LN",
        "parentId": null,
        "author": "flennic",
        "content": "@Joaomfcarmo It is a field in the \u0060IAuthorizationMiddlewareResultHandler\u0060 declared like this:\r\n\r\n\u0060\u0060\u0060cs\r\nprivate readonly AuthorizationMiddlewareResultHandler _defaultHander = new();\r\n\u0060\u0060\u0060",
        "createdAt": "2024-07-18T09:36:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2236064461"
      },
      {
        "id": "IC_kwDOAQzde86Flvgj",
        "parentId": null,
        "author": "killyp",
        "content": "Is there official documentation on this yet?  I am still using the \u0060IAuthorizationMiddlewareResultHandler\u0060 workaround on my Blazor Webapp to get the NotAuthorized component to trigger and redirect to a landing page.",
        "createdAt": "2024-07-20T19:06:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2241263651"
      },
      {
        "id": "IC_kwDOAQzde86GEx3I",
        "parentId": null,
        "author": "danieldespainTLS",
        "content": "The template code is very misleading.  Looking at \u0060Routes.razor\u0060 makes it look like the \u0060\u003CRedirectToLogin /\u003E\u0060 component is where the \u0022magic\u0022 happens - which is the way it used to be.  As mentioned, that component isn\u0027t involved anymore **(so why is it in the Routes template??)**.  You can open up the RedirectToLogin.razor file and change the \u0060NavigateTo(...)\u0060 path but it will still take you to \u0060Account/Login?\u2026\u0060.  You can put a breakpoint in that component, and it never gets hit.\r\n\r\nThe solution from @Liandrel about \u0060services.ConfigureApplicationCookie(\u2026)\u0060 is what finally helped me out - after wasting way too many hours.",
        "createdAt": "2024-07-25T04:53:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2249399752"
      },
      {
        "id": "IC_kwDOAQzde86GQxRj",
        "parentId": null,
        "author": "Appli4Ever",
        "content": "\u003E The template code is very misleading. Looking at \u0060Routes.razor\u0060 makes it look like the \u0060\u003CRedirectToLogin /\u003E\u0060 component is where the \u0022magic\u0022 happens - which is the way it used to be. As mentioned, that component isn\u0027t involved anymore **(so why is it in the Routes template??)**. You can open up the RedirectToLogin.razor file and change the \u0060NavigateTo(...)\u0060 path but it will still take you to \u0060Account/Login?\u2026\u0060. You can put a breakpoint in that component, and it never gets hit.\r\n\u003E \r\n\u003E The solution from @Liandrel about \u0060services.ConfigureApplicationCookie(\u2026)\u0060 is what finally helped me out - after wasting way too many hours.\r\n\r\nSo I know what the \u0022problem\u0022 semes to be: Prerender\r\n1. Create a new Blazor Web App\r\n2. Select Individual Accounts\r\n3. Select Interactive Render Mode\r\n4. Change \u0060NavigateTo(...)\u0060 to counter page (or anything else)\r\n5. Start project. \r\n6. You will get redirected to counter always.\r\n\r\nSomething to look out for, if you have prerender enabled:\r\nI does not use \u0060RedirectToLogin.razor\u0060 when you prerender a page with \u0060@attribute [Authorize]\u0060. \r\n\r\nThis is because:\r\n\u0060\u0060\u0060\r\napp.MapRazorComponents\u003CApp\u003E()\r\n    .[your render modes]\r\n    .AddAdditionalAssemblies(typeof(test.Client._Imports).Assembly); \r\n\u0060\u0060\u0060\r\n\r\nredirects you to the login page, befor App renders Routes.\r\n\r\nSimple Fix:\r\n\r\n\u0060\u0060\u0060\r\napp.MapRazorComponents\u003CApp\u003E()\r\n    .[your render modes]\r\n    .AddAdditionalAssemblies(typeof(test.Client._Imports).Assembly)\r\n    .AllowAnonymous();\r\n\u0060\u0060\u0060\r\n",
        "createdAt": "2024-07-26T11:17:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2252543075"
      },
      {
        "id": "IC_kwDOAQzde86GQ_H2",
        "parentId": null,
        "author": "Appli4Ever",
        "content": "To be more specific: Asp.Net Core Redirects you while prerender, not Blazor. If you call .AllowAnonymous() App.razor will prerender anonymous and Routes will execute RedirectToLogin or anything else in  \r\n\u0060\u0060\u0060\r\n\u003CNotAuthorized\u003E\r\n...\r\n \u003C/NotAuthorized\u003E\r\n\u0060\u0060\u0060\r\nUse this: if you want to change the behavior of Asp.Net core redirecting ur API calls:\r\n\u0060\u0060\u0060\r\n.AddIdentityCookies(o =\u003E\r\n{\r\n    o.ApplicationCookie?.Configure(\r\n        co =\u003E\r\n        {\r\n            co.Events.OnRedirectToLogin = e =\u003E\r\n            {\r\n                e.Response.StatusCode = 401;\r\n                return Task.CompletedTask;\r\n            };\r\n            co.Events.OnRedirectToAccessDenied = e =\u003E\r\n            {\r\n                e.Response.StatusCode = 401;\r\n                return Task.CompletedTask;\r\n            };\r\n            ...\r\n        });\r\n});\r\n\u0060\u0060\u0060\r\nThis way, API Endpoints wont send back a redirect result when called from Blazor WASM. ",
        "createdAt": "2024-07-26T11:52:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2252599798"
      },
      {
        "id": "IC_kwDOAQzde86GXVuk",
        "parentId": null,
        "author": "Liandrel",
        "content": "That solution works like a charm. I didn\u0027t think about it initially, but it makes perfect sense that it was redirecting to the default login path because of the pre-render on the server. And by allowing all paths to be anonymous, it reaches App.razor and displays the NotAuthorized content.",
        "createdAt": "2024-07-27T22:03:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2254265252"
      },
      {
        "id": "IC_kwDOAQzde86HXAuS",
        "parentId": null,
        "author": "Mecerburn",
        "content": "I had the same issue as described in this post\r\nhttps://github.com/dotnet/aspnetcore/issues/52317\r\nBut instead of doing this overwrite\r\n\u0060public class BlazorAuthorizationMiddlewareResultHandler : IAuthorizationMiddlewareResultHandler\r\n{\r\n    public Task HandleAsync(RequestDelegate next, HttpContext context, AuthorizationPolicy policy, PolicyAuthorizationResult authorizeResult)\r\n    {\r\n        return next(context);\r\n    }\r\n}\u0060\r\n\r\nI went with making splash screen on routes rather\r\n![Screenshot 2024-08-06 123804](https://github.com/user-attachments/assets/09b8bd80-5f4d-4c01-a3e0-fcebbfa336f5)\r\n\r\n\r\nThis way the refresh can happen and after render my javascript interop that reads session for token on auth will work.  Wanted to post on initial post but it was close.  Hope someone finds this as an helpfull way to workaround the issue and is a better work around without messing with the rest of the auth",
        "createdAt": "2024-08-06T10:36:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2270956434"
      },
      {
        "id": "IC_kwDOAQzde86JiOzT",
        "parentId": null,
        "author": "nemtajo",
        "content": "I have the same problem. I tried creating custom auth library with Cookie authentication scheme, but it seems whatever is in the Router is not rendered at all. \r\n\r\nIn all my components where AuthorizeView is used, even though all custom cookies are deleted and the user is logged out via \r\n\u0060await _httpContextAccessor.HttpContext.SignOutAsync(LingoDub.Blazor.Auth.Model.Constants.AuthenticationScheme, new AuthenticationProperties\r\n{\r\n    RedirectUri = \u0022/\u0022\r\n});\u0060\r\nThe components always render Authorized content...\r\n\r\nIt would be great if Microsoft provided example implementation of different custom sign in options (openid, jwt bearer, cookie, etc) on both WebAssembly and Server hosting models.",
        "createdAt": "2024-08-23T16:48:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2307452115"
      },
      {
        "id": "IC_kwDOAQzde86JiTzr",
        "parentId": null,
        "author": "Mecerburn",
        "content": "\u003E I have the same problem. I tried creating custom auth library with Cookie authentication scheme, but it seems whatever is in the Router is not rendered at all.\r\n\u003E \r\n\u003E In all my components where AuthorizeView is used, even though all custom cookies are deleted and the user is logged out via \u0060await _httpContextAccessor.HttpContext.SignOutAsync(LingoDub.Blazor.Auth.Model.Constants.AuthenticationScheme, new AuthenticationProperties { RedirectUri = \u0022/\u0022 });\u0060 The components always render Authorized content...\r\n\u003E \r\n\u003E It would be great if Microsoft provided example implementation of different custom sign in options (openid, jwt bearer, cookie, etc) on both WebAssembly and Server hosting models.\r\n\r\nIf you use the browser storage then the components need to complete the rendering to be able to access the storage.  That is the issue, so adding the loading as I given in the image will sort that out.  When you logout are you calling the NotifyAuthenticationStateChanged  so that blazor can rerender?  For me calling that logs out and no more authorized views show.  Only issue is using the browser storage to read and write the auth tokens or cookies, this can be worked around with the loading stuff I shared",
        "createdAt": "2024-08-23T17:00:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2307472619"
      },
      {
        "id": "IC_kwDOAQzde86MLfws",
        "parentId": null,
        "author": "nemtajo",
        "content": "@Mecerburn Thank you for sharing a possible solution. I think wrapping Router in an if statement, whose condition is changed only after rendering the page, disables prerendering completely for the whole webapp, and therefore might not be a suitable solution for everyone. Afterall, I want to have prerendering enabled for some pages - it is an awesome feature to have.\r\n\r\nI discovered that my issue would be resolved with the workaround proposed above, if I didn\u0027t have additional problems in my auth library. I just want to mention the solution, in case someone else wants to implement auth library of their own. There is a very unclear behaviour of ClaimsIdentity constructor, depending on which parameters you pass in, you will get IsAuthenticated property set to always true or always false. I hope that ASP.NET Core team cleans up this confusion. For reference, this blog helped me tackle my problem:\r\nhttps://www.benday.com/2021/08/13/3-common-problems-with-claimsidentity-and-claimsprincipal-in-asp-net-core/",
        "createdAt": "2024-09-15T23:02:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2351823916"
      },
      {
        "id": "IC_kwDOAQzde86SB7UL",
        "parentId": null,
        "author": "Woudjee",
        "content": "\n\n\n\u003E To be more specific: Asp.Net Core Redirects you while prerender, not Blazor. If you call .AllowAnonymous() App.razor will prerender anonymous and Routes will execute RedirectToLogin or anything else in\n\u003E \n\u003E \u0060\u0060\u0060\n\u003E \u003CNotAuthorized\u003E\n\u003E ...\n\u003E  \u003C/NotAuthorized\u003E\n\u003E \u0060\u0060\u0060\n\u003E \n\u003E Use this: if you want to change the behavior of Asp.Net core redirecting ur API calls:\n\u003E \n\u003E \u0060\u0060\u0060\n\u003E .AddIdentityCookies(o =\u003E\n\u003E {\n\u003E     o.ApplicationCookie?.Configure(\n\u003E         co =\u003E\n\u003E         {\n\u003E             co.Events.OnRedirectToLogin = e =\u003E\n\u003E             {\n\u003E                 e.Response.StatusCode = 401;\n\u003E                 return Task.CompletedTask;\n\u003E             };\n\u003E             co.Events.OnRedirectToAccessDenied = e =\u003E\n\u003E             {\n\u003E                 e.Response.StatusCode = 401;\n\u003E                 return Task.CompletedTask;\n\u003E             };\n\u003E             ...\n\u003E         });\n\u003E });\n\u003E \u0060\u0060\u0060\n\u003E \n\u003E This way, API Endpoints wont send back a redirect result when called from Blazor WASM.\n\n@Appli4Ever I believe your cookie approach is the best solution. However, when attempting it myself, it does not work for me. I also tried setting the \u0060RedirectUri\u0060, but this also seems to not be doing anything. Any suggestions what else I could do?",
        "createdAt": "2024-10-31T14:16:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2449978635"
      },
      {
        "id": "IC_kwDOAQzde86S_Gwx",
        "parentId": null,
        "author": "Zzzzjle",
        "content": "\u003E app.MapRazorComponents\u003CApp\u003E()\n\u003E     .[your render modes]\n\u003E     .AddAdditionalAssemblies(typeof(test.Client._Imports).Assembly)\n\u003E     .AllowAnonymous();\n\nThanks, this works for me.",
        "createdAt": "2024-11-09T03:26:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2466016305"
      },
      {
        "id": "IC_kwDOAQzde86S_czd",
        "parentId": null,
        "author": "Appli4Ever",
        "content": "@Woudjee what exactly did not work? Can you share some code?",
        "createdAt": "2024-11-09T07:48:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2466106589"
      },
      {
        "id": "IC_kwDOAQzde86S_oih",
        "parentId": null,
        "author": "Woudjee",
        "content": "I haven\u2019t worked on this problem since I posted. Next week, I will take a look at it again \uD83D\uDC4D\r\n\r\nOp 9 nov. 2024 om 08:48 heeft Simon M\u00FCller ***@***.***\u003E het volgende geschreven:\r\n\r\n\uFEFF\r\n\r\n@Woudjee\u003Chttps://github.com/Woudjee\u003E what exactly did not work? Can you share some code?\r\n\r\n\u2014\r\nReply to this email directly, view it on GitHub\u003Chttps://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2466106589\u003E, or unsubscribe\u003Chttps://github.com/notifications/unsubscribe-auth/AUGP35DKX7WNIZUL5X7CL3TZ7W46DAVCNFSM6AAAAAA7L36HRSVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDINRWGEYDMNJYHE\u003E.\r\nYou are receiving this because you were mentioned.Message ID: ***@***.***\u003E\r\n",
        "createdAt": "2024-11-09T10:02:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2466154657"
      },
      {
        "id": "IC_kwDOAQzde86S_2La",
        "parentId": null,
        "author": "Appli4Ever",
        "content": "\u003E \u003E The template code is very misleading. Looking at \u0060Routes.razor\u0060 makes it look like the \u0060\u003CRedirectToLogin /\u003E\u0060 component is where the \u0022magic\u0022 happens - which is the way it used to be. As mentioned, that component isn\u0027t involved anymore **(so why is it in the Routes template??)**. You can open up the RedirectToLogin.razor file and change the \u0060NavigateTo(...)\u0060 path but it will still take you to \u0060Account/Login?\u2026\u0060. You can put a breakpoint in that component, and it never gets hit.\n\u003E \n\u003E \u003E \n\u003E \n\u003E \u003E The solution from @Liandrel about \u0060services.ConfigureApplicationCookie(\u2026)\u0060 is what finally helped me out - after wasting way too many hours.\n\u003E \n\u003E \n\u003E \n\u003E So I know what the \u0022problem\u0022 semes to be: Prerender\n\u003E \n\u003E 1. Create a new Blazor Web App\n\u003E \n\u003E 2. Select Individual Accounts\n\u003E \n\u003E 3. Select Interactive Render Mode\n\u003E \n\u003E 4. Change \u0060NavigateTo(...)\u0060 to counter page (or anything else)\n\u003E \n\u003E 5. Start project. \n\u003E \n\u003E 6. You will get redirected to counter always.\n\u003E \n\u003E \n\u003E \n\u003E Something to look out for, if you have prerender enabled:\n\u003E \n\u003E I does not use \u0060RedirectToLogin.razor\u0060 when you prerender a page with \u0060@attribute [Authorize]\u0060. \n\u003E \n\u003E \n\u003E \n\u003E This is because:\n\u003E \n\u003E \u0060\u0060\u0060\n\u003E \n\u003E app.MapRazorComponents\u003CApp\u003E()\n\u003E \n\u003E     .[your render modes]\n\u003E \n\u003E     .AddAdditionalAssemblies(typeof(test.Client._Imports).Assembly); \n\u003E \n\u003E \u0060\u0060\u0060\n\u003E \n\u003E \n\u003E \n\u003E redirects you to the login page, befor App renders Routes.\n\u003E \n\u003E \n\u003E \n\u003E Simple Fix:\n\u003E \n\u003E \n\u003E \n\u003E \u0060\u0060\u0060\n\u003E \n\u003E app.MapRazorComponents\u003CApp\u003E()\n\u003E \n\u003E     .[your render modes]\n\u003E \n\u003E     .AddAdditionalAssemblies(typeof(test.Client._Imports).Assembly)\n\u003E \n\u003E     .AllowAnonymous();\n\u003E \n\u003E \u0060\u0060\u0060\n\u003E \n\u003E \n\nI recently published a blogpost about this with video showing it: https://www.databinding.net/prerender-mit-blazor-webassembly-wasm-in-asp-net-core-8-teil-3/\n\nIt is in german but I am sure your browser can translate it.",
        "createdAt": "2024-11-09T13:14:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52063#issuecomment-2466210522"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde8528p9p",
    "title": "Authentication.WsFederation breaks with on-premise AD FS use",
    "url": "https://github.com/dotnet/aspnetcore/issues/52099",
    "createdAt": "2023-11-15T21:42:22Z",
    "lastUpdated": "2024-09-25T00:27:00Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nUsing Authentication.WsFederation for authentication results in error regardless of new UseSecurityTokenHandlers setting. \r\n\r\n\u0060options.UseSecurityTokenHandlers = true;\u0060\r\n\r\nSecurityTokenInvalidIssuerException: IDX10204: Unable to validate issuer. validationParameters.ValidIssuer is null or whitespace AND validationParameters.ValidIssuers is null or empty.\r\n\r\nExpected: behavior prior to change introduced with issue 49469.\r\n\r\n\u0060options.UseSecurityTokenHandlers = false;\u0060\r\n\r\nXmlReadException: IDX30011: Unable to read XML. Expecting XmlReader to be at ns.element: \u0027urn:oasis:names:tc:SAML:2.0:assertion.Assertion\u0027, found: \u0027urn:oasis:names:tc:SAML:1.0:assertion.Assertion\u0027.\r\n\r\nExpected: to be able to handle SAML 1.0 assertion emitted by WsFed server.\n\n### Expected Behavior\n\noptions.UseSecurityTokenHandlers = true;\r\n\r\nExpected: behavior prior to change introduced with issue 49469.\r\n\r\noptions.UseSecurityTokenHandlers = false;\r\n\r\nExpected: to be able to handle SAML 1.0 assertion emitted by WsFed server.\n\n### Steps To Reproduce\n\nRepro project: https://github.com/csowa/aspdotnetcore-auth-sample\r\n\r\nDemonstrates WS-Federation issue with change introduced for https://github.com/dotnet/aspnetcore/issues/49469\r\n\r\nBased on example at https://learn.microsoft.com/en-us/aspnet/core/security/authentication/ws-federation?view=aspnetcore-8.0#use-ws-federation-without-aspnet-core-identity\r\n\r\nBuild and run. Home page uses [Authorize] attribute, authentication begins when loading.\r\n\r\nDependency: ADFS server required. Server version tested: 10.0.17763.4644\r\n\n\n### Exceptions (if any)\n\n\u0060options.UseSecurityTokenHandlers = true;\u0060\r\n\r\nSecurityTokenInvalidIssuerException: IDX10204: Unable to validate issuer. validationParameters.ValidIssuer is null or whitespace AND validationParameters.ValidIssuers is null or empty.\r\n\r\n\u0060options.UseSecurityTokenHandlers = false;\u0060\r\n\r\nXmlReadException: IDX30011: Unable to read XML. Expecting XmlReader to be at ns.element: \u0027urn:oasis:names:tc:SAML:2.0:assertion.Assertion\u0027, found: \u0027urn:oasis:names:tc:SAML:1.0:assertion.Assertion\u0027.\r\n\n\n### .NET Version\n\n8.0.100\n\n### Anything else?\n\n_No response_",
    "upvotes": 9,
    "labels": [
      "External",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85sLWuw",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "Thanks for contacting us.\r\nPlease share the full stack-trace of the error that you see.",
        "createdAt": "2023-11-16T17:32:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1814916016"
      },
      {
        "id": "IC_kwDOAQzde85sM7vS",
        "parentId": null,
        "author": "csowa",
        "content": "\u0060options.UseSecurityTokenHandlers = true;\u0060\r\n\r\n----\r\n\r\nMicrosoft.AspNetCore.Authentication.AuthenticationFailureException: An error was encountered while handling the remote login.\r\n ---\u003E Microsoft.IdentityModel.Tokens.SecurityTokenException: No token validator or token handler was found for the given token.\r\n ---\u003E Microsoft.IdentityModel.Tokens.SecurityTokenInvalidIssuerException: IDX10204: Unable to validate issuer. validationParameters.ValidIssuer is null or whitespace AND validationParameters.ValidIssuers is null or empty.\r\n   at Microsoft.IdentityModel.Tokens.Validators.ValidateIssuerAsync(String issuer, SecurityToken securityToken, TokenValidationParameters validationParameters, BaseConfiguration configuration)\r\n   at Microsoft.IdentityModel.Tokens.Validators.ValidateIssuer(String issuer, SecurityToken securityToken, TokenValidationParameters validationParameters, BaseConfiguration configuration)\r\n   at Microsoft.IdentityModel.Tokens.Validators.ValidateIssuer(String issuer, SecurityToken securityToken, TokenValidationParameters validationParameters)\r\n   at Microsoft.IdentityModel.Tokens.Saml.SamlSecurityTokenHandler.ValidateIssuer(String issuer, SecurityToken securityToken, TokenValidationParameters validationParameters)\r\n   at Microsoft.IdentityModel.Tokens.Saml.SamlSecurityTokenHandler.ValidateSignature(SamlSecurityToken samlToken, String token, TokenValidationParameters validationParameters)\r\n   at Microsoft.IdentityModel.Tokens.Saml.SamlSecurityTokenHandler.ValidateSignature(String token, TokenValidationParameters validationParameters)\r\n   at Microsoft.IdentityModel.Tokens.Saml.SamlSecurityTokenHandler.ValidateToken(String token, TokenValidationParameters validationParameters, SecurityToken\u0026 validatedToken)\r\n   at Microsoft.AspNetCore.Authentication.WsFederation.WsFederationHandler.HandleRemoteAuthenticateAsync()\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.AspNetCore.Authentication.WsFederation.WsFederationHandler.HandleRemoteAuthenticateAsync()\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.AspNetCore.Authentication.RemoteAuthenticationHandler\u00601.HandleRequestAsync()\r\n   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)\r\n   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)",
        "createdAt": "2023-11-16T21:18:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1815329746"
      },
      {
        "id": "IC_kwDOAQzde85sM8df",
        "parentId": null,
        "author": "csowa",
        "content": "\u0060options.UseSecurityTokenHandlers = false;\u0060\r\n\r\n-----\r\n\r\nMicrosoft.AspNetCore.Authentication.AuthenticationFailureException: An error was encountered while handling the remote login.\r\n ---\u003E Microsoft.IdentityModel.Tokens.SecurityTokenException: No token validator or token handler was found for the given token.\r\n ---\u003E System.AggregateException: One or more errors occurred. (IDX30011: Unable to read XML. Expecting XmlReader to be at ns.element: \u0027urn:oasis:names:tc:SAML:2.0:assertion.Assertion\u0027, found: \u0027urn:oasis:names:tc:SAML:1.0:assertion.Assertion\u0027.) (IDX10204: Unable to validate issuer. validationParameters.ValidIssuer is null or whitespace AND validationParameters.ValidIssuers is null or empty.) (IDX14100: JWT is not well formed, there are no dots (.).\r\nThe token needs to be in JWS or JWE Compact Serialization Format. (JWS): \u0027EncodedHeader.EndcodedPayload.EncodedSignature\u0027. (JWE): \u0027EncodedProtectedHeader.EncodedEncryptedKey.EncodedInitializationVector.EncodedCiphertext.EncodedAuthenticationTag\u0027.)\r\n ---\u003E Microsoft.IdentityModel.Xml.XmlReadException: IDX30011: Unable to read XML. Expecting XmlReader to be at ns.element: \u0027urn:oasis:names:tc:SAML:2.0:assertion.Assertion\u0027, found: \u0027urn:oasis:names:tc:SAML:1.0:assertion.Assertion\u0027.\r\n   at Microsoft.IdentityModel.Xml.XmlUtil.CheckReaderOnEntry(XmlReader reader, String element, String namespace)\r\n   at Microsoft.IdentityModel.Tokens.Saml2.Saml2Serializer.ReadAssertion(XmlReader reader)\r\n   at Microsoft.IdentityModel.Tokens.Saml2.Saml2SecurityTokenHandler.ReadSaml2Token(XmlReader reader)\r\n   at Microsoft.IdentityModel.Tokens.Saml2.Saml2SecurityTokenHandler.ReadSaml2Token(String token)\r\n   at Microsoft.IdentityModel.Tokens.Saml2.Saml2SecurityTokenHandler.ValidateSignature(String token, TokenValidationParameters validationParameters)\r\n   at Microsoft.IdentityModel.Tokens.Saml2.Saml2SecurityTokenHandler.ValidateToken(String token, TokenValidationParameters validationParameters, SecurityToken\u0026 validatedToken)\r\n   at Microsoft.IdentityModel.Tokens.Saml2.Saml2SecurityTokenHandler.ValidateTokenAsync(String token, TokenValidationParameters validationParameters)\r\n   --- End of inner exception stack trace ---\r\n ---\u003E (Inner Exception #1) Microsoft.IdentityModel.Tokens.SecurityTokenInvalidIssuerException: IDX10204: Unable to validate issuer. validationParameters.ValidIssuer is null or whitespace AND validationParameters.ValidIssuers is null or empty.\r\n   at Microsoft.IdentityModel.Tokens.Validators.ValidateIssuerAsync(String issuer, SecurityToken securityToken, TokenValidationParameters validationParameters, BaseConfiguration configuration)\r\n   at Microsoft.IdentityModel.Tokens.Validators.ValidateIssuer(String issuer, SecurityToken securityToken, TokenValidationParameters validationParameters, BaseConfiguration configuration)\r\n   at Microsoft.IdentityModel.Tokens.Validators.ValidateIssuer(String issuer, SecurityToken securityToken, TokenValidationParameters validationParameters)\r\n   at Microsoft.IdentityModel.Tokens.Saml.SamlSecurityTokenHandler.ValidateIssuer(String issuer, SecurityToken securityToken, TokenValidationParameters validationParameters)\r\n   at Microsoft.IdentityModel.Tokens.Saml.SamlSecurityTokenHandler.ValidateSignature(SamlSecurityToken samlToken, String token, TokenValidationParameters validationParameters)\r\n   at Microsoft.IdentityModel.Tokens.Saml.SamlSecurityTokenHandler.ValidateSignature(String token, TokenValidationParameters validationParameters)\r\n   at Microsoft.IdentityModel.Tokens.Saml.SamlSecurityTokenHandler.ValidateToken(String token, TokenValidationParameters validationParameters, SecurityToken\u0026 validatedToken)\r\n   at Microsoft.IdentityModel.Tokens.Saml.SamlSecurityTokenHandler.ValidateTokenAsync(String token, TokenValidationParameters validationParameters)\u003C---\r\n\r\n ---\u003E (Inner Exception #2) Microsoft.IdentityModel.Tokens.SecurityTokenMalformedException: IDX14100: JWT is not well formed, there are no dots (.).\r\nThe token needs to be in JWS or JWE Compact Serialization Format. (JWS): \u0027EncodedHeader.EndcodedPayload.EncodedSignature\u0027. (JWE): \u0027EncodedProtectedHeader.EncodedEncryptedKey.EncodedInitializationVector.EncodedCiphertext.EncodedAuthenticationTag\u0027.\r\n ---\u003E Microsoft.IdentityModel.Tokens.SecurityTokenMalformedException: IDX14122: JWT is not a well formed JWE, there are more than four dots (.) a JWE can have at most 4 dots.\r\nThe token needs to be in JWS or JWE Compact Serialization Format. (JWS): \u0027EncodedHeader.EndcodedPayload.EncodedSignature\u0027. (JWE): \u0027EncodedProtectedHeader.EncodedEncryptedKey.EncodedInitializationVector.EncodedCiphertext.EncodedAuthenticationTag\u0027.\r\n   at Microsoft.IdentityModel.JsonWebTokens.JsonWebToken.ReadToken(String encodedJson)\r\n   at Microsoft.IdentityModel.JsonWebTokens.JsonWebToken..ctor(String jwtEncodedString)\r\n   at Microsoft.IdentityModel.JsonWebTokens.JsonWebTokenHandler.ReadToken(String token, TokenValidationParameters validationParameters)\r\n   --- End of inner exception stack trace ---\u003C---\r\n\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.AspNetCore.Authentication.WsFederation.WsFederationHandler.HandleRemoteAuthenticateAsync()\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.AspNetCore.Authentication.RemoteAuthenticationHandler\u00601.HandleRequestAsync()\r\n   at Microsoft.AspNetCore.Authentication.AuthenticationMiddleware.Invoke(HttpContext context)\r\n   at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddlewareImpl.Invoke(HttpContext context)",
        "createdAt": "2023-11-16T21:20:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1815332703"
      },
      {
        "id": "IC_kwDOAQzde85sPqjY",
        "parentId": null,
        "author": "Hakon",
        "content": "We have encountered this issue as well and implemented a [workaround](https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/2406#issuecomment-1814246256).\r\n\r\nThis may be an issue with a difference in how JsonWebTokenHandler and SamlSecurityTokenHandler handles configuration fetching from ConfigurationManager. I have reported this issue to Microsoft.IdentityModel here: https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/2406\r\n\r\nThe JsonWebTokenHandler fetches BaseConfiguration from the ConfigurationManager when validating a token, the Saml*SecurityTokenHandler does not. This change https://github.com/dotnet/aspnetcore/commit/a56e968c19be1275db6dc462310d723615b006a7#diff-42233637069e62d711d83e163c06bbf11849c4acb594daaf5587697c3ef0789fL99 changed configuration fetching so that this now is delegated to the TokenHandler when using the default ConfigurationManager or StaticConfigurationManager (inherits from BaseConfigurationManager). While this works for JsonWebTokenHandler, the SAML handlers is not compatible.",
        "createdAt": "2023-11-17T09:43:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1816045784"
      },
      {
        "id": "IC_kwDOAQzde85sdaFG",
        "parentId": null,
        "author": "csowa",
        "content": "Received the following response via email, does not appear here.\r\n\r\n-----\r\n\r\nFrom: Stephen Halter \r\nSent: Monday, November 20, 2023 9:49 AM\r\nTo: dotnet/aspnetcore \r\nCc: Chris Sowa; Author \r\nSubject: Re: [dotnet/aspnetcore] Authentication.WsFederation breaks with on-premise AD FS use (Issue #52099) \r\n \r\n\r\nIt\u0027s undocumented breaking change.\r\nWe did make a breaking change announcement for the switch from JwtSecurityToken and JwtTokenValidators to JsonWebToken and TokenHandler in .NET 8 preview 7.  https://learn.microsoft.com/en-us/dotnet/core/compatibility/aspnet-core/8.0/securitytoken-events\r\n\r\nWe recommend updating your code to utilize the newer, more-optimized types. But if that\u0027s not possible, you can set WsFederationOptions.UseSecurityTokenHandlers = true which is the second option listed in the \u0022Recommended action\u0022 section of the announcement.\r\nIf there\u0027s something that is no longer possible with the new types, please file an issue at https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet. If you have suggestions for how to improve the breaking change announcement, you can suggest edits at https://github.com/dotnet/docs/blob/main/docs/core/compatibility/aspnet-core/8.0/securitytoken-events.md",
        "createdAt": "2023-11-20T19:10:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1819648326"
      },
      {
        "id": "IC_kwDOAQzde85sdgAy",
        "parentId": null,
        "author": "csowa",
        "content": "Thank you for your response. I am aware of the breaking change as described.  Unfortunately, that is not the issue here.  \r\nI am attempting to use an ASP.NET Core component, and it breaks regardless of UseSecurityTokenHandlers setting.  Please see the provided repro app.\r\n\r\nI can confirm the issue noted above https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1816045784, and I can work around the initialization problem related to that which was introduced in the associated ASP.NET Core change to the WsFederation component.  \r\n\r\nWhile that initialization issue may have a root cause deeper in the architecture and in a separate project, the issue is exposed in a component from this project.  \r\n\r\nThere is a separate issue in the new token handler in that it does not appear to handle WS-Fed tokens properly.  But again, that is internal to the ASP.NET Core component implementation in its choice of relying on other projects.\r\n\r\nI am not using the token handlers directly, there is nothing in the code or the sample app to be switched.\r\n\r\nIt appears that ASP.NET Core\u0027s Authentication.WsFederation component has relied internally on one or more broken components from other project(s).  \r\n\r\nI would expect that such internal issues between projects would be addressed by the involved projects\u0027 members.\r\n\r\nTo reiterate: this is not a question about the breaking change that was noted, it\u0027s an issue with the component not working as documented, requiring user space work arounds.",
        "createdAt": "2023-11-20T19:29:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1819672626"
      },
      {
        "id": "IC_kwDOAQzde85serI6",
        "parentId": null,
        "author": "OttoG",
        "content": "Hi, I can confirm what @csowa assumes, that this is not a matter of the state of the \u0060UseSecurityTokenHandlers\u0060 setting or in any way specifically related to the breaking change announced for Preview 7 that prompted the introduction of that setting, as mentioned above.\r\n\r\nThat change relates to the use of JWT tokens (and handling them with one class or the other), but the error messages in the bug report clearly indicate that @csowa uses SAML tokens, which are handled by completely different classes.\r\n\r\n@Hakon has, as far as I can tell, correctly diagnosed the problem and has also published a great workaround in this issue: https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/2406\r\n\r\nThe error message in this bug report indicates that the workaround should be applicable as-is, but users who get a SAML 2.0 version token may need to subclass \u0060Saml2SecurityTokenHandler\u0060 instead of \u0060SamlSecurityTokenHandler\u0060.\r\n\r\nAs @csowa writes, this is fine for those of us who are in control of the code that configures WsFederation, but if that code resides in a separate component that cannot be easily modified, it of course becomes a direct obstacle to adoption .NET 8.0.",
        "createdAt": "2023-11-20T23:40:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1819980346"
      },
      {
        "id": "IC_kwDOAQzde85siiSE",
        "parentId": null,
        "author": "Hakon",
        "content": "\u003E The error message in this bug report indicates that the workaround should be applicable as-is, but users who get a SAML 2.0 version token may need to subclass \u0060Saml2SecurityTokenHandler\u0060 instead of \u0060SamlSecurityTokenHandler\u0060.\r\n\r\nThis is correct. It was not intended as a general fix for everyone but rather a hint at how to work around the problem. I am working on a proper fix in IdentityModel.",
        "createdAt": "2023-11-21T14:07:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1820992644"
      },
      {
        "id": "IC_kwDOAQzde85tv5rB",
        "parentId": null,
        "author": "brentschmaltz",
        "content": "@Hakon @OttoG @csowa @halter73 the workaround is great and can be used until we get the fix into IdentityModel.\r\nPlease make sure to call TokenValidationParameters.Clone() before modifying and calling ValidateTokenAsync(...) as TokenValidationParameters can persist across http requests.",
        "createdAt": "2023-12-05T17:23:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1841273537"
      },
      {
        "id": "IC_kwDOAQzde85tzYGa",
        "parentId": null,
        "author": "Hakon",
        "content": "Thank you for the warning. I have submitted a fix to IdentityModel.",
        "createdAt": "2023-12-06T06:43:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1842184602"
      },
      {
        "id": "IC_kwDOAQzde85vT5Vh",
        "parentId": null,
        "author": "arknu",
        "content": "Just hit this as well. This is a pretty big breaking change to be undocumented! And how come this has not been fixed? It completely breaks ADFS Integration.\r\n\r\nThanks for the workaround, @Hakon! It works great.",
        "createdAt": "2023-12-22T10:01:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1867486561"
      },
      {
        "id": "IC_kwDOAQzde850blsI",
        "parentId": null,
        "author": "SimonCropp",
        "content": "@Hakon \r\n\r\n\u003E Thank you for the warning. I have submitted a fix to IdentityModel.\r\n\r\ncan you link to the fix. did it make it into net8?\r\n",
        "createdAt": "2024-02-20T02:31:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1953389320"
      },
      {
        "id": "IC_kwDOAQzde851TCvr",
        "parentId": null,
        "author": "halter73",
        "content": "\u003E can you link to the fix. did it make it into net8?\r\n\r\nNot yet. The PR to fix it is still open at https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/pull/2412.",
        "createdAt": "2024-02-27T23:49:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1967926251"
      },
      {
        "id": "IC_kwDOAQzde852GYci",
        "parentId": null,
        "author": "iSatishYadav",
        "content": "Stumbled upon this after spending afternoon. The workaround works as claimed. But a major breaking change.",
        "createdAt": "2024-03-06T17:14:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1981384482"
      },
      {
        "id": "IC_kwDOAQzde852GY9T",
        "parentId": null,
        "author": "guillaume86",
        "content": "Yes some regression tests would be welcome for components this sensitive.",
        "createdAt": "2024-03-06T17:15:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1981386579"
      },
      {
        "id": "IC_kwDOAQzde852bXhy",
        "parentId": null,
        "author": "MatiasEnrique",
        "content": "Had it fixed after replacing:\r\n![image](https://github.com/dotnet/aspnetcore/assets/87081374/77d09311-6cda-4f36-a973-e73324c47e92)\r\nfor:\r\n![image](https://github.com/dotnet/aspnetcore/assets/87081374/d56d02f6-3c10-4dde-933f-043531640f47)\r\n\r\n",
        "createdAt": "2024-03-09T15:27:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-1986885746"
      },
      {
        "id": "IC_kwDOAQzde853PJrQ",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "Closing as the updated packages from the Microsoft.IdentityModel.* version 7.4.1 have shipped now, which includes the fix.",
        "createdAt": "2024-03-15T21:26:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2000460496"
      },
      {
        "id": "IC_kwDOAQzde853PkJK",
        "parentId": null,
        "author": "hheexx",
        "content": "Will next patch version of WsFederation depend on fixed versions of IdentityModel?",
        "createdAt": "2024-03-15T22:08:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2000568906"
      },
      {
        "id": "IC_kwDOAQzde853Po10",
        "parentId": null,
        "author": "csowa",
        "content": "\u003E Will next patch version of WsFederation depend on fixed versions of IdentityModel?\r\n\r\nThat is the bug covered by this issue.  This appears to have been prematurely closed, pending resolution / confirmation of WsFederation\u0027s dependency.",
        "createdAt": "2024-03-15T22:33:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2000588148"
      },
      {
        "id": "IC_kwDOAQzde857BQ01",
        "parentId": null,
        "author": "pcibraro",
        "content": "Microsoft.AspNetCore.Authentication.WsFederation has not been updated to reference 7.4.1, which is the one that contains the fix. The latest version 8.0.4 still references to 7.1.2. Do you know if there is any plan to get that updated ? Thanks",
        "createdAt": "2024-04-18T13:55:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2063928629"
      },
      {
        "id": "IC_kwDOAQzde859RFRp",
        "parentId": null,
        "author": "jjacobson",
        "content": "@mkArtakMSFT This issue was specifically for Authentication.WsFederation breaking. Despite the fix to Microsoft.IdentityModel, Authentication.WsFederation still has not been updated to reference the fixed version, and thus the issue raised by this ticket still exists. This was closed prematurely.",
        "createdAt": "2024-05-08T22:54:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2101630057"
      },
      {
        "id": "IC_kwDOAQzde86EXXEm",
        "parentId": null,
        "author": "ngboardway",
        "content": "It would appear that the 4th preview version for the package with net 9 has finally increased the minimum version to 7.4.1 (and a couple later bumped it again). I\u0027d love if they could release a version with 8, but if you ever upgrade it should eventually be resolved.",
        "createdAt": "2024-07-10T14:47:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2220716326"
      },
      {
        "id": "IC_kwDOAQzde86Fn-YO",
        "parentId": null,
        "author": "SimonCropp",
        "content": "please re-open. this is still broken",
        "createdAt": "2024-07-22T00:42:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2241848846"
      },
      {
        "id": "IC_kwDOAQzde86F1Kwv",
        "parentId": null,
        "author": "FlavioMH",
        "content": "Re-open please. Still not working:\r\n![image](https://github.com/user-attachments/assets/723d6229-50f6-4ab8-9ff3-98f24d9a5684)\r\n",
        "createdAt": "2024-07-23T13:46:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2245307439"
      },
      {
        "id": "IC_kwDOAQzde86F3NkK",
        "parentId": null,
        "author": "halter73",
        "content": "Generally speaking, we do not force higher dependency versions for external dependencies in patch releases. Updating IdentityModel packages has not been without [issues](https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/2513), and forcing an update to Microsoft.IdentityModel.Protocols.WsFederation to 7.4.1 would also force us to also update other packages which are much more widely used like Microsoft.IdentityModel.Tokens to 7.1.2 to 7.4.1.\r\n\r\nUnlike with new major versions, it\u0027s a lot harder for us to build confidence that taking a major update to external dependencies will not be too breaking since we do not have multiple preview releases to try to iron out any kinks. Instead, we have to rely entirely on internal automated and manual testing. I\u0027m sympathetic to wanting AD FS to work out of the box without updating any NuGet packages with ASP.NET Core 8, but the workaround of updating outdated NuGet packages does not seem too onerous. You should generally be doing this to get security updates as fast as possible in any case.\r\n\r\n@mkArtakMSFT @wtgodbe @JeremyLikness @danroth27 @jennyf19 Given the severity of the issue, would we be willing to make an exception to our usual patching policy and take a dependency update to Microsoft.IdentityModel.Protocols.WsFederation, Microsoft.IdentityModel.Tokens, et al. in a .NET 8 patch? And would 7.4.1 be the version we pick? It does seem risky and has implications beyond just the Microsoft.AspNetCore.Authentication.WsFederation package, and the workaround is simply updating NuGet packages.",
        "createdAt": "2024-07-23T17:34:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2245843210"
      },
      {
        "id": "IC_kwDOAQzde86J7qtx",
        "parentId": null,
        "author": "SimonCropp",
        "content": "@mkArtakMSFT @wtgodbe @JeremyLikness @danroth27 @jennyf19  any thoughts on the above?",
        "createdAt": "2024-08-28T03:18:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2314120049"
      },
      {
        "id": "IC_kwDOAQzde86J-51h",
        "parentId": null,
        "author": "pcibraro",
        "content": "To be clear, the issue is not only affecting apps using adfs, but any app that uses an external idp saml metadata file. ",
        "createdAt": "2024-08-28T10:45:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2314968417"
      },
      {
        "id": "IC_kwDOAQzde86KYurk",
        "parentId": null,
        "author": "wtgodbe",
        "content": "What\u0027s stopping users from updating the PackageReference to WSFederation in their own app to work around the issue? That would generally be our recommendation for situations like this. I generally agree w/ @halter73\u0027s interpretation here - we definitely wouldn\u0027t upgrade to a new Major version in a servicing release, and upgrading to a new Minor version would be highly unusual",
        "createdAt": "2024-08-30T15:52:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2321738468"
      },
      {
        "id": "IC_kwDOAQzde86KZEij",
        "parentId": null,
        "author": "pcibraro",
        "content": "\u003E What\u0027s stopping users from updating the PackageReference to WSFederation in their own app to work around the issue? That would generally be our recommendation for situations like this. I generally agree w/ @halter73\u0027s interpretation here - we definitely wouldn\u0027t upgrade to a new Major version in a servicing release, and upgrading to a new Minor version would be highly unusual\r\n\r\nWhat do you mean with that ? If you reference the latest version for WSFederation, it includes the version  7.1.2 for Microsoft.IdentityModel that is broken. The only workaround is to go and manually reference the assembly with the latest version of the SamlHandler that fixes the issue. ",
        "createdAt": "2024-08-30T16:16:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2321828003"
      },
      {
        "id": "IC_kwDOAQzde86KZiw-",
        "parentId": null,
        "author": "wtgodbe",
        "content": "\u003E What do you mean with that ? If you reference the latest version for WSFederation, it includes the version 7.1.2 for Microsoft.IdentityModel that is broken.\r\n\r\nSorry, looks like I got some of the details wrong. \r\n\r\n\u003E The only workaround is to go and manually reference the assembly with the latest version of the SamlHandler that fixes the issue.\r\n\r\nThis is what I was trying to suggest - Would adding a PackageReference to the 7.4.1 version of \u0060Microsoft.IdentityModel.*\u0060 not fix the issue?",
        "createdAt": "2024-08-30T16:46:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2321951806"
      },
      {
        "id": "IC_kwDOAQzde86K100I",
        "parentId": null,
        "author": "FlavioMH",
        "content": "@wtgodbe Even if I don\u0027t find it a very clean solution, yes: manually forcing _System.IdentityModel.Protocols.WsFederation_ to the version (at least) 7.4.1 fixes the issue:\r\n![image](https://github.com/user-attachments/assets/a6482d93-9a94-4dd4-b99a-4bc4f4c76fa1)\r\n",
        "createdAt": "2024-09-04T15:23:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2329365768"
      },
      {
        "id": "IC_kwDOAQzde86K2lcG",
        "parentId": null,
        "author": "wtgodbe",
        "content": "@FlavioMH thanks for confirming - we\u0027re happy to take these kind of dependency updates in our active development branches (e.g. we\u0027ve already done this update in .NET 9 \u0026 10), but our policy is not to take Minor or Major version updates in Servicing releases, as they can contain breaking changes. Given that the proposed workaround fixes the problem, I\u0027m going to close this issue. Feel free to re-open if you feel there\u0027s an angle that we\u0027ve missed here.",
        "createdAt": "2024-09-04T16:57:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2329564934"
      },
      {
        "id": "IC_kwDOAQzde86K2oLE",
        "parentId": null,
        "author": "hheexx",
        "content": "@wtgodbe As I understand the problem, angle you missed in last message is that WsFederation package is almost completely broken without this update.",
        "createdAt": "2024-09-04T17:04:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2329576132"
      },
      {
        "id": "IC_kwDOAQzde86K2q-o",
        "parentId": null,
        "author": "arknu",
        "content": "\u003E @wtgodbe As I understand the problem, angle you missed in last message is that WsFederation package is almost completely broken without this update.\r\n\r\n@wtgodbe Not to mention that this is a regression compared to .NET 7. It should absolutely be fixed in a servicing update for .NET 8, especially since .NET 8 is an LTS release with a longer lifespan.",
        "createdAt": "2024-09-04T17:10:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2329587624"
      },
      {
        "id": "IC_kwDOAQzde86K3EE7",
        "parentId": null,
        "author": "wtgodbe",
        "content": "Unfortunately we aren\u0027t able to take the dependency update in 8.0, as there is a known breaking change between 7.1.2 and 7.4.1 - https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/2513. If we _were_ to take that update, then later realize that we\u0027d broken even _more_ people, it would be impossible for us to roll it back.\r\n\r\nWe realize that this isn\u0027t a great state to be in, but we\u0027re essentially stuck between a rock and a hard place on this one. I\u0027m going to re-open this issue to track our ongoing work to improve the documentation for this one (to suggest adding a \u0060PackageReference\u0060 to user projects), which @halter73 is working on.",
        "createdAt": "2024-09-04T18:11:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2329690427"
      },
      {
        "id": "IC_kwDOAQzde86K3Jcy",
        "parentId": null,
        "author": "csowa",
        "content": "And just an FYI, I updated the repro project with a branch that verifies the proposed work-around, in this case taking an explicit dependency on Microsoft.IdentityModel.Protocols.WsFederation v8.0.0, which is version-number-consistent with the rest  of the packages.\r\n",
        "createdAt": "2024-09-04T18:24:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2329712434"
      },
      {
        "id": "IC_kwDOAQzde86K3XT8",
        "parentId": null,
        "author": "hheexx",
        "content": "@wtgodbe you probably want to mention this issue in WsFederation project readme and other high visibility places. I just wanted to make sure you understand that package is completely broken OOB without update.",
        "createdAt": "2024-09-04T18:58:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2329769212"
      },
      {
        "id": "IC_kwDOAQzde86Na1-J",
        "parentId": null,
        "author": "SimonCropp",
        "content": "![image](https://github.com/user-attachments/assets/123a30cf-c0f9-47c2-8f21-ff2485d1a6cb)\r\n",
        "createdAt": "2024-09-25T00:26:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52099#issuecomment-2372624265"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde8538qg6",
    "title": "Custom state not set for OpenIdConnectProtocolValidator",
    "url": "https://github.com/dotnet/aspnetcore/issues/52400",
    "createdAt": "2023-11-27T14:22:49Z",
    "lastUpdated": "2024-11-21T23:18:59Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nWe are currently in the process of hardening our OIDC implementation. As part of this, we want to add an antiforgery token to the state and validate it when getting the response from the IDP.\r\n\r\nHowever, when using context.ProtocolMessage.State, enabling state validation on OpenIdConnectProtocolValidator causes an exception.\n\n### Expected Behavior\n\nAfter enabling RequireState and RequireStateValidation, any state set in context.ProtocolMessage.State should be validated automatically.\n\n### Steps To Reproduce\n\nWhen configuring OpenIdConnect, I am enabling both RequireState and RequireStateValidation:\r\n\r\n\u0060\u0060\u0060\r\noptions.ProtocolValidator.RequireState = true;\r\noptions.ProtocolValidator.RequireStateValidation = true;\r\n\u0060\u0060\u0060\r\n\r\nThen in OnRedirectToIdentityProvider, I am configuring a custom state:\r\n\r\n\u0060\u0060\u0060\r\noptions.Events.OnRedirectToIdentityProvider = (RedirectContext context) =\u003E\r\n{\r\n    context.ProtocolMessage.State = \u0022AntiForgery token will go here\u0022;\r\n    return Task.CompletedTask;\r\n};\r\n\u0060\u0060\u0060\r\n\r\nThis will result in the following exception:\r\n\u0060OpenIdConnectProtocolInvalidStateException: IDX21329: RequireState is \u0027System.Boolean\u0027 but the OpenIdConnectProtocolValidationContext.State is null. State cannot be validated.\u0060\r\n\r\nAfter further investiation, I see that inside the OpenIdConnectProtocolValidator, OpenIdConnectProtocolValidationContext.State remains null.\r\n\r\nWhen looking into where this is created, it seems that State is never set on this context:\r\nhttps://github.com/dotnet/aspnetcore/blob/9efaf0e84dead340be574a27c6924efb5ffaa39b/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectHandler.cs#L684\n\n### Exceptions (if any)\n\nOpenIdConnectProtocolInvalidStateException: IDX21329: RequireState is \u0027System.Boolean\u0027 but the OpenIdConnectProtocolValidationContext.State is null. State cannot be validated.\n\n### .NET Version\n\n7.0.403\n\n### Anything else?\n\nWhen looking into where this is created, it seems that State is never set on this context:\r\nhttps://github.com/dotnet/aspnetcore/blob/9efaf0e84dead340be574a27c6924efb5ffaa39b/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectHandler.cs#L684",
    "upvotes": 0,
    "labels": [
      "investigate",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85tCucJ",
        "parentId": null,
        "author": "DevJasperNL",
        "content": "After some experimenting with this, it seems there are two issues:\r\n\r\n1. State validation on OpenIdConnectProtocolValidator does not work at all. Even if the original state is not altered, setting both RequireState and RequireStateValidation to true will never work due to the state not being set on the context.\r\n\r\nHOWEVER: If the incorrect state is passed, it does result in exceptions. So at least some checks are done on it. Looking in OpenIdConnectHandler, I do see a ValidateCorrelationId method being called, but I am unsure if this actually validates the state itself:\r\nhttps://github.com/dotnet/aspnetcore/blob/c8ef35df22225230b5524ba824b97c5099c87475/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectHandler.cs#L612\r\n\r\n2. Setting context.ProtocolMessage.State in OnRedirectToIdentityProvider handler does not change the state being sent to the IDP. It does however change the state in OpenIdConnectProtocolValidationContext.ProtocolMessage.State (but OpenIdConnectProtocolValidationContext.State remains null)",
        "createdAt": "2023-11-28T09:33:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52400#issuecomment-1829431049"
      },
      {
        "id": "IC_kwDOAQzde85uQI8t",
        "parentId": null,
        "author": "Rora",
        "content": "I also need to know how to leverage the state, is there any update or expected timeline on this?",
        "createdAt": "2023-12-11T10:05:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52400#issuecomment-1849724717"
      },
      {
        "id": "IC_kwDOAQzde85w-LNG",
        "parentId": null,
        "author": "RickvF",
        "content": "I am facing the same issue. Can anyone please give an update on this?",
        "createdAt": "2024-01-17T08:46:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52400#issuecomment-1895347014"
      },
      {
        "id": "IC_kwDOAQzde85zK7JJ",
        "parentId": null,
        "author": "DevJasperNL",
        "content": "I have closed and reopened this issue as suggested by the bot above, yet the \u0022pending-ci-rerun\u0022 label is not removed.\r\n\r\nLeaving this comment to inform that I have rechecked, and the issue is still there.",
        "createdAt": "2024-02-07T15:06:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52400#issuecomment-1932243529"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde854B2kR",
    "title": "which authentication shceme is used to authenticate the current request",
    "url": "https://github.com/dotnet/aspnetcore/issues/52415",
    "createdAt": "2023-11-28T06:31:16Z",
    "lastUpdated": "2024-03-13T17:04:58Z",
    "body": "### Is there an existing issue for this?\n\n- [X] #54532\n\n### Is your feature request related to a problem? Please describe the problem.\n\nin my application we are using two authentication schemes and in my controller action I want to know the which authentication scheme is used for current request, so that I can execute related code.\n\n### Describe the solution you\u0027d like\n\nAdd property in ClaimsPrincipal and set it during authentication, so later it can be used to know which authentication scheme is used.\n\n### Additional context\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85tF304",
        "parentId": null,
        "author": "Tratcher",
        "content": "Getting access to the AuthenticationTicket would address this without requiring modification of the principal. It could be cached in the auth feature? Note that AspNetCore often does not directly create or modify the Principal.",
        "createdAt": "2023-11-28T16:33:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52415#issuecomment-1830255928"
      },
      {
        "id": "IC_kwDOAQzde8526YWh",
        "parentId": null,
        "author": "halter73",
        "content": "It would be nice to provide a built-in way to see what schemes successfully authenticated.\r\n\r\nIn the meantime, you could customize your \u0060AuthenticationHandlers\u0060 to add a \u0060Claim\u0060 to the \u0060ClaimsPrincipal\u0060 on success that indicates that the user was successfully authenticated by the scheme. Even for non-custom handlers, there are usually options like \u0060CookieAuthenticationOptions.Events.OnValidatePrincipal\u0060 (or \u0060OnSigningIn\u0060) and \u0060JwtBearerOptions.Events.OnTokenValidated\u0060 that allow customizing the \u0060ClaimsPrincipal\u0060.\r\n\r\nYou could also replace [the default IPolicyEvaluator](https://github.com/dotnet/aspnetcore/blob/268a2dfc29b33e3fdb73cbac6eb198c05314d77e/src/Security/Authorization/Policy/src/PolicyEvaluator.cs) to include the successful schemes in the \u0060ClaimsPrincipal\u0060 it creates.",
        "createdAt": "2024-03-13T17:04:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52415#issuecomment-1995015585"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde856tyOA",
    "title": "/signin-oidc does not unset nonce and correlation cookies with param error=login_required from failed identity server prompt=none request",
    "url": "https://github.com/dotnet/aspnetcore/issues/53048",
    "createdAt": "2023-12-28T21:09:20Z",
    "lastUpdated": "2024-11-06T01:27:32Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nThis issue has a similar symptom as other reported issues, but I believe has a different cause:\r\n- https://github.com/dotnet/aspnetcore/issues/46053\r\n- https://github.com/dotnet/aspnetcore/issues/24870\r\n- https://github.com/dotnet/aspnetcore/issues/17247\r\n\r\nFor context, we have an application that authenticates with OIDC to an identity server that is on the same domain/site as our application. We\u0027re using Duende.Bff and we have a silent login flow implemented, where an iframe is opened up to \u0060/bff/silent-login\u0060. \u0060/silent-login\u0060 issues a challenge (thus setting the nonce and correlation cookies) and redirects to the identity server using the \u0060prompt=none\u0060 parameter. If the user is already logged into the identity server, then the IS redirects back to \u0060/signin-oidc\u0060, which then deletes the nonce and correlation cookies. That\u0027s expected behavior. The problem occurs when the user is **not** already signed into the identity server. In this case, the IS redirects back to \u0060/signin-oidc\u0060 with the \u0060?error=login_required\u0060 parameter. When this happens, the \u0060/signin-oidc\u0060 endpoint does **NOT** delete the nonce and correlation cookies. And, while Duende.Bff correctly notifies the parent frame via a message that silent login was unsuccessful (so that we can notify the user and prompt for them to login manually), this leaves around extra nonce and correlation cookies until they expire.\r\n\r\nIt does not take long for these extra cookies to build up to the point that we get errors for cookies being too big. Around 4 or 5 navigations to the site without being logged in, within a 15 minute window, will cause the errors to occur. Users clicking on a handful of deep links or accidently double clicking the refresh button a couple of times while not being logged in will trigger the errors, so it\u0027s plausible this will occur outside of QA testing.\r\n\r\nI\u0027ve noticed some differences in the successful vs unsuccessful request, though I don\u0027t know if they are relevant or are the cause:\r\n\r\n- successful requests send \u0060code\u0060, \u0060scope\u0060, \u0060state\u0060, \u0060session_state\u0060, and \u0060iss\u0060 parameters\r\n- unsuccessful requests send \u0060error=login_required\u0060, \u0060state\u0060, and \u0060session_state\u0060 parameters (i.e. missing \u0060code\u0060 and \u0060scope\u0060 parameters)\r\n\r\nThus, I\u0027m not sure if this is expected behavior, given that the unsuccessful request is missing the \u0060code\u0060 parameter - perhaps there is no way for the OIDC middleware to associate it with the original nonce/correlation cookies? Please advise. Our options to mitigate this issue are limited, outside of eliminating silent login functionality which is an option of last resort given we are attempting to support SSO for multiple applications, and that would be a bad user experience.\r\n\r\nNote: contrary to previously reported issues, I can verify that this is not due to a cookie SameSite issue (the identity server is on the same site, and I can confirm that the cookies are being sent correctly with the \u0060/signin-oidc\u0060 request). I can also confirm that there is no login redirect loop happening, and that there is only one challenge being made (in Duende.Bff\u0027s implementation of the \u0060/bff/silent-login\u0060 endpoint).\r\n\r\n### Expected Behavior\r\n\r\nWhen the identity server redirects back to \u0060/signin-oidc\u0060 with the \u0060?error=login_required\u0060 parameter, I expect that it will still delete the nonce and correlation cookies corresponding to the original request, just as it does when the \u0060?error=login_required\u0060 is not present in the request.\r\n\r\n### Steps To Reproduce\r\n\r\nHere is the setup code for our API:\r\n\r\n\u0060\u0060\u0060CSharp\r\nbuilder.Services.AddAuthentication(options =\u003E\r\n{\r\n    options.DefaultScheme = \u0022cookie\u0022;\r\n    options.DefaultChallengeScheme = \u0022oidc\u0022;\r\n    options.DefaultSignOutScheme = \u0022oidc\u0022;\r\n})\r\n.AddCookie(\u0022cookie\u0022, options =\u003E\r\n{\r\n    // set session lifetime\r\n    options.ExpireTimeSpan = TimeSpan.FromHours(8);\r\n\r\n    // sliding or absolute\r\n    options.SlidingExpiration = false;\r\n\r\n    // the \u0022__Secure\u0022 prefix is special\r\n    // See: https://www.ietf.org/archive/id/draft-west-cookie-prefixes-05.txt\r\n    // We are using __Secure instead of __Host because\r\n    // the cookie will have a subpath (e.g. {subdomain.domain}/{app-subpath}) and not the root \u0022/\u0022\r\n    options.Cookie.Name = \u0022__Secure-bff\u0022;\r\n\r\n    // strict SameSite handling\r\n    options.Cookie.SameSite = SameSiteMode.Strict;\r\n})\r\n.AddOpenIdConnect(\u0022oidc\u0022, options =\u003E\r\n{\r\n    if (isOptions is null)\r\n    {\r\n        throw new InvalidOperationException(\u0022Missing IdentityServer config section\u0022);\r\n    }\r\n\r\n    options.Authority = isOptions.Authority;\r\n\r\n    // confidential client using code flow \u002B PKCE\r\n    options.RequireHttpsMetadata = true;\r\n    options.ClientId = isOptions.ClientId;\r\n    options.ClientSecret = isOptions.ClientSecret;\r\n    options.ResponseType = OpenIdConnectResponseType.Code;\r\n\r\n    // query response type is compatible with strict SameSite mode\r\n    options.ResponseMode = OpenIdConnectResponseMode.Query;\r\n\r\n    // get claims without mappings\r\n    options.MapInboundClaims = false;\r\n    options.GetClaimsFromUserInfoEndpoint = true;\r\n\r\n    // save tokens into authentication session\r\n    // to enable automatic token management\r\n    options.SaveTokens = true;\r\n\r\n    // request scopes\r\n    options.Scope.Clear();\r\n    options.Scope.Add(\u0022openid\u0022);\r\n    options.Scope.Add(\u0022profile\u0022);\r\n\r\n    // and refresh token\r\n    options.Scope.Add(\u0022offline_access\u0022);\r\n});\r\n\u0060\u0060\u0060\r\n\r\nAnd here is the silent-login functionality on the frontend side (note the issue occurs with or without the \u0060redirectToLogin\u0060 functionality below):\r\n\r\n\u0060\u0060\u0060Ts\r\n  private silentLogin(s: Session) {\r\n    if (this.userIsAnonymous(s)) {\r\n      console.log(\u0027not already logged in, attempting silent login...\u0027);\r\n      const timeout = 5000;\r\n\r\n      function redirectToLogin() {\r\n        const returnUrl = window.location.pathname \u002B window.location.search \u002B window.location.hash;\r\n        window.location.href = \u0060/app1/bff/login?returnUrl=${returnUrl}\u0060;\r\n      }\r\n\r\n      function onMessage(e: any) {\r\n        if (e.data \u0026\u0026 e.data.source === \u0027bff-silent-login\u0027) {\r\n          window.removeEventListener(\u0022message\u0022, onMessage);\r\n          if (e.data.isLoggedIn) {\r\n            console.log(\u0027silent login succeeded, refreshing\u0027);\r\n            window.location.reload();\r\n          } else {\r\n            console.log(\u0027silent login failed due to not being logged in, redirecting to identity server login page\u0027);\r\n            redirectToLogin();\r\n          }\r\n        }\r\n      }\r\n      window.addEventListener(\u0022message\u0022, onMessage);\r\n\r\n      window.setTimeout(() =\u003E {\r\n        window.removeEventListener(\u0022message\u0022, onMessage);\r\n        console.error(\u0027silent login timed out, redirecting to login\u0027);\r\n        redirectToLogin();\r\n      }, timeout);\r\n\r\n      const iframe = document.createElement(\u0027iframe\u0027);\r\n      iframe.src = \u0027/app1/bff/silent-login\u0027;\r\n      iframe.setAttribute(\u0027style\u0027, \u0027width:0px;height:0px\u0027);\r\n      document.body.appendChild(iframe);\r\n    }\r\n    return s;\r\n  }\r\n\u0060\u0060\u0060\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n8.0.100\r\n\r\n### Anything else?\r\n\r\nASP.NET Core version is 6.0.25\r\n\r\n\u0060dotnet --info\u0060:\r\n\r\n\u0060\u0060\u0060\r\n.NET SDK:\r\n Version:           8.0.100\r\n Commit:            57efcf1350\r\n Workload version:  8.0.100-manifests.8d38d0cc\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.22631\r\n OS Platform: Windows\r\n RID:         win-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\8.0.100\\\r\n\r\n.NET workloads installed:\r\n Workload version: 8.0.100-manifests.8d38d0cc\r\n [wasm-tools]\r\n   Installation Source: VS 17.8.34330.188\r\n   Manifest Version:    8.0.0/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.workload.mono.toolchain.current\\8.0.0\\WorkloadManifest.json\r\n   Install Type:              Msi\r\n\r\n [android]\r\n   Installation Source: VS 17.8.34330.188\r\n   Manifest Version:    34.0.43/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.android\\34.0.43\\WorkloadManifest.json\r\n   Install Type:              Msi\r\n\r\n [wasm-tools-net6]\r\n   Installation Source: VS 17.8.34330.188\r\n   Manifest Version:    8.0.0/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.workload.mono.toolchain.net6\\8.0.0\\WorkloadManifest.json\r\n   Install Type:              Msi\r\n\r\n [maui-windows]\r\n   Installation Source: VS 17.8.34330.188\r\n   Manifest Version:    8.0.3/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.maui\\8.0.3\\WorkloadManifest.json\r\n   Install Type:              Msi\r\n\r\n [maccatalyst]\r\n   Installation Source: VS 17.8.34330.188\r\n   Manifest Version:    17.0.8478/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.maccatalyst\\17.0.8478\\WorkloadManifest.json\r\n   Install Type:              Msi\r\n\r\n [ios]\r\n   Installation Source: VS 17.8.34330.188\r\n   Manifest Version:    17.0.8478/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.ios\\17.0.8478\\WorkloadManifest.json\r\n   Install Type:              Msi\r\n\r\n\r\nHost:\r\n  Version:      8.0.0\r\n  Architecture: x64\r\n  Commit:       5535e31a71\r\n\r\n.NET SDKs installed:\r\n  8.0.100 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.App 6.0.25 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 7.0.14 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 8.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 6.0.25 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 7.0.14 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 8.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 6.0.25 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 7.0.14 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 8.0.0 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\nOther architectures found:\r\n  x86   [C:\\Program Files (x86)\\dotnet]\r\n    registered at [HKLM\\SOFTWARE\\dotnet\\Setup\\InstalledVersions\\x86\\InstallLocation]\r\n\r\nEnvironment variables:\r\n  Not set\r\n\r\nglobal.json file:\r\n  Not found\r\n\r\nLearn more:\r\n  https://aka.ms/dotnet/info\r\n\r\nDownload .NET:\r\n  https://aka.ms/dotnet/download\r\n\u0060\u0060\u0060",
    "upvotes": 0,
    "labels": [
      "help wanted",
      "enhancement",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85vmbVI",
        "parentId": null,
        "author": "Tratcher",
        "content": "That makes sense, the nonce cookie isn\u0027t consumed \u0026 deleted until late in the validation process. Maybe that could happen earlier?\r\n\r\nIf there\u0027s an id token:\r\nhttps://github.com/dotnet/aspnetcore/blob/e6be3e95fec33ca3a3b576df4b265ead680a91a0/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectHandler.cs#L669\r\n\r\nIf there\u0027s a code:\r\nhttps://github.com/dotnet/aspnetcore/blob/e6be3e95fec33ca3a3b576df4b265ead680a91a0/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectHandler.cs#L752\r\n\r\nThe logic for deleting the right cookie only cross checks against the received code/token, that would have to be relaxed in the error scenario.\r\nhttps://github.com/dotnet/aspnetcore/blob/e6be3e95fec33ca3a3b576df4b265ead680a91a0/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectHandler.cs#L1062-L1090",
        "createdAt": "2023-12-29T21:23:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53048#issuecomment-1872344392"
      },
      {
        "id": "IC_kwDOAQzde86SWJcA",
        "parentId": null,
        "author": "dotnet-policy-service",
        "content": "Looks like this issue has been identified as a candidate for community contribution. If you\u0027re considering sending a PR for this issue, look for the \u0060Summary Comment\u0060 link in the issue description. That comment has been left by an engineer on our team to help you get started with handling this issue. You can learn more about our Help Wanted process [here](https://aka.ms/aspnet/processes/help-wanted)\n\u003C!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003E",
        "createdAt": "2024-11-04T17:19:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53048#issuecomment-2455279360"
      },
      {
        "id": "IC_kwDOAQzde86SiVvM",
        "parentId": null,
        "author": "AndyWangMSFT",
        "content": "@JeroMiya Thanks for posting this question. Just curious, were you able to delete the nonce/correlation cookie from server side? I\u0027m trying to delete these two types of cookie so that they are not building up",
        "createdAt": "2024-11-06T00:39:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53048#issuecomment-2458475468"
      },
      {
        "id": "IC_kwDOAQzde86SigdU",
        "parentId": null,
        "author": "JeroMiya",
        "content": "\u003E [@JeroMiya](https://github.com/JeroMiya) Thanks for posting this question. Just curious, were you able to delete the nonce/correlation cookie from server side? I\u0027m trying to delete these two types of cookie so that they are not building up\n\nIt\u0027s funny, we actually decided to port the Angular app to Blazor. Since we are using enhanced navigation, we removed the need to implement silent login using an iframe in the frontend, since the redirect happens on the server side before the frontend even loads (or it happens at navigation time if it happens post load). So, I didn\u0027t need to go back and implement a workaround. But the problem will still exist for anybody trying to implement the silent login flow with a more traditional frontend spa following the latest OIDC recommendations.",
        "createdAt": "2024-11-06T01:27:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53048#issuecomment-2458519380"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde857ocuZ",
    "title": "Invalid authentication configuration crashes ASP.NET core (stack overflow)",
    "url": "https://github.com/dotnet/aspnetcore/issues/53267",
    "createdAt": "2024-01-10T11:47:06Z",
    "lastUpdated": "2024-11-14T17:17:53Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nAn invalid/incomplete ASPNET Core authentication configuration causes the framework to crash and generate a stack overflow.\n\n### Expected Behavior\n\nI would the application not to crash.\r\n\n\n### Steps To Reproduce\n\nIf I:\r\n\r\n1. Create a new empty ASP.NET Core application, .NET 8\r\n2. Add OpenIdConnect NuGet package (Microsoft.AspNetCore.Authentication.OpenIdConnect 8.0.1)\r\n3. add this code\r\n\u0060\u0060\u0060\r\nbuilder.Services.AddAuthentication()\r\n.AddOpenIdConnect(\u0022oidc\u0022, o =\u003E\r\n{\r\n    o.Authority = \u0022https://example.com\u0022;\r\n\r\n    o.ClientId = \u0022localhost-client\u0022;\r\n    o.ClientSecret = \u0022mysecret\u0022;\r\n\r\n    o.ResponseType = \u0022code\u0022;\r\n    o.Prompt = \u0022consent\u0022;\r\n\r\n});\r\n\r\n\u0060\u0060\u0060\r\n\r\n4. I start the application\r\n5. Then I get a stack overflow as shown below and the console output just outputs errors forever.\r\n\r\n\r\n\u0060\u0060\u0060\r\ninfo: Microsoft.Hosting.Lifetime[14]\r\n      Now listening on: https://localhost:7106\r\ninfo: Microsoft.Hosting.Lifetime[14]\r\n      Now listening on: http://localhost:5080\r\ninfo: Microsoft.Hosting.Lifetime[0]\r\n      Application started. Press Ctrl\u002BC to shut down.\r\ninfo: Microsoft.Hosting.Lifetime[0]\r\n      Hosting environment: Development\r\ninfo: Microsoft.Hosting.Lifetime[0]\r\n      Content root path: c:\\code\\WebApplication1\\WebApplication1\r\nStack overflow.\r\n   at System.Threading.Tasks.Task.FromResult[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]](System.__Canon)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601[[System.__Canon, System.Private.CoreLib, Version=8.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].SetResult(System.__Canon)\r\n   at Microsoft.AspNetCore.Authentication.AuthenticationHandlerProvider\u002B\u003CGetHandlerAsync\u003Ed__5.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Microsoft.AspNetCore.Authentication.AuthenticationHandlerProvider\u002B\u003CGetHandlerAsync\u003Ed__5, Microsoft.AspNetCore.Authentication.Core, Version=8.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60]](\u003CGetHandlerAsync\u003Ed__5 ByRef)\r\n...\r\n\u0060\u0060\u0060\r\n\r\n\r\nYes, the confiuration is not complete/valid.\r\n\r\n\n\n### Exceptions (if any)\n\nStack Overflow\n\n### .NET Version\n\ndotnet --version 8.0.100\n\n### Anything else?\n\n_No response_",
    "upvotes": 3,
    "labels": [
      "enhancement",
      "area-auth",
      "Pillar: Dev Experience"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85xwbwg",
        "parentId": null,
        "author": "ltrzesniewski",
        "content": "FWIW, I have the same issue, and I\u0027d also like ASP.NET to give me an error message if possible.\r\n\r\nI\u0027m just trying to serve static files for authenticated users, and this seems much harder than it should be. Right now I\u0027m kind of stuck because I don\u0027t know ASP.NET very well. \uD83D\uDE15 ",
        "createdAt": "2024-01-24T16:47:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53267#issuecomment-1908522016"
      },
      {
        "id": "IC_kwDOAQzde85ydSvc",
        "parentId": null,
        "author": "cadcad-sat",
        "content": "I was able to reproduce this issue as well.\r\n\r\nThe reason for the occurrence of the loop is due to the setting of oidc in defaultAuthenticate.Name in the AuthenticationMiddleware when calling context.AuthenticateAsync(defaultAuthenticate.Name).\r\n\u0060\u0060\u0060 cs\r\n// AuthenticationMiddleware.cs\r\nvar defaultAuthenticate = await Schemes.GetDefaultAuthenticateSchemeAsync(); \r\nif (defaultAuthenticate != null)\r\n{\r\n    var result = await context.AuthenticateAsync(defaultAuthenticate.Name);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThe rationale behind Schemes.GetDefaultAuthenticateSchemeAsync returning OidcScheme is that in AuthenticationSchemeProvider.GetDefaultSchemeAsync, it used to return null in version 6.0.26, but in version 8.0.1, it now returns _autoDefaultScheme.\r\n\u0060\u0060\u0060 cs\r\n// AuthenticationSchemeProvider.cs\r\nprivate Task\u003CAuthenticationScheme?\u003E GetDefaultSchemeAsync()\r\n    =\u003E _options.DefaultScheme != null\r\n    ? GetSchemeAsync(_options.DefaultScheme)\r\n    : _autoDefaultScheme; // 6.0.26 Task.FromResult\u003CAuthenticationScheme?\u003E(null);\r\n\r\npublic virtual Task\u003CAuthenticationScheme?\u003E GetDefaultAuthenticateSchemeAsync()\r\n    =\u003E _options.DefaultAuthenticateScheme != null\r\n    ? GetSchemeAsync(_options.DefaultAuthenticateScheme)\r\n    : GetDefaultSchemeAsync();\r\n\r\nprivate void CheckAutoDefaultScheme()\r\n{\r\n    if (!_options.DisableAutoDefaultScheme)\r\n    {\r\n        if (_schemes.Count == 1)\r\n        {\r\n            _autoDefaultScheme = Task.FromResult\u003CAuthenticationScheme?\u003E(_schemesCopy.First());\r\n        }\r\n        else\r\n        {\r\n            _autoDefaultScheme = _nullScheme;\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nTo resolve the issue, it is recommended to add CookieAuthentication. Please refer to the following code snippet:\r\n\u0060\u0060\u0060 cs\r\nservices.AddAuthentication(options =\u003E\r\n{\r\n    options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme;\r\n    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\r\n})\r\n.AddCookie(setup =\u003E setup.ExpireTimeSpan = TimeSpan.FromMinutes(sessionCookieLifetime))\r\n.AddOpenIdConnect(options =\u003E\r\n{\r\n    options.SignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;\r\n});\r\n\u0060\u0060\u0060\r\nReference: [Authenticate with an OpenID Connect or OAuth 2.0 Identity Provider](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/secure-net-microservices-web-applications/#authenticate-with-an-openid-connect-or-oauth-20-identity-provider)",
        "createdAt": "2024-02-01T01:03:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53267#issuecomment-1920281564"
      },
      {
        "id": "IC_kwDOAQzde85yhWaI",
        "parentId": null,
        "author": "ltrzesniewski",
        "content": "@cadcad-sat Thank you so much for your explanation, I managed to get the authentication to work thanks to your help! \uD83D\uDE00 ",
        "createdAt": "2024-02-01T13:37:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53267#issuecomment-1921345160"
      },
      {
        "id": "IC_kwDOAQzde85-TgtS",
        "parentId": null,
        "author": "rashadrivera",
        "content": "I have the same problem, except I\u0027m using the \u0060AddMicrosoftAccount\u0060 instead of the \u0060AddOpenIdConnect\u0060 method.  I\u0027m also using the .NET Core 7 library version.",
        "createdAt": "2024-05-19T00:37:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53267#issuecomment-2119043922"
      },
      {
        "id": "IC_kwDOAQzde86DiLM_",
        "parentId": null,
        "author": "halter73",
        "content": "\u003E I have the same problem, except I\u0027m using the \u0060AddMicrosoftAccount\u0060 instead of the \u0060AddOpenIdConnect\u0060 method. I\u0027m also using the .NET Core 7 library version.\r\n\r\nWere you able to fix this by calling [AddCookie](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.cookieextensions.addcookie?view=aspnetcore-8.0)?",
        "createdAt": "2024-07-03T16:42:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53267#issuecomment-2206774079"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde8578rZK",
    "title": "UseAuthorization does not work with WebHostBuilder on .NET 8",
    "url": "https://github.com/dotnet/aspnetcore/issues/53332",
    "createdAt": "2024-01-12T18:59:24Z",
    "lastUpdated": "2024-11-14T17:26:42Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nWhen using \u0060WebHostBuilder\u0060 to run web applications or tests in .NET 8, and \u0060app.UseAuthorization()\u0060 is called, when starting the web app, an exception is thrown stating the following:\r\n\r\n\u003E Unable to resolve service for type \u0027Microsoft.AspNetCore.Routing.EndpointDataSource\u0027 while attempting to activate \u0027Microsoft.AspNetCore.Authorization.Policy.AuthorizationPolicyCache\u0027.\r\n\r\nThis issue does not occur with any prior version of .NET.\r\n\r\n### Expected Behavior\r\n\r\nUsing WebHostBuilder to create a web application should work as it did in .NET 7 and prior versions.\r\n\r\n### Steps To Reproduce\r\n\r\n\u0060\u0060\u0060xml\r\n\u003CProject Sdk=\u0022Microsoft.NET.Sdk.Web\u0022\u003E\r\n\r\n  \u003CPropertyGroup\u003E\r\n    \u003COutputType\u003EExe\u003C/OutputType\u003E\r\n    \u003CTargetFramework\u003Enet8.0\u003C/TargetFramework\u003E\u003C!-- change to 7.0 and it works --\u003E\r\n    \u003CImplicitUsings\u003Eenable\u003C/ImplicitUsings\u003E\r\n    \u003CNullable\u003Eenable\u003C/Nullable\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n\u003C/Project\u003E\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060cs\r\nvar hostBuilder = new WebHostBuilder();\r\nhostBuilder.UseIIS(); // fails with UseKestrel() also\r\nhostBuilder.ConfigureServices(services =\u003E\r\n{\r\n    services.AddAuthentication();\r\n    services.AddAuthorization();\r\n});\r\nhostBuilder.Configure(app =\u003E\r\n{\r\n    app.UseAuthentication();\r\n    app.UseAuthorization();\r\n    app.Run(async context =\u003E\r\n    {\r\n        context.Response.StatusCode = 200;\r\n        context.Response.ContentType = \u0022text/plain\u0022;\r\n        await context.Response.WriteAsync(\u0022OK\u0022);\r\n    });\r\n});\r\nawait hostBuilder.Build().RunAsync(); // \u003C-- crashes here\r\n\u0060\u0060\u0060\r\n\r\n\r\n### Exceptions (if any)\r\n\r\n\u0060\u0060\u0060\r\nSystem.InvalidOperationException\r\n  HResult=0x80131509\r\n  Message=Unable to resolve service for type \u0027Microsoft.AspNetCore.Routing.EndpointDataSource\u0027 while attempting to activate \u0027Microsoft.AspNetCore.Authorization.Policy.AuthorizationPolicyCache\u0027.\r\n  Source=Microsoft.Extensions.DependencyInjection\r\n  StackTrace:\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteFactory.CreateArgumentCallSites(ServiceIdentifier serviceIdentifier, Type implementationType, CallSiteChain callSiteChain, ParameterInfo[] parameters, Boolean throwIfCallSiteNotFound)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteFactory.CreateConstructorCallSite(ResultCache lifetime, ServiceIdentifier serviceIdentifier, Type implementationType, CallSiteChain callSiteChain)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteFactory.TryCreateExact(ServiceDescriptor descriptor, ServiceIdentifier serviceIdentifier, CallSiteChain callSiteChain, Int32 slot)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteFactory.TryCreateExact(ServiceIdentifier serviceIdentifier, CallSiteChain callSiteChain)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteFactory.CreateCallSite(ServiceIdentifier serviceIdentifier, CallSiteChain callSiteChain)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteFactory.GetCallSite(ServiceIdentifier serviceIdentifier, CallSiteChain callSiteChain)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceProvider.CreateServiceAccessor(ServiceIdentifier serviceIdentifier)\r\n   at System.Collections.Concurrent.ConcurrentDictionary\u00602.GetOrAdd(TKey key, Func\u00602 valueFactory)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceProvider.GetService(ServiceIdentifier serviceIdentifier, ServiceProviderEngineScope serviceProviderEngineScope)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceLookup.ServiceProviderEngineScope.GetService(Type serviceType)\r\n   at Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetService[T](IServiceProvider provider)\r\n   at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware..ctor(RequestDelegate next, IAuthorizationPolicyProvider policyProvider, IServiceProvider services)\r\n   at Microsoft.AspNetCore.Authorization.AuthorizationMiddlewareInternal..ctor(RequestDelegate next, IServiceProvider services, IAuthorizationPolicyProvider policyProvider, ILogger\u00601 logger)\r\n   at System.RuntimeMethodHandle.InvokeMethod(Object target, Void** arguments, Signature sig, Boolean isConstructor)\r\n   at System.Reflection.MethodBaseInvoker.InvokeDirectByRefWithFewArgs(Object obj, Span\u00601 copyOfArgs, BindingFlags invokeAttr) in /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs:line 178\r\n   at System.Reflection.MethodBaseInvoker.InvokeWithFewArgs(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture) in /_/src/libraries/System.Private.CoreLib/src/System/Reflection/MethodBaseInvoker.cs:line 145\r\n   at System.Reflection.RuntimeConstructorInfo.Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture) in /_/src/libraries/System.Private.CoreLib/src/System/Reflection/RuntimeConstructorInfo.cs:line 162\r\n   at Microsoft.Extensions.Internal.ActivatorUtilities.ConstructorMatcher.CreateInstance(IServiceProvider provider)\r\n   at Microsoft.Extensions.Internal.ActivatorUtilities.CreateInstance(IServiceProvider provider, Type instanceType, Object[] parameters)\r\n   at Microsoft.AspNetCore.Builder.UseMiddlewareExtensions.ReflectionMiddlewareBinder.CreateMiddleware(RequestDelegate next)\r\n   at Microsoft.AspNetCore.Builder.ApplicationBuilder.Build()\r\n   at Microsoft.AspNetCore.Hosting.WebHost.BuildApplication() in /_/src/Hosting/Hosting/src/Internal/WebHost.cs:line 225\r\n   at Microsoft.AspNetCore.Hosting.WebHost.\u003CStartAsync\u003Ed__27.MoveNext() in /_/src/Hosting/Hosting/src/Internal/WebHost.cs:line 132\r\n   at Microsoft.AspNetCore.Hosting.WebHostExtensions.\u003CRunAsync\u003Ed__5.MoveNext() in /_/src/Hosting/Hosting/src/WebHostExtensions.cs:line 112\r\n   at Microsoft.AspNetCore.Hosting.WebHostExtensions.\u003CRunAsync\u003Ed__5.MoveNext() in /_/src/Hosting/Hosting/src/WebHostExtensions.cs:line 147\r\n   at Microsoft.AspNetCore.Hosting.WebHostExtensions.\u003CRunAsync\u003Ed__4.MoveNext() in /_/src/Hosting/Hosting/src/WebHostExtensions.cs:line 97\r\n   at Program.\u003C\u003CMain\u003E$\u003Ed__0.MoveNext() in C:\\......\\Program.cs:line 24\r\n   at Program.\u003CMain\u003E(String[] args)\r\n\u0060\u0060\u0060\r\n\r\n### .NET Version\r\n\r\n8.0.101\r\n\r\n### Anything else?\r\n\r\n- Workaround: add \u0060services.AddRouting();\u0060\r\n- Workaround is not required when using \u0060WebApplication.CreateBuilder\u0060",
    "upvotes": 2,
    "labels": [
      "bug",
      "area-auth",
      "Pillar: Dev Experience"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde858r0d8",
        "parentId": null,
        "author": "seantleonard",
        "content": "Hi @Shane32, I was having the same issue.\r\n\r\nI got my tests working by adding \u0060services.AddRouting()\u0060 before \u0060services.AddAuthorization()\u0060.\r\n\r\n\u0060\u0060\u0060csharp\r\nservices.AddRouting(); // \u003C-- Order matters\r\nservices.AddAuthorization();\r\n\u0060\u0060\u0060\r\n\r\n### Background:\r\nThat idea was motivated by a comment in the source code of \u0060app.UseAuthorization()\u0060. \r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/0bae45ebe88ad07f69e13a142c93a05b496dc9b4/src/Security/Authorization/Policy/src/AuthorizationAppBuilderExtensions.cs#L20-L21\r\n\r\nI added the \u0022using\u0022 (and not the service.AddRouting) and received this error:\r\n\u0060\u0060\u0060\r\nSystem.InvalidOperationException: Unable to find the required services. Please add all the required services by calling \u0027IServiceCollection.AddRouting\u0027 inside the call to \u0027ConfigureServices(...)\u0027 in the application startup code.\r\n\u0060\u0060\u0060\r\n\r\nTo mitigate, I then added \u0060 services.AddRouting();\u0060 before \u0060services.AddAuthorization();\u0060 and my code worked!\r\nJust out of curiosity because my tests didn\u0027t explicitly need \u0022app.UseRouting()\u0022, I checked whether removing the \u0022using\u0022 would render the same results. My code ran without issue.\r\n\r\n### Mitigation -\u003E more contextual setup code.\r\n\u0060\u0060\u0060csharp\r\nwebBuilder\r\n    .UseTestServer()\r\n    .ConfigureServices(services =\u003E\r\n    {\r\n        services.AddAuthentication(defaultScheme: \u003Cscheme\u003E);\r\n        services.AddRouting();\r\n        services.AddAuthorization();\r\n    })\r\n    .Configure(app =\u003E\r\n    {\r\n        //app.UseRouting(); // \u003C- didn\u0027t need this. Whether it is correct to leave out is TBD.\r\n        app.UseAuthentication();\r\n        app.UseAuthorization();\r\n\r\n        // app.Run acts as terminating middleware to return 200 if we reach it. Without this,\r\n        // the Middleware pipeline will return 404 by default.\r\n        app.Run(async (context) =\u003E\r\n        {\r\n            context.Response.StatusCode = (int)HttpStatusCode.OK;\r\n            await context.Response.WriteAsync(\u0022Successful Request\u0022);\r\n            await context.Response.StartAsync();\r\n        });\r\n    });\r\n\u0060\u0060\u0060\r\n\r\n### Original exception\r\nI observed (and found this issue) because my stack trace matched yours.\r\n\u003E System.InvalidOperationException: Unable to resolve service for type \u0027Microsoft.AspNetCore.Routing.EndpointDataSource\u0027 while attempting to activate \u0027Microsoft.AspNetCore.Authorization.Policy.AuthorizationPolicyCache\u0027.\r\n\r\n### notes\r\n\r\nI\u0027m sure there must be a more elegant way of doing this, but I didn\u0027t have more time to look into this because I was trying to unblock myself from finishing a deliverable.",
        "createdAt": "2024-05-02T22:37:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53332#issuecomment-2091861884"
      },
      {
        "id": "IC_kwDOAQzde85872kY",
        "parentId": null,
        "author": "warmfire540",
        "content": "I\u0027m having this same exception, but in a console app...\r\nI added \u0060.UseRouting()\u0060 and it works... but this is not a webhost?\r\n\r\nafter upgrading to NET 8",
        "createdAt": "2024-05-06T13:49:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53332#issuecomment-2096064792"
      },
      {
        "id": "IC_kwDOAQzde86C3RfV",
        "parentId": null,
        "author": "johnkors",
        "content": "What warmfire said. Routing does not make sense in a Console app.",
        "createdAt": "2024-06-27T19:36:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53332#issuecomment-2195527637"
      },
      {
        "id": "IC_kwDOAQzde86TpDWc",
        "parentId": null,
        "author": "mikekistler",
        "content": "We should optionally resolve endpoint datasource.",
        "createdAt": "2024-11-14T17:26:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53332#issuecomment-2477012380"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde859ax1B",
    "title": "Kestrel Windows Auth is not prompting UN/PW challenge on macOS, when server runs on windows AD.",
    "url": "https://github.com/dotnet/aspnetcore/issues/53675",
    "createdAt": "2024-01-28T13:45:46Z",
    "lastUpdated": "2024-04-04T16:49:43Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nI\u0027m struggling to get windows auth working on Kestler.\r\nIt kinda works, but only when clients are windows Chrome or IE browsers. When client in MacOS UN/PW challenge is not prompted.\n\n### Expected Behavior\n\nExpected behaviour is that macOS Chrome / Safari would also prompt for username password.\n\n### Steps To Reproduce\n\nSetup keslter server running on windows and enable windows auth like:\r\nMain:\r\n\u0060builder.Services.AddAuthentication(NegotiateDefaults.AuthenticationScheme).AddNegotiate();\r\n//for my case I want Auth to be executed on specific path of URL\r\napp.UseWhen(context =\u003E context.Request.Path.StartsWithSegments(\u0022/Auth\u0022), specificPathApp =\u003E {\r\n\tspecificPathApp.UseAuthentication(); // Apply authentication only for this path\r\n\tspecificPathApp.UseAuthorization();\r\n});\u0060\r\n\r\n\r\nAuthController:\r\n\u0060public class AuthController : Controller {\r\n\t[HttpGet]\r\n\t[Authorize]\r\n\tpublic ActionResult Index(string? redirect = null) {\r\n\t\tWindowsIdentity? winIdent = User.Identity as WindowsIdentity;\r\n\t\treturn new ContentResult { Content = \u0022Auth ok, winidentity: name=\u0022 \u002B (winIdent?.Name ?? \u0022user not found\u0022), ContentType = \u0022text/plain\u0022 };\r\n\t}\r\n}\u0060\r\n\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n8.0.101\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "investigate",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85yJ_B6",
        "parentId": null,
        "author": "Tratcher",
        "content": "That seems like a client limitation, I don\u0027t know that there\u0027s anything the server can/should do differently here. Does it work with any other servers?",
        "createdAt": "2024-01-29T17:25:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53675#issuecomment-1915220090"
      },
      {
        "id": "IC_kwDOAQzde85yP8MV",
        "parentId": null,
        "author": "sanderaiaots",
        "content": "Might as well be issue how browsers have implemented Negotiate authentication on MacOS, but on windows I get prompted UN/PW when I access site outside my domain, in Mac I just get 401.\r\nSo far same behaviour in Mac with: Chrome, Safari, Firefox.\r\nIt works with IIS 10 server, but its also offer NTLM auth, that might work on MacOS.",
        "createdAt": "2024-01-30T12:52:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53675#issuecomment-1916781333"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86Bpjxy",
    "title": "Improve observability of Microsoft.IdentityModel logs",
    "url": "https://github.com/dotnet/aspnetcore/issues/54424",
    "createdAt": "2024-03-08T02:26:00Z",
    "lastUpdated": "2024-10-31T21:41:29Z",
    "body": "If you use an authentication handler from Microsoft.Identity.Web, it will [wire up](https://github.com/AzureAD/microsoft-identity-web/blob/0f1095cede2529a9311392ef3405448bb35d44f7/src/Microsoft.Identity.Web/WebApiExtensions/MicrosoftIdentityWebApiAuthenticationBuilderExtensions.cs#L172) Microsoft.IdentityModel logs [with Microsoft.Extensions.Logging](https://github.com/AzureAD/microsoft-identity-web/blob/0f1095cede2529a9311392ef3405448bb35d44f7/src/Microsoft.Identity.Web.TokenAcquisition/MicrosoftIdentityBaseAuthenticationBuilder.cs#L63) using [IdentityLoggerAdapter](https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/3f504620646bff24e22a41ee636baecb47b6937b/src/Microsoft.IdentityModel.LoggingExtensions/IdentityLoggerAdapter.cs). The authentication handlers we ship out of this repo (JwtBearerHandler, OpenIdConnectHander, and WsFederationHandler) don\u0027t do this.\r\n\r\nCurrently, to get logs from IdentityModel like \u0022IDX10214: Audience validation failed.\u0022 from the JwtBearerHandler into your ASP.NET Core loggers, you have to do something like the following after adding a new package reference to Microsoft.IdentityModel.LoggingExtensions:\r\n\r\n\u0060\u0060\u0060csharp\r\nvar loggerFactory = app.Services.GetRequiredService\u003CILoggerFactory\u003E();\r\nvar logger = loggerFactory.CreateLogger(\u0022IdentityLogger\u0022);\r\nLogHelper.Logger = new IdentityLoggerAdapter(logger);\r\n\u0060\u0060\u0060\r\n\r\nSetting the static LogHelper.Logger property the way Microsoft.Identity.Web does in methods like AddJwtBearer is far from ideal. We should work with the Identity team to add APIs to components like JsonWebTokenHandler and ConfigurationManager so they log to a non-static IIdentityLogger provided by our authentication handlers.\r\n\r\nThis could be used to improve the Microsoft.Identity.Web integration with ASP.NET Core logging as well by allowing log messages to be scoped to the handler that is logging and include things like the whether the log came from AddMicrosoftIdentityWebApp or AddMicrosoftIdentityWebApi.\r\n\r\n@jennyf19 @keegan-caruso ",
    "upvotes": 5,
    "labels": [
      "enhancement",
      "blocked",
      "area-auth",
      "feature-observability"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde852T8d3",
        "parentId": null,
        "author": "halter73",
        "content": "This is similar to https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/1778, but it looks like some progress has been made since then with the addition of \u0060IdentityLoggerAdapter\u0060. I don\u0027t know if that needs its own assembly, but maybe a middle ground would be to introduce a \u0060AddIdentityLoggerAdapter\u0060 API to Microsoft.IdentityModel.LoggingExtensions and have all the handlers call that. That wouldn\u0027t be nearly as good as being able to provide a unique logger from each authentication handler, but it would be better than what we have now.",
        "createdAt": "2024-03-08T02:32:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54424#issuecomment-1984939895"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86DHKV-",
    "title": "Combine MapWhen with UseAuthorization and many Endpoints is slow",
    "url": "https://github.com/dotnet/aspnetcore/issues/54664",
    "createdAt": "2024-03-21T09:54:17Z",
    "lastUpdated": "2024-07-03T16:19:10Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nWe have several hundreds of endpoints and discovered that our startup time of our application is terrible slow.\r\nAfter Investigation into this situation we enclosed the problem that the call to \u0022UseAuthorization\u0022 makes the WebApplication configuration process slow.\r\n\r\nSee here the sample code to reproduce the issue:\r\nhttps://gist.github.com/softwaretirol/a3169c404226fbe5193c70a721ec8cc5\r\n\r\nWith UseAuthorization() the console gives us a duration of \u002200:00:02.94\u0022.\r\nWithout UseAuthorization() the console gives us a duration of \u002200:00:00.023\u0022\r\n\r\n\n\n### Expected Behavior\n\nSame performance with UseAuthorization as without UseAuthorization\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n8.0.100\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "investigate",
      "Perf",
      "area-auth"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86DUJeA",
    "title": "OpenIdConnectHandler to support async state data format operations",
    "url": "https://github.com/dotnet/aspnetcore/issues/54704",
    "createdAt": "2024-03-22T18:42:20Z",
    "lastUpdated": "2024-03-28T21:46:14Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nCurrently the \u0060OpenIdConnectHandler\u0060 class uses \u0060Options.StateDataFormat\u0060 to protect/unprotect OAuth state, and the interface \u0060ISecureDataFormat\u003CTData\u003E\u0060 does not define any async methods, so the data protection operation here is always synchronous.\r\nThis creates a problem for the following use case: \r\nPutting the entire state in \u0060state\u0060 query param could make the URL too large, a common solution to this is putting the actual state in storage and only set an encrypted key in state param which can be used later to retrieve the state.\r\nObviously the storage operations will need to be async, but the way that \u0060OpenIdConnectHandler\u0060 handles this today, like I mentioned earlier, makes it impossible to do state data protection synchronously. The only option we have is to implement \u0060ISecureDataFormat\u003CTData\u003E\u0060, call async storage methods and wait for Task results synchronously. But this sort of \u0022sync over async\u0022 behavior should best be avoided if possible.\n\n### Describe the solution you\u0027d like\n\nOne possible solution: \r\n\r\n1. define a new interface \u0060IAsyncSecureDataFormat\u003CTData\u003E\u0060, similar to \u0060ISecureDataFormat\u003CTData\u003E\u0060 except the methods are all async \r\n2. add a new property in \u0060OpenIdConnectOptions\u0060: \u0060IAsyncSecureDataFormat\u003CAuthenticationProperties\u003E AsyncStateDataFormat { get; set; }\u0060\r\n3. in \u0060OpenIdConnectHandler\u0060, use the \u0060Options.AsyncStateDataFormat\u0060 if defined, otherwise fallback to \u0060Options.StateDataFormat\u0060\n\n### Additional context\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86NU28C",
    "title": "Warn when [Authorize] is overridden on SignalR Hubs, Razor Pages, and Razor Components",
    "url": "https://github.com/dotnet/aspnetcore/issues/56435",
    "createdAt": "2024-06-24T20:41:50Z",
    "lastUpdated": "2024-06-26T17:01:22Z",
    "body": "It would be nice to expand analyzer warning ASP0026, \u0022[Authorize] overridden by [AllowAnonymous] from farther away\u0022, to apply not only to MVC Controllers and Actions, but also to SignalR Hubs (and Hub methods), Razor Pages, and Razor Components.\r\n\r\nhttps://github.com/dotnet/aspnetcore/pull/56244 introduced this analyzer for MVC Controllers.",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth",
      "analyzer"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86TLLij",
    "title": "Validate or sanitize client-controlled inputs to the JwtBearer WWW-Authenticate header",
    "url": "https://github.com/dotnet/aspnetcore/issues/57356",
    "createdAt": "2024-08-16T00:08:39Z",
    "lastUpdated": "2024-10-31T21:41:30Z",
    "body": "When a JWT includes an invalid issuer or audience, the \u0060JwtBearerHandler\u0060 will try to produce a \u0060WWW-Authenticate\u0060 response header including the invalid issuer and/or audience from the user-supplied token.\r\n\r\nThese values appear to come from untrusted user input:\r\n https://github.com/dotnet/aspnetcore/blob/27f2a011a4211118552dfb8f38d36e8629267d2b/src/Security/Authentication/JwtBearer/src/JwtBearerHandler.cs#L389-L390\r\n \r\nAnd flow unescaped into headers here: https://github.com/dotnet/aspnetcore/blob/27f2a011a4211118552dfb8f38d36e8629267d2b/src/Security/Authentication/JwtBearer/src/JwtBearerHandler.cs#L328\r\n\r\nThis impact of this lack of validation in a response header is mitigated by the fact that our servers (Kestrel, IIS and HttpSys) ll immediately throw an InvalidOperationException from HttpResponse.Headers.Append as expected with a message indicating the header contained an invalid control character given any instance of either a carriage return or line feed in the header string.\r\n\r\nAll of our servers validate headers values when they are set using one of [these two methods](https://github.com/dotnet/aspnetcore/blob/257d69079e0f7fc84e3f6cd5047272d7f79b4d66/src/Shared/ServerInfrastructure/HttpCharacters.cs#L49-L54). The methods are SearchValues based, so it\u2019s straightforward to see exactly which characters are allowed and disallowed if you\u2019re interested. By default, Kestrel will only allow ASCII characters and IIS/HttpSys will allow extended ASCII, but none of our servers allow control characters regardless of how they\u2019re configured.\r\n\r\nThrowing an \u0060InvalidOperationException\u0060 given a JWT token with an issuer or audience containing a newline isn\u2019t ideal since this will usually result in a 500 response instead of a 401 response with a helpful \u0060WWW-Authenticate\u0060 response header as expected. The simplest option to fix this would be to always use a generic error_description for invalid issuers and audiences, but I think that would be unnecessarily inconvenient in development scenarios. I would probably scan the InvalidIssuer and InvalidAudience to verify it only has allowed characters before using it in the error_description and fall back to a generic message otherwise.",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "area-auth"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86UWp2x",
    "title": "Bad Request - Request Too Long - IIS Server",
    "url": "https://github.com/dotnet/aspnetcore/issues/57545",
    "createdAt": "2024-08-27T10:45:36Z",
    "lastUpdated": "2024-09-05T16:50:26Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\n\r\nI cloned the repository and started working with the [BlazorWebappOidc](https://github.com/dotnet/blazor-samples/tree/main/8.0/BlazorWebAppOidc) project. I configured the Entra ID settings, such as the client ID and tenant ID, using the details from my Entra ID tenant account. After running the application locally on the Kestrel server with the HTTPS profile, the Blazor application launched successfully. The interface loaded in the browser, and I was able to log in using my Entra ID account. After a successful callback to my Blazor application URL, I was redirected and received the expected details (Such as Username, email address, etc).\r\n\r\nHowever, when I deployed the same application on an IIS server, I encountered an issue. While the Blazor application opened, when I attempted to log in to my Microsoft Entra ID account, I received a Bad Request - Request Too Long (HTTP Error 400. The size of the request headers is too long) error after the callback.\r\n\r\n\r\n### Expected Behavior\r\n\r\n\r\nAfter a successful callback to my Blazor application URL, I was redirected and received the expected details (Such as Username, email address, etc).\r\n\r\n### Steps To Reproduce\r\n\r\n- Go to repository and clone [BlazorWebappOidc](https://github.com/dotnet/blazor-samples/tree/main/8.0/BlazorWebAppOidc) and Open the application in Visual Studio.\r\n\r\n- Provide the needed configuration like Tenant ID, Client ID, etc for your Microsoft Azure Entra ID.\r\n\r\n- Add an IIS Settings to launchsettings.json to run the application on IIS locally then Run\r\n\r\n\u0060 \u0022iisSettings\u0022: { \u0022windowsAuthentication\u0022: false, \u0022anonymousAuthentication\u0022: true, \u0022iisExpress\u0022: { \u0022applicationUrl\u0022: \u0022http://localhost:46294\u0022, \u0022sslPort\u0022: 44381 }  },\u0022profiles\u0022: {   \u0022IIS Express\u0022: { \u0022commandName\u0022: \u0022IISExpress\u0022, \u0022launchBrowser\u0022: true, \u0022inspectUri\u0022: \u0022{wsProtocol}://{url.hostname}:{url.port}/_framework/debug/ws-proxy?browser={browserInspectUri}\u0022, \u0022environmentVariables\u0022: { \u0022ASPNETCORE_ENVIRONMENT\u0022: \u0022Development\u0022 }   } }\u0060\r\n\r\n- Click on login and it will redirect you to the authentication flow then provide the Credentials for login (Entra ID Username and password).\r\n\r\n- After the successful callback you get back to the Blazor Application and then you will see the Error\r\n\r\nBad Request - Request Too Long (HTTP Error 400. The size of the request headers is too long.)\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\nDOTNET 8 \r\n\r\n### Anything else?\r\n\r\n![Screenshot_10](https://github.com/user-attachments/assets/5ea76b6e-b850-417e-a832-dcb6fd91652b)\r\n\r\ncc: @guardrex https://github.com/dotnet/blazor-samples/issues/344\r\n",
    "upvotes": 1,
    "labels": [
      "Docs",
      "area-auth",
      "area-networking"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86J0Tod",
        "parentId": null,
        "author": "martincostello",
        "content": "Try configuring [IIS Request Limits](https://learn.microsoft.com/iis/configuration/system.webserver/security/requestfiltering/requestlimits/) in web.config like this to increase the allowed query string length:\r\n\r\n\u0060\u0060\u0060diff\r\n\uFEFF\u003C?xml version=\u00221.0\u0022 encoding=\u0022utf-8\u0022?\u003E\r\n\u003Cconfiguration\u003E\r\n  \u003C!-- Any existing configuration you may have --\u003E\r\n\u002B \u003Csystem.webServer\u003E\r\n\u002B   \u003Csecurity\u003E\r\n\u002B     \u003CrequestFiltering\u003E\r\n\u002B       \u003CrequestLimits maxQueryString=\u00224096\u0022 /\u003E\r\n\u002B     \u003C/requestFiltering\u003E\r\n\u002B   \u003C/security\u003E\r\n\u002B \u003C/system.webServer\u003E\r\n\u003C/configuration\u003E\r\n\u0060\u0060\u0060\r\n",
        "createdAt": "2024-08-27T10:50:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2312190493"
      },
      {
        "id": "IC_kwDOAQzde86J0UGf",
        "parentId": null,
        "author": "kuldeepcis-lab",
        "content": "Already tried, but Not Worked.",
        "createdAt": "2024-08-27T10:51:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2312192415"
      },
      {
        "id": "IC_kwDOAQzde86J0XE2",
        "parentId": null,
        "author": "javiercn",
        "content": "@kuldeepcis-lab thanks for contacting us.\r\n\r\nThe request that fails is the one that happens after the logging, isn\u0027t it? Seems that too much information might be stored in the auth cookie. (There are 5 chunks at 4Kb per chunk)\r\n\r\nSo I suspect IIS has a 16KB header limit.\r\n\r\nIn that situation, you need to either configure a higher limit (not sure if possible) or reduce the amount of information that you put on the cookie.\r\n\r\nYou can do so by hooking on to the Oidc call and customizing the claims principal https://learn.microsoft.com/en-us/aspnet/core/security/authentication/claims?view=aspnetcore-8.0",
        "createdAt": "2024-08-27T10:56:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2312204598"
      },
      {
        "id": "IC_kwDOAQzde86J0XPk",
        "parentId": null,
        "author": "utkarshdubeyfsd",
        "content": "@kuldeepcis-lab, Try configuring the other IIS limits in the web.config file, such as increasing the request length and content length.\r\n\r\n\u0060\u0060\u0060\r\n\u003C?xml version=\u00221.0\u0022 encoding=\u0022utf-8\u0022?\u003E\r\n\u003Cconfiguration\u003E\r\n  \u003Csystem.web\u003E\r\n    \u003C!-- Increase max request length in KB --\u003E\r\n    \u003ChttpRuntime maxRequestLength=\u002251200\u0022 /\u003E \u003C!-- 50 MB --\u003E\r\n  \u003C/system.web\u003E\r\n  \r\n  \u003Csystem.webServer\u003E\r\n    \u003Csecurity\u003E\r\n      \u003CrequestFiltering\u003E\r\n        \u003C!-- Increase max content length in bytes --\u003E\r\n        \u003CrequestLimits maxAllowedContentLength=\u002252428800\u0022 /\u003E \u003C!-- 50 MB --\u003E\r\n      \u003C/requestFiltering\u003E\r\n    \u003C/security\u003E\r\n  \u003C/system.webServer\u003E\r\n\u003C/configuration\u003E\r\n\r\n\u0060\u0060\u0060",
        "createdAt": "2024-08-27T10:57:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2312205284"
      },
      {
        "id": "IC_kwDOAQzde86J0Zm_",
        "parentId": null,
        "author": "kuldeepcis-lab",
        "content": "Hello @utkarshdubeyfsd \r\nI had already tried both of the solutions but did not work at all.",
        "createdAt": "2024-08-27T11:00:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2312214975"
      },
      {
        "id": "IC_kwDOAQzde86J0cMl",
        "parentId": null,
        "author": "kuldeepcis-lab",
        "content": "Hello @javiercn \r\n\r\nI had tried setting the header limit to 64 KB, but no luck even after that change.",
        "createdAt": "2024-08-27T11:03:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2312225573"
      },
      {
        "id": "IC_kwDOAQzde86J0icv",
        "parentId": null,
        "author": "guardrex",
        "content": "@kuldeepcis-lab ... You tried by setting the registry keys?",
        "createdAt": "2024-08-27T11:09:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2312251183"
      },
      {
        "id": "IC_kwDOAQzde86J0lS3",
        "parentId": null,
        "author": "kuldeepcis-lab",
        "content": "@guardrex \r\nNo, I do not know, Can you please guide me.",
        "createdAt": "2024-08-27T11:12:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2312262839"
      },
      {
        "id": "IC_kwDOAQzde86J0rUq",
        "parentId": null,
        "author": "guardrex",
        "content": "Note that I\u0027m not recommending this even if it will work. The product unit must state what approach should be taken here. We will need to do ***something*** in the article/sample to address this because this is a failure with the BWA\u002BOIDC sample app OOB with no special config.\r\n\r\nSee ...\r\n\r\nhttps://learn.microsoft.com/troubleshoot/developer/webapps/iis/iisadmin-service-inetinfo/httpsys-registry-windows\r\n\r\n... for \u0060MaxFieldLength\u0060 and \u0060MaxRequestBytes\u0060.\r\n\r\nAgain ... I mention this \u26A0\uFE0F ***for testing here to get to the root problem.*** \u26A0\uFE0F\r\n\r\nSee if that even lets the app run properly, and then @javiercn / @halter73 can discuss with us how the article/sample app should really address this. I kind\u0027a doubt that we\u0027ll be including guidance on how to adjust registry keys to let the OOB app run under IIS.\r\n\r\nI\u0027ve opened a docs issue \uD83D\uDC47 for when there\u0027s guidance to publish.",
        "createdAt": "2024-08-27T11:20:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2312287530"
      },
      {
        "id": "IC_kwDOAQzde86J1c0t",
        "parentId": null,
        "author": "kuldeepcis-lab",
        "content": "@guardrex \r\nby adding the MaxFieldLength and MaxRequestBytes parameter to registry. it is still **not** working",
        "createdAt": "2024-08-27T12:56:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2312490285"
      },
      {
        "id": "IC_kwDOAQzde86J1lkK",
        "parentId": null,
        "author": "guardrex",
        "content": "Ok ... thanks for checking (and I assume that you changed those and restarted the server).\r\n\r\nI\u0027m \uD83D\uDC42 here for the discussion/resolution, and I\u0027ll get the article\u002Bsample updated per the docs issue that I opened as soon as I know what to do.",
        "createdAt": "2024-08-27T13:11:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2312526090"
      },
      {
        "id": "IC_kwDOAQzde86J4e-N",
        "parentId": null,
        "author": "halter73",
        "content": "@kuldeepcis-lab What did you try setting \u0060MaxRequestBytes\u0060 to? Did you confirm changing this setting allowed you to manually send a request with more than 16 KiB of request headers?\r\n\r\nEven [Kestrel has a limit on the total size of request headers](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.server.kestrel.core.kestrelserverlimits.maxrequestheaderstotalsize?view=aspnetcore-8.0). If Kestrel can handle request headers of this size without custom configuration, IIS should also be able to with the right configuration.\r\n\r\nThe default \u0060MaxRequestHeadersTotalSize\u0060 for Kestrel is 32 KiB while IIS\u0027s \u0060MaxRequestBytes\u0060 (which is nearly equivalent except that the IIS limit also counts the size of the request line in addition to the headers) is 16 KiB, but this can be increased all the way to 16 MiB.\r\n\r\nThere\u0027s also the \u0060MaxFieldLength\u0060, but that shouldn\u0027t come into play considering the cookies are chunked at 4 KiB per header, and the \u0060MaxFieldLength\u0060 limit is 16 KiB per header.\r\n\r\nHowever, I think @javiercn is on the right track. You probably don\u0027t want to take the performance hit of sending such large cookies every request anyway. Your best bet is likely to first inspect which claims are getting stored in the cookie and try clearing any unnecessary claims from the cookie using \u0060OpenIdConnectOptions.ClaimActions.DeleteClaim\u0060. https://learn.microsoft.com/en-us/aspnet/core/security/authentication/social/additional-claims?view=aspnetcore-8.0#remove-claim-actions-and-claims\r\n\r\nhttps://learn.microsoft.com/troubleshoot/developer/webapps/iis/www-administration-management/http-bad-request-response-kerberos has some similar guidance to https://learn.microsoft.com/troubleshoot/developer/webapps/iis/iisadmin-service-inetinfo/httpsys-registry-windows, but it\u0027s first suggestion is to \u0022Decrease the number of Active Directory groups\u0022. This is for Kerberos rather than OIDC, but the principle is the same. If you try to encode too many claims into a header (in this case the \u0022Cookie\u0022 header), you\u0027ll eventually run into limits.",
        "createdAt": "2024-08-27T18:53:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2313285517"
      },
      {
        "id": "IC_kwDOAQzde86J9dfV",
        "parentId": null,
        "author": "kuldeepcis-lab",
        "content": "Hi @halter73 \r\n[BlazorWebappOidc](https://github.com/dotnet/blazor-samples/tree/main/8.0/BlazorWebAppOidc) Works locally when launched using Visual Studio and it runs on Kestral Server on Https profile by default and we do not need to customize the headers \r\nbut having issues With the IIS Server, Not only on deployment The issue is persistent when run locally on IIS through Visual Studio \r\n \r\nNow trying to Delete the unnecessary claim \u0060OpenIdConnectOptions.ClaimActions.DeleteClaim\u0060 \r\nwill back soon.",
        "createdAt": "2024-08-28T07:54:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2314590165"
      },
      {
        "id": "IC_kwDOAQzde86KGMPc",
        "parentId": null,
        "author": "kuldeepcis-lab",
        "content": "Hi @halter73 \r\nReducing the claim size **helps** but also creates an issue that the application does not contain the Authentication state I think because whenever I tried to switch between the pages the application automatically goes down. \r\n",
        "createdAt": "2024-08-29T07:15:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2316878812"
      },
      {
        "id": "IC_kwDOAQzde86KIeDi",
        "parentId": null,
        "author": "guardrex",
        "content": "Given that this issue has arisen and concern that other devs are going to face it in the future with users who have many AD groups/AD built-in Admin Roles, I now plan to modify the approach described by the article.\r\n\r\nLet\u0027s obtain AD groups/AD built-in Admin Roles ***via Graph SDK/API*** separately for authenticating users on sign in. It will eliminate this problem for everyone forever. I already have a separate issue to include an add-on section for Graph SDK/API setup anyway.\r\n\r\n@kuldeepcis-lab ... The soonest that I can reach it is next week (if no fires come up between now and then) due to a couple of factors ... \uD83E\uDD96\uD83E\uDDE0\uD83D\uDD25\uD83D\uDE06 ... I\u0027m tired and need a few days off. We also have the Labor Day holiday on Monday. If you can wait until next week, I\u0027ll have a new Graph-based approach for you.\r\n\r\n@halter73 @MackinnonBuck @javiercn ... If everyone is in agreement with my plan, this PU issue can be closed in favor of the existing docs issues ...\r\n\r\n* [Add Graph access to the BWA\u002BOIDC article\u002Bsamples (\u0060dotnet/AspNetCore.Docs\u0060 #33099)](https://github.com/dotnet/AspNetCore.Docs/issues/33099)\r\n* [BWA\u002BOIDC request header length problem in IIS (\u0060dotnet/AspNetCore.Docs\u0060 #33450)](https://github.com/dotnet/AspNetCore.Docs/issues/33450)\r\n\r\n@halter73 ... I\u0027ll ping u for review when the docs PR goes up.",
        "createdAt": "2024-08-29T12:12:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2317476066"
      },
      {
        "id": "IC_kwDOAQzde86KtthI",
        "parentId": null,
        "author": "guardrex",
        "content": "@kuldeepcis-lab ... I have a working \uD83D\uDE48 ***RexHacks!***\u0026trade; \uD83D\uDE48 approach that uses Graph SDK/API now. It doesn\u0027t rely upon sending AD groups and AD built-in Admin Roles via the cookie, so it should work in your scenario. However, a few caveats ...\r\n\r\n* I ran into some problems trying to create a Graph client prototype with the OIDC provider (i.e., \u0060AddOpenIdConnect\u0060), but I had success with MS Identity Web (i.e., \u0060AddMicrosoftIdentityWebApp\u0060). AFAIK, we\u0027ll have an MS Identity Web-based BWA sample app for 9.0 GA, and I defer to the PU for what such an app is ***really*** supposed to look like. I hacked it to life following a Jean-Marc example for regular ASP.NET Core apps.\r\n* Since I went with MS Identity Web, I won\u0027t be adding Graph for AD groups/roles to the BWA\u002BOIDC article. Azure recommends MS Identity Web for ME-ID, and I think that\u0027s the direction the coverage will go. When I write a new article, that\u0027s where Graph for AD groups/roles will appear.\r\n* The [*Application roles for apps registered with Microsoft Entra (ME-ID)* section](https://learn.microsoft.com/en-us/aspnet/core/blazor/security/blazor-web-app-with-oidc?view=aspnetcore-8.0\u0026pivots=without-bff-pattern#application-roles-for-apps-registered-with-microsoft-entra-me-id) will be removed from the BWA\u002BOIDC article, leaving the [*Application roles for apps not registered with Microsoft Entra (ME-ID)* section](https://learn.microsoft.com/en-us/aspnet/core/blazor/security/blazor-web-app-with-oidc?view=aspnetcore-8.0\u0026pivots=without-bff-pattern#application-roles-for-apps-not-registered-with-microsoft-entra-me-id) in place with a section heading name change.\r\n\r\nThe simplest way for me to show you my \uD83E\uDD96 ***hacks*** is to toss this prototype app into GH for you to look at. You can adopt its approaches \u26A0\uFE0F ***AT YOUR OWN RISK*** \u26A0\uFE0F\uD83D\uDE28 until an official sample\u002Bcoverage is released. The README has the particulars. If you want to discuss the sample, open an issue on that sample repo. This isn\u0027t an official sample, and we won\u0027t discuss it here, unless Halter/Javier/Mackinnon want to chat about it.\r\n\r\nhttps://github.com/guardrex/BlazorWebAppMSIdentityWeb/\r\n\r\n@halter73 may or may not look at that. *Idk if he has time for such silly* \uD83E\uDD96 *things!* \uD83D\uDE06\r\n\r\n",
        "createdAt": "2024-09-03T19:13:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2327238728"
      },
      {
        "id": "IC_kwDOAQzde86K3Dhe",
        "parentId": null,
        "author": "guardrex",
        "content": "I took one more shot with the Graph client \u002B BWA\u002BOIDC, and it still gives me a \uD83D\uDCA5. It complains about a malformed request using the OBO credential provider. \r\n\r\nI\u0027ll throw a dog a bone tho ... ***REST API to the rescue!*** \uD83D\uDE91\uD83D\uDE92\uD83D\uDE93.\r\n\r\nIt\u0027s not \u0022nice\u0022 in the SDK sense, but it works \u2728. It has the nice benefit of requiring no packages, so it\u0027s very lean.\r\n\r\nIn the \u0060CookieOidcRefresher.cs\u0060, I made a nullable string property for the access token (\u0060CurrentAccessToken\u0060) and assign to it at the top and the bottom of the \u0060ValidateOrRefreshCookieAsync\u0060 method. That keeps it updated regardless of refreshing the cookie.\r\n\r\nNeed a couple of classes for deserializing ...\r\n\r\n\u0060\u0060\u0060csharp\r\npublic class RootObject\r\n{\r\n    [JsonPropertyName(\u0022odatacontext\u0022)]\r\n    public string? Context { get; set; }\r\n\r\n    [JsonPropertyName(\u0022value\u0022)]\r\n    public Value[]? Value { get; set; }\r\n}\r\n\r\npublic class Value\r\n{\r\n    [JsonPropertyName(\u0022@odata.type\u0022)]\r\n    public string? Type { get; set; }\r\n\r\n    [JsonPropertyName(\u0022id\u0022)]\r\n    public string? Id { get; set; }\r\n        \r\n    [JsonPropertyName(\u0022roleTemplateId\u0022)]\r\n    public string? RoleTemplateId { get; set; }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nIn \u0060PersistingAuthenticationStateProvider.cs\u0060, inject the \u0060CookieOidcRefresher\u0060 as \u0060cookieOidcRefresher\u0060.\r\n\r\n\u0060OnPersistingAsync\u0060 looks like this ...\r\n\r\n\u0060\u0060\u0060csharp\r\nprivate async Task OnPersistingAsync()\r\n{\r\n    var authenticationState = await GetAuthenticationStateAsync();\r\n    var principal = authenticationState.User;\r\n\r\n    if (principal.Identity?.IsAuthenticated == true)\r\n    {\r\n        var claimsIdentity = (ClaimsIdentity)principal.Identity;\r\n        var accessToken = cookieOidcRefresher.CurrentAccessToken;\r\n\r\n        var client = new HttpClient();\r\n        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\u0022Bearer\u0022, accessToken);\r\n\r\n        var response = await client.GetAsync(\u0022https://graph.microsoft.com/v1.0/me/memberOf\u0022);\r\n\r\n        if (response.StatusCode == HttpStatusCode.OK)\r\n        {\r\n            var content = await response.Content.ReadAsStringAsync();\r\n            RootObject? rootObject = JsonSerializer.Deserialize\u003CRootObject\u003E(content);\r\n\r\n            var groupsAndRoles = rootObject?.Value;\r\n\r\n            if (groupsAndRoles is not null)\r\n            {\r\n                foreach (var entry in groupsAndRoles)\r\n                {\r\n                    if (entry.Type == \u0022#microsoft.graph.group\u0022 \u0026\u0026 entry.Id is not null)\r\n                    {\r\n                        claimsIdentity.AddClaim(new Claim(\u0022groups\u0022, entry.Id));\r\n                    }\r\n\r\n                    if (entry.Type == \u0022#microsoft.graph.directoryRole\u0022 \u0026\u0026 entry.RoleTemplateId is not null)\r\n                    {\r\n                        claimsIdentity.AddClaim(\r\n                            new Claim(\u0022directoryRole\u0022, entry.RoleTemplateId));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            throw new HttpRequestException($\u0022Invalid status code in the HttpResponseMessage: {response.StatusCode}.\u0022);\r\n        }\r\n\r\n        principal = new ClaimsPrincipal(claimsIdentity);\r\n        persistentComponentState.PersistAsJson(nameof(UserInfo), UserInfo.FromClaimsPrincipal(principal));\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThis won\u0027t be for docs. I\u0027m just placing this here in passing in case anyone wants to see how I did it in the BWA\u002BOIDC app. If anyone figures out the Graph client approach ***without \u0027malformed requests\u0027***, I\u0027d like to hear about it \uD83D\uDC42. I still think we\u0027re going to move the AD groups/roles section into a new article on BWA\u002BMS Identity Web, where I know the API call to Graph works well for AD groups/roles \uD83C\uDF89. MS Identity Web ***IS*** the Entra-recommended way to go.\r\n\r\n@halter73 ... My ***hacked*** sample for BWA\u002BMS Identity Web is linked in the prior comment, but I\u0027ll wait for an official sample before writing anything up.",
        "createdAt": "2024-09-04T18:09:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2329688158"
      },
      {
        "id": "IC_kwDOAQzde86K5Edh",
        "parentId": null,
        "author": "halter73",
        "content": "At a glance, https://github.com/guardrex/BlazorWebAppMSIdentityWeb/ looks pretty good to me. You might be able to leverage \u0060AddMicrosoftIdentityUI\u0060 to get rid of \u0060LoginLogoutEndpointRouteBuilderExtensions\u0060, but it\u0027s nice that the latter doesn\u0027t rely on MVC, so I understand leaving it there. I might do the same in the \u0022official\u0022 version we use for the template.\r\n\r\nInstead of putting the Microsoft Graph logic inside of \u0060OnPersistingAsync\u0060, you could do the same thing in \u0060OpenIdConnectOptions.Events.OnTokenValidated\u0060. It might also be worth checking if you can get the same claims you can from Microsoft Graph if you configure \u0060OpenIdConnectOptions.GetClaimsFromUserInfoEndpoint = true\u0060. If we did that, we\u0027d need to update \u0060CookieOidcRefresher\u0060 to also query the \u0060userinfo_endpoint\u0060. I agree that using \u0060AddMicrosoftIdentityWebApp\u0060 is best if you\u0027re connecting to Entra ID. And I\u0027m not sure how much the data \u0060userinfo_endpoint\u0060 overlaps with the Microsoft Graph data.\r\n\r\nI\u0027m also not sure that \u0060JwtSecurityTokenHandler.DefaultMapInboundClaims = false\u0060 does anything anymore, since \u0060JwtSecurityToken\u0060 has been deprecated and is no longer used unless you configure \u0060UseSecurityTokenValidators = true\u0060. https://learn.microsoft.com/en-us/dotnet/core/compatibility/aspnet-core/8.0/securitytoken-events\r\n\r\nYou should be able to achieve the same result with \u0060JsonWebToken\u0060 by calling \u0060JsonWebTokenHandler.DefaultInboundClaimTypeMap.Clear()\u0060. Or if you don\u0027t want to rely on mutating static state, you can still configure \u0060OpenIdConnectOptions.MapInboundClaims = false\u0060 as follows:\r\n\r\n\u0060\u0060\u0060\r\nbuilder.Services.Configure\u003CMicrosoftIdentityOptions\u003E(OpenIdConnectDefaults.AuthenticationScheme, oidcOptions =\u003E\r\n{\r\n    oidcOptions.MapInboundClaims = false;\r\n});\r\n\u0060\u0060\u0060\r\n\r\nIt\u0027s also probably better to use an array of DownstreamApi scopes rather than splitting a single string with \u0060builder.Configuration.GetValue\u003Cstring\u003E(\u0022DownstreamApi:Scopes\u0022)?.Split(\u0027 \u0027)\u0060. \u0060AddMicrosoftGraph(builder.Configuration.GetSection(\u0022DownstreamApi\u0022))\u0060 should already be reading the scopes [as an array](https://github.com/AzureAD/microsoft-identity-abstractions-for-dotnet/blob/5d2d6fb00b1988b644df3517c03b3e3bdfdc33e4/src/Microsoft.Identity.Abstractions/DownstreamApi/DownstreamApiOptions.cs#L25). I\u0027m not sure if \u0060EnableTokenAcquisitionToCallDownstreamApi\u0060 needs the initial scopes, but if it does, you should be able to manually read them as an array without splitting using \u0060builder.Configuration.GetValue\u003Cstring[]\u003E(\u0022DownstreamApi:Scopes\u0022)\u0060.\r\n\r\nAlso, where is \u0060HandleSameSiteCookieCompatibility()\u0060 coming from? And what does it do exactly?",
        "createdAt": "2024-09-04T21:59:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2330216289"
      },
      {
        "id": "IC_kwDOAQzde86K5ONb",
        "parentId": null,
        "author": "guardrex",
        "content": "For ...\r\n\r\n\u003E I\u0027m also not sure that \u0060JwtSecurityTokenHandler.DefaultMapInboundClaims = false\u0060 does anything anymore\r\n\r\n... and ...\r\n\r\n\u003E \u0060HandleSameSiteCookieCompatibility()\u0060 coming from?\r\n\r\nThose are taken from the Azure docs sample app. It might be a Jean-Marc sample. ~I don\u0027t have the link handy at the moment, but I\u0027ll post it tomorrow.~ One of my source links is lost. No matter. I\u0027m going to update per your tips :point_up:.\r\n\r\n\u003E builder.Configuration.GetValue\u003Cstring\u003E(\u0022DownstreamApi:Scopes\u0022)?.Split(\u0027 \u0027)\r\n\r\nI think that came from the sample, too.\r\n\r\nFor the rest, I\u0027ll see if I can take those approaches with the sample app to improve it. I\u0027ll let you know how it turns out.",
        "createdAt": "2024-09-04T22:23:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2330256219"
      },
      {
        "id": "IC_kwDOAQzde86LAq78",
        "parentId": null,
        "author": "guardrex",
        "content": "I found ... \r\n\r\nhttps://github.com/microsoftgraph/msgraph-sample-aspnet-core/tree/main/GraphTutorial\r\n\r\n... and based a set of updates on that. They\u0027re using extension methods and grabbing a lot more Graph data. I\u0027m just hacking a minimal approach without all the bells and whistles at this point.\r\n\r\nHere are my latest \uD83E\uDD96 ***Hack\u0027ins!***\u0026trade; ...\r\n\r\nhttps://github.com/guardrex/BlazorWebAppMSIdentityWeb\r\n\r\n* \u0060LoginLogoutEndpointRouteBuilderExtensions ... doesn\u0027t rely on MVC\u0060 \uD83D\uDC49 I left that alone because not relying on MVC sounds good to me.\r\n* Uses \u0060OnTokenValidated\u0060 for the Graph work.\r\n* \u0060OpenIdConnectOptions.GetClaimsFromUserInfoEndpoint = true\u0060 \uD83D\uDC49 I didn\u0027t check, but I might look into that approach tomorrow.\r\n* \u0060JwtSecurityTokenHandler.DefaultMapInboundClaims = false\u0060 \uD83D\uDC49 Removed.\r\n* \u0060OpenIdConnectOptions.MapInboundClaims = false\u0060 \uD83D\uDC49 Along with setting the \u0060NameClaimType\u0060 and \u0060RoleClaimType\u0060, I resolved it.\r\n* \u0060builder.Configuration.GetValue\u003Cstring\u003E(\u0022DownstreamApi:Scopes\u0022)?.Split(\u0027 \u0027)\u0060 \uD83D\uDC49 Resolved.\r\n* \u0060manually read them as an array without splitting using builder.Configuration.GetValue\u003Cstring[]\u003E(\u0022DownstreamApi:Scopes\u0022)\u0060 \uD83D\uDC49 Resolved.\r\n* \u0060where is HandleSameSiteCookieCompatibility() coming from?\u0060 \uD83D\uDC49 I\u0027ve removed the cookie policy stuff. It\u0027s not in the Azure Graph sample that I\u0027m looking at now. I lost that original sample source, but here\u0027s the API for it ...\r\n  * https://learn.microsoft.com/en-us/dotnet/api/microsoft.identity.web.cookiepolicyoptionsextensions.handlesamesitecookiecompatibility\r\n  * https://github.com/AzureAD/microsoft-identity-web/blob/master/src/Microsoft.Identity.Web/CookiePolicyOptionsExtensions.cs\r\n\r\nWhen we reach the point of having an official BWA\u002BMS Identity Web sample that I can write a new article from, I\u0027ll include steps ***in an article section***. I\u0027ll probably mirror the approach that the Azure sample takes with one or more fancy extension methods. I\u0027ll also add some Key Vault code via Managed Identity for the client secret when writing it up, and I\u0027ll back-port the new Key Vault coverage to the BWA\u002BOIDC article.",
        "createdAt": "2024-09-05T16:50:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57545#issuecomment-2332208892"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86UuyhD",
    "title": "Blazor Server App on iPhone Repeatedly Prompts for Windows Authentication",
    "url": "https://github.com/dotnet/aspnetcore/issues/57603",
    "createdAt": "2024-08-29T18:43:25Z",
    "lastUpdated": "2024-09-04T17:35:56Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nIf you create a new Blazor server-side web application using Windows authentication, after publishing it, you will be prompted to authenticate twice when trying to access it. The issue seems to be related to _framework/blazor.server.js. I am unsure why the Edge browser on iPhone cannot pass credentials to blazor.server.js. After you log in the first time, you are prompted to authenticate again. You can skip the second prompt and navigate to the home page, but each time you click on another link, you are asked to enter your username and password again. This issue has started occurring after recent updates.\n\n### Expected Behavior\n\n_No response_\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n.NET 8\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "bug",
      "External",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86KNCOP",
        "parentId": null,
        "author": "AliAjami2020",
        "content": "\r\nHere you can see that I was able to log in to the app, but immediately after, it prompts the challenge box again.\r\n\r\nPhone screenshot = \r\n![Iphone_edge_WindowAuth](https://github.com/user-attachments/assets/c071f2d6-6817-499c-a07c-bf71ad1b89b1)\r\n\r\nCode =\r\n![image](https://github.com/user-attachments/assets/16ff11fc-a9ff-48c3-be7f-150dd7da45f3)\r\n",
        "createdAt": "2024-08-29T19:12:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57603#issuecomment-2318672783"
      },
      {
        "id": "IC_kwDOAQzde86KTd_x",
        "parentId": null,
        "author": "javiercn",
        "content": "@AliAjami2020 thanks for contacting us.\r\n\r\nI\u0027m not an expert in this area, but I suspect that the problem is either:\r\n1) Your phone configuration.\r\n2) By design, since you are not logged in with your windows user on the iphone.\r\n\r\nThe two prompts you are getting are:\r\n1) During prerendering\r\n2) When the interactive connection is established.\r\n\r\nYou should strongly consider using a different means of authentication if you want to target other mobile devices.",
        "createdAt": "2024-08-30T07:39:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57603#issuecomment-2320359409"
      },
      {
        "id": "IC_kwDOAQzde86KVneI",
        "parentId": null,
        "author": "AliAjami2020",
        "content": "Thank you for your response\r\n\r\nI cannot tell you exactly what the issue is, but my Blazor app was working\r\non the iPhone with one-time authentication before the recent Edge update.\r\nYou will not encounter this issue with an MVC web app that does not have\r\nBlazor.Server. Here are the steps to simulate the exact issue:\r\n\r\n 1. Open Visual Studio and create a new Blazor server app with Windows\r\nAuthentication.\r\n 2. Publish it on IIS and enable Windows Authentication in IIS.\r\n 3. Open your app on an iPhone using Edge.\r\n\r\n\r\nThank you\r\n\r\n\r\n\r\nOn Fri, Aug 30, 2024 at 3:39\u202FAM Javier Calvarro Nelson \u003C\r\n***@***.***\u003E wrote:\r\n\r\n\u003E @AliAjami2020 \u003Chttps://github.com/AliAjami2020\u003E thanks for contacting us.\r\n\u003E\r\n\u003E I\u0027m not an expert in this area, but I suspect that the problem is either:\r\n\u003E\r\n\u003E    1. Your phone configuration.\r\n\u003E    2. By design, since you are not logged in with your windows user on\r\n\u003E    the iphone.\r\n\u003E\r\n\u003E The two prompts you are getting are:\r\n\u003E\r\n\u003E    1. During prerendering\r\n\u003E    2. When the interactive connection is established.\r\n\u003E\r\n\u003E You should strongly consider using a different means of authentication if\r\n\u003E you want to target other mobile devices.\r\n\u003E\r\n\u003E \u2014\r\n\u003E Reply to this email directly, view it on GitHub\r\n\u003E \u003Chttps://github.com/dotnet/aspnetcore/issues/57603#issuecomment-2320359409\u003E,\r\n\u003E or unsubscribe\r\n\u003E \u003Chttps://github.com/notifications/unsubscribe-auth/ALX7OQ2C62QFSIZD7TPEFHTZUAOTJAVCNFSM6AAAAABNLAMAMKVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGMRQGM2TSNBQHE\u003E\r\n\u003E .\r\n\u003E You are receiving this because you were mentioned.Message ID:\r\n\u003E ***@***.***\u003E\r\n\u003E\r\n",
        "createdAt": "2024-08-30T11:28:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57603#issuecomment-2320922504"
      },
      {
        "id": "IC_kwDOAQzde86K21kN",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "UPDATE: I\u0027ve engaged with the Edge team internally and they have filed an internal ticket tracking this issue. At this point it\u0027s out of our control, so marking this as \u0060external\u0060 and parking in the Backlog.",
        "createdAt": "2024-09-04T17:35:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57603#issuecomment-2329630989"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86c_cvy",
    "title": "Make authentication libraries trimmable",
    "url": "https://github.com/dotnet/aspnetcore/issues/58786",
    "createdAt": "2024-11-04T21:25:31Z",
    "lastUpdated": "2024-11-04T21:25:31Z",
    "body": "Leftover work from https://github.com/dotnet/aspnetcore/issues/27384",
    "upvotes": 1,
    "labels": [
      "enhancement",
      "area-auth",
      "triaged",
      "feature-trimming"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86dN4vV",
    "title": "Event-like extensions for authentication.",
    "url": "https://github.com/dotnet/aspnetcore/issues/58812",
    "createdAt": "2024-11-06T10:29:44Z",
    "lastUpdated": "2024-11-06T17:45:24Z",
    "body": "## Background and Motivation\n\nI\u0027d like to run custom actions after authentication succeeds or fails. While some authentication options allow me to define callbacks for various events, there\u0027s no generic way to react to authentication process unless I implement \u0060IClaimsTransformation\u0060 which has other intent.\nIn theory, custom middleware could work but authentication can be performed both by Authentication and Authorization middleware, so it must be enabled at correct place.\n\n## Proposed API\n\nI\u0027d like to be able to register a custom implementation of \u0060IAuthneticationEvents\u0060 (maybe multiple implementations):\n\u0060\u0060\u0060\npublic interface IAuthneticationEvents\n{\n    // Always executed after authentication phase.\n    ValueTask AuthenticationCompleted(IReadOnlyDictionary\u003Cstring, AuthenticationResult\u003E resultByScheme);\n\n    // Executed if at least one scheme from the effective policy is successfully authenticated.\n    ValueTask AuthenticationSucceeded(IReadOnlySet\u003Cstring\u003E succededSchemes, ClaimsPrincipal principal);\n\n    // Executed if neither of the schemes from effective policy was successfully authenticated.\n    ValueTask AuthenticationFailed(IReadOnlyDictionary\u003Cstring, AuthenticationResult\u003E resultByScheme);\n}\n\u0060\u0060\u0060\n\n## Risks\n\nIf I am not mistaken, the current architecture of authentication and authorization process makes implementing this functionality a bit hard. For example, authentication middleware always attempts to authenticate default scheme, but it is not aware of other authentications which will be executed by policy evaluator which belongs to authorization middleware.",
    "upvotes": 2,
    "labels": [
      "enhancement",
      "area-auth",
      "api-suggestion"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86dYCZi",
    "title": "BlazorWebAppOidc AddOpenIdConnect with GetClaimsFromUserInfoEndpoint = true doesn\u0027t propogate role claims to client",
    "url": "https://github.com/dotnet/aspnetcore/issues/58826",
    "createdAt": "2024-11-07T08:54:57Z",
    "lastUpdated": "2024-12-03T18:54:38Z",
    "body": "### Is there an existing issue for this?\n\n- [x] I have searched the existing issues\n\n### Describe the bug\n\nI am using the Blazor 8 BlazorWebAppOidc sample to authenticate and authorize using OpenIdConnect with keycloak. I am seeing an issue where role claims from the userinfo endpoint do not propogate to the client. My setup is as follows:\n\n\u0060\u0060\u0060csharp\nbuilder.Services.AddAuthentication(MS_OIDC_SCHEME)\n    .AddOpenIdConnect(MS_OIDC_SCHEME, oidcOptions =\u003E\n    {\n        oidcOptions.SignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;\n\n        oidcOptions.Authority = \u0022https://host.docker.internal/keycloak/realms/Autostore/\u0022;\n\n        oidcOptions.ClientId = \u0022WMSServiceCalendar\u0022;\n\n        oidcOptions.ResponseType = OpenIdConnectResponseType.Code;\n\n        oidcOptions.MapInboundClaims = false;\n        oidcOptions.TokenValidationParameters = new TokenValidationParameters\n        {\n            NameClaimType = JwtRegisteredClaimNames.Name,\n            RoleClaimType = \u0022role\u0022\n        };\n\n        oidcOptions.UsePkce = true;\n        oidcOptions.GetClaimsFromUserInfoEndpoint = true;\n\n        oidcOptions.Events.OnUserInformationReceived = ctx =\u003E\n        {\n            Console.WriteLine();\n            Console.WriteLine(\u0022Claims from the ID token\u0022);\n            foreach (var claim in ctx.Principal.Claims)\n            {\n                Console.WriteLine($\u0022{claim.Type} - {claim.Value}\u0022);\n            }\n            Console.WriteLine();\n            Console.WriteLine(\u0022Claims from the UserInfo endpoint\u0022);\n            foreach (var property in ctx.User.RootElement.EnumerateObject())\n            {\n                Console.WriteLine($\u0022{property.Name} - {property.Value}\u0022);\n            }\n            return Task.CompletedTask;\n        };\n    })\n    .AddCookie(CookieAuthenticationDefaults.AuthenticationScheme, options =\u003E\n    {\n        options.Events.OnSigningIn = ctx =\u003E\n        {\n            Console.WriteLine();\n            Console.WriteLine(\u0022Claims received by the Cookie handler\u0022);\n            foreach (var claim in ctx.Principal.Claims)\n            {\n                Console.WriteLine($\u0022{claim.Type} - {claim.Value}\u0022);\n            }\n            Console.WriteLine();\n\n            return Task.CompletedTask;\n        };\n    });\n\u0060\u0060\u0060\n\nWith the OnUserInformationReceived logging I can see the claims coming from Keycloak:\n\n\u0060\u0060\u0060\nClaims from the ID token\nexp - 1730968528\niat - 1730968228\nauth_time - 1730968228\njti - 1801bcab-dfd5-463f-9bf6-7cf84ded884a\niss - https://host.docker.internal/keycloak/realms/Autostore\naud - WMSServiceCalendar\nsub - c5f3046c-b1b7-497d-b12e-a3f29afc5d11\ntyp - ID\nazp - WMSServiceCalendar\nnonce - 638665650239925001.M2YxOGZlNDMtMzkxYi00MDhkLWJmZTEtYzM1Y2QwNjI3NjAxODBkODhmZDAtMjE3OC00ZDYyLWEwZjktZGM0MjI5MzZkNjA1\nsid - 654b19df-4dcf-405b-9d34-27bffd126968\nat_hash - iCCj0tkd2HpoJZRclzph-w\nacr - 1\nemail_verified - true\nname - manager name\npreferred_username - manager\ngiven_name - manager\nfamily_name - name\n\nClaims from the UserInfo endpoint\nsub - c5f3046c-b1b7-497d-b12e-a3f29afc5d11\nresource_access - {\u0022CommonClient\u0022:{\u0022roles\u0022:[\u0022CommonClient:GrafanaViewer\u0022,\u0022CommonClient:MessagingAdmin\u0022,\u0022CommonClient:GrafanaEditor\u0022,\u0022CommonClient:GrafanaAdmin\u0022,\u0022CommonClient:UserManagement\u0022,\u0022CommonClient:Users\u0022]}}\nemail_verified - True\nrole - [\u0022WMSServiceCalendar:VehicleTypeDelete\u0022,\u0022WMSServiceCalendar:VehicleDelete\u0022,\u0022WMSServiceCalendar:VehicleExport\u0022,\u0022WMSServiceCalendar:VehicleTypeView\u0022,\u0022WMSServiceCalendar:VehicleView\u0022,\u0022WMSServiceCalendar:Users\u0022]\nname - manager name\npreferred_username - manager\ngiven_name - manager\nfamily_name - name\n\nClaims received by the Cookie handler\nauth_time - 1730968228\njti - 1801bcab-dfd5-463f-9bf6-7cf84ded884a\nsub - c5f3046c-b1b7-497d-b12e-a3f29afc5d11\ntyp - ID\nsid - 654b19df-4dcf-405b-9d34-27bffd126968\nemail_verified - true\nname - manager name\npreferred_username - manager\ngiven_name - manager\nfamily_name - name\nrole - WMSServiceCalendar:VehicleTypeDelete\nrole - WMSServiceCalendar:VehicleDelete\nrole - WMSServiceCalendar:VehicleExport\nrole - WMSServiceCalendar:VehicleTypeView\nrole - WMSServiceCalendar:VehicleView\nrole - WMSServiceCalendar:Users\n\u0060\u0060\u0060\n\nI have amended UserInfo as follows:\n\n\u0060\u0060\u0060csharp\npublic sealed class UserInfo\n{\n    public required string UserId { get; init; }\n    public required string Name { get; init; }\n    public required string[] Roles { get; init; }\n\n    public const string UserIdClaimType = \u0022sub\u0022;\n    public const string NameClaimType = \u0022name\u0022;\n    public const string RoleClaimType = \u0022role\u0022;\n\n    public static UserInfo FromClaimsPrincipal(ClaimsPrincipal principal) =\u003E\n        new()\n        {\n            UserId = GetRequiredClaim(principal, UserIdClaimType),\n            Name = GetRequiredClaim(principal, NameClaimType),\n            Roles = principal.FindAll(RoleClaimType).Select(c =\u003E c.Value).ToArray(),\n        };\n\n    public ClaimsPrincipal ToClaimsPrincipal() =\u003E\n        new(new ClaimsIdentity(\n            Roles.Select(role =\u003E new Claim(RoleClaimType, role))\n                .Concat([\n                    new Claim(UserIdClaimType, UserId),\n                    new Claim(NameClaimType, Name),\n                ]),\n            authenticationType: nameof(UserInfo),\n            nameType: NameClaimType,\n            roleType: RoleClaimType));\n\n    private static string GetRequiredClaim(ClaimsPrincipal principal, string claimType) =\u003E\n        principal.FindFirst(claimType)?.Value ?? throw new InvalidOperationException($\u0022Could not find required \u0027{claimType}\u0027 claim.\u0022);\n}\n\u0060\u0060\u0060\n\nIn my client I then have the following in my page:\n\n\u0060@attribute [Authorize(Roles = \u0022WMSServiceCalendar:Users\u0022)]\u0060\n\nAs a result of the issue I see the following error:\n\n\u0060info: Microsoft.AspNetCore.Authorization.DefaultAuthorizationService[2]\n      Authorization failed. These requirements were not met:\n      RolesAuthorizationRequirement:User.IsInRole must be true for one of the following roles: (WMSServiceCalendar:Users)\u0060\n\nNote: If I add the claims to the id token in keycloak then all works but that feels like it defeats the point of using GetClaimsFromUserInfoEndpoint?\n\n### Expected Behavior\n\nUsing GetClaimsFromUserInfoEndpoint = true should flow the claims from server to client side and allow the roles to be used during authorization\n\n### Steps To Reproduce\n\nI am using the above setup with no further modifications to the sample application.\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n8.0.403\n\n### Anything else?\n\nID Token:\n\u0060\u0060\u0060\n{\n  \u0022exp\u0022: 1730967440,\n  \u0022iat\u0022: 1730967140,\n  \u0022jti\u0022: \u0022aab08d01-1d37-4d87-9c73-7f9f95aa103c\u0022,\n  \u0022iss\u0022: \u0022https://host.docker.internal/keycloak/realms/Autostore\u0022,\n  \u0022aud\u0022: \u0022WMSServiceCalendar\u0022,\n  \u0022sub\u0022: \u0022c5f3046c-b1b7-497d-b12e-a3f29afc5d11\u0022,\n  \u0022typ\u0022: \u0022ID\u0022,\n  \u0022azp\u0022: \u0022WMSServiceCalendar\u0022,\n  \u0022sid\u0022: \u00220bf27112-0271-4ce1-9d97-9e1d18cc9214\u0022,\n  \u0022acr\u0022: \u00221\u0022,\n  \u0022email_verified\u0022: true,\n  \u0022name\u0022: \u0022manager name\u0022,\n  \u0022preferred_username\u0022: \u0022manager\u0022,\n  \u0022given_name\u0022: \u0022manager\u0022,\n  \u0022family_name\u0022: \u0022name\u0022\n}\n\u0060\u0060\u0060\n\nUser Info:\n\u0060\u0060\u0060\n{\n  \u0022sub\u0022: \u0022c5f3046c-b1b7-497d-b12e-a3f29afc5d11\u0022,\n  \u0022email_verified\u0022: true,\n  \u0022role\u0022: [\n    \u0022WMSServiceCalendar:VehicleTypeDelete\u0022,\n    \u0022WMSServiceCalendar:VehicleDelete\u0022,\n    \u0022WMSServiceCalendar:VehicleExport\u0022,\n    \u0022WMSServiceCalendar:VehicleTypeView\u0022,\n    \u0022WMSServiceCalendar:VehicleView\u0022,\n    \u0022WMSServiceCalendar:Users\u0022\n  ],\n  \u0022name\u0022: \u0022manager name\u0022,\n  \u0022preferred_username\u0022: \u0022manager\u0022,\n  \u0022given_name\u0022: \u0022manager\u0022,\n  \u0022family_name\u0022: \u0022name\u0022\n}\n\u0060\u0060\u0060",
    "upvotes": 0,
    "labels": [
      "Docs",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86TBFEc",
        "parentId": null,
        "author": "halter73",
        "content": "Does it work if you map the \u0022role\u0022 json key to the \u0022role\u0022 claim type using [MapJsonKey](https://learn.microsoft.com/dotnet/api/microsoft.aspnetcore.authentication.claimactioncollectionmapextensions.mapjsonkey?view=aspnetcore-8.0)?\n\n\u0060\u0060\u0060csharp\nbuilder.Services.AddAuthentication(MS_OIDC_SCHEME)\n    .AddOpenIdConnect(MS_OIDC_SCHEME, oidcOptions =\u003E\n    {\n        // ...\n        oidcOptions.GetClaimsFromUserInfoEndpoint = true;\n        oidcOptions.ClaimActions.MapJsonKey(\u0022role\u0022, \u0022role\u0022);\n        // ...\n\u0060\u0060\u0060\n\n\u003E Another way to get the user claims is to use the OpenID Connect User Info API. The ASP.NET Core client app uses the \u0060GetClaimsFromUserInfoEndpoint\u0060 property to configure this. One important difference from the first settings, is that you must specify the claims you require using the \u0060MapUniqueJsonKey\u0060 method, otherwise only the \u0060name\u0060, \u0060given_name\u0060 and \u0060email\u0060 standard claims will be available in the client app. The claims included in the \u0060id_token\u0060 are mapped per default. This is the major difference to the first option. You must explicitly define some of the claims you require.\n\nhttps://learn.microsoft.com/aspnet/core/security/authentication/claims?view=aspnetcore-8.0#mapping-claims-using-openid-connect-authentication\n\nThe difference from the docs is that a \u0022role\u0022 is not unique, so we want to use \u0060MapJsonKey\u0060 rather than \u0060MapUniqueJsonKey\u0060.",
        "createdAt": "2024-11-10T01:11:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/58826#issuecomment-2466533660"
      },
      {
        "id": "IC_kwDOAQzde86TEr7_",
        "parentId": null,
        "author": "BenJags",
        "content": "No, I have added the MapJsonKey call and the role claims show in my logging but they are still not available on the claimsprincipal client side or at the minimal api server side to able to use them for authorization. The only claims that are in the principal identity are the ones from the ID token.",
        "createdAt": "2024-11-11T08:05:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/58826#issuecomment-2467479295"
      },
      {
        "id": "IC_kwDOAQzde86TL8ea",
        "parentId": null,
        "author": "halter73",
        "content": "It\u0027s really surprising to me that the claims you see in a minimal API are different than what you\u0027re logging in \u0060CookieAuthenticationOptions.Events.OnSigningIn\u0060. That event is called almost immediately before setting the cookie. Maybe you could check again in \u0060OnSignedIn\u0060 to verify nothing else is messing with the \u0060ClaimsPrincipal\u0060.\n\nWhat do you see if you add the following minimal API endpoint?\n\n\u0060\u0060\u0060csharp\napp.MapGet(\u0022/claims\u0022, (ClaimsPrincipal user) =\u003E user.Claims.Select(c =\u003E new { c.Type, c.Value }));\n\u0060\u0060\u0060\n\nSince the minimal API is relying purely on the cookie authentication handler and not the Blazor \u0060AuthenticationStateProvider\u0060, it should match exactly what you see in the \u0060OnSigningIn\u0060 and \u0060OnSignedIn\u0060 callbacks. If it\u0027s not exactly the same, what\u0027s different? Just the roles? Is \u0060ClaimsIdentity.RoleClaimType\u0060 \u0022role\u0022 as expected in both the callbacks and the minimal endpoint?\n\nThe \u0060ClaimsIdentity\u0060 should be [created](https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/40ab6a944118b215e8c5780334df8bb103feb48e/src/Microsoft.IdentityModel.Tokens/TokenValidationParameters.cs#L245) with the \u0060RoleClaimType\u0060 you specify in \u0060ValidationParameters\u0060 and the default cookie serializer should [serialize](https://github.com/dotnet/aspnetcore/blob/036ec9ec2ffbfe927f9eb7622dfff122c634ccbb/src/Security/Authentication/Core/src/TicketSerializer.cs#L86-L87) and deserialize it.\n\nIf you cannot figure out what\u0027s going on based on inspecting the \u0060ClaimsPrincipal\u0060 in the events and a minimal API, we will need a repro project hosted on GitHub to take a look at. I know that you\u0027re trying to make only minor changes to the BlazorWebAppOidc sample, but I\u0027m not seeing the issue you are when I try it myself, and I cannot easily guess what the differences may be. Don\u0027t worry about the OIDC server bits. I can fake a userinfo response to match what you\u0027re seeing.",
        "createdAt": "2024-11-12T01:07:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/58826#issuecomment-2469382042"
      },
      {
        "id": "IC_kwDOAQzde86TOD9v",
        "parentId": null,
        "author": "BenJags",
        "content": "I\u0027ve added the \u0060/claims\u0060 endpoint which outputs the following:\n\n\u0060\u0060\u0060\n[\n  {\n    \u0022type\u0022: \u0022exp\u0022,\n    \u0022value\u0022: \u00221731400359\u0022\n  },\n  {\n    \u0022type\u0022: \u0022iat\u0022,\n    \u0022value\u0022: \u00221731400059\u0022\n  },\n  {\n    \u0022type\u0022: \u0022auth_time\u0022,\n    \u0022value\u0022: \u00221731400051\u0022\n  },\n  {\n    \u0022type\u0022: \u0022jti\u0022,\n    \u0022value\u0022: \u00226a14407a-a1b1-416b-b9d7-cc4d784d7305\u0022\n  },\n  {\n    \u0022type\u0022: \u0022iss\u0022,\n    \u0022value\u0022: \u0022https://host.docker.internal/keycloak/realms/Autostore\u0022\n  },\n  {\n    \u0022type\u0022: \u0022aud\u0022,\n    \u0022value\u0022: \u0022WMSServiceCalendar\u0022\n  },\n  {\n    \u0022type\u0022: \u0022sub\u0022,\n    \u0022value\u0022: \u0022c5f3046c-b1b7-497d-b12e-a3f29afc5d11\u0022\n  },\n  {\n    \u0022type\u0022: \u0022typ\u0022,\n    \u0022value\u0022: \u0022ID\u0022\n  },\n  {\n    \u0022type\u0022: \u0022azp\u0022,\n    \u0022value\u0022: \u0022WMSServiceCalendar\u0022\n  },\n  {\n    \u0022type\u0022: \u0022sid\u0022,\n    \u0022value\u0022: \u0022bbc98c8b-a536-4255-a3d2-595750e90d8e\u0022\n  },\n  {\n    \u0022type\u0022: \u0022at_hash\u0022,\n    \u0022value\u0022: \u00225rH5HNNhgTmaE_Sg2pdaQw\u0022\n  },\n  {\n    \u0022type\u0022: \u0022acr\u0022,\n    \u0022value\u0022: \u00221\u0022\n  },\n  {\n    \u0022type\u0022: \u0022email_verified\u0022,\n    \u0022value\u0022: \u0022true\u0022\n  },\n  {\n    \u0022type\u0022: \u0022name\u0022,\n    \u0022value\u0022: \u0022manager name\u0022\n  },\n  {\n    \u0022type\u0022: \u0022preferred_username\u0022,\n    \u0022value\u0022: \u0022manager\u0022\n  },\n  {\n    \u0022type\u0022: \u0022given_name\u0022,\n    \u0022value\u0022: \u0022manager\u0022\n  },\n  {\n    \u0022type\u0022: \u0022family_name\u0022,\n    \u0022value\u0022: \u0022name\u0022\n  }\n]\n\u0060\u0060\u0060\n\nThe output of my logging in the \u0060OnSigningIn\u0060 callback is:\n\n\u0060\u0060\u0060\nClaims received by the Cookie handler\nauth_time - 1731400580\njti - ef2430e9-bd4a-401f-a88f-8794f59d306e\nsub - c5f3046c-b1b7-497d-b12e-a3f29afc5d11\ntyp - ID\nsid - 3ad70098-979f-4c42-8958-b66cf2592fd2\nemail_verified - true\nname - manager name\npreferred_username - manager\ngiven_name - manager\nfamily_name - name\nrole - WMSServiceCalendar:VehicleTypeDelete\nrole - WMSServiceCalendar:VehicleDelete\nrole - WMSServiceCalendar:VehicleExport\nrole - WMSServiceCalendar:VehicleTypeView\nrole - WMSServiceCalendar:VehicleView\nrole - WMSServiceCalendar:Users\n\u0060\u0060\u0060\n\nAnd adding logging to the \u0060/weather-forecast\u0060 endpoint results in:\n\n\u0060\u0060\u0060\nClaims received by the weather minimal api\nexp - 1731400887\niat - 1731400587\nauth_time - 1731400580\njti - 91fea84a-7258-41e4-ad21-a3b15bb74c38\niss - https://host.docker.internal/keycloak/realms/Autostore\naud - WMSServiceCalendar\nsub - c5f3046c-b1b7-497d-b12e-a3f29afc5d11\ntyp - ID\nazp - WMSServiceCalendar\nsid - 3ad70098-979f-4c42-8958-b66cf2592fd2\nat_hash - ZMCKk1NT_u0h_QH_hSNkzQ\nacr - 1\nemail_verified - true\nname - manager name\npreferred_username - manager\ngiven_name - manager\nfamily_name - name\n\u0060\u0060\u0060\n\nSo, I am only missing the role claims. The \u0060ClaimsIdentity.RoleClaimType\u0060 is set to \u0060role\u0060 in both the callback and the minimal api identities.\n\nI am at a loss the same as you. So I have uploaded the repo to the following location:\n\nhttps://github.com/BenJags/BlazorWebAppOidc\n\nLet me know if you need more details about the keycloak responses to be able to fake them.",
        "createdAt": "2024-11-12T08:52:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/58826#issuecomment-2469937007"
      },
      {
        "id": "IC_kwDOAQzde86UlCpe",
        "parentId": null,
        "author": "halter73",
        "content": "Thanks for the repro. I tried it out myself with Keycloak, and I discovered that the issue is that the \u0060CookieOidcRefresher\u0060 (which is [part of the BlazorWebAppOidc sample](https://github.com/dotnet/blazor-samples/blob/ba593024d1bcdf1bb775fef081def5153efb74f0/8.0/BlazorWebAppOidc/BlazorWebAppOidc/CookieOidcRefresher.cs)) refreshes the cookie using claims from just the ID token and not the \u0060/userinfo\u0060 endpoint.\n\nThis \u0022refresher\u0022 is only supposed to have an effect as the access token nears expiration, so that the cookie always contains an unexpired access token, but it winds up reissuing a cookie just about every request is because Keycloak\u0027s default access token timeout is 5 minutes, and the \u0060CookieOidcRefresher\u0060 tries to refresh the cookie whenever the access token is within 5 minutes of expiration.\n\nIf you don\u0027t need the access token (see [here](https://github.com/dotnet/blazor-samples/blob/ba593024d1bcdf1bb775fef081def5153efb74f0/9.0/BlazorWebAppOidcBff/BlazorWebAppOidc/Program.cs#L199-L200) for how it can be used to make requests to another server using \u0060AddJwtBearer\u0060 as explained in the [BFF variant of the Blazor Web OIDC documentation](https://learn.microsoft.com/en-us/aspnet/core/blazor/security/blazor-web-app-with-oidc?view=aspnetcore-9.0\u0026pivots=with-bff-pattern#sample-app-code-1)), you can remove the call to \u0060ConfigureCookieOidcRefresh\u0060 from \u0060Program.cs\u0060, and delete the \u0060CookieOidcRefresher.cs\u0060 and \u0060CookieOidcServiceCollectionExtensions.cs\u0060 files from your project.\n\nOtherwise, if you decide to keep the cookie/token refreshing logic, I think the first step is to reduce [this 5 minute interval in \u0060CookieOidcRefresher\u0060](https://github.com/dotnet/blazor-samples/blob/ba593024d1bcdf1bb775fef081def5153efb74f0/8.0/BlazorWebAppOidc/BlazorWebAppOidc/CookieOidcRefresher.cs#L34), to something smaller like 1 minute. As long as it doesn\u0027t take longer than that to process a request and there isn\u0027t too much clock drift, it should still be fine to use the access token with a smaller interval. Another option is to adjust Keycloak\u0027s \u0022Access Token Lifespan\u201D configuration under the \u0022Realm settings\u0022 to something larger like 15 minutes. Or you could adjust both.\n\n![Keycloak\u0027s \u0022Access Token Lifespan\u201D configuration](https://github.com/user-attachments/assets/f5c128b2-73f3-44c1-a4b0-5c81f6410a26)\n\nOf course, even after we fix the refreshing logic to not run every request, we\u0027d still want to get claims from the \u0060/userinfo\u0060 endpoint while refreshing the cookie. You can do so by applying the following patch to your \u0060CookieOidcRefresher.cs\u0060 file. I mostly copied the logic from [\u0060OpenIdConnectHandler.GetUserInformationAsync\u0060](https://github.com/dotnet/aspnetcore/blob/8d0f798cc4de54a2851748be635a58eadbf79593/src/Security/Authentication/OpenIdConnect/src/OpenIdConnectHandler.cs#L1040-L1107), but left out bits like calling the \u0060OnUserInformationReceived\u0060 event. Feel free to add that back if it\u0027s important.\n\n\u0060\u0060\u0060diff\ndiff --git a/BlazorWebAppOidc/CookieOidcRefresher.cs b/BlazorWebAppOidc/CookieOidcRefresher.cs\nindex c832924..af33cd7 100644\n--- a/BlazorWebAppOidc/CookieOidcRefresher.cs\n\u002B\u002B\u002B b/BlazorWebAppOidc/CookieOidcRefresher.cs\n@@ -1,6 \u002B1,8 @@\n using System.Globalization;\n using System.IdentityModel.Tokens.Jwt;\n\u002Busing System.Net.Http.Headers;\n using System.Security.Claims;\n\u002Busing System.Text.Json;\n using Microsoft.AspNetCore.Authentication;\n using Microsoft.AspNetCore.Authentication.Cookies;\n using Microsoft.AspNetCore.Authentication.OpenIdConnect;\n@@ -86,6 \u002B88,12 @@ internal sealed class CookieOidcRefresher(IOptionsMonitor\u003COpenIdConnectOptions\u003E\n             ValidatedIdToken = validatedIdToken,\n         });\n \n\u002B        if (oidcOptions.GetClaimsFromUserInfoEndpoint \u0026\u0026 !string.IsNullOrEmpty(oidcConfiguration.UserInfoEndpoint))\n\u002B        {\n\u002B            await AddClaimsFromUserInfoEndpointAsync(oidcConfiguration.UserInfoEndpoint, message.AccessToken, oidcScheme,\n\u002B                validatedIdToken, validationResult.ClaimsIdentity, oidcOptions, validateContext.HttpContext.RequestAborted);\n\u002B        }\n\u002B\n         validateContext.ShouldRenew = true;\n         validateContext.ReplacePrincipal(new ClaimsPrincipal(validationResult.ClaimsIdentity));\n \n@@ -99,4 \u002B107,43 @@ internal sealed class CookieOidcRefresher(IOptionsMonitor\u003COpenIdConnectOptions\u003E\n             new() { Name = \u0022expires_at\u0022, Value = expiresAt.ToString(\u0022o\u0022, CultureInfo.InvariantCulture) },\n         ]);\n     }\n\u002B\n\u002B    private static async Task AddClaimsFromUserInfoEndpointAsync(string userInfoEndpoint, string accessToken, string oidcScheme,\n\u002B        JwtSecurityToken validatedIdToken, ClaimsIdentity identity, OpenIdConnectOptions options, CancellationToken cancellationToken)\n\u002B    {\n\u002B        var requestMessage = new HttpRequestMessage(HttpMethod.Get, userInfoEndpoint);\n\u002B        requestMessage.Headers.Authorization = new AuthenticationHeaderValue(\u0022Bearer\u0022, accessToken);\n\u002B        requestMessage.Version = options.Backchannel.DefaultRequestVersion;\n\u002B        var responseMessage = await options.Backchannel.SendAsync(requestMessage, cancellationToken);\n\u002B        responseMessage.EnsureSuccessStatusCode();\n\u002B        var userInfoResponse = await responseMessage.Content.ReadAsStringAsync(cancellationToken);\n\u002B\n\u002B        string userInfoJson;\n\u002B        var contentType = responseMessage.Content.Headers.ContentType;\n\u002B        if (contentType?.MediaType?.Equals(\u0022application/json\u0022, StringComparison.OrdinalIgnoreCase) ?? false)\n\u002B        {\n\u002B            userInfoJson = userInfoResponse;\n\u002B        }\n\u002B        else if (contentType?.MediaType?.Equals(\u0022application/jwt\u0022, StringComparison.OrdinalIgnoreCase) ?? false)\n\u002B        {\n\u002B            var userInfoEndpointJwt = new JwtSecurityToken(userInfoResponse);\n\u002B            userInfoJson = userInfoEndpointJwt.Payload.SerializeToJson();\n\u002B        }\n\u002B        else\n\u002B        {\n\u002B            return;\n\u002B        }\n\u002B\n\u002B        using var user = JsonDocument.Parse(userInfoJson);\n\u002B        options.ProtocolValidator.ValidateUserInfoResponse(new OpenIdConnectProtocolValidationContext()\n\u002B        {\n\u002B            UserInfoEndpointResponse = userInfoResponse,\n\u002B            ValidatedIdToken = validatedIdToken,\n\u002B        });\n\u002B\n\u002B        foreach (var action in options.ClaimActions)\n\u002B        {\n\u002B            action.Run(user.RootElement, identity, options.ClaimsIssuer ?? oidcScheme);\n\u002B        }\n\u002B    }\n }\n\u0060\u0060\u0060",
        "createdAt": "2024-11-22T02:18:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/58826#issuecomment-2492738142"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86h3mnJ",
    "title": "ASP.NET Core Identity and Auth documentation improvements",
    "url": "https://github.com/dotnet/aspnetcore/issues/59290",
    "createdAt": "2024-12-03T18:17:13Z",
    "lastUpdated": "2025-01-22T10:18:39Z",
    "body": "We plan to spend some time as a team to drive improvements in this area during .NET 10 timeframe.",
    "upvotes": 3,
    "labels": [
      "Docs",
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86bVA7P",
        "parentId": null,
        "author": "mikeholczer",
        "content": "This would be great! I was recently trying to get authentication and authorization setup and working in a Blazor standalone webassembly app. I was founding various docs that were inconsistent with each other. I\u0027ll see if I can find the various doc links I found and post them here, but please include cleaning up existing docs in the effort, not just adding new docs on top of what\u0027s there. ",
        "createdAt": "2025-01-21T23:53:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59290#issuecomment-2605977295"
      },
      {
        "id": "IC_kwDOAQzde86bXkpS",
        "parentId": null,
        "author": "ahelland",
        "content": "If you are a .NET developer looking for docs on identity and auth you invariably end up in different places:\n- The .NET documentation\n- The Entra ID documentation\n- Specific library documentation (like Identity.Web and MSAL)\n\nSome pieces clearly belong in one place or the other, but then there\u0027s some overlap. For instance Entra needs to offer code samples in multiple languages meaning that they offer .NET samples in parallell with what the .NET docs have in the same area. Concepts that are strongly tied to Entra features might be explained better than what can be expected by a .NET generalist, but you can also run across samples still using \u0060startup.cs \u0060which is confusing for a dev who\u0027ve only been around for \u0060program.cs\u0060. The .NET docs in turn might approach the syntactical part differently.\n\n(And you can also come across things like samples for identity related functionality leveraging Azure Functions where the in-proc model is used instead of isolated worker. But I guess that might be slightly out of scope in this discussion.)\n\nThis confusion extends further when you dive into the complete samples which are usually hosted in GitHub - should I look under \u0060github.com/azure/xyz \u0060or \u0060github.com/dotnet/xyz\u0060?\n\nI guess this in part echoes what @mikeholczer said.\n\n**Best Practices**\nSample code illustrating specific things should be clearly marked with \u0022this is not production grade\u0022 when that is the case. (When I create samples I also skip non-essential things so it\u0027s not a concern in itself that some code is dev grade.) But what if I want to have production grade? If I want .NET code that uses a clientId and a clientSecret I can find a sample in no time. What if I want to use a certificate instead? Those samples are much harder to find.\n\nOr let\u0027s say I\u0027m real nerdy about identity and come across something like the RFC draft \u0022OAuth 2.0 for Browser-Based Applications\u0022. How do I translate that into .NET code? There is an official .NET 9 BFF sample (which is good by the way) - can I assume the finer details was also considered in making that or is that something I am expected to figure out on my own? (I understand that most of the development will always be the dev\u0027s responsibility and MSFT cannot provide exact samples for every conceivable use case, but where secure defaults can be supplied they should.)\n\n**\u0022Missing pieces\u0022**\nHave you tried typing builder.Services.AddAuthentication(). and see the number of options IntelliSense provides? Should I use builder.Services.AddAuthentication().AddMicrosoftIdentityWebApp, or builder.Services.AddAuthentication().AddOpenIdConnect - what\u0027s the difference? And how does this relate to .AddCookie, .AddBearerToken and .AddJwtBearer? It\u0027s a rabbit hole of testing, debugging, searching the web for info and pulling your hair :)\n\n**\u0022The bigger picture\u0022**\nWhen living in dotnet-land (great place, btw) you can do fancy things like passing the auth state from Blazor server to Blazor WASM and everyone\u0027s happy. But at some point in time some frontend dev will say they want to do React and Next.js and the story falls apart. Also something that quickly extends past what the .NET team can solve, but how do I make the .NET backend bits right here? Should I just expose API endpoints, validate incoming JWTs and be happy? Or can I easily implement the B in BFF in .NET and have a \u0022plug-in here\u0022 integration point to mediate tokens/sessions/what-have-you?\n\nI can see how this comes across more ranty than concrete implementation tips, but currently I\u0027m just trying to get the discussion going :)",
        "createdAt": "2025-01-22T09:00:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59290#issuecomment-2606647890"
      },
      {
        "id": "IC_kwDOAQzde86bXpgZ",
        "parentId": null,
        "author": "davidfowl",
        "content": "There\u0027s lots of work to do here and the space is complex, but from my POV we need to \u0022teach people how to fish\u0022. That is, teach you general auth concepts and relate them to various ASP.NET APIs. Once that part is done then you have a solid foundation in understanding how to begin to ask the right set of questions that will help you validate choices for your auth architecture. This is no different from any other part of your application and we can provide the building blocks for your understanding and some samples, but it is your job to design the auth system (putting all of the building blocks together) to accomplish your scenarios.\n\nThat said, we will definitely provide samples for the *MOST* popular patterns, explicitly calling out which ones \u0022need more work\u0022 to be production ready and what that would entail.\n\nPS: I want to acknowledge that the auth system is complex, even when you understand the general auth concepts, but we don\u0027t do a great job today mapping those 2 things together.",
        "createdAt": "2025-01-22T09:09:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59290#issuecomment-2606667801"
      },
      {
        "id": "IC_kwDOAQzde86bYGAG",
        "parentId": null,
        "author": "ahelland",
        "content": "Auth is hard and it\u0027s definitely not an area where I would give a junior dev access to the \u0022push directly to prod\u0022 button. It\u0027s a full-time job keeping track of it all. Which applies to other areas of .NET as well. Who hasn\u0027t been burned by a migration gone wrong when getting started with Entity Framework? ;)\n\nThe job of understanding when to acquire a token and when to validate said token is best left to the developer/architect, and it\u0027s not necessarily the  .NET team that should be explaining all the intricacies of different OAuth flows either. I do think however that Microsoft are better suited to provide correct implementations of the flows than a non-specialist dev. (If this is best handled by the .NET team or Entra teams internally isn\u0027t top of mind for most people on the outside.) Even good tools might require a user manual though.\n\nI agree the approach should be teaching people to fish - the hard part is figuring out what is needed in addition to giving them driving directions to the nearest lake :) (And to be clear; there is also a distinction between what is suited for official docs and what works better as informal blog posts by the team and various community members.)",
        "createdAt": "2025-01-22T09:58:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59290#issuecomment-2606784518"
      },
      {
        "id": "IC_kwDOAQzde86bYIz8",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E The job of understanding when to acquire a token and when to validate said token is best left to the developer/architect, and it\u0027s not necessarily the .NET team that should be explaining all the intricacies of different OAuth flows either. I do think however that Microsoft are better suited to provide correct implementations of the flows than a non-specialist dev. (If this is best handled by the .NET team or Entra teams internally isn\u0027t top of mind for most people on the outside.) Even good tools might require a user manual though.\n\nI\u0027ll be frank and I don\u0027t think the .NET team is going to solve this problem. People build entire careers and companies around this specific domain. \n\nThere is no free lunch here. We\u0027re not going to turn you into an auth expert, if you want that guarantee then pay for a hosted service, otherwise, there will be lots of gap filling to do.",
        "createdAt": "2025-01-22T10:03:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59290#issuecomment-2606796028"
      },
      {
        "id": "IC_kwDOAQzde86bYRwW",
        "parentId": null,
        "author": "ahelland",
        "content": "No, no, to be clear - I don\u0027t expect the .NET team to turn me (or anyone else) into an identity expert or a database ninja or an SME in other coding related fields for that matter. That requires effort and time from the individual.\n\nWhat I\u0027m trying to highlight is that even if you know both C# and OAuth it can be daunting to go from \u0060builder.Services.AddAuthentication().\u0060 to a working web app if you\u0027re not able to find the docs and samples to nudge you along the way. (I\u0027m not hung up on that particular line of code - that\u0027s just to exemplify.)\n",
        "createdAt": "2025-01-22T10:18:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59290#issuecomment-2606832662"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86jH3Gn",
    "title": "OIDC - Validation failure during PAR does not trigger OnAuthenticationFailed() event",
    "url": "https://github.com/dotnet/aspnetcore/issues/59462",
    "createdAt": "2024-12-12T19:46:26Z",
    "lastUpdated": "2024-12-16T17:32:49Z",
    "body": "### Is there an existing issue for this?\n\n- [x] I have searched the existing issues\n\n### Describe the bug\n\n\u0060OpenIdConnectHandler.cs\u0060\n\nWhen a validation failure occurs during a PAR request (ex. the request includes an invalid client_id), an \u0060OpenIdConnectProtocolException\u0060 is thrown.  This exception bubbles up as an unhandled middleware exception.\n\nThis happens during \u0060HandleChallengeAsync()\u0060, but that method does not catch this (or any other) exception and call the \u0060OnAuthenticationFailed()\u0060 event.\n\n\n\n\n\n\n### Expected Behavior\n\nI would expect this type of error to trigger the \u0060OnAuthenticationFailed()\u0060 event so that it can be specifically handled.\n\nBefore PAR, the user is redirected to the IDP for login. That redirect request carried with it the client app\u0027s configuration (client_id, redirect_uri, etc). If that information was not valid, the IDP itself would handle presentation of the error to the end user.\n\nWith PAR, we are moving the validation response handling to the client application.\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n9.0.101\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-auth",
      "feature-oidc"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86XY32v",
        "parentId": null,
        "author": "bigred8982",
        "content": "Would love an opinion from @josephdecock if this is desired behavior.",
        "createdAt": "2024-12-12T19:49:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59462#issuecomment-2539879855"
      },
      {
        "id": "IC_kwDOAQzde86XZHVh",
        "parentId": null,
        "author": "halter73",
        "content": "I\u0027m also interested in @josephdecock\u0027s opinion here. My gut is that it should be handled similarly to what we\u0027d do if we got an invalid response from the token or userinfo endpoints. And since \u0060HandleRemoteAuthenticateAsync\u0060 calls into those endpoints in a big try/catch block that turns all exceptions into \u0060AuthenticationFailed\u0060 events, I think we should probably do something similar for PAR requests.\n\nThat said, looking a bit deeper at the \u0060AuthenticationFailed\u0060 event, I see that the \u0060AuthenticationFailedContext\u0060 is a \u0060HandleRequestContext\u0060 which doesn\u0027t make much sense for error that happen even before redirecting to the identity provider. At that point the \u0060OpenIdConnectHandler\u0060 hasn\u0027t handled any requests to \u0022handle\u0022 or \u0022skip\u0022 or whatever.\n\nWe could create a new event, but is that worth it if the only time that event would likely fire is when there\u0027s a misconfiguration or the provider is down? Is an event that much easier to deal with than throwing directly out of \u0060ChallengeAsync()\u0060? And even if we did have an event, wouldn\u0027t it be better to continue to throw out of \u0060ChallengeAsync()\u0060 if we can to ensure the error isn\u0027t missed?",
        "createdAt": "2024-12-12T20:21:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59462#issuecomment-2539943265"
      },
      {
        "id": "IC_kwDOAQzde86XZNX0",
        "parentId": null,
        "author": "bigred8982",
        "content": "For what it\u0027s worth, when using PAR, you are now communicating with the IDP prior to redirecting. You\u0027re basically initiating protocol behavior with the IDP at that point, not just gearing up to redirect. It _feels_ like \u0060AuthenticationFailed\u0060 events are appropriate here, even from \u0060ChallengeAsync()\u0060.\n",
        "createdAt": "2024-12-12T20:36:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59462#issuecomment-2539967988"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86k0YrJ",
    "title": "suggested feature:Prepared \u0060GenerateJwtToken\u0060 Method",
    "url": "https://github.com/dotnet/aspnetcore/issues/59680",
    "createdAt": "2025-01-01T18:15:02Z",
    "lastUpdated": "2025-01-06T17:42:19Z",
    "body": "### Is there an existing issue for this?\n\n- [x] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nCurrently, developers need to manually generate JWT tokens by creating a custom method that includes the necessary claims and signing credentials. This process can be repetitive and prone to errors if not done correctly.\n\n### Describe the solution you\u0027d like\n\nIntroduce a \u0060GenerateJwtTokenAsync\u0060 method in the \u0060SignInManager\u0060 class that automatically generates a JWT token with the necessary claims and signing credentials. The method should take parameters similar to \u0060SignInManager.SignInAsync\u0060, such as the user object and additional claims.\n\n**Example Code:**\n\n\u0060\u0060\u0060csharp\npublic class JwtService\n{\n    private readonly UserManager\u003CApplicationUser\u003E _userManager;\n    private readonly IConfiguration _configuration;\n\n    public JwtService(UserManager\u003CApplicationUser\u003E userManager, IConfiguration configuration)\n    {\n        _userManager = userManager;\n        _configuration = configuration;\n    }\n\n    public async Task\u003Cstring\u003E GenerateJwtTokenAsync(ApplicationUser user, IList\u003CClaim\u003E additionalClaims = null)\n    {\n        var userClaims = await _userManager.GetClaimsAsync(user);\n        var claims = new List\u003CClaim\u003E\n        {\n            new Claim(JwtRegisteredClaimNames.Sub, user.UserName),\n            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),\n            new Claim(ClaimTypes.NameIdentifier, user.Id)\n        };\n        claims.AddRange(userClaims);\n        if (additionalClaims != null)\n        {\n            claims.AddRange(additionalClaims);\n        }\n\n        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration[\u0022Jwt:Key\u0022]));\n        var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);\n\n        var token = new JwtSecurityToken(\n            issuer: _configuration[\u0022Jwt:Issuer\u0022],\n            audience: _configuration[\u0022Jwt:Audience\u0022],\n            claims: claims,\n            expires: DateTime.Now.AddMinutes(30),\n            signingCredentials: creds);\n\n        return new JwtSecurityTokenHandler().WriteToken(token);\n    }\n}\n\u0060\u0060\u0060\n\n### Additional context\n\n*Benefits:**\n\n- Simplifies the process of generating JWT tokens by providing a built-in method.\n- Ensures consistency and security in JWT token generation across applications.\n- Reduces the likelihood of misconfiguration and potential security vulnerabilities.\n- Provides a similar level of convenience as the \u0060SignInManager.SignInAsync\u0060 method for cookie-based authentication.\n\n**Additional Context:**\n\nThis feature request is inspired by the convenience and security provided by the \u0060SignInManager.SignInAsync\u0060 method for cookie-based authentication. Having a similar method for JWT authentication would provide a consistent and secure experience for developers.\n",
    "upvotes": 2,
    "labels": [
      "area-auth"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86ZDcHw",
        "parentId": null,
        "author": "davidfowl",
        "content": "See https://learn.microsoft.com/en-us/aspnet/core/security/authentication/identity-api-authorization?view=aspnetcore-9.0#use-token-based-authentication",
        "createdAt": "2025-01-02T13:57:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59680#issuecomment-2567815664"
      },
      {
        "id": "IC_kwDOAQzde86ZEVnT",
        "parentId": null,
        "author": "ahmeteid7",
        "content": "\u003E See https://learn.microsoft.com/en-us/aspnet/core/security/authentication/identity-api-authorization?view=aspnetcore-9.0#use-token-based-authentication\n\ni read it,ok let\u0027s focous only on createing prepared generatjwttoken , instead of let users make it full manually, i think it\u0027s better to provide it prepared and provide options for it as params or optiotion to enable user to control it without error",
        "createdAt": "2025-01-02T16:35:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59680#issuecomment-2568051155"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86lxqnG",
    "title": "[API Proposal]: AuthN/AuthZ metrics",
    "url": "https://github.com/dotnet/aspnetcore/issues/59818",
    "createdAt": "2025-01-10T21:55:53Z",
    "lastUpdated": "2025-01-24T17:35:23Z",
    "body": "## Background and Motivation\n\nThis is a collection of metrics for ASP.NET Core Authentication and Authorization.\n\nImplemented in https://github.com/dotnet/aspnetcore/pull/59557.\n\n## Proposed API\n\n### Microsoft.AspNetCore.Authentication\n\n\u0060aspnetcore.authentication.request.duration\u0060\n\n| Name                                         | Instrument Type | Unit        | Description                                                          |\n| -------------------------------------------- | --------------- | ----------- | -------------------------------------------------------------------- |\n| \u0060aspnetcore.authentication.request.duration\u0060 | Histogram       | \u0060{request}\u0060 | The authentication duration for a request. |\n\n| Attribute                          | Type   | Description                            | Examples                                                  | Presence                                                          |\n| ---------------------------------- | ------ | -------------------------------------- | --------------------------------------------------------- | ----------------------------------------------------------------- |\n| \u0060aspnetcore.authentication.scheme\u0060 | string | The name of the authentication scheme. | \u0060Bearer\u0060; \u0060Cookies\u0060                                       | \u0060Conditionally Required\u0060 if the request did not end with an error |\n| \u0060aspnetcore.authentication.result\u0060 | string | The authentication result.             | \u0060success\u0060; \u0060failure\u0060; \u0060none\u0060; \u0060_OTHER\u0060                    | \u0060Conditionally Required\u0060 if the request did not end with an error |\n| \u0060error.type\u0060                       | string | The full name of the exception type.   | \u0060System.InvalidOperationException\u0060; \u0060Contoso.MyException\u0060 | \u0060Conditionally Required\u0060 if the request has ended with an error   |\n\n\u0060aspnetcore.authentication.challenges\u0060\n\n| Name                                   | Instrument Type | Unit        | Description                                       |\n| -------------------------------------- | --------------- | ----------- | ------------------------------------------------- |\n| \u0060aspnetcore.authentication.challenges\u0060 | Counter         | \u0060{request}\u0060 | The total number of times a scheme is challenged. |\n\n| Attribute                          | Type   | Description                            | Examples                                                  | Presence                                                          |\n| ---------------------------------- | ------ | -------------------------------------- | --------------------------------------------------------- | ----------------------------------------------------------------- |\n| \u0060aspnetcore.authentication.scheme\u0060 | string | The name of the authentication scheme. | \u0060Bearer\u0060; \u0060Cookies\u0060                                       | \u0060Conditionally Required\u0060 if the request did not end with an error |\n| \u0060error.type\u0060                       | string | The full name of the exception type.   | \u0060System.InvalidOperationException\u0060; \u0060Contoso.MyException\u0060 | \u0060Conditionally Required\u0060 if the request has ended with an error   |\n\n\u0060aspnetcore.authentication.forbids\u0060\n\n| Name                                | Instrument Type | Unit        | Description                                                                                                      |\n| ----------------------------------- | --------------- | ----------- | ---------------------------------------------------------------------------------------------------------------- |\n| \u0060aspnetcore.authentication.forbids\u0060 | Counter         | \u0060{request}\u0060 | The total number of times an authenticated user attempts to access a resources they are not permitted to access. |\n\n| Attribute                          | Type   | Description                            | Examples                                                  | Presence                                                          |\n| ---------------------------------- | ------ | -------------------------------------- | --------------------------------------------------------- | ----------------------------------------------------------------- |\n| \u0060aspnetcore.authentication.scheme\u0060 | string | The name of the authentication scheme. | \u0060Bearer\u0060; \u0060Cookies\u0060                                       | \u0060Conditionally Required\u0060 if the request did not end with an error |\n| \u0060error.type\u0060                       | string | The full name of the exception type.   | \u0060System.InvalidOperationException\u0060; \u0060Contoso.MyException\u0060 | \u0060Conditionally Required\u0060 if the request has ended with an error   |\n\n\u0060aspnetcore.authentication.sign_ins\u0060\n\n| Name                                 | Instrument Type | Unit        | Description                                         |\n| ------------------------------------ | --------------- | ----------- | --------------------------------------------------- |\n| \u0060aspnetcore.authentication.sign_ins\u0060 | Counter         | \u0060{request}\u0060 | The total number of times a principal is signed in. |\n\n| Attribute                          | Type   | Description                            | Examples                                                  | Presence                                                          |\n| ---------------------------------- | ------ | -------------------------------------- | --------------------------------------------------------- | ----------------------------------------------------------------- |\n| \u0060aspnetcore.authentication.scheme\u0060 | string | The name of the authentication scheme. | \u0060Bearer\u0060; \u0060Cookies\u0060                                       | \u0060Conditionally Required\u0060 if the request did not end with an error |\n| \u0060error.type\u0060                       | string | The full name of the exception type.   | \u0060System.InvalidOperationException\u0060; \u0060Contoso.MyException\u0060 | \u0060Conditionally Required\u0060 if the request has ended with an error   |\n\n\u0060aspnetcore.authentication.sign_outs\u0060\n\n| Name                                 | Instrument Type | Unit        | Description                                       |\n| ------------------------------------ | --------------- | ----------- | ------------------------------------------------- |\n| \u0060aspnetcore.authentication.sign_ins\u0060 | Counter         | \u0060{request}\u0060 | The total number of times a scheme is signed out. |\n\n| Attribute                          | Type   | Description                            | Examples                                                  | Presence                                                          |\n| ---------------------------------- | ------ | -------------------------------------- | --------------------------------------------------------- | ----------------------------------------------------------------- |\n| \u0060aspnetcore.authentication.scheme\u0060 | string | The name of the authentication scheme. | \u0060Bearer\u0060; \u0060Cookies\u0060                                       | \u0060Conditionally Required\u0060 if the request did not end with an error |\n| \u0060error.type\u0060                       | string | The full name of the exception type.   | \u0060System.InvalidOperationException\u0060; \u0060Contoso.MyException\u0060 | \u0060Conditionally Required\u0060 if the request has ended with an error   |\n\n### Microsoft.AspNetCore.Authorization\n\n\u0060aspnetcore.authorization.requests\u0060\n\n| Name                                 | Instrument Type | Unit        | Description                                                         |\n| ------------------------------------ | --------------- | ----------- | ------------------------------------------------------------------- |\n| \u0060aspnetcore.authorization.requests\u0060 | Counter         | \u0060{request}\u0060 | The total number of requests for which authorization was attempted. |\n\n| Attribute                         | Type    | Description                                         | Examples                                                  | Presence                                                                    |\n| --------------------------------- | ------- | --------------------------------------------------- | --------------------------------------------------------- | --------------------------------------------------------------------------- |\n| \u0060user.is_authenticated\u0060           | boolean | Whether the request came from an authenticated user | \u0060true\u0060                                                    | \u0060Required\u0060                                                                  |\n| \u0060aspnetcore.authorization.policy\u0060 | string  | The name of the authorization policy.               | \u0060AtLeast21\u0060; \u0060EmployeeOnly\u0060                               | \u0060Conditionally required\u0060 if an authorization policy is used                                |\n| \u0060aspnetcore.authorization.result\u0060 | string  | Whether the authorization succeeded or failed.      | \u0060success\u0060; \u0060failure\u0060                                      | \u0060Conditionally Required\u0060 if an exception is not thrown during authorization |\n| \u0060error.type\u0060                      | string  | The full name of the exception type.                | \u0060System.InvalidOperationException\u0060; \u0060Contoso.MyException\u0060 | \u0060Conditionally Required\u0060 if the request has ended with an error             |\n\n## Alternative Designs\n\nCurrently, \u0060error.type\u0060 is just the exception type name. This isn\u0027t very descriptive. We could also consider a way to allow authentication handlers to specify a failure reason (maybe in some kind of \u0060aspnetcore.authentication.failure_reason\u0060 attribute). This can be added in the future as a non-breaking change.\n\nAlso, \u0060error.type\u0060 is only populated if an unhandled exception is thrown by a handler. This excludes cases where authentication fails by returning an \u0060AuthenticationResult\u0060 indicating failure (even though the \u0060AuthenticateResult\u0060 contains an \u0060Exception\u0060 describing the failure). We could change \u0060error.type\u0060 to contain the type of any exception in the \u0060AuthenticateResult\u0060, but this would be inconsistent with authorization because \u0060AuthorizationResult\u0060 does not contain an exception to be reported on.\n\n## Risks\n\nNone that I\u0027m aware of.",
    "upvotes": 0,
    "labels": [
      "area-auth",
      "api-approved",
      "feature-authentication"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86azLvn",
        "parentId": null,
        "author": "dotnet-policy-service",
        "content": "Thank you for submitting this for API review. This will be reviewed by @dotnet/aspnet-api-review at the next meeting of the ASP.NET Core API Review group. Please ensure you take a look at [the API review process documentation](https://github.com/dotnet/aspnetcore/blob/main/docs/APIReviewProcess.md) and ensure that:\n\n* The PR contains changes to the reference-assembly that describe the API change. **Or**, you have included a snippet of reference-assembly-style code that illustrates the API change.\n* The PR describes the impact to users, both positive (useful new APIs) and negative (breaking changes).\n* Someone is assigned to \u0022champion\u0022 this change in the meeting, and they understand the impact and design of the change.\n\u003C!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003E",
        "createdAt": "2025-01-16T23:23:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59818#issuecomment-2597108711"
      },
      {
        "id": "IC_kwDOAQzde86bpM9F",
        "parentId": null,
        "author": "halter73",
        "content": "- Is \u0060aspnetcore.authentication.request.duration\u0060 for the entire request or just \u0060AuthenticateAsync\u0060?\n  - \u0060AuthenticateAsync\u0060\n  - Could we rename it to \u0060aspnetcore.authentication.authenticate.duration\u0060? Yes.\n-  Is \u0060_OTHER\u0060 possible for \u0060aspnetcore.authentication.result\u0060? No. We\u0027ll remove it.\n- Why is \u0060challenges\u0060 plural when \u0060authenticate\u0060 is not? \u0060challenges\u0060 is a Counter, so it should be plural. https://opentelemetry.io/docs/specs/semconv/general/metrics/#pluralization\n- The authz \u0060aspnetcore.authentication.requests\u0060 should be \u0060aspnetcore.authorization.requests\u0060\n- Should \u0060aspnetcore.authorization.requests\u0060 be \u0060aspnetcore.authorization.count\u0060? https://opentelemetry.io/docs/specs/semconv/general/metrics/#use-count-instead-of-pluralization-for-updowncounters\n  - Or what about \u0060aspnetcore.authorization.attempts\u0060 so \u0022requests\u0022 isn\u0027t interpreted as an HTTP request?\n  - \u0060aspnetcore.authorization.attempts\u0060 wins.\n- Do need units for \u0060duration\u0060? No. It\u0027s implied to be seconds. \u0027duration\u0027 is a pretty common otel name ending.\n\nAPI approved!\n\n### Microsoft.AspNetCore.Authentication\n\n\u0060aspnetcore.authentication.authenticate.duration\u0060\n\n| Name                                         | Instrument Type | Unit        | Description                                                          |\n| -------------------------------------------- | --------------- | ----------- | -------------------------------------------------------------------- |\n| \u0060aspnetcore.authentication.authenticate.duration\u0060 | Histogram       | \u0060{\u0027s\u0027}\u0060 | The authentication duration for a request. |\n\n| Attribute                          | Type   | Description                            | Examples                                                  | Presence                                                          |\n| ---------------------------------- | ------ | -------------------------------------- | --------------------------------------------------------- | ----------------------------------------------------------------- |\n| \u0060aspnetcore.authentication.scheme\u0060 | string | The name of the authentication scheme. | \u0060Bearer\u0060; \u0060Cookies\u0060                                       | \u0060Conditionally Required\u0060 if the request did not end with an error |\n| \u0060aspnetcore.authentication.result\u0060 | string | The authentication result.             | \u0060success\u0060; \u0060failure\u0060; \u0060none\u0060; \u0060_OTHER\u0060                    | \u0060Conditionally Required\u0060 if the request did not end with an error |\n| \u0060error.type\u0060                       | string | The full name of the exception type.   | \u0060System.InvalidOperationException\u0060; \u0060Contoso.MyException\u0060 | \u0060Conditionally Required\u0060 if the request has ended with an error   |\n\n\u0060aspnetcore.authentication.challenges\u0060\n\n| Name                                   | Instrument Type | Unit        | Description                                       |\n| -------------------------------------- | --------------- | ----------- | ------------------------------------------------- |\n| \u0060aspnetcore.authentication.challenges\u0060 | Counter         | \u0060{request}\u0060 | The total number of times a scheme is challenged. |\n\n| Attribute                          | Type   | Description                            | Examples                                                  | Presence                                                          |\n| ---------------------------------- | ------ | -------------------------------------- | --------------------------------------------------------- | ----------------------------------------------------------------- |\n| \u0060aspnetcore.authentication.scheme\u0060 | string | The name of the authentication scheme. | \u0060Bearer\u0060; \u0060Cookies\u0060                                       | \u0060Conditionally Required\u0060 if the request did not end with an error |\n| \u0060error.type\u0060                       | string | The full name of the exception type.   | \u0060System.InvalidOperationException\u0060; \u0060Contoso.MyException\u0060 | \u0060Conditionally Required\u0060 if the request has ended with an error   |\n\n\u0060aspnetcore.authentication.forbids\u0060\n\n| Name                                | Instrument Type | Unit        | Description                                                                                                      |\n| ----------------------------------- | --------------- | ----------- | ---------------------------------------------------------------------------------------------------------------- |\n| \u0060aspnetcore.authentication.forbids\u0060 | Counter         | \u0060{request}\u0060 | The total number of times an authenticated user attempts to access a resources they are not permitted to access. |\n\n| Attribute                          | Type   | Description                            | Examples                                                  | Presence                                                          |\n| ---------------------------------- | ------ | -------------------------------------- | --------------------------------------------------------- | ----------------------------------------------------------------- |\n| \u0060aspnetcore.authentication.scheme\u0060 | string | The name of the authentication scheme. | \u0060Bearer\u0060; \u0060Cookies\u0060                                       | \u0060Conditionally Required\u0060 if the request did not end with an error |\n| \u0060error.type\u0060                       | string | The full name of the exception type.   | \u0060System.InvalidOperationException\u0060; \u0060Contoso.MyException\u0060 | \u0060Conditionally Required\u0060 if the request has ended with an error   |\n\n\u0060aspnetcore.authentication.sign_ins\u0060\n\n| Name                                 | Instrument Type | Unit        | Description                                         |\n| ------------------------------------ | --------------- | ----------- | --------------------------------------------------- |\n| \u0060aspnetcore.authentication.sign_ins\u0060 | Counter         | \u0060{request}\u0060 | The total number of times a principal is signed in. |\n\n| Attribute                          | Type   | Description                            | Examples                                                  | Presence                                                          |\n| ---------------------------------- | ------ | -------------------------------------- | --------------------------------------------------------- | ----------------------------------------------------------------- |\n| \u0060aspnetcore.authentication.scheme\u0060 | string | The name of the authentication scheme. | \u0060Bearer\u0060; \u0060Cookies\u0060                                       | \u0060Conditionally Required\u0060 if the request did not end with an error |\n| \u0060error.type\u0060                       | string | The full name of the exception type.   | \u0060System.InvalidOperationException\u0060; \u0060Contoso.MyException\u0060 | \u0060Conditionally Required\u0060 if the request has ended with an error   |\n\n\u0060aspnetcore.authentication.sign_outs\u0060\n\n| Name                                 | Instrument Type | Unit        | Description                                       |\n| ------------------------------------ | --------------- | ----------- | ------------------------------------------------- |\n| \u0060aspnetcore.authentication.sign_ins\u0060 | Counter         | \u0060{request}\u0060 | The total number of times a scheme is signed out. |\n\n| Attribute                          | Type   | Description                            | Examples                                                  | Presence                                                          |\n| ---------------------------------- | ------ | -------------------------------------- | --------------------------------------------------------- | ----------------------------------------------------------------- |\n| \u0060aspnetcore.authentication.scheme\u0060 | string | The name of the authentication scheme. | \u0060Bearer\u0060; \u0060Cookies\u0060                                       | \u0060Conditionally Required\u0060 if the request did not end with an error |\n| \u0060error.type\u0060                       | string | The full name of the exception type.   | \u0060System.InvalidOperationException\u0060; \u0060Contoso.MyException\u0060 | \u0060Conditionally Required\u0060 if the request has ended with an error   |\n\n### Microsoft.AspNetCore.Authorization\n\n\u0060aspnetcore.authorization.attempts\u0060\n\n| Name                                 | Instrument Type | Unit        | Description                                                         |\n| ------------------------------------ | --------------- | ----------- | ------------------------------------------------------------------- |\n| \u0060aspnetcore.authorization.attempts\u0060 | Counter         | \u0060{request}\u0060 | The total number of requests for which authorization was attempted. |\n\n| Attribute                         | Type    | Description                                         | Examples                                                  | Presence                                                                    |\n| --------------------------------- | ------- | --------------------------------------------------- | --------------------------------------------------------- | --------------------------------------------------------------------------- |\n| \u0060user.is_authenticated\u0060           | boolean | Whether the request came from an authenticated user | \u0060true\u0060                                                    | \u0060Required\u0060                                                                  |\n| \u0060aspnetcore.authorization.policy\u0060 | string  | The name of the authorization policy.               | \u0060AtLeast21\u0060; \u0060EmployeeOnly\u0060                               | \u0060Conditionally required\u0060 if an authorization policy is used                                |\n| \u0060aspnetcore.authorization.result\u0060 | string  | Whether the authorization succeeded or failed.      | \u0060success\u0060; \u0060failure\u0060                                      | \u0060Conditionally Required\u0060 if an exception is not thrown during authorization |\n| \u0060error.type\u0060                      | string  | The full name of the exception type.                | \u0060System.InvalidOperationException\u0060; \u0060Contoso.MyException\u0060 | \u0060Conditionally Required\u0060 if the request has ended with an error             |",
        "createdAt": "2025-01-24T00:10:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59818#issuecomment-2611269445"
      },
      {
        "id": "IC_kwDOAQzde86bwBny",
        "parentId": null,
        "author": "MackinnonBuck",
        "content": "@lmolkova, would you mind giving this API a look (described in the comment just above this one) and letting us know if you think there\u0027s anything else that needs revision? The main things that need confirmation are:\n1. Whether \u0060{request}\u0060 is a valid unit, especially on \u0060aspnetcore.authorization.attempts\u0060 (should be something like \u0060{attempt}\u0060 instead?)\n2. Whether \u0060user.is_authenticated\u0060 is a valid attribute name. There are standard [\u0060user\u0060](https://opentelemetry.io/docs/specs/semconv/attributes-registry/user/) attributes, and \u0060is_authenticated\u0060 is not one of them.\n\nThanks!",
        "createdAt": "2025-01-24T17:35:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59818#issuecomment-2613058034"
      }
    ]
  }
]