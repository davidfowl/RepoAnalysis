[
  {
    "id": "MDU6SXNzdWUzOTI3NzAxOTQ=",
    "title": "Support the new \u0022Forwarded\u0022 header (RFC 7239)",
    "url": "https://github.com/dotnet/aspnetcore/issues/5978",
    "createdAt": "2016-01-27T16:28:01Z",
    "lastUpdated": "2024-03-02T01:07:32Z",
    "body": "There is now a standard for the most common X-Forwarded-\\* headers. It was introduced with RFC 7239: \u0022[Forwarded HTTP Extension](https://tools.ietf.org/html/rfc7239)\u0022. \n\nExample: \u0060Forwarded: for=192.0.2.60;proto=http;by=203.0.113.43\u0060\n\nIt would be great if this could be supported.\n",
    "upvotes": 26,
    "labels": [
      "enhancement",
      "severity-minor",
      "affected-medium",
      "feature-forwarded-headers",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDE3NTc0NDE2MQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Yes, we\u0027ve seen it. Are you aware of any proxies that actually set that new header?\n",
        "createdAt": "2016-01-27T16:59:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-175744161"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDE3NTgyNzM0Mg==",
        "parentId": null,
        "author": "cwe1ss",
        "content": "No - but I haven\u0027t looked either. I recently built a small ASP.NET gateway proxy for Azure Service Fabric and that\u0027s why I stumbled upon this RFC. I guess this definitely isn\u0027t high priority since there won\u0027t be anyone who\u0027s setting just this header for a looong time. It would just be good to support it someday since it is a standard and will eventually get more common.\n",
        "createdAt": "2016-01-27T20:04:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-175827342"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDE5MTUyNzI0NA==",
        "parentId": null,
        "author": "lantrix",
        "content": "I have a scenario whereby we have a reverse proxy (internally) passing requests to backend api\u2019s and web apps; and one of the api\u0027s is ASP.NET 5 and using the BasicMiddleware classes to handle the headers from the upstream proxies. The team had implemented the newer RFC so BasicMiddleware can\u0027t handle \u0060Forwarded\u0060 headers from the [RFC](https://tools.ietf.org/html/rfc7239).\n",
        "createdAt": "2016-03-03T01:28:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-191527244"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NTEwMDczMA==",
        "parentId": null,
        "author": "asbjornu",
        "content": "We\u0027re using \u0060Forwarded\u0060 and plan to implement it in the proxies we use, [such as NGINX](https://www.nginx.com/resources/wiki/start/topics/examples/forwarded/). The header is becoming more mainstream and it would be good of Microsoft to advocate for its use over the (non-standard) \u0060X-Forwarded-*\u0060 headers.",
        "createdAt": "2018-01-03T19:17:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-355100730"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ0MzUwODY2Ng==",
        "parentId": null,
        "author": "damianh",
        "content": "Would also like to have ability to extend the \u0027Forwared\u0027 header with a \u0060PathBase\u0060 parameter as well as support for that with the current implementation i.e. \u0060X-Forwarded-PathBase\u0060\r\n\r\n(somewhat) Related: https://github.com/aspnet/Hosting/issues/1120 ",
        "createdAt": "2018-12-02T13:43:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-443508666"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ0MzUxNzk5Ng==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@damianh do you expect PathBase to be different per request? That Hosting issue is about getting one value at startup.",
        "createdAt": "2018-12-02T15:55:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-443517996"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ0MzUzNzYyNg==",
        "parentId": null,
        "author": "damianh",
        "content": "Yes, I would certainly like to be able to do so on a per-request basis. This will allow two scenarios where generated URLs and paths (fully qualified, rooted, relative) would \u0022just work\u0022:\r\n\r\n1. Re-configuring the proxy to a new path base (e.g. \u0060http://proxy/foo/\u0060 -\u003E \u0060http://backend/\u0060 to \u0060http://proxy/bar/\u0060 -\u003E \u0060http://backend/\u0060 ) *without* having to reconfigure and restart the backend server.\r\n\r\n2. Having one backend server responding on two separate paths (e.g. \u0060http://proxy/foo/\u0060 | \u0060http://proxy/bar/\u0060 -\u003E \u0060http://backend/\u0060). Useful if \u0022migrating\u0022 to a new route without breaking clients in situ.",
        "createdAt": "2018-12-02T20:07:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-443537626"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ0MzU0MjEwNQ==",
        "parentId": null,
        "author": "damianh",
        "content": "@Tratcher This is what I use near top of my \u0060Configure(IApplicationBuilder app)\u0060:\r\n\r\n            var forwardedHeadersOptions = new ForwardedHeadersOptions\r\n            {\r\n                ForwardedHeaders = ForwardedHeaders.All\r\n            };\r\n            app.UseForwardedHeaders(forwardedHeadersOptions);\r\n            app.Use((context, next) =\u003E {\r\n                if (context.Request.Headers.TryGetValue(\u0022X-Forwarded-PathBase\u0022, out var pathBases))\r\n                {\r\n                    context.Request.PathBase = pathBases.First();\r\n                }\r\n                return next();\r\n            });",
        "createdAt": "2018-12-02T21:07:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-443542105"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU4NTg4Mzg1Mg==",
        "parentId": null,
        "author": "colgreen",
        "content": "\u003E \u0022Are you aware of any proxies that actually set that new header?\u0022\r\n\r\nArguably that point is somewhat circular, i.e. maybe if ASP.NET Core supported the \u0027Forwarded\u0027 header there would be more pressure on the reverse proxy implementations to support it. It is after all the only approach that actually has a formal specification (rfc7239).",
        "createdAt": "2020-02-13T17:45:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-585883852"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyMTczNjk2Mw==",
        "parentId": null,
        "author": "damianh",
        "content": "\u003E Would also like to have ability to extend the \u0027Forwared\u0027 header with a \u0060PathBase\u0060 parameter as well as support for that with the current implementation i.e. \u0060X-Forwarded-PathBase\u0060\r\n\r\n\r\nJust to mention that I\u0027ve shipped a package that supports this https://github.com/ProxyKit/HttpOverrides",
        "createdAt": "2020-04-30T10:02:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-621736963"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY1NDczMzY1Ng==",
        "parentId": null,
        "author": "apeeters",
        "content": "\u003E \u003E \u0022Are you aware of any proxies that actually set that new header?\u0022\r\n\u003E \r\n\u003E Arguably that point is somewhat circular, i.e. maybe if ASP.NET Core supported the \u0027Forwarded\u0027 header there would be more pressure on the reverse proxy implementations to support it. It is after all the only approach that actually has a formal specification (rfc7239).\r\n\r\nIndeed. If no one starts implementing the standard, it will never gain traction. Also: Spring has support for this \u0060Forwarded\u0060 header since 2016...\r\n",
        "createdAt": "2020-07-07T09:44:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-654733656"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY1NDc1NjAxMA==",
        "parentId": null,
        "author": "colgreen",
        "content": "Perhaps someone could reach out to the YARP team to get their views, i.e. e.g. are they planning to implement rfc7239\r\n\r\n[microsoft/reverse-proxy](https://github.com/microsoft/reverse-proxy)",
        "createdAt": "2020-07-07T10:23:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-654756010"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2ODAwODEyMQ==",
        "parentId": null,
        "author": "NatMarchand",
        "content": "\u003E Yes, we\u0027ve seen it. Are you aware of any proxies that actually set that new header?\r\n\r\n@Tratcher, it is the documented way for Azure APIM : https://docs.microsoft.com/en-us/azure/api-management/policies/set-header-to-enable-backend-to-construct-urls",
        "createdAt": "2020-08-03T12:58:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-668008121"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2ODAxMzI0Ng==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E Perhaps someone could reach out to the YARP team to get their views, i.e. e.g. are they planning to implement rfc7239\n\u003E \n\u003E [microsoft/reverse-proxy](https://github.com/microsoft/reverse-proxy)\n\nYARP is being built by this team. We did add support for the new header in YARP but it\u0027s off by default. See https://microsoft.github.io/reverse-proxy/articles/transforms.html#forwarded\n\nDesign note: this probably should be implemented in AspNetCore as a whole new middleware, it takes very different options. I\u0027m also not sure what to do with the randomized client ids, stash them in a new request feature?",
        "createdAt": "2020-08-03T13:09:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-668013246"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3MjAwNDI3MA==",
        "parentId": null,
        "author": "JonAnders",
        "content": "\u003E Design note: this probably should be implemented in AspNetCore as a whole new middleware, it takes very different options. \r\n\r\n@Tratcher I think there is value in keeping it in the same middleware, if possible, as the headers are conceptually the same. A class called \u0060ForwardedHeadersMiddleware\u0060 is where I would expect to find the standards-compliant implementation, I wouldn\u0027t keep looking for a different middleware.\r\n\r\nWhat if \u0060Forwarded\u0060 was added to the \u0060ForwardedHeaders\u0060 enum? To restrict the processing, in line with how \u0060X-Forwarded-*\u0060 is configured, the enum could include \u0060ForwardedBy\u0060, \u0060ForwardedFor\u0060, \u0060ForwardedHost\u0060 and \u0060ForwardedProto\u0060 as well.\r\n\r\nSupport for both \u0060Forwarded\u0060 and \u0060X-Forwarded-*\u0060 could then be configured together, such as:\r\n\u0060\u0060\u0060\r\napp.UseForwardedHeaders(new ForwardedHeadersOptions\r\n{\r\n    ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.ForwardedFor\r\n});\r\n\u0060\u0060\u0060\r\n\r\nThere are some options that only make sense for the \u0060X-Forwarded-*\u0060 headers, but is that a problem? They can either be ignored or cause an exception if they are set when only support for the \u0060Forwarded\u0060 header is configured.\r\n\r\n\r\n\u003E I\u0027m also not sure what to do with the randomized client ids, stash them in a new request feature?\r\n\r\nWould it be a plausible alternative to just provide a class for parsing the \u0060Forwarded\u0060 header and leave the rest up to the developer when using randomized client ids?\r\n",
        "createdAt": "2020-08-11T15:09:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-672004270"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY5MjE3NzMzNQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E Support for both \u0060Forwarded\u0060 and \u0060X-Forwarded-*\u0060 could then be configured together, such as:\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E app.UseForwardedHeaders(new ForwardedHeadersOptions\r\n\u003E {\r\n\u003E     ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.ForwardedFor\r\n\u003E });\r\n\u003E \u0060\u0060\u0060\r\n\r\nThat\u0027s a good example of why these shouldn\u0027t be combine into one middleware. If a request has both headers then what order should they be processed in? It\u0027s ambiguous.",
        "createdAt": "2020-09-14T16:44:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-692177335"
      },
      {
        "id": "IC_kwDOAQzde85KP95d",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-13T17:07:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-1245699677"
      },
      {
        "id": "IC_kwDOAQzde85TfGTE",
        "parentId": null,
        "author": "asbjornu",
        "content": "\u003E That\u0027s a good example of why these shouldn\u0027t be combine into one middleware. If a request has both headers then what order should they be processed in? It\u0027s ambiguous.\r\n\r\nI\u0027m not disagreeing with you @Tratcher, but I do think it\u0027s easy to argue that \u0060Forwarded\u0060 should take precedence over \u0060X-Forwarded-*\u0060, both due to chronology and precision.\r\n\r\n### Chronology\r\n\r\nSince \u0060X-Forwarded-*\u0060 existed before \u0060Forwarded\u0060, it is most likely that \u0060Forwarded\u0060 was added after \u0060X-Forwarded-*\u0060 in order to accommodate middleware that supports \u0060Forwarded\u0060. Middleware that doesn\u0027t support \u0060Forwarded\u0060 will just ignore it and process \u0060X-Forwarded-*\u0060 as before.\r\n\r\nIf adding \u0060Forwarded\u0060 to an HTTP request doesn\u0027t do anything because \u0060X-Forwarded-*\u0060 takes precedence, it makes it very hard to evolve beyond the status quo since every new header will have to be added as a clean break with existing infrastructure.\r\n\r\n### Precision\r\n\r\n\u0060Forwarded\u0060 also has a precisely defined processing model, which I assume most implementers prefer over the undefined behavior of \u0060X-Forwarded-*\u0060.\r\n\r\nWhat is a proxy supposed to do when there are an unequal amount of items added to \u0060X-Forwarded-For\u0060, \u0060X-Forwarded-Host\u0060 and \u0060X-Forwareded-Proto\u0060, for instance? Which item corresponds to which between the three headers? Such situations may occur if a reverse proxy doesn\u0027t support all 3 headers and only modifies one or two of them.\r\n\r\nThere\u0027s also the question of whether new items should be appended or prepended to existing headers. There are numerous edge cases that are unresolved since these headers have been invented separately and never thoroughly specified in terms of a single, coherent standard.\r\n\r\nSince \u0060Forwarded\u0060 groups \u0060for\u0060, \u0060by\u0060, \u0060host\u0060 and \u0060proto\u0060 together for each item and clearly defines that items should be appended to an existing header, it doesn\u0027t suffer from these problems. If issues with \u0060Forwarded\u0060 arises, IETF has a clearly defined process to improve upon the published RFC, which will be made available in a canonical RFC that all implementers can use and reference.\r\n\r\nBecause of all of these benefits, I think it\u0027s obvious that \u0060Forwarded\u0060 should take precedence over \u0060X-Forwarded-*\u0060, when both exist in an HTTP request.",
        "createdAt": "2023-01-23T16:49:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5978#issuecomment-1400661188"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTI3NzA0MDk=",
    "title": "Performance of Rewrite Middleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/5981",
    "createdAt": "2016-08-04T22:51:45Z",
    "lastUpdated": "2024-11-07T10:00:52Z",
    "body": "The whole rewrite middleware needs to be profiled. Specifically, checking for hotspots in the actual application of rules, which matters significantly more than startup time. Memory allocation should be checked too.\n",
    "upvotes": 0,
    "labels": [
      "feature-rewrite-middleware",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI0Njc4Njg4NA==",
        "parentId": null,
        "author": "natemcmaster",
        "content": "Areas for examination:\n- what happens with large numbers of rules? Does the middleware hold up or does perf cripple the server?\n- what is the startup perf of adding large numbers of rules? (e.g. in theory, adding 10000 rules from a database).\n",
        "createdAt": "2016-09-13T18:57:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5981#issuecomment-246786884"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI1MzI5MTg0Mw==",
        "parentId": null,
        "author": "mikaelm12",
        "content": "Initial perf investigation done by @natemcmaster  here https://github.com/aspnet/BasicMiddleware/pull/105\n",
        "createdAt": "2016-10-12T18:08:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5981#issuecomment-253291843"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgwODkxOTE1OQ==",
        "parentId": null,
        "author": "davidfowl",
        "content": "@jkotalik I\u0027m gonn mark this as help wanted. It\u0027s a reasonable task for a contribution to add some benchmarks.",
        "createdAt": "2021-03-28T16:18:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5981#issuecomment-808919159"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTI3NzA0Nzc=",
    "title": "Mod Rewrite Middleware Checklist",
    "url": "https://github.com/dotnet/aspnetcore/issues/5982",
    "createdAt": "2016-08-15T22:33:38Z",
    "lastUpdated": "2023-10-28T14:10:12Z",
    "body": "**Features implemented in mod_rewrite:**\nTypes:\n- [x] RewriteCond\n- [x] RewriteRule\n\nFlags:\n- [x] Cookie\n- [x] Escape Back References\n- [x] End\n- [x] Forbidden\n- [x] Gone\n- [x] Last\n- [x] No Case\n- [x] Query String Append\n- [x] Query String Delete\n- [x] Redirect\n\nServer Variables:\n- [x] HTTP_ACCEPT\n- [x] HTTP_COOKIE\n- [x] HTTP_FORWARDED\n- [x] HTTP_HOST\n- [x] HTTP_REFERER\n- [x] HTTP_USER_AGENT\n- [x] CONN_REMOTE_ADDR\n- [x] QUERY_STRING\n- [x] REMOTE_ADDR\n- [x] IPV6\n- [x] REMOTE_PORT\n- [x] REQUEST_METHOD\n- [x] SCRIPT_FILENAME\n- [x] SERVER_ADDR\n- [x] SERVER_PORT\n- [x] SERVER_PROTOCOL\n- [x] TIME_YEAR\n- [x] TIME_MON\n- [x] TIME_DAY\n- [x] TIME_HOUR\n- [x] TIME_MIN\n- [x] TIME_SEC\n- [x] TIME_WDAY\n- [x] TIME\n- [x] HTTPS\n- [x] REQUEST_FILENAME\n- [x] REQUEST_SCHEME\n- [x] REQUEST_URI\n\nCondPattern:\n- [x] Integer Comparison\n- [x] String Comparison\n- [x] Is File\n- [x] Is Directory\n- [x] Size\n\n**Features that are not implemented in mod_rewrite:**\nTypes:\n- [ ] RewriteBase\n- [ ] RewriteMap\n- [ ] RewriteEngine\n\nFlags:\n- [ ] Chain\n- [ ] Discard Path\n- [ ] Env\n- [ ] Next\n- [ ] No Escape\n- [ ] Pass Through\n- [ ] Query String Last\n- [ ] Skip\n\nServer Variables:\n- [ ] PATH_INFO\n\nCondPattern:\n- [ ] Symbolic Link\n\n**Features that will most likely not be implemented (not supported)**\nTypes:\n- [ ] RewriteOptions\n\nFlags:\n- [ ] Handler\n- [ ] No Subrequest\n- [ ] No Vary\n- [ ] Proxy\n- [ ] Type\n\nServer Variables:\n- [ ] HTTP_PROXY_CONNECTION\n- [ ] AUTH_TYPE\n- [ ] CONTEXT_PREFIX\n- [ ] CONTEXT_DOCUMENT_ROOT\n- [ ] REMOTE_HOST\n- [ ] REMOTE_IDENT\n- [ ] REMOTE_USER\n- [ ] DOCUMENT_ROOT\n- [ ] SCRIPT_GROUP\n- [ ] SCRIPT_USER\n- [ ] SERVER_ADMIN\n- [ ] SERVER_NAME\n- [ ] SERVER_SOFTWARE\n- [ ] API_VERSION\n- [ ] CONN_REMOTE_ADDR\n- [ ] IS_SUBREQ\n- [ ] REMOTE_ADDR\n- [ ] THE_REQUEST\n- [ ] Segmented Lookups (Ex HTTP:header) \n\nCondPattern:\n- [ ] Existing Url via subrequest\n- [ ] Executable\n",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "feature-rewrite-middleware",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDIzOTk1MDM4Mw==",
        "parentId": null,
        "author": "jkotalik",
        "content": "This will be updated on completion of more features/ deciding if features will not be supported.\n",
        "createdAt": "2016-08-15T22:37:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5982#issuecomment-239950383"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI0NDQ1NjgxMA==",
        "parentId": null,
        "author": "jkotalik",
        "content": ":up: :date: to this list.\n",
        "createdAt": "2016-09-02T18:44:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5982#issuecomment-244456810"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTI3NzA2Mjc=",
    "title": "Perf: add API to avoid regex matching rewrite rules unless necessary",
    "url": "https://github.com/dotnet/aspnetcore/issues/5984",
    "createdAt": "2016-08-30T18:14:05Z",
    "lastUpdated": "2023-10-28T14:10:13Z",
    "body": "Regex is an expensive part of the rewrite middleware a lot in order to do pattern matching. It is common for rewrite patterns to be led by a static prefix.\n\nExample:\n\u0022blogs/(.*)\u0022 =\u003E \u0022api/blogs?id=$1\u0022\n\nFor this rule, the middleware can avoid unnecessary regex allocations by only running the rule when the path begins with \u0022/blogs/\u0022.\n\nPossible API design:\n\n\u0060\u0060\u0060 c#\nRewriteOptions.AddRewrite(string prefix, string pattern, string urlResult) // prefix is static, doesn\u0027t container rules. If uri doesn\u0027t start with the prefix, skip this rule\nRewriteOptions.Ignore(string prefix); // always skip rule processing for urls beginning with this prefix\n\u0060\u0060\u0060\n\nUsage\n\n\u0060\u0060\u0060 c#\nRewriteOptions.AddRewrite(prefix: \u0022/blogs/\u0022, pattern: \u0022(.*)\u0022, urlResult: \u0022/api/blogs?id=$1\u0022)\nRewriteOptions.Ignore(\u0022/images/\u0022)\n\u0060\u0060\u0060\n",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "feature-rewrite-middleware",
      "api-suggestion",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI1MzI5ODU5OA==",
        "parentId": null,
        "author": "mikaelm12",
        "content": "We settled on something like \n\n\u0060RewriteOptions.AddRewriteWithPrefix(string prefix, string regex, string replcement)\u0060\n\nright?\n",
        "createdAt": "2016-10-12T18:32:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5984#issuecomment-253298598"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI1MzMwMDEwNw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "There was talk of:\n\n\u0060\u0060\u0060\nRewriteOptions.AddWithPrefix(string prefix, builder =\u003E \n{\n  builder.AddRewrite(regex, replcement);\n});\n\u0060\u0060\u0060\n\nBut we shouldn\u0027t do anything here without finding a large set of customer rules that would benifit.\n",
        "createdAt": "2016-10-12T18:37:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5984#issuecomment-253300107"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTI3NzA3NDM=",
    "title": "Add support for outbound rules in rewrite middleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/5986",
    "createdAt": "2016-09-02T18:55:24Z",
    "lastUpdated": "2023-08-28T23:10:23Z",
    "body": "As an extension on my implementation of UrlRewrite, Outbound rules will look through an Http response for any regex match, and replace them appropriately. \nDocumentation here:\nhttp://www.iis.net/learn/extensions/url-rewrite-module/creating-outbound-rules-for-url-rewrite-module\nhttp://www.iis.net/learn/extensions/url-rewrite-module/url-rewrite-module-20-configuration-reference\n\nThe big problem here will be perf, as we are going to regex match on the whole body of the response. \n\nThis would probably be an extension on top of the rewriter.\n",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "feature-rewrite-middleware",
      "affected-few",
      "severity-major",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyNjkwNjQ2MQ==",
        "parentId": null,
        "author": "aleq",
        "content": "Is there already extension for outbound rules, I couldn\u0027t find anything about it?",
        "createdAt": "2017-09-04T08:58:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5986#issuecomment-326906461"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MTA3MDUxMA==",
        "parentId": null,
        "author": "iamsunny",
        "content": "Hi, any update on the Outbound Rules?",
        "createdAt": "2019-12-03T09:09:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5986#issuecomment-561070510"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MTA5MzEwNQ==",
        "parentId": null,
        "author": "davidfowl",
        "content": "No, we have no plans to implement them ",
        "createdAt": "2019-12-03T10:03:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5986#issuecomment-561093105"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU2MTExNTM2Mw==",
        "parentId": null,
        "author": "iamsunny",
        "content": "thanks @davidfowl for replying. Please, do you suggest any alternate for the outbound rewrite rules? I\u0027ve a situation to replace body contents before the content is rendered. I\u0027m not sure if Regex would be costly in terms of performance. I highly appreciate any pointers, thanks.",
        "createdAt": "2019-12-03T10:57:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5986#issuecomment-561115363"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYzOTQwNjgzMA==",
        "parentId": null,
        "author": "MohammadMokhtarii",
        "content": "Hi, any update on the Outbound Rules?\r\n@davidfowl \r\n\r\nDo You Find Any Solution ?\r\n@iamsunny \r\n\r\n",
        "createdAt": "2020-06-05T10:50:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5986#issuecomment-639406830"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYzOTQyMzY3MQ==",
        "parentId": null,
        "author": "iamsunny",
        "content": "Not yet @mmokhtari, I\u0027m doing string replacement using Regex on the final output before rendering. Not sure why we can\u0027t have this feature out of the box?",
        "createdAt": "2020-06-05T11:27:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5986#issuecomment-639423671"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTI3NzA4MDA=",
    "title": "See if FileAttributes.ReparsePoint can allow for symbolic link checks",
    "url": "https://github.com/dotnet/aspnetcore/issues/5987",
    "createdAt": "2016-09-02T19:06:42Z",
    "lastUpdated": "2023-08-28T23:10:22Z",
    "body": "See title. Nate had this idea and I wanted to formally document it.\n",
    "upvotes": 2,
    "labels": [
      "feature-rewrite-middleware",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI0OTMwNzkyNQ==",
        "parentId": null,
        "author": "natemcmaster",
        "content": "In checking file system attributes, Apache mod_rewrite supports checking if a file is a symbolic link. We might be able to imitate this behavior by checking if a file has the \u0060FileAttributes.ReparsePoint\u0060 attribute set, but we need to verify the semantics are correct. e.g. when is ReparsePoint true? soft/hard links? junctions? etc.\n\nHere\u0027s the TODO in code:\nhttps://github.com/aspnet/BasicMiddleware/blob/ead052324c911604a18a64594672613cca211115/src/Microsoft.AspNetCore.Rewrite/Internal/ApacheModRewrite/RuleBuilder.cs#L134-L137\n\nApache RewriteCond: http://httpd.apache.org/docs/current/mod/mod_rewrite.html#rewritecond\n",
        "createdAt": "2016-09-23T21:33:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5987#issuecomment-249307925"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI2NTA0MTYwNA==",
        "parentId": null,
        "author": "natemcmaster",
        "content": "More context: https://blogs.windows.com/buildingapps/2016/12/02/symlinks-windows-10/",
        "createdAt": "2016-12-06T02:19:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5987#issuecomment-265041604"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTI3NzA4NzY=",
    "title": "Consider re-adding .AddRewrite API with default skip flag",
    "url": "https://github.com/dotnet/aspnetcore/issues/5988",
    "createdAt": "2016-09-28T23:56:18Z",
    "lastUpdated": "2023-08-28T23:10:22Z",
    "body": "In #105 we remove an API from rewrite middleware because we worried it might hide potential perf problems for users. This removal requires users to explicitly declare \u0022skipProcessingRules\u0022 on each call to .AddRewrite. We should reconsidering adding .AddRewrite with a default skipProcessingRules = false.\n\nSee https://github.com/aspnet/BasicMiddleware/pull/105#pullrequestreview-1880064 for more context.\n",
    "upvotes": 0,
    "labels": [
      "feature-rewrite-middleware",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI1NzM1NTEzOA==",
        "parentId": null,
        "author": "muratg",
        "content": "Based on customer feedback, we may bring this back in.\n",
        "createdAt": "2016-10-31T17:08:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5988#issuecomment-257355138"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTI3NzEwMzQ=",
    "title": "Consider caching rule results",
    "url": "https://github.com/dotnet/aspnetcore/issues/5990",
    "createdAt": "2016-10-19T19:12:38Z",
    "lastUpdated": "2023-08-28T23:10:21Z",
    "body": "Some rewrite rules could be cachable. We should investigate possible perf improvements by caching the result of a cachable rule instead of needing expensive regex pattern matching for every request.\n",
    "upvotes": 0,
    "labels": [
      "feature-rewrite-middleware",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "MDU6SXNzdWUzOTI3NzExMTA=",
    "title": "Add more code-first rewrite rules",
    "url": "https://github.com/dotnet/aspnetcore/issues/5991",
    "createdAt": "2016-11-09T21:27:00Z",
    "lastUpdated": "2023-08-28T23:10:20Z",
    "body": "What if I want case insensitive matching? What if I want to match https requests so I can redirect them to http? What if I want to redirect www to non-www (or vice-versa)?\r\n\r\nDo I really have to implement my own \u0060IRule\u0060 for these simple use cases? The \u0060RedirectRule\u0060 class and \u0060AddRedirect\u0060 extension seem way too basic for me.",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "feature-rewrite-middleware",
      "severity-minor",
      "affected-very-few",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI1OTk0NTIxNQ==",
        "parentId": null,
        "author": "strohhut",
        "content": "I found that with \u0060(?i)\u0060 case insesitive matching without \u0060RegexOptions.IgnoreCase\u0060 can be done. So this is supported already.\n\nPlease also consider port and query dependent redirects besides domain and protocol ones I described above (basically all uri parts). Inverted matching would be nice too (e.g. apply a rule when the regex doesn\u0027t match). Also providing multiple match regexes to a rule that get combined (like IIS URL Rewrite).\n\nSomething like\n\n\u0060\u0060\u0060 Csharp\nvar conditions = new [] {new UriMatchCondition(\u0022myPattern\u0022, UriPart.Path, invert: false, caseInsesitive: true)};\noptions.AddRedirect(conditions, \u0022replacement\u0022, requireAllConditions: true);\n\u0060\u0060\u0060\n\nThe replacement pattern could include backreferences to named groups from the conditions\n",
        "createdAt": "2016-11-11T12:14:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5991#issuecomment-259945215"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI1OTk5MTA2Nw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@strohhut thanks for the input. We\u0027re still working on getting the core infrastructure finished and then we can explore more of these scenarios.\n\nYou can also do some of these things using the UrlRewrite and ModRewrite infrastructure already added.\n\nThey way the infrastructure is setup it should be pretty easy for people to build and share custom code rules. https://github.com/aspnet-contrib may be a good place for collaberating on these.\n",
        "createdAt": "2016-11-11T16:08:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5991#issuecomment-259991067"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI2MDAwOTMxOA==",
        "parentId": null,
        "author": "strohhut",
        "content": "Thx, for the help and considering this. \u0060AddIISUrlRewrite\u0060 surely is a good idea if you need more than \u0060RedirectRule\u0060 provides and if you don\u0027t want to implement your own rule classes.\n",
        "createdAt": "2016-11-11T17:26:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5991#issuecomment-260009318"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI2MjA5Mjc5OA==",
        "parentId": null,
        "author": "muratg",
        "content": "This needs design. Putting in 1.2.0 for now.",
        "createdAt": "2016-11-21T22:50:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5991#issuecomment-262092798"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTI3NzEyNjE=",
    "title": "Custom request/response headers in IIS via server variables",
    "url": "https://github.com/dotnet/aspnetcore/issues/5993",
    "createdAt": "2016-12-05T16:02:19Z",
    "lastUpdated": "2023-10-28T14:10:14Z",
    "body": "https://www.iis.net/learn/extensions/url-rewrite-module/url-rewrite-module-20-configuration-reference#Note_about_request_headers_",
    "upvotes": 0,
    "labels": [
      "feature-rewrite-middleware",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI2NDkyMzUyNw==",
        "parentId": null,
        "author": "davidpeden3",
        "content": "PR: https://github.com/aspnet/BasicMiddleware/pull/184",
        "createdAt": "2016-12-05T17:46:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5993#issuecomment-264923527"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgwODkxOTcxMg==",
        "parentId": null,
        "author": "davidfowl",
        "content": "I can\u0027t tell if we ever merged this PR. We support server variables via a feature now though so should be possible to implement.",
        "createdAt": "2021-03-28T16:23:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5993#issuecomment-808919712"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTI3NzEzMzA=",
    "title": "Compression: Add threshold for compression ",
    "url": "https://github.com/dotnet/aspnetcore/issues/5994",
    "createdAt": "2016-12-05T21:26:34Z",
    "lastUpdated": "2023-10-28T14:10:15Z",
    "body": "There are instances where compression is a detriment by comparison to the benefit. Where the time to compress and gzip payload is higher than the original payload.\r\n\r\n**ngnix** defaults to all content with the \u0060gzip_min_length\u0060 setting used to set the minimum length of a response to that will be gzipped. \r\n\r\n**expressjs** compression module is 1k by default, uses \u0060threshold\u0060 option to set globally.\r\n",
    "upvotes": 2,
    "labels": [
      "enhancement",
      "feature-response-compression",
      "affected-few",
      "severity-minor",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI2NTA2NDI3Mw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "As content-length is optional and only set by a few components, this would require buffering the response body up to that threshold before enabling compression. That\u0027s doable, but it can cause un-expected delays for streaming scenarios.",
        "createdAt": "2016-12-06T05:27:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5994#issuecomment-265064273"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI2NTEyNjQzMQ==",
        "parentId": null,
        "author": "spboyer",
        "content": "For the streaming scenarios the threshold should be set to 0, by passing the need to for check/routine. ",
        "createdAt": "2016-12-06T11:24:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5994#issuecomment-265126431"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI2NTE4NjEzMA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Except that streaming is only done for some requests, where this setting would be for all requests.",
        "createdAt": "2016-12-06T15:51:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5994#issuecomment-265186130"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI2NTIwMjk1Nw==",
        "parentId": null,
        "author": "spboyer",
        "content": "So is the use case for the compression middleware only for streaming? Considering that Kestrel is not a web facing server and should be proxied. So typically, compression would be handled by IIS, nginx or apache for requests.  Trying to find to use case, or is this in an effort to get to a public facing server? ",
        "createdAt": "2016-12-06T16:48:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5994#issuecomment-265202957"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI2NjUxNDA2NA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Yes, the main use case is for when Kestrel or WebListener are used independently. Kestrel will eventually be safe for edge deployments, and WebListener already is.\r\n\r\nStreams are not the main use case, but the middleware should not break streaming with too much buffering like the IIS implementation does.",
        "createdAt": "2016-12-12T18:40:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5994#issuecomment-266514064"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI4ODAxNzI4Mw==",
        "parentId": null,
        "author": "RehanSaeed",
        "content": "When the static file middleware is being used, the size of the content is known. Can\u0027t that scenario be optimized?",
        "createdAt": "2017-03-21T09:08:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5994#issuecomment-288017283"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgwODkxOTkxMQ==",
        "parentId": null,
        "author": "davidfowl",
        "content": "@Tratcher is this something we want to do? If so, can it be a contribution?",
        "createdAt": "2021-03-28T16:24:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5994#issuecomment-808919911"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgwODk1MTg0Ng==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Design considerations:\r\n- This would be limited to content-length responses, we wouldn\u0027t want to buffer streamed responses to find out if they were over the threshold or not.\r\n- I don\u0027t know if we\u0027d enable it by default, the effectiveness of compression varies a lot by the content.\r\n- Would a callback that let you check the response and dynamically enable/disable compression be more useful?",
        "createdAt": "2021-03-28T20:06:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5994#issuecomment-808951846"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgwODk1NTgzMw==",
        "parentId": null,
        "author": "davidfowl",
        "content": "Seems we also have prior art for nginx and expressjs as data points. Whoever does this issues should report on what those other servers/frameworks do. \n\nPS: I would assume it would only apply for content length based responses as well.",
        "createdAt": "2021-03-28T20:38:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5994#issuecomment-808955833"
      },
      {
        "id": "IC_kwDOAQzde84_H5VH",
        "parentId": null,
        "author": "WeihanLi",
        "content": "New config options for \u0060ResponseCompressionOptions\u0060?\r\n\r\n\u0060\u0060\u0060 c#\r\npublic int Threshold { get; set; }\r\npublic Func\u003CHttpContext, ValueTask\u003Cbool\u003E\u003E? CompressValidator { get; set; }\r\n\u0060\u0060\u0060\r\n\r\n",
        "createdAt": "2022-03-04T10:25:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5994#issuecomment-1059034439"
      },
      {
        "id": "IC_kwDOAQzde85CHfkt",
        "parentId": null,
        "author": "pbiggar",
        "content": "The [Response Compression docs](https://docs.microsoft.com/en-us/aspnet/core/performance/response-compression?view=aspnetcore-6.0#response-compression) say\r\n\r\n\u003E Don\u0027t compress files smaller than about 150-1000 bytes, depending on the file\u0027s content and the efficiency of compression. The overhead of compressing small files may produce a compressed file larger than the uncompressed file.\r\n\r\nso it feels quite surprising that the middleware being discussed in those docs does not actually support that.",
        "createdAt": "2022-04-26T03:17:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5994#issuecomment-1109260589"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTI3NzE0NzI=",
    "title": "No support for X-Forwarded-Port",
    "url": "https://github.com/dotnet/aspnetcore/issues/5996",
    "createdAt": "2017-02-07T08:24:21Z",
    "lastUpdated": "2023-08-28T23:10:18Z",
    "body": "X-Forwarded-Port header is not supported, only ports in X-Forwarded-Host",
    "upvotes": 1,
    "labels": [
      "enhancement",
      "affected-few",
      "severity-minor",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI3ODA4NjkzNA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Is the port in the Host inadequate / inaccurate?",
        "createdAt": "2017-02-07T18:04:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-278086934"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDI3ODE0MjAwOA==",
        "parentId": null,
        "author": "Lanoli",
        "content": "It works, but I have an existing environment that uses the X-Forwarded-Port header to communicate the port instead of putting it in the X-Forwarded-Host header. Both methods seem to be valid.",
        "createdAt": "2017-02-07T21:14:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-278142008"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyMDk0MTY3MQ==",
        "parentId": null,
        "author": "Abdruggi",
        "content": "Libraries like Swashbuckle expect the port in a separate X-Forwarded-Port header. On the other hand, AWS Load Balancing sets the Port header (http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/x-forwarded-headers.html#x-forwarded-port). If the task is still open i would be willing to implement it.",
        "createdAt": "2017-08-08T12:31:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-320941671"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyMDk3MTE0Nw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@Abdruggi does the x-forwarded-port value differ from the value included in the Host header?\r\n\r\nYou\u0027re welcome to submit a PR for this.",
        "createdAt": "2017-08-08T14:22:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-320971147"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDMyMDk5MDA5OQ==",
        "parentId": null,
        "author": "Abdruggi",
        "content": "The x-forwarded-host header should not include a port if the x-forwarded-port header is set. I would suggest something like that: \r\n\r\nIf just the x-forwarded-port header is present:\r\n- request.Host.Port = x-forwarded-port header \r\n\r\nIf just the x-forwarded-host header is present:\r\n- request.Host.Host = x-forwarded-host header (don\u2019t strip the port if available)\r\n\r\nif both headers are present: \r\n- request.Host.Port = x-forwarded-port header \r\n- request.Host.Host = x-forwarded-host header (strip the port if available)\r\n\r\nWhat do you think about this? \r\n",
        "createdAt": "2017-08-08T15:22:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-320990099"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwOTU4ODc0NA==",
        "parentId": null,
        "author": "??",
        "content": "I\u0027ve just run into this too, only the \u0060x-forwarded-port\u0060 header is forwarded in my setup (and \u0060X-Forwarded-Proto\u0060, \u0060X-Forwarded-For\u0060, but no \u0060x-forwarded-host\u0060)",
        "createdAt": "2018-08-01T14:11:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-409588744"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwOTc0MDc5MA==",
        "parentId": null,
        "author": "biaol-odata",
        "content": "@Tratcher @Abdruggi Any timeline information available for resolution of this issue? If this is not going to be resolved in near future, we will probably consider alternative of patching it up in upper layer (WebApi for OData) to unblock some user scenario. Thanks.",
        "createdAt": "2018-08-01T22:07:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-409740790"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQwOTc0OTQ5OA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "No, we don\u0027t have any plans for this feature at the moment. What proxy is sending you that header?",
        "createdAt": "2018-08-01T22:45:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-409749498"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQxMDAwMjI2OA==",
        "parentId": null,
        "author": "biaol-odata",
        "content": "@elevate-andrewlock ?",
        "createdAt": "2018-08-02T17:16:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-410002268"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQxMDE1MzcwOA==",
        "parentId": null,
        "author": "andrewlock",
        "content": "Both the NGINX and HAProxy setups we currently have send that \u0060x-forwarded-port\u0060. I believe AWS ELBs also send this header. NGINX also sends the \u0060x-forwarded-host\u0060 (without the port), but HAProxy does not. Consequently, we have not been able to use the \u0060XForwardedHost\u0060 header. \r\n\r\nAs a workaround, I\u0027ve basically had to duplicate the \u0060ForwardedHeadersMiddleware\u0060 in miniature, but it really feels like @Abdruggi\u0027s [comment](https://github.com/aspnet/BasicMiddleware/issues/204#issuecomment-320990099) would be the most logical treatment of this header.",
        "createdAt": "2018-08-03T06:02:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-410153708"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQxMDE1NDg1MA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@shirhatti ",
        "createdAt": "2018-08-03T06:09:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-410154850"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQxMDM4NjYzMQ==",
        "parentId": null,
        "author": "shirhatti",
        "content": "Clearing Backlog milestone so we can re-triage and assess priority",
        "createdAt": "2018-08-03T21:57:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-410386631"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzMDQxOTEwOA==",
        "parentId": null,
        "author": "muratg",
        "content": "@shirhatti Can you take a look?",
        "createdAt": "2018-10-16T22:10:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-430419108"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzMDQzNDk2MA==",
        "parentId": null,
        "author": "shirhatti",
        "content": "@Abdruggi @andrewlock  I spent some time taking a look at your suggestions. Unless I\u0027m mistaken I couldn\u0027t find any RFC that defines the behavior that you\u0027ve called out?\r\n\r\nWe\u0027d be extremely hesitant to introduce non-standard behavior.",
        "createdAt": "2018-10-16T23:21:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-430434960"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzMDUyMjYzMw==",
        "parentId": null,
        "author": "andrewlock",
        "content": "@shirhatti, no as far as I can see, there is no RFC governing X-Forwarded-Port. However, while not standard, it is extremely common. For example [AWS use X-Forwarded-Port in the Elastic Load Balancers](https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/x-forwarded-headers.html), as does [the standard Kubernetes NGINX ingress-controller](https://github.com/kubernetes/ingress-nginx/blob/master/rootfs/etc/nginx/template/nginx.tmpl#L1074) (which is where I found the issue). Even Swashbuckle [uses the header to correctly generate links](https://github.com/domaindrivendev/Swashbuckle/blob/master/Swashbuckle.Core/Application/SwaggerDocsConfig.cs#L308).\r\n\r\nI don\u0027t feel like supporting \u0060X-Forwarded-Port\u0060 would be a particularly controversial requirement given its widespread use, and the fact that it can be easily (optionally) added to existing behaviour. I think [This comment](https://github.com/aspnet/BasicMiddleware/issues/204#issuecomment-320990099) best describes the expected behaviour, which is to simply use the forwarded port if it\u0027s provided. We\u0027ve already seen bugs in your own products (OData) which were highlighted (\u0022caused\u0022 is probably a bit strong) by this issue. \r\n\r\nI understand the reticence to add \u0022non standard\u0022 behaviour, but it seems like this will be something that bites people without them realising, and can cause some tricky bugs to identify. What about that \u0022pit of success\u0022 \uD83D\uDE09. Obviously this is mostly selfish - I really don\u0027t want to have to maintain my own version of the forwarded ports middleware (as I\u0027m currently doing locally), but if you commit to _not_ implementing this I\u0027ll just publish my version on NuGet. ",
        "createdAt": "2018-10-17T07:37:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-430522633"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzMDczMDY3OQ==",
        "parentId": null,
        "author": "shirhatti",
        "content": "\u003E I understand the reticence to add \u0022non standard\u0022 behaviour, but it seems like this will be something that bites people without them realising, and can cause some tricky bugs to identify.\r\n\r\nI would love to understand these scenarios better. Given that the \u0060X-Forwarded-Host\u0060 already contains port, I\u0027m missing these pits of failures without \u0060X-Forwarded-Port\u0060.",
        "createdAt": "2018-10-17T18:07:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-430730679"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzMDkyODkzNw==",
        "parentId": null,
        "author": "andrewlock",
        "content": "Sure, so for the examples I\u0027ve described (and experienced):\r\n\r\n* AWS ELB doesn\u0027t use \u0060X-Forwarded-Host\u0060 at all, only \u0060X-Forwarded-Port\u0060. This is probably the most common occurence (they send \u0060X-Forwarded-Port\u0060, \u0060X-Forwarded-Proto\u0060, \u0060X-Forwarded-For\u0060, but no \u0060X-forwarded-host\u0060). \r\n* Some upstream proxies won\u0027t set the port in the \u0060X-Forwarded-Host\u0060 - instead \u0060X-Forwarded-Host\u0060 contains the hostname only, and \u0060X-Forwarded-Port\u0060 contains the port. I can\u0027t remember the exact setup where I saw this, but I believe it was behind an HAProxy instance.",
        "createdAt": "2018-10-18T08:52:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-430928937"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzMTEwNjExMA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "What does ELB put in the real Host header? The back-end machine name and port? Or the original public value?",
        "createdAt": "2018-10-18T18:02:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-431106110"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzMTExNTQzMA==",
        "parentId": null,
        "author": "shirhatti",
        "content": "As I best I can tell from ELB docs, it sends the original unmodified Host Header.\r\n\r\nFor HAProxy, there is no default behavior. The suggested configuration has this\r\n\u0060\u0060\u0060\r\n  http-request set-header X-Forwarded-Host %[req.hdr(host)]\r\n  http-request set-header X-Forwarded-Port %[dst_port]\r\n  http-request set-header X-Forwarded-Proto http if !{ ssl_fc }\r\n  http-request set-header X-Forwarded-Proto https if { ssl_fc }\r\n\u0060\u0060\u0060\r\n\r\nFrom this it\u0027s evident that that \u0060X-Forwarded-Host\u0060 still contains the port information.",
        "createdAt": "2018-10-18T18:32:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-431115430"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzMTExNjEwOQ==",
        "parentId": null,
        "author": "shirhatti",
        "content": "If anything, this thread is testament to why we don\u0027t like to ship non-standard behavior \uD83D\uDE04 \r\n\r\nI\u0027m going to backlog this for now, unless we have evidence that there seems to be consensus among what different proxies do.",
        "createdAt": "2018-10-18T18:34:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-431116109"
      },
      {
        "id": "IC_kwDOAQzde85Vxg8w",
        "parentId": null,
        "author": "amccool",
        "content": "\u003E I understand the reticence to add \u0022non standard\u0022 behaviour, but it seems like this will be something that bites people without them realising, and can cause some tricky bugs to identify. What about that \u0022pit of success\u0022 \uD83D\uDE09. Obviously this is mostly selfish - I really don\u0027t want to have to maintain my own version of the forwarded ports middleware (as I\u0027m currently doing locally), but if you commit to _not_ implementing this I\u0027ll just publish my version on NuGet.\r\n\r\n@andrewlock did you end up publishing your own version of \u0060ForwardedHeadersMiddleware\u0060 ?\r\n",
        "createdAt": "2023-02-21T20:19:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/5996#issuecomment-1439043376"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTI3NzE5Njc=",
    "title": "IISUrlRewrite \u0022URL\u0022 parameter",
    "url": "https://github.com/dotnet/aspnetcore/issues/6002",
    "createdAt": "2017-09-01T17:28:57Z",
    "lastUpdated": "2023-10-28T14:10:16Z",
    "body": "We missed implementing the URL parameter in IIS Url Rewrite rules. The URL parameter will just return the original request url. Ex:\r\n\r\n\u0060\u0060\u0060xml\r\n\u003Crule name=\u0022LowerCaseRule1\u0022 enabled=\u0022true\u0022 stopProcessing=\u0022true\u0022\u003E\r\n    \u003Cmatch url=\u0022[A-Z]\u0022 ignoreCase=\u0022false\u0022 /\u003E\r\n    \u003Caction type=\u0022Redirect\u0022 url=\u0022{ToLower:{URL}}\u0022 /\u003E\r\n\u003C/rule\u003E\r\n\u0060\u0060\u0060\r\n\r\nthe ToLower:{URL} would return the lower cased request url. \r\n",
    "upvotes": 0,
    "labels": [
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgwODkzMjY5NA==",
        "parentId": null,
        "author": "davidfowl",
        "content": "This looks like a good up for grabs",
        "createdAt": "2021-03-28T17:56:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6002#issuecomment-808932694"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTI3NzIwMzg=",
    "title": "Regex Timeout are too short, not consistent, and not configurable in RewriteMiddleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/6003",
    "createdAt": "2017-12-19T22:37:28Z",
    "lastUpdated": "2023-10-28T14:10:16Z",
    "body": "Regex timeouts that are used across [UrlRewrite](https://github.com/aspnet/BasicMiddleware/blob/dev/src/Microsoft.AspNetCore.Rewrite/Internal/IISUrlRewrite/UrlRewriteRuleBuilder.cs#L13), ApacheModRewrite, and [code rules](https://github.com/aspnet/BasicMiddleware/blob/03b63e2c2a5ec27deef4be692ff2119188b67d73/src/Microsoft.AspNetCore.Rewrite/Internal/RewriteRule.cs) are not consistent. The are set at 1 second or 1 millisecond in different places. Secondly, 1 millisecond is too short for a regex expression; it should be 1 second as the timeout is mostly for making sure your server isn\u0027t locked. Also if the expression timeouts, it returns a 500 server error as the exception is unhandled. Thirdly, the timeout should be configurable in RewriteOptions. \r\n\r\nPlan of action:\r\n- Timeouts should be increased to 1 second across the board.\r\n- For 2.1, we should make Regex timeouts configurable a\r\n- The timeouts should be backported to 2.0 and 1.1\r\n\r\n@Eilon @muratg this is a patch candidate. Workarounds are very difficult. ",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "feature-rewrite-middleware",
      "severity-minor",
      "affected-very-few",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1MjkwOTE4MA==",
        "parentId": null,
        "author": "Eilon",
        "content": "Need to consult with @blowdart on a good timeout. I agree 1ms is waaaay too small.",
        "createdAt": "2017-12-19T22:42:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6003#issuecomment-352909180"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1MjkxMTA4MQ==",
        "parentId": null,
        "author": "blowdart",
        "content": "1.1 milliseconds.\r\n\r\nMerry Christmas \u26C4\uFE0F \r\n\r\nOh ok, 1 second is fine as a default, as long as it\u0027s configurable.",
        "createdAt": "2017-12-19T22:50:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6003#issuecomment-352911081"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1MjkyNjIwNw==",
        "parentId": null,
        "author": "Eilon",
        "content": "@blowdart but in a patch, we might not make it configurable. Would 1sec be reasonable in the patch? (With a switch to restore the original bizarre 1ms timeout.)",
        "createdAt": "2017-12-20T00:15:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6003#issuecomment-352926207"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1Mjk3ODI1Nw==",
        "parentId": null,
        "author": "jkotalik",
        "content": "The patch is a simple fix. However the redesign would require more work. When calling options.AddRedirect(), options.AddIISUrlRewrite, etc, we eagerly create the Regex object, which is too early as options would now store the regex timeout. Someone could do:\r\n\u0060\u0060\u0060\r\noptions.AddRedirect(...); // Creates a regex object with default timeout of 1 ms\r\noptions.RegexTimeout = TimeSpan.FromSeconds(1);\r\noptions.AddRewrite(...);\r\n\u0060\u0060\u0060\r\nwhich would set the timeout of 1 ms instead of 1 second for the regex expression. We shouldn\u0027t have options apis that need to be ordered.\r\nWe could either create the regex objects on first request or use a different pattern to know when rules are done being added. \r\n",
        "createdAt": "2017-12-20T06:37:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6003#issuecomment-352978257"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1MzEwNTM4Ng==",
        "parentId": null,
        "author": "blowdart",
        "content": "Config would be better, but if we can\u0027t do that for a patch, then, ugh, ok fix it at 1 second.",
        "createdAt": "2017-12-20T16:07:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6003#issuecomment-353105386"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1MzEzNzM5OQ==",
        "parentId": null,
        "author": "Eilon",
        "content": "@jkotalik yeah I don\u0027t think having a property on the options would be the right way to do it. It would have to be a parameter on each \u0060.AddXyz()\u0060 call.",
        "createdAt": "2017-12-20T18:00:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6003#issuecomment-353137399"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1MzQ0NTM5NQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u0060options.RegexTimeout = TimeSpan.FromSeconds(1); \u0060 looks like a simple, piratical solution. Changing it to DefaultRegexTimeout might make it\u0027s usage a little more clear. The ordering restriction is not a hard thing to explain to users.\r\n\r\nPassing in the timeout to every .Add API looks like overkill, you\u0027ll add a lot of overloads that very few people will use, and they\u0027ll have to specify it on every rule.",
        "createdAt": "2017-12-21T20:05:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6003#issuecomment-353445395"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1MzY5NjY2Ng==",
        "parentId": null,
        "author": "jkotalik",
        "content": "Adding timeouts through each of the \u0060.AddXyz()\u0060 calls would be bloated for sure. I guess we can add it to options and throw if someone does:\r\n\u0060\u0060\u0060csharp\r\noptions.AddRule();\r\noptions.RegexTimeout = TimeSpan.FromSeconds(1); // throw\r\n\u0060\u0060\u0060",
        "createdAt": "2017-12-23T00:51:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6003#issuecomment-353696666"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NDE0ODc3OA==",
        "parentId": null,
        "author": "Eilon",
        "content": "Or don\u0027t throw and make it work: have every call to \u0060.AddXyz()\u0060 capture the \u0022current\u0022 RegexTimeout and use it.",
        "createdAt": "2017-12-27T17:41:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6003#issuecomment-354148778"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NTEyMDc1OA==",
        "parentId": null,
        "author": "jkotalik",
        "content": "#280 for an initial fix to dev. Will make PRs to 1.1.x and 2.0.x branches and then address fixes to 2.1.x.",
        "createdAt": "2018-01-03T20:39:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6003#issuecomment-355120758"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NzQwMzE5OQ==",
        "parentId": null,
        "author": "Eilon",
        "content": "FYI, we ended up deciding no to patch this. But for 2.1 we can consider if we want some fancier behavior(s).",
        "createdAt": "2018-01-13T02:28:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6003#issuecomment-357403199"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUyODUzMjY1Njk=",
    "title": "Add EventSource/EventCounter tracing and metrics for Session",
    "url": "https://github.com/dotnet/aspnetcore/issues/2396",
    "createdAt": "2018-01-01T20:15:31Z",
    "lastUpdated": "2023-10-28T14:10:07Z",
    "body": "_From @anurse on Wednesday, November 1, 2017 3:22:31 PM_\r\n\r\nSome events listed below. The goal is to add events that will help users solve problems so if these aren\u0027t going to do that job, feel free to suggest/discuss others!\r\n\r\n* \u0060Microsoft-AspNetCore-Session\u0060 EventSource\r\n    * \u0060SessionsCreated\u0060 - Counts sessions created\r\n    * \u0060SessionsLoaded\u0060 - Counts the number of times a session is loaded from the provider (this happens on each request for a session)\r\n    * \u0060SessionsCommitted\u0060 - Counts the number of times a session is commited to the provider (again, happens on each request)\r\n    * We can\u0027t track abandoned or timed-out sessions any more as they are handled by caching now and we don\u0027t provide a way to explicitly abandon a session. We could detect \u0022empty\u0022 sessions (with no data) but such a session could always be added to again later.\r\n\r\nSee https://gist.github.com/anurse/af1859663ac91c6cf69c820cebe92303 for some guidance on adding EventSources and EventCounters to ASP.NET projects.\r\n\r\n_Copied from original issue: aspnet/Session#200_",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "feature-session",
      "severity-nice-to-have",
      "affected-few",
      "area-middleware",
      "help candidate"
    ],
    "comments": []
  },
  {
    "id": "MDU6SXNzdWUyODUzMzAzMzQ=",
    "title": "Extensionless files are not served by default",
    "url": "https://github.com/dotnet/aspnetcore/issues/2438",
    "createdAt": "2018-01-01T21:29:04Z",
    "lastUpdated": "2023-08-28T23:10:30Z",
    "body": "_From @sebastienros on Tuesday, November 14, 2017 6:16:05 PM_\r\n\r\nBecause it\u0027s missing an entry in the default \u0060IContentTypeProvider\u0060\r\nSome files like \u0060acme-challenge\u0060 (used by Let\u0027s Encrypt) or Apple application ids, don\u0027t use extensions.\r\n\r\nI\u0027d like to know if it could be reconsidered. \r\n\r\n_Copied from original issue: aspnet/StaticFiles#223_",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "feature-static-files",
      "affected-few",
      "severity-minor",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NDY3ODQ2NA==",
        "parentId": null,
        "author": "aspnet-hello",
        "content": "_From @Tratcher on Tuesday, November 14, 2017 9:38:07 PM_\r\n\r\nThis acme-challenge spec?\r\nhttps://github.com/ietf-wg-acme/acme/blob/0b172d509a725336633b9a76998e907a8e0002e3/draft-ietf-acme-acme.md#L1992\r\nThis doesn\u0027t look like static content, it looks like a dynamic challenge-response handshake.\r\n\r\nApple app ids look like they\u0027re domain name based, or am I missing something?\r\nhttps://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/AppID.html",
        "createdAt": "2018-01-01T21:29:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2438#issuecomment-354678464"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NDY3ODQ2OQ==",
        "parentId": null,
        "author": "aspnet-hello",
        "content": "_From @sebastienros on Wednesday, November 15, 2017 9:08:00 AM_\r\n\r\nThis is the set of files I personally needed for Let\u0027s Encrypt, you\u0027ll notice they don\u0027t have extensions\r\n\r\n![image](https://user-images.githubusercontent.com/1165805/32849368-cc4acb68-c9e3-11e7-904f-b497687e9931.png)\r\n\r\nHere is the documentation on how to configure Stripe with apple pay id (it\u0027s not apple application id, my bad)\r\n\r\n![image](https://user-images.githubusercontent.com/1165805/32849442-024c7e32-c9e4-11e7-9107-ef94346a8f87.png)\r\n\r\nI believe many developers would lose some time understanding why it doesn\u0027t work, or even not be able to update the app that easily as it needs a new deployment.\r\n\r\n",
        "createdAt": "2018-01-01T21:29:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2438#issuecomment-354678469"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NDY3ODQ3MQ==",
        "parentId": null,
        "author": "aspnet-hello",
        "content": "_From @sebastienros on Wednesday, November 15, 2017 9:42:27 AM_\r\n\r\nI can confirm that there is no other way to serve these file than setting \u0060ServeUnknownFileTypes\u0060 and optionally \u0060DefaultContentType\u0060. Registering a custom \u0060IContentTypeProvider\u0060 and adding \u0060\u0022\u0022\u0060 or \u0060\u0022.\u0022\u0060 won\u0027t have any effect. So it\u0027s all or nothing in this case.",
        "createdAt": "2018-01-01T21:29:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2438#issuecomment-354678471"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUyODUzMzA5MTQ=",
    "title": "Option to look for default files at the root of wwwroot path only, not at subpath",
    "url": "https://github.com/dotnet/aspnetcore/issues/2455",
    "createdAt": "2018-01-01T21:40:45Z",
    "lastUpdated": "2023-10-28T14:10:08Z",
    "body": "_From @NickAb on Sunday, February 28, 2016 6:26:46 AM_\r\n\r\n\u0060DefaultFiles\u0060 middleware allows routing to default files at request subpath if no file was found, but for angular or other single page apps we would need to always route to \u0060/wwwroot/index.html\u0060 for any subpath, i.e.:\n- \u0060http://localhost:5000/\u0060 -\u003E \u0060wwwroot/index.html\u0060\n- \u0060http://localhost:5000/some-sub-path\u0060 -\u003E \u0060wwwroot/index.html\u0060\n\nCurrently we have to write custom middleware to handle this case (see [stackoverflow](http://stackoverflow.com/questions/34628536/asp-net-5-angular-2-routing-template-page-not-reloading/34643314) for example). But it seems that adding option to \u0060DefaultFiles\u0060 to route to \u0060wwwroot\u0060 will be a good solution for such a common case.\n\nhttps://github.com/aspnet/StaticFiles/blob/dev/src/Microsoft.AspNetCore.StaticFiles/DefaultFilesMiddleware.cs#L67\n\r\n\r\n_Copied from original issue: aspnet/StaticFiles#115_",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "feature-static-files",
      "affected-few",
      "severity-minor",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NDY3OTEzMg==",
        "parentId": null,
        "author": "aspnet-hello",
        "content": "_From @muratg on Monday, February 29, 2016 2:11:17 PM_\r\n\r\n@NickAb By \u0022custom middleware\u0022 do you mean the example in http://stackoverflow.com/questions/31184446/asp-net-5-html5-history/34882405#34882405? \n",
        "createdAt": "2018-01-01T21:40:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2455#issuecomment-354679132"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NDY3OTEzMw==",
        "parentId": null,
        "author": "aspnet-hello",
        "content": "_From @NickAb on Monday, February 29, 2016 6:30:16 PM_\r\n\r\nFor the moment I use this instead:\n\n\u0060\u0060\u0060 cs\napp.Use(async (context, next) =\u003E\n{\n    await next();\n\n    if (context.Response.StatusCode == 404 \u0026\u0026 IsGetOrHeadMethod(context.Request.Method))\n    {\n        context.Request.Path = \u0022/\u0022; // Put your Angular root page here \n        await next();\n    }\n});\n\u0060\u0060\u0060\n\nAlso there is an [Angular Middleware](https://github.com/a11smiles/AngularMiddleware/blob/master/AngularMiddleware/AngularRequestMiddleware.cs) on github.\n",
        "createdAt": "2018-01-01T21:40:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2455#issuecomment-354679133"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NDY3OTEzOQ==",
        "parentId": null,
        "author": "aspnet-hello",
        "content": "_From @Tratcher on Tuesday, March 1, 2016 8:50:09 PM_\r\n\r\nPossibly related to https://github.com/aspnet/StaticFiles/issues/111\n",
        "createdAt": "2018-01-01T21:40:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2455#issuecomment-354679139"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NDY3OTE0MQ==",
        "parentId": null,
        "author": "aspnet-hello",
        "content": "_From @Tratcher on Wednesday, April 27, 2016 11:37:19 AM_\r\n\r\nI think it would be an option like IncludeSubDirectories on PhysicalFileProvider.\n",
        "createdAt": "2018-01-01T21:40:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2455#issuecomment-354679141"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUyODUzMzA5MzE=",
    "title": "Add event for customizing file selection",
    "url": "https://github.com/dotnet/aspnetcore/issues/2456",
    "createdAt": "2018-01-01T21:41:06Z",
    "lastUpdated": "2023-08-28T23:10:29Z",
    "body": "_From @Tratcher on Tuesday, February 16, 2016 9:01:28 AM_\r\n\r\nAdd an event at the beginning of the static file middleware when the request first arrives that would let you map any path to any file, and pick the content-type. Then the middleware could process that file normally (e-tags, if-modified-since, range, etc..).\n\r\n\r\n_Copied from original issue: aspnet/StaticFiles#111_",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "feature-static-files",
      "severity-nice-to-have",
      "affected-very-few",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NDY3OTE1Nw==",
        "parentId": null,
        "author": "aspnet-hello",
        "content": "_From @Eilon on Saturday, February 20, 2016 10:55:18 PM_\r\n\r\nMoving to backlog as we\u0027re trying to limit new features at this time.\n",
        "createdAt": "2018-01-01T21:41:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2456#issuecomment-354679157"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUyODUzNDEzNjE=",
    "title": "Cache invalidation",
    "url": "https://github.com/dotnet/aspnetcore/issues/2622",
    "createdAt": "2018-01-02T01:08:59Z",
    "lastUpdated": "2023-10-28T14:09:31Z",
    "body": "_From @JunTaoLuo on Thursday, September 15, 2016 2:15:48 PM_\r\n\r\nCurrently we only set the absolute timeouts for cache entries. There is no mechanism to explicitly invalidate a cache entry before expiry. Also, how would applications/users interact with this feature?\n\nNote that invalidation is required by the RFC for unsafe methods, e.g. a successful PUT should invalidate any previous cached resources at the same URI.\n\r\n\r\n_Copied from original issue: aspnet/ResponseCaching#38_",
    "upvotes": 11,
    "labels": [
      "Needs: Design",
      "enhancement",
      "feature-response-caching",
      "severity-nice-to-have",
      "affected-few",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NDY5MDExOQ==",
        "parentId": null,
        "author": "aspnet-hello",
        "content": "_From @refactorthis on Friday, March 31, 2017 9:38:12 AM_\r\n\r\nendpoints that mutate state should invalidate the previous cached item by default as you mention. It would also be beneficial to have the ability to inject a service that allows invalidating cached items on demand. For example an event received over a bus may mutate the objects state which would require invalidation. This may however be out of scope and better handled by abstracting the cache to a different layer?",
        "createdAt": "2018-01-02T01:08:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2622#issuecomment-354690119"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NDY5MDEyMQ==",
        "parentId": null,
        "author": "aspnet-hello",
        "content": "_From @muratg on Thursday, May 25, 2017 3:42:26 PM_\r\n\r\n@glennc If we want to do this in the future, we should get together and agree on a design.",
        "createdAt": "2018-01-02T01:09:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2622#issuecomment-354690121"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1NDY5MDEyNA==",
        "parentId": null,
        "author": "aspnet-hello",
        "content": "_From @justintubbs on Wednesday, August 9, 2017 12:19:14 PM_\r\n\r\nAny update on this?  Cache invalidation would be a killer feature both for REST API interactions, but also SignalR or other types of event buffers/message queues that cause the underlying data to mutate.",
        "createdAt": "2018-01-02T01:09:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2622#issuecomment-354690124"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3MDU5ODMwOA==",
        "parentId": null,
        "author": "xantari",
        "content": "How is this not solved yet? This is a common use case:\r\n\r\n1. Server caches result of page\r\n2. We receive a cache eviction event notification from a headless CMS\r\n3. We should be able to clear the response output cache and load the new CMS data!",
        "createdAt": "2020-08-07T16:22:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2622#issuecomment-670598308"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcwNjM0NTk3OQ==",
        "parentId": null,
        "author": "mjrousos",
        "content": "@muratg @glennc, just checking in. Any updates on this one? I\u0027m working with a customer whose scenario sounds similar to @xantari\u0027s. Being able to invalidate items from the cache would make response caching a lot more useful in that scenario.",
        "createdAt": "2020-10-09T18:47:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2622#issuecomment-706345979"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyODI0OTk4Ng==",
        "parentId": null,
        "author": "JunTaoLuo",
        "content": "This is something we\u0027d want to keep in mind when designing Output Cache: https://github.com/dotnet/aspnetcore/issues/2627.",
        "createdAt": "2020-11-16T18:40:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2622#issuecomment-728249986"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1MjI1MzM3OA==",
        "parentId": null,
        "author": "xantari",
        "content": "Our current workaround to this limitation so that we can still have the extreme performance that response output caching provides when surfacing our headless CMS data is that we have set our response output cache to 2 hours.\r\n\r\nThis poses several problems for our content management system (CMS) editors however. It has the following ramifications:\r\n\r\n1. Edits to pages in the headless CMS are not reflected to end users for up to 2 hours as we can\u0027t immediately evict the changed pages.\r\n2. We can\u0027t cache the page indefinitely which would increase server performance. Instead we load it every 2 hours as it\u0027s the only way to render page changes due to the inability to evict items from the response output cache.\r\n\r\nIdeally this issue would be solved and we would just set the response output cache to something like 24 or 48 hours and our servers would just be sitting idle since the servers wouldn\u0027t have to think about rendering new pages anymore unless it receives a cache eviction notification that tells the system it needs to evict the response output cache and the next hit to that page would go through the normal MVC rendering process.",
        "createdAt": "2020-12-29T21:51:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2622#issuecomment-752253378"
      },
      {
        "id": "IC_kwDOAQzde845VNwl",
        "parentId": null,
        "author": "catalin-ifacts",
        "content": "OMG, I am stunned. No ResponseCache invalidation \u00EEn .NET Core? November 2021 here.....\r\n!@#$@!#",
        "createdAt": "2021-11-05T12:37:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2622#issuecomment-961862693"
      },
      {
        "id": "IC_kwDOAQzde8498P-4",
        "parentId": null,
        "author": "oezoezoe",
        "content": "Below a simplefied workaround we use:\r\n\r\n\r\n\u0060\u0060\u0060\r\n[ApiController]\r\n    [Route(\u0022[controller]\u0022)]\r\n    public class TimeController : ControllerBase\r\n    {\r\n        private int _version = 0;\r\n\r\n        [HttpGet]\r\n        public IActionResult Get()\r\n        {\r\n            return RedirectToAction(\u0022GetInternal\u0022, new { version = _version });\r\n        }\r\n\r\n        [HttpGet(\u0022{version:int}\u0022)]\r\n        [ApiExplorerSettings(IgnoreApi = true)]\r\n        [ResponseCache(Duration = 3600, VaryByQueryKeys = new[] { \u0022version\u0022 })]\r\n        public async Task\u003CIActionResult\u003E GetInternal(int version)\r\n        {\r\n            await Task.Delay(2000);\r\n            return Ok(DateTime.Now);\r\n        }\r\n\r\n        [HttpPut]\r\n        public IActionResult ClearCache()\r\n        {\r\n            _version\u002B\u002B;\r\n            return Ok();\r\n        }\r\n    }\r\n    \r\n\u0060\u0060\u0060\r\nThe consumer can use the normal get method and via a different call the version gets updated and thereby invalidating the old version.",
        "createdAt": "2022-02-14T15:14:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2622#issuecomment-1039204280"
      },
      {
        "id": "IC_kwDOAQzde85P3-TH",
        "parentId": null,
        "author": "xantari",
        "content": "Not sure, but is this now solved via #27387 in .net 7?",
        "createdAt": "2022-12-06T22:07:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2622#issuecomment-1340073159"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTI3NzIxMDY=",
    "title": "URL rewrite module - REQUEST_URI does not contain querystring",
    "url": "https://github.com/dotnet/aspnetcore/issues/6004",
    "createdAt": "2018-01-23T11:35:22Z",
    "lastUpdated": "2023-08-28T23:10:16Z",
    "body": "Using server variable REQUEST_URI does not seem to work when working with query strings.\r\n\r\nThis does not work:\r\n\r\n\u0060\u0060\u0060xml\r\n\u003Crewrite\u003E\r\n  \u003Crules\u003E\r\n   \u003Crule name=\u0022rulename\u0022 stopProcessing=\u0022true\u0022\u003E\r\n      \u003Cmatch url=\u0022.*\u0022 /\u003E\r\n      \u003Cconditions logicalGrouping=\u0022MatchAll\u0022\u003E\r\n        \u003Cadd input=\u0022{Map_Name:{REQUEST_URI}}\u0022 pattern=\u0022(.\u002B)\u0022 /\u003E\r\n      \u003C/conditions\u003E\r\n      \u003Caction type=\u0022Redirect\u0022 url=\u0022{C:1}\u0022 appendQueryString=\u0022false\u0022 redirectType=\u0022Permanent\u0022  /\u003E\r\n    \u003C/rule\u003E\r\n  \u003C/rules\u003E\r\n\r\n  \u003CrewriteMaps\u003E\r\n    \u003CrewriteMap name=\u0022Map_Name\u0022 defaultValue=\u0022\u0022\u003E\r\n      \u003Cadd key=\u0022/url/with/querystring.html?a=b\u0022 value=\u0022/other/url.html\u0022 /\u003E\r\n    \u003C/rewriteMap\u003E\r\n  \u003C/rewriteMaps\u003E\r\n\u003C/rewrite\u003E\r\n\u0060\u0060\u0060\r\n\r\nAs a workaround, I appended the QUERY_STRING variable to the condition. But this does not seem to be in line with the [IIS documentation](https://docs.microsoft.com/en-us/iis/extensions/url-rewrite-module/url-rewrite-module-configuration-reference#accessing-url-parts-from-a-rewrite-rule) I found\r\n\r\nThis is the workaround:\r\n\r\n\u0060\u0060\u0060xml\r\n\u003Crewrite\u003E\r\n  \u003Crules\u003E\r\n   \u003Crule name=\u0022rulename\u0022 stopProcessing=\u0022true\u0022\u003E\r\n      \u003Cmatch url=\u0022.*\u0022 /\u003E\r\n      \u003Cconditions logicalGrouping=\u0022MatchAll\u0022\u003E\r\n        \u003Cadd input=\u0022{Map_Name:{REQUEST_URI}?{QUERY_STRING}}\u0022 pattern=\u0022(.\u002B)\u0022 /\u003E\r\n      \u003C/conditions\u003E\r\n      \u003Caction type=\u0022Redirect\u0022 url=\u0022{C:1}\u0022 appendQueryString=\u0022false\u0022 redirectType=\u0022Permanent\u0022  /\u003E\r\n    \u003C/rule\u003E\r\n  \u003C/rules\u003E\r\n\r\n  \u003CrewriteMaps\u003E\r\n    \u003CrewriteMap name=\u0022Map_Name\u0022 defaultValue=\u0022\u0022\u003E\r\n      \u003Cadd key=\u0022/url/with/querystring.html?a=b\u0022 value=\u0022/other/url.html\u0022 /\u003E\r\n    \u003C/rewriteMap\u003E\r\n  \u003C/rewriteMaps\u003E\r\n\u003C/rewrite\u003E\r\n\u0060\u0060\u0060\r\n\r\nI\u0027m using version 2.0.1 of the Microsoft.AspNetCore.Rewrite package",
    "upvotes": 1,
    "labels": [
      "bug",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM1OTg3NDUyMg==",
        "parentId": null,
        "author": "jkotalik",
        "content": "It looks like you are correct. Unfortunately, we may not be able to fix this until a major release as people may be relying on the REQUEST_URI not containing the query string. For now, I think you will need to stick with your workaround. \r\ncc/ @muratg ",
        "createdAt": "2018-01-23T17:53:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6004#issuecomment-359874522"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQzMDQxMTE1Mg==",
        "parentId": null,
        "author": "muratg",
        "content": "Similar to #308.  ",
        "createdAt": "2018-10-16T21:41:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6004#issuecomment-430411152"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgwODk0MTM3Mg==",
        "parentId": null,
        "author": "davidfowl",
        "content": "If we do it, it is a breaking change right?",
        "createdAt": "2021-03-28T18:51:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6004#issuecomment-808941372"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzOTI3NzIyNzM=",
    "title": "Add support for PATH_INFO server variable",
    "url": "https://github.com/dotnet/aspnetcore/issues/6006",
    "createdAt": "2018-03-08T10:53:25Z",
    "lastUpdated": "2023-10-28T14:09:48Z",
    "body": "Hi there,\r\n\r\nCan you please provide support for the PATH_INFO server variable on IIS. I\u0027m trying to migrate my legacy MVC website to the new one I\u0027ve built ASP.Net Core. I\u0027m trying to migrate the URL rewrite rules but they don\u0027t work as they rely on the PATH_INFO server variable.\r\n\r\nI get the following error when trying to run my application:\r\nUnrecognized parameter type: \u0027PATH_INFO\u0027, terminated at string index: \u002710\u0027\r\nMicrosoft.AspNetCore.Rewrite.Internal.IISUrlRewrite.ServerVariables.FindServerVariable(string serverVariable, ParserContext context, UriMatchPart uriMatchPart)\r\n\r\nExtract from my configure method in startup.cs which reads in an xml file:\r\n\r\n\u0060\u0060\u0060\r\nusing (StreamReader iisUrlRewriteStreamReader =\r\n    File.OpenText(\u0022IISUrlRewrite.xml\u0022))\r\n            {\r\n                var options = new RewriteOptions()\r\n                    .AddIISUrlRewrite(iisUrlRewriteStreamReader);\r\n\r\n                app.UseRewriter(options);\r\n            }\r\n\u0060\u0060\u0060\r\n\r\nThe example content of the IISUrlRewrite,xml file is:\r\n\u0060\u0060\u0060\r\n\u003Crewrite\u003E\r\n  \u003Crules\u003E\r\n    \u003Crule name=\u0022Redirect /foo to foo2\u0022 stopProcessing=\u0022true\u0022\u003E\r\n      \u003Cmatch url=\u0022.*\u0022 /\u003E\r\n      \u003Cconditions\u003E\r\n        \u003Cadd input=\u0022{PATH_INFO}\u0022 pattern=\u0022^/foo$\u0022 /\u003E\r\n      \u003C/conditions\u003E\r\n      \u003Caction type=\u0022Redirect\u0022 url=\u0022http://www.foo2.co.uk\u0022 appendQueryString=\u0022false\u0022 /\u003E\r\n    \u003C/rule\u003E\r\n  \u003C/rules\u003E\r\n\u003C/rewrite\u003E\r\n\u0060\u0060\u0060\r\n\r\n\r\nIf I change {PATH_INFO} to {QUERY_STRING}, the application loads but this isn\u0027t the redirect I need. Can you please provide support for this ASAP please?\r\n\r\nIn the meantime, is there a workaround I can use that will support {PATH_INFO} patterns on IIS?\r\n\r\nThanks",
    "upvotes": 2,
    "labels": [
      "enhancement",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3MTQ1NTgxNA==",
        "parentId": null,
        "author": "neilmulhy",
        "content": "I\u0027ve reviewed the serverVariables file and can see that you support HTTP_URL. I should be able to change the rules to use this instead unless you see any issues with this?",
        "createdAt": "2018-03-08T11:04:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6006#issuecomment-371455814"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3MTU2Nzk1OA==",
        "parentId": null,
        "author": "jkotalik",
        "content": "From what I can tell, HTTP_URL is supposed to include the query string, however after I reread the implementation, it seems that we didn\u0027t include the query string. Try swapping PATH_INFO with HTTP_URL?",
        "createdAt": "2018-03-08T17:52:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6006#issuecomment-371567958"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3MTc1MjQwMw==",
        "parentId": null,
        "author": "neilmulhy",
        "content": "I\u0027ve been able to use HTTP_URL but will appreciate if you can update this issue when PATH_INFO is supported.",
        "createdAt": "2018-03-09T08:56:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/6006#issuecomment-371752403"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUzMDUwOTgzNTY=",
    "title": "Response caching middleware doesn\u0027t allow injection of IResponseCache",
    "url": "https://github.com/dotnet/aspnetcore/issues/2957",
    "createdAt": "2018-03-14T10:20:29Z",
    "lastUpdated": "2023-09-04T11:45:26Z",
    "body": "The response caching middleware uses a MemoryCache object to cache responses and it is hardcoded in the public constructor to use it. See: https://github.com/aspnet/ResponseCaching/blob/master/src/Microsoft.AspNetCore.ResponseCaching/ResponseCachingMiddleware.cs. This makes it impossible to provide your own implementation of IResponseCache. I would for example like to create a DistributedResponseCache so I can have better horizontal scaling.",
    "upvotes": 5,
    "labels": [
      "enhancement",
      "feature-response-caching",
      "affected-few",
      "severity-minor",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3Mjk3OTcwNA==",
        "parentId": null,
        "author": "tpeczek",
        "content": "You can go around this, please take a look here: https://www.tpeczek.com/2018/03/redis-backed-response-caching-in-aspnet.html",
        "createdAt": "2018-03-14T10:49:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-372979704"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3Mjk4MTYwOA==",
        "parentId": null,
        "author": "angrymrt",
        "content": "@tpeczek thanks, this is useful as a temporary hack, but I would prefer an official solution for this.",
        "createdAt": "2018-03-14T10:57:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-372981608"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDM3Mjk4NTMwMg==",
        "parentId": null,
        "author": "tpeczek",
        "content": "@angrymrt I went arround, because according to discussion [here](https://github.com/aspnet/ResponseCaching/commit/f125329ed70a5aeaa28d5ecfaf433aed8e318a59#diff-10af08b8eec1eb0744eabb7defa3c966) it has been done on purpose.",
        "createdAt": "2018-03-14T11:12:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-372985302"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ1MzY3NzAyMA==",
        "parentId": null,
        "author": "shirhatti",
        "content": "@JunTaoLuo What do think next steps here are? Is this work-around fine? Or did you already have a design in mind?",
        "createdAt": "2019-01-11T22:27:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-453677020"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ1MzY5MjA3Nw==",
        "parentId": null,
        "author": "JunTaoLuo",
        "content": "The workaround isn\u0027t ideal since it uses reflection but it does get the job done.",
        "createdAt": "2019-01-11T23:40:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-453692077"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ1MzczMTEzOQ==",
        "parentId": null,
        "author": "angrymrt",
        "content": "@JunTaoLuo how about a dependency on an IResponseCacheFactory that has a Create(IOptions\u003CResponseCachingOptions\u003E options) method?\r\n\r\nThen just pass the IResponseCacheFactory into the internal constructor and use it to create a cache (either distributed or memory).",
        "createdAt": "2019-01-12T08:47:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-453731139"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ1NDEyNTQxNA==",
        "parentId": null,
        "author": "JunTaoLuo",
        "content": "There are certainly many ways to build this functionality. I\u0027m not sure when we\u0027ll triage this work item though.",
        "createdAt": "2019-01-14T19:13:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-454125414"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNDIyMzIzNQ==",
        "parentId": null,
        "author": "yringler",
        "content": "@JunTaoLuo , unfortunately that workaround no longer works, because [this commit](https://github.com/dotnet/aspnetcore/commit/cc1f23c5f8afb7d2a00405f19811d2372c4fcec2#diff-bf48ddb7e9ad4ab420a8bf38b9df508d) removes public access to the IResponseCache interface.\r\nPerhaps could that be made public again?  ",
        "createdAt": "2020-05-05T18:17:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-624223235"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNDIzMTYwMQ==",
        "parentId": null,
        "author": "slangeder",
        "content": "\u003E @JunTaoLuo , unfortunately that workaround no longer works, because [this commit](https://github.com/dotnet/aspnetcore/commit/cc1f23c5f8afb7d2a00405f19811d2372c4fcec2#diff-bf48ddb7e9ad4ab420a8bf38b9df508d) removes public access to the IResponseCache interface.\r\n\u003E Perhaps could that be made public again?\r\n\r\n\u002B1 to that. I ended up copying the AspNetCore ResponseCaching code into our repository and adapted the visibility modifiers. Not proud about that, but now we can upgrade to AspNetCore 3.1.\r\nWhy can\u0027t the ResponseCaching feature make use of the IDistributedCache interface like so many other AspNetCore features?",
        "createdAt": "2020-05-05T18:34:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-624231601"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNDI0NDQ3MQ==",
        "parentId": null,
        "author": "yringler",
        "content": "I\u0027m [poking around](https://github.com/yringler/distributed-middleware-cache) with maybe making a nuget package which people can use. It uses aspnetcore as a submodule.\r\nThe basic idea is to link to all the asnetcore source files through the submodule into a new project, and then add more IResponseCache implementations to that new project.\r\nThe only concern is that I end up going down a rabibit hole of linking to more and more source files... But I think it\u0027ll be ok.\r\n\r\n_update_\r\nIt works! I\u0027m sure it could be improved, but it does the job.\r\nAvailable [on nuget as DistributedResponseCachingMiddleware ](https://www.nuget.org/packages/DistributedResponseCachingMiddleware/)\r\n@slangeder, does it fulfill the requirements for you\u0027re project?",
        "createdAt": "2020-05-05T18:59:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-624244471"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNDY0ODgxOA==",
        "parentId": null,
        "author": "slangeder",
        "content": "@yringler Thank you very much for creating that package.\r\nA coworker included it in our project today, and it works perfectly.",
        "createdAt": "2020-05-06T13:27:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-624648818"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNzQxMTk3OA==",
        "parentId": null,
        "author": "dustinmoris",
        "content": "Possible duplicate or at least closely related to [https://github.com/dotnet/aspnetcore/issues/2617](https://github.com/dotnet/aspnetcore/issues/2617).\r\n\r\nCan we priorotise this work again? If I was to send in a PR what are the chances of you guys merging it in for the next release?\r\n\r\nEDIT:\r\n\r\nThe current response caching implementatiom is extremely frustrating. It means that an app caches the same data on every node where it\u0027s been deployed, which makes it even dumber when you think that you can run more pods in Kubernetes than physical nodes, effectively the same node caching the same data multiple times and wasting valuable and costly cloud resources. Having a configurable public interface to allow an \u0060IDistributedCache\u0060 would make so much more sense.\r\n\r\nNot to mention that the more nodes have to cache a response the less likely it is that a cached response will be returned on a request, because there\u0027s a chance that each request hits a different node, effectively defeating the purpose of caching in the first place.\r\n\r\nNot sure why this was ever approved/shipped in this form, but it needs urgent fixing!",
        "createdAt": "2020-05-12T15:19:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-627411978"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNzQyMDE5NQ==",
        "parentId": null,
        "author": "yringler",
        "content": "Yes, a resolution of #2617 would also resolve this. (Unless the resolution is also done with private/internal classes.) It\u0027s a particular place where the functionality requested in this issue is needed.\r\n\r\nFeel free to take a look at [my repo](https://github.com/yringler/distributed-middleware-cache) mentioned earlier, [available on nuget](https://www.nuget.org/packages/DistributedResponseCachingMiddleware/).\r\n\r\nIt is a replacement for [Microsoft.AspNetCore.ResponseCaching](https://www.nuget.org/packages/Microsoft.AspNetCore.ResponseCaching/) which allows customizing the response cache, with a bunch of ready made implementations, for example, one which accepts an injected IDistributedCache. It\u0027s implemented with all the official Microsoft code internally via git submodule and csproj linking, so the amount of code in it which isn\u0027t coming from Microsoft is pretty tiny.\r\n\r\n@slangeder  is using it, and I have tested it at my company, although we aren\u0027t using it in production yet.\r\n\r\nIf you see something which needs improvement, it\u0027s under the MIT license if you want to fork, or you can drop me a PR.",
        "createdAt": "2020-05-12T15:33:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-627420195"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyODI1MDE2OQ==",
        "parentId": null,
        "author": "JunTaoLuo",
        "content": "Extensibility is something we\u0027d want to keep in mind when designing Output Cache: https://github.com/dotnet/aspnetcore/issues/2627.",
        "createdAt": "2020-11-16T18:40:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-728250169"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgzMjI4MzExNg==",
        "parentId": null,
        "author": "brunolm",
        "content": "Any updates on this? What\u0027s the current workaround?",
        "createdAt": "2021-05-04T22:10:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-832283116"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgzMjI5MzIyMg==",
        "parentId": null,
        "author": "yringler",
        "content": "The only workaround I\u0027m aware of is kinda to fork MS code \uD83E\uDD37 \r\nEven the nice guy I was working with on my proj, after he couldn\u0027t use it b/c of his company rules, said that they were going to use the same approach, namely to reference the MS code with CSPROJ links, to access all the internal classes.\r\nThere\u0027s a workaround [here](https://github.com/yringler/distributed-middleware-cache), which basically uses the MS code, opens it up, and adds some functionality.\r\nI\u0027ve been meaning to get around to updating the docs and republishing a nuget, but haven\u0027t yet. Feel free to take ownership of it!\r\n",
        "createdAt": "2021-05-04T22:37:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-832293222"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgzMzQ1NzQ3OA==",
        "parentId": null,
        "author": "brunolm",
        "content": "I found a way to implement a custom filter attribute that can handle server caching. This works for me on dotnet core 5.0\r\n\r\nnote: This is not fully finished, it needs to get values from params.\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace Something\r\n{\r\n    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, AllowMultiple = false, Inherited = false)]\r\n    public class ActionResultCacheAttribute : ActionFilterAttribute\r\n    {\r\n        private string _cacheKey;\r\n\r\n        /// \u003Csummary\u003E\r\n        /// The comma separated parameters to vary the caching by.\r\n        /// \u003C/summary\u003E\r\n        public string VaryByParam { get; set; }\r\n        public string VaryByHeader { get; set; }\r\n        public string VaryByQueryKeys { get; set; }\r\n        public bool VaryByAuth { get; set; } = false;\r\n\r\n\r\n        public int Duration { get; set; }\r\n        public int SlidingDuration { get; set; }\r\n\r\n        public override async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)\r\n        {\r\n            var _cache = context.HttpContext.RequestServices\r\n                .GetService(typeof(IDistributedCache)) as IDistributedCache;\r\n\r\n            this._cacheKey = GetCacheKey(context);\r\n\r\n            var resultStr = await _cache.GetStringAsync(this._cacheKey);\r\n\r\n            if (resultStr != null)\r\n            {\r\n                var result = Newtonsoft.Json.JsonConvert.DeserializeObject\u003CObjectResult\u003E(\r\n                    resultStr\r\n                );\r\n                result.Value = result.Value?.ToString();\r\n                context.Result = result;\r\n                return;\r\n            }\r\n\r\n            await base.OnActionExecutionAsync(context, next);\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Occurs when an action has executed.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022filterContext\u0022\u003EThe filter context.\u003C/param\u003E\r\n        public async override void OnActionExecuted(ActionExecutedContext filterContext)\r\n        {\r\n            if (filterContext.Exception != null || string.IsNullOrWhiteSpace(this._cacheKey))\r\n            {\r\n                return;\r\n            }\r\n\r\n            var _cache = filterContext.HttpContext.RequestServices\r\n                .GetService(typeof(IDistributedCache)) as IDistributedCache;\r\n\r\n            var result = Newtonsoft.Json.JsonConvert.SerializeObject(filterContext.Result);\r\n\r\n            await _cache.SetStringAsync(this._cacheKey, result, new DistributedCacheEntryOptions\r\n            {\r\n                AbsoluteExpirationRelativeToNow = Duration \u003E 0 ? TimeSpan.FromSeconds(Duration) : null,\r\n                SlidingExpiration = SlidingDuration \u003E 0 ? TimeSpan.FromSeconds(SlidingDuration) : null,\r\n            });\r\n        }\r\n\r\n        private string GetCacheKey(ActionExecutingContext context)\r\n        {\r\n            var routeValues = context.RouteData.Values;\r\n            var actionParameters = context.ActionArguments;\r\n            var username = context.HttpContext?.User?.Claims?.FirstOrDefault(o =\u003E o.Type == ClaimTypes.Sid)?.Value;\r\n\r\n            var sb = new StringBuilder(routeValues[\u0022controller\u0022].ToString());\r\n            sb.Append(\u0027_\u0027).Append(routeValues[\u0022action\u0022].ToString());\r\n\r\n            if (!string.IsNullOrWhiteSpace(VaryByParam))\r\n            {\r\n                sb.Append(VaryByParam);\r\n            }\r\n\r\n            if (!string.IsNullOrWhiteSpace(VaryByHeader))\r\n            {\r\n                sb.Append(VaryByHeader);\r\n            }\r\n\r\n            if (!string.IsNullOrWhiteSpace(VaryByQueryKeys))\r\n            {\r\n                sb.Append(VaryByQueryKeys);\r\n            }\r\n\r\n            if (VaryByAuth)\r\n            {\r\n                sb.Append($\u0022U-{username}-\u0022);\r\n            }\r\n\r\n            return sb.ToString();\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060",
        "createdAt": "2021-05-06T11:43:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-833457478"
      },
      {
        "id": "IC_kwDOAQzde85loegc",
        "parentId": null,
        "author": "Ognen67",
        "content": "\u003E The only workaround I\u0027m aware of is kinda to fork MS code \uD83E\uDD37 Even the nice guy I was working with on my proj, after he couldn\u0027t use it b/c of his company rules, said that they were going to use the same approach, namely to reference the MS code with CSPROJ links, to access all the internal classes. There\u0027s a workaround [here](https://github.com/yringler/distributed-middleware-cache), which basically uses the MS code, opens it up, and adds some functionality. I\u0027ve been meaning to get around to updating the docs and republishing a nuget, but haven\u0027t yet. Feel free to take ownership of it!\r\n\r\nDoes this still work now with the Microsoft.AspNetCore.ResponseCaching package Version: 2.2.0 ?",
        "createdAt": "2023-09-04T11:32:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-1705109532"
      },
      {
        "id": "IC_kwDOAQzde85lofUo",
        "parentId": null,
        "author": "martincostello",
        "content": "\u003E Does this still work now with the Microsoft.AspNetCore.ResponseCaching package Version: 2.2.0 ?\r\n\r\nThat NuGet package is deprecated and doesn\u0027t receive updates.\r\n",
        "createdAt": "2023-09-04T11:35:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-1705112872"
      },
      {
        "id": "IC_kwDOAQzde85loihW",
        "parentId": null,
        "author": "Ognen67",
        "content": "\u003E \u003E Does this still work now with the Microsoft.AspNetCore.ResponseCaching package Version: 2.2.0 ?\r\n\u003E \r\n\u003E That NuGet package is deprecated and doesn\u0027t receive updates.\r\n\r\nOkay, thanks for the prompt response.",
        "createdAt": "2023-09-04T11:45:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-1705125974"
      },
      {
        "id": "IC_kwDOAQzde85loioV",
        "parentId": null,
        "author": "Ognen67",
        "content": "Is there another way to achieve the same results as of now?",
        "createdAt": "2023-09-04T11:45:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/2957#issuecomment-1705126421"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3NTY2Mjg5NjU=",
    "title": "SQL Server deadlock with Microsoft.Extensions.Caching.SqlServer",
    "url": "https://github.com/dotnet/aspnetcore/issues/28380",
    "createdAt": "2018-11-14T05:10:56Z",
    "lastUpdated": "2023-06-02T03:14:28Z",
    "body": "We\u0027ve been running into SQL Server deadlocks when using \u0060Microsoft.Extensions.Caching.SqlServer\u0060 for Session State.\r\n\r\nWe went through this before in our ASP.NET apps. It comes down to this query:\r\n\r\nhttps://github.com/aspnet/Caching/blob/c6a7f611fb537cbc58d9ac3bbe0b61fabe79ae8a/src/Microsoft.Extensions.Caching.SqlServer/SqlQueries.cs#L55\r\n\r\n\u0060\u0060\u0060cs\r\npublic const string DeleteExpiredCacheItemsFormat = \u0022DELETE FROM {0} WHERE @UtcNow \u003E ExpiresAtTime\u0022;\r\n\u0060\u0060\u0060\r\n\r\nThis query can easily escalate to a table lock. To reduce the potential of table locks the [recommendation](https://support.microsoft.com/en-us/help/323630/how-to-resolve-blocking-problems-that-are-caused-by-lock-escalation-in) is to perform the deletes in batches. Ex:\r\n\r\n\u0060\u0060\u0060sql\r\nSET ROWCOUNT 50\r\ndelete_more:\r\n     DELETE FROM {0} WHERE @UtcNow \u003E ExpiresAtTime\r\nIF @@ROWCOUNT \u003E 0 GOTO delete_more\r\nSET ROWCOUNT 0\r\n\u0060\u0060\u0060\r\n\r\nIn ASP.NET apps this was very easy to change because these were stored procedures we could change ourselves. In ASP.NET Core the queries are in code and in classes that are not extensible (internal classes).\r\n\r\nPotential for deadlocks is more common in ASP.NET Core than in ASP.NET apps because in ASP.NET apps the delete sessions query used to be a SQL Job performed by just one server, whereas in ASP.NET Core if we have 10 instances of the app running it will be 10 DELETE queries hitting the DB.\r\n\r\nSo my ask is that you make the queries easy to change. In the current state, we pretty much have to reimplement the  \u0060Microsoft.Extensions.Caching.SqlServer\u0060 if we want to change the queries. Maybe the queries can be overriden via \u0060SqlServerCacheOptions\u0060 or at least just this one clean up query.",
    "upvotes": 0,
    "labels": [
      "bug",
      "feature-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY0NzQ0MzUxNg==",
        "parentId": null,
        "author": "elvirdolic",
        "content": "What\u0027s the status of this issue? We are facing same problems with small dtu on azure sql",
        "createdAt": "2020-06-22T10:56:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28380#issuecomment-647443516"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MTk3MzY0MQ==",
        "parentId": null,
        "author": "msmaverick2018",
        "content": "We are curious to know the status of this issue. We are planning to utilize SQL Server for caching and concerned about running into this issue in production. Should we refrain from using this extension until this issue is resolved? \r\n\r\n@epignosisx did you do any workaround for getting around this issue?",
        "createdAt": "2020-07-21T16:43:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28380#issuecomment-661973641"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2NjA3NzQ2Mw==",
        "parentId": null,
        "author": "epignosisx",
        "content": "@msmaverick2018 we disabled this cleanup query (there is a setting you can tweak) and added the optimized query as a SQL job.\n\nUltimately we ended up switching to Redis. Our app used session state heavily and SQL was not able to keep up with 3500 active sessions. DB queries would start to queue and response time would go above 1 sec.\n\nWe spent a lot time trying to make SQL work for us since we had great success in the past with ASP.NET apps. We even forked the repo and modified it to support SQL Server in-memory tables (datetimeoffset datatype is not supported). It helped but it was not enough.\n\nThe reality is that this SQL Server provider is a very simple implementation compared to the SQL Server Session State provider of ASP.NET. I looked into the provider and you could tell a lot of time went into optimizing it.\n\nMoving to Redis fixed all our issues. In our load tests we were able to reach 20K active sessions and Redis didn\u0027t break a sweat.",
        "createdAt": "2020-07-30T03:40:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28380#issuecomment-666077463"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2NjQ5OTM2MA==",
        "parentId": null,
        "author": "msmaverick2018",
        "content": "@epignosisx thanks for responding and the details. Agree with you, at least configuration option should have been provided to override the default DELETE query. Also, if you have a web farm, then each application would fire delete request on 30 min interval to the DB.\r\nWe do not have REDIS available yet in our infrastructure and we are planning to use SQL Server as an interim measure to cache data until we get there. Good to know that in memory tables also did not help, since we were thinking of investing some time in evaluating that approach. Our concurrent load would be around 50 req/sec. \r\n\r\nOne of the things i am curious about is also the table design for the cache, it has a wide primary key on which the clustered index is created. We plan to use guids as keys in our use case and as expected when i load data into the table the clustered index is around 99% fragmented. This would affect I/O and probably query performance, we will load test and evaluate. As of now, thinking of adding index rebuild to the cleanup job. Few queries:\r\n1) Did you guys running into issues with index fragmentation and its impact on performance?\r\n2) How often were you able to run the delete job (using batches) without running into the deadlock issue?",
        "createdAt": "2020-07-30T16:15:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28380#issuecomment-666499360"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2NzI4NjgzNQ==",
        "parentId": null,
        "author": "epignosisx",
        "content": "@msmaverick2018 We did not modified the primary key length because we were caching all sort of things with different key lengths. We modified the datetimeoffset columns to have precision 2 instead of 7. We found that much precision overkill. I would definitely encourage you to modify the table to match your needs.\r\n\r\nWe did not look into index fragmentation, our thought was that since this table had so much volatility it was going to be very hard to have healthy indexes.\r\n\r\nWe were running the delete query every 15 mins which is our average user session.",
        "createdAt": "2020-07-31T18:25:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28380#issuecomment-667286835"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczODM1MTM3Nw==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-12-03T22:08:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28380#issuecomment-738351377"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgwOTM5NDcxMA==",
        "parentId": null,
        "author": "davidfowl",
        "content": "I assume people are still running into this issue?",
        "createdAt": "2021-03-29T13:52:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28380#issuecomment-809394710"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3NTY2MjI0MjM=",
    "title": "Support AccessToken in config for AddDistributedSqlServerCache",
    "url": "https://github.com/dotnet/aspnetcore/issues/28377",
    "createdAt": "2019-02-20T20:35:29Z",
    "lastUpdated": "2023-06-02T03:14:25Z",
    "body": "### Is your feature request related to a problem? Please describe.\r\nI\u0027m trying to setup Distributed SQL Caching so that is uses an AccessToken to connect to an Azure SQL database instead of using other types of credentials.  \r\n\r\n### Describe the solution you\u0027d like\r\nNow that Net Core 2.2 supports the AccessToken property on a SqlConnection, the AddDistributedSqlServerCache extension should be modified to support this as well.  Perhaps an overload could be added that takes in a delegate to retrieve an AccessToken.  The delegate would just need to be a simple factory method that does something like this:\r\n\r\n            var tokenProvider = new AzureServiceTokenProvider();\r\n            var accessToken = tokenProvider.GetAccessTokenAsync(\u0022https://database.windows.net/\u0022).Result;\r\n\r\nIn a web environment, the factory should be scoped to the session.\r\n\r\nOr perhaps even build this AccessToken retrieval into the extension.\r\n\r\n### Describe alternatives you\u0027ve considered\r\nI\u0027ve considered writing my own implementation of IDistributedCache that takes advantage of the AccessToken property but I\u0027m not quite sure how to accomplish it and I don\u0027t have the time right now.  At the moment, I\u0027m just using the classic implementation of the extension which passes in a connection string that is transformed between environments in an Azure Devops pipeline.\r\n\r\n### Additional context\r\n",
    "upvotes": 3,
    "labels": [
      "enhancement",
      "feature-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ3MDMwNjg4OA==",
        "parentId": null,
        "author": "DOMZE",
        "content": "Same problem here. Impossible to pass an access token. How are we supposed to use managed identities otherwise, without overwriting the whole library? Workarounds are appreciated @Eilon ",
        "createdAt": "2019-03-06T22:41:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28377#issuecomment-470306888"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU1Mzg1MTM0Mg==",
        "parentId": null,
        "author": "jacqueskang",
        "content": "Hi, this is a blocking issue for our Azure migration. Since our security team doesn\u0027t accept password-based SQL authentication, we will have to refactor and switch to another caching system.\r\nIt would be nice if this can be solved in both 2.2 and 3.0",
        "createdAt": "2019-11-14T11:42:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28377#issuecomment-553851342"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU1NDQ3NzgyMQ==",
        "parentId": null,
        "author": "Eilon",
        "content": "I realize it\u0027s not ideal, but I think you can re-use a lot of the current cache system logic and probably types, but with a modified copy of the configuration logic. You could use the source code in this repo as a starting point and modify the code that creates the services to support other auth patterns.",
        "createdAt": "2019-11-15T18:35:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28377#issuecomment-554477821"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNTU1Nzg2MA==",
        "parentId": null,
        "author": "??",
        "content": "As part of the migration of components from dotnet/extensions to dotnet/runtime (https://github.com/aspnet/Announcements/issues/411) we will be bulk closing some of the older issues. If you are still interested in having this issue addressed, just comment and the issue will be automatically reactivated (even if you aren\u0027t the author). When you do that, I\u0027ll page the team to come take a look. If you\u0027ve moved on or workaround the issue and no longer need this change, just ignore this and the issue will be closed in **7 days**.\n\nIf you know that the issue affects a package that has moved to a different repo, please consider re-opening the issue in that repo. If you\u0027re unsure, that\u0027s OK, someone from the team can help!",
        "createdAt": "2020-05-08T00:06:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28377#issuecomment-625557860"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNjYxNzExNQ==",
        "parentId": null,
        "author": "yonail",
        "content": "It is still a blocking issue for our Azure migration. Any update when you plan to fix it for .net core 2.2?",
        "createdAt": "2020-05-11T10:27:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28377#issuecomment-626617115"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNjYxNzE0Mw==",
        "parentId": null,
        "author": "??",
        "content": "Paging @dotnet/extensions-migration ! This issue has been revived from staleness. Please take a look and route to the appropriate repository.",
        "createdAt": "2020-05-11T10:27:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28377#issuecomment-626617143"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNjgyODEwMQ==",
        "parentId": null,
        "author": "analogrelay",
        "content": "@yonibauduin .NET Core 2.2 is end of life and no longer supported.\n\nI\u2019ll put this in the queue to consider in 5.0, which is the next opportunity to add functionality requiring new API such as this",
        "createdAt": "2020-05-11T17:02:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28377#issuecomment-626828101"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3MjMzNjIyOQ==",
        "parentId": null,
        "author": "ckrempp91",
        "content": "Is there any update on this?",
        "createdAt": "2020-08-11T22:52:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28377#issuecomment-672336229"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3MzA2MjcyNA==",
        "parentId": null,
        "author": "maryamariyan",
        "content": "I believe this wouldn\u0027t make it to 5.0 as the window for that is closing this week and this is a feature request.",
        "createdAt": "2020-08-12T19:21:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28377#issuecomment-673062724"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3MzYyMjE0OQ==",
        "parentId": null,
        "author": "ckrempp91",
        "content": "If it can\u0027t make it into 5.0, then what is the next release that this can be included?",
        "createdAt": "2020-08-13T17:52:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28377#issuecomment-673622149"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY4NDQ1NjM0OA==",
        "parentId": null,
        "author": "Nisden",
        "content": "Wow, this is still unsupported... :\u0027(",
        "createdAt": "2020-09-01T06:36:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28377#issuecomment-684456348"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczNDM3OTkzNg==",
        "parentId": null,
        "author": "paul-oleary",
        "content": "\u002B1\r\n\r\nThis is a blocker for us disabling SQL authentication on our database",
        "createdAt": "2020-11-26T16:05:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28377#issuecomment-734379936"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczODM0MzcwOA==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-12-03T21:57:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28377#issuecomment-738343708"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc0NDM2Njk5MQ==",
        "parentId": null,
        "author": "Nisden",
        "content": "With the addition of https://github.com/dotnet/SqlClient/pull/730 explicit support for AccessToken is no longer required, as the SqlConnection can handle this on its own. Just be aware that its currently a little broken https://github.com/dotnet/SqlClient/issues/815",
        "createdAt": "2020-12-14T11:08:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28377#issuecomment-744366991"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc5MTQ4MjI0OA==",
        "parentId": null,
        "author": "hugoqribeiro",
        "content": "While a better solution is not designed, wouldn\u0027t it be possible to at least provide a delegate on SqlServerCacheOptions to manipulate the SqlConnection?",
        "createdAt": "2021-03-05T15:14:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28377#issuecomment-791482248"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0MTg1OTAxNTk=",
    "title": "Invalid pathBase in RedirectRule",
    "url": "https://github.com/dotnet/aspnetcore/issues/8310",
    "createdAt": "2019-03-08T01:25:15Z",
    "lastUpdated": "2023-08-28T23:10:14Z",
    "body": "### Describe the bug\r\nI found a bug about pathBase in RedirectRule class. (namespace: Microsoft.AspNetCore.Rewrite.Internal)\r\nIf I use pathBase in my project and set an absolute URL to the replacement parameter, an error occurs.\r\n\r\n### To Reproduce\r\nSteps to reproduce the behavior:\r\n1. Using this version of ASP.NET Core App \u00272.2.0\u0027\r\n2. Run this code\r\n\r\n        public async Task CheckRewritePath(string pathBase, string regex, string replacement, string expected)\r\n        {\r\n            // Arrange\r\n            var options = new RewriteOptions().Add(new RedirectRule(regex, replacement, StatusCodes.Status302Found));\r\n            var builder = new WebHostBuilder().Configure(app =\u003E { app.UsePathBase(pathBase); app.UseRewriter(options); });\r\n            var server = new TestServer(builder);\r\n\r\n            // Act\r\n            var response = await server.CreateClient().GetAsync(pathBase \u002B \u0022/\u0022 \u002B regex);\r\n\r\n            // Assert\r\n            Assert.Equal(expected, response.Headers.Location.OriginalString);\r\n        }\r\n3. With these arguments\r\n        [Theory]\r\n        [InlineData(\u0022/Test\u0022, \u0022RedirectRule1\u0022, \u0022https://localhost/Test/Home/Index\u0022, \u0022https://localhost/Test/Home/Index\u0022)]\r\n        [InlineData(\u0022/Test\u0022, \u0022RedirectRule2\u0022, \u0022/Home/Index\u0022, \u0022/Test/Home/Index\u0022)]\r\n        [InlineData(\u0022/Test\u0022, \u0022RedirectRule3\u0022, \u0022Home/Index\u0022, \u0022/Test/Home/Index\u0022)]\r\n4. See error\r\nrespons.Headers.Location.OrinalString returned /Testhttps://localhost/Test/RedirectRule \r\n\r\n### Expected behavior\r\nI expected to redirect absolute URL.\r\nex) https://localhost/Test/Home/Index\r\n\r\n### Screenshots\r\n![image](https://user-images.githubusercontent.com/8253350/53999829-475ac700-4188-11e9-97fd-094195e18161.png)\r\n",
    "upvotes": 0,
    "labels": [
      "bug",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ3NDAyMTU4NQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@jkotalik ",
        "createdAt": "2019-03-18T17:31:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/8310#issuecomment-474021585"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0MzgxMDc0MzM=",
    "title": "Review AsyncLocals (HeaderPropagation and Action context)",
    "url": "https://github.com/dotnet/aspnetcore/issues/9813",
    "createdAt": "2019-04-28T22:32:15Z",
    "lastUpdated": "2023-08-28T23:10:13Z",
    "body": "Recently merged #9370 included a new use of an async local. Prompting me to search this repo for other uses, only to happily conclude there\u0027s not many outside tests. You have #9370, an optional ActionContextAccessor and some for what looks like razor things and the well known HttpContextAccessor.\r\n\r\nAre these first two async locals not better expressed as fetching features or info from HttpContext? That would mean small changes of replacing them with a dependency on HttpContextAccessor instead. \r\n\r\nLifetime being the only open question here. Would their behavior become invalid when strictly scoped to request lifetime as HttpContextAccessor is?",
    "upvotes": 0,
    "labels": [
      "Perf",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ4NzQyNzA4Mw==",
        "parentId": null,
        "author": "benaadams",
        "content": "Also:\r\n\r\n[\u0060Activity.Current\u0060](https://github.com/dotnet/corefx/blob/81c8c68d81daad033251d643e230061f38a9ae3a/src/System.Diagnostics.DiagnosticSource/src/System/Diagnostics/Activity.Current.net46.cs#L33) which [gets set in Hosting](https://github.com/aspnet/AspNetCore/blob/8e37f8477d51221369bcaceb4316f79cbb2854e8/src/Hosting/Hosting/src/Internal/HostingApplicationDiagnostics.cs#L235-L277) when logging is enabled.\r\n\r\n[LoggerExternalScopeProvider](https://github.com/aspnet/Extensions/blob/55518d79834d3319c91f40b449d028338b129ed6/src/Logging/Logging.Abstractions/src/LoggerExternalScopeProvider.cs#L14) when a logging scope is set.\r\n\r\n[CacheEntryHelper](https://github.com/aspnet/Extensions/blob/aabe8c34a62786c313e20125d70b36d3c5e72a75/src/Caching/Memory/src/CacheEntryHelper.cs) not sure when.\r\n\r\n[JSRuntime](https://github.com/aspnet/Extensions/blob/c1d8be8b980de62a299958e1816f06a81fea07bb/src/JSInterop/Microsoft.JSInterop/src/JSRuntime.cs) not sure when.",
        "createdAt": "2019-04-29T00:09:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9813#issuecomment-487427083"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ4NzQyODIxNw==",
        "parentId": null,
        "author": "benaadams",
        "content": "If you set \u0060Thread.CurrentPrincipal\u0060 that will be another; so don\u0027t do that ;)\r\n\r\nIf you set \u0060Thread.CurrentCulture\u0060 that will be another; better to flow these via a request feature\r\n\r\n",
        "createdAt": "2019-04-29T00:26:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9813#issuecomment-487428217"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ4NzQyOTA0OQ==",
        "parentId": null,
        "author": "benaadams",
        "content": "In 3.0 use of \u0060BinaryFormatter\u0060 will create one via Serialization Guard; but no one is using BinaryFormatter #amirite?\r\n\r\n\u0060System.Transactions.Transaction\u0060 uses them, but again uncommon, and \u0060AssemblyLoadContext\u0060 but probably also uncommon in usage.\r\n\r\n ",
        "createdAt": "2019-04-29T00:39:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9813#issuecomment-487429049"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ4ODQ2MDkyNA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "HeaderPropagation was a case where we expected it to be used in a multi-threaded way so direct access to HttpContext was not an option (HttpContext is not thread safe).",
        "createdAt": "2019-05-01T22:24:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9813#issuecomment-488460924"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ4ODU0MjYwNQ==",
        "parentId": null,
        "author": "benaadams",
        "content": "Can do something like https://github.com/aspnet/AspNetCore/pull/9908 for HeaderPropagation ",
        "createdAt": "2019-05-02T03:30:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/9813#issuecomment-488542605"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3NTY2MTk4ODA=",
    "title": "[StackExchange.Redis] Add DefaultReadCommandFlag into RedisCacheOptions for read operations",
    "url": "https://github.com/dotnet/aspnetcore/issues/28375",
    "createdAt": "2019-05-14T19:12:53Z",
    "lastUpdated": "2023-10-28T14:09:15Z",
    "body": "### Is your feature request related to a problem? Please describe.\r\nI am trying to hookup \u0060RedisCache\u0060 to multiple nodes in AWS ElastiCache. I have 1 primary node and _n_ replication nodes. Currently when configuring \u0060RedisCacheOptions.ConfigurationOptions\u0060 with multiple \u0060Endpoint\u0060s, \u0060RedisCache\u0060 doesn\u0027t read from the replication nodes.\r\n\r\n### Describe the solution you\u0027d like\r\nIn StackExchange.Redis there is a \u0060CommandFlags\u0060 enum that will allow us to \u0060PreferSlave\u0060. I would like to add another property along the lines of \u0060DefaultReadCommandFlag\u0060 to \u0060RedisCacheOptions\u0060 for read commands. This will allow us to specify \u0060PreferSlave\u0060 and distribute load across the replication nodes.\r\n\r\nCommand Flags: https://github.com/StackExchange/StackExchange.Redis/blob/c72ffa8413572262b8eb9f8f4e0c5da07f856359/src/StackExchange.Redis/Enums/CommandFlags.cs#L27-L47",
    "upvotes": 2,
    "labels": [
      "enhancement",
      "feature-caching",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMTg1OTI0MQ==",
        "parentId": null,
        "author": "Vandersteen",
        "content": "What is the status on this one ?\r\nWe are having similar issues. I wouldn\u0027t mind creating a PR for this if the proposed solution is acceptable.",
        "createdAt": "2019-06-13T20:06:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28375#issuecomment-501859241"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwNjA0MjYxMQ==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Seems reasonable to me. A PR would be reasonable, but we are starting to lock public APIs for 3.0 and don\u0027t have a place for post-3.0 contributions right now, so I don\u0027t think we have a good branch in which to accept this change.",
        "createdAt": "2019-06-26T21:00:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28375#issuecomment-506042611"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNTU1NzQ3Mg==",
        "parentId": null,
        "author": "??",
        "content": "As part of the migration of components from dotnet/extensions to dotnet/runtime (https://github.com/aspnet/Announcements/issues/411) we will be bulk closing some of the older issues. If you are still interested in having this issue addressed, just comment and the issue will be automatically reactivated (even if you aren\u0027t the author). When you do that, I\u0027ll page the team to come take a look. If you\u0027ve moved on or workaround the issue and no longer need this change, just ignore this and the issue will be closed in **7 days**.\n\nIf you know that the issue affects a package that has moved to a different repo, please consider re-opening the issue in that repo. If you\u0027re unsure, that\u0027s OK, someone from the team can help!",
        "createdAt": "2020-05-08T00:04:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28375#issuecomment-625557472"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNTYxNDY2OA==",
        "parentId": null,
        "author": "jonathann92",
        "content": "Hi I would still like to have this issue addressed please.",
        "createdAt": "2020-05-08T03:48:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28375#issuecomment-625614668"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNTYxNDY3Nw==",
        "parentId": null,
        "author": "??",
        "content": "Paging @dotnet/extensions-migration ! This issue has been revived from staleness. Please take a look and route to the appropriate repository.",
        "createdAt": "2020-05-08T03:48:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28375#issuecomment-625614677"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczODM0MjA0Ng==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-12-03T21:53:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28375#issuecomment-738342046"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0NDQ2ODAzODg=",
    "title": "Profile/Benchmark ForwardedHeadersMiddleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/10276",
    "createdAt": "2019-05-15T22:54:32Z",
    "lastUpdated": "2023-08-28T23:10:12Z",
    "body": "https://github.com/aspnet/AspNetCore/pull/10273#discussion_r284474884\r\n\r\nIt was already added to the pipeline by default for IIS out-of-proc, but now we\u0027re adding it for Azure App Services Linux scenarios.",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "Perf",
      "severity-nice-to-have",
      "affected-few",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "MDU6SXNzdWU0NDQ4NzYwMTk=",
    "title": "ResponseCachingKeyProvider Performance Optimisations",
    "url": "https://github.com/dotnet/aspnetcore/issues/10290",
    "createdAt": "2019-05-16T10:26:14Z",
    "lastUpdated": "2023-08-28T23:10:12Z",
    "body": "\u003E tl;dr; This is a query about whether the team would accept performance optimisations for the \u0060ResponseCachingKeyProvider\u0060 \u0026 related components?\r\n\r\nI\u0027ve recently been playing around with String.Create for an upcoming blog post and I remembered a discussion with @rynowak about ObjectPool being used to pool StringBuilder instances for some of the ASP.NET Core middleware.\r\n\r\nOne example I found is in [ResponseCachingKeyProvider](https://github.com/aspnet/AspNetCore/blob/master/src/Middleware/ResponseCaching/src/Internal/ResponseCachingKeyProvider.cs)\r\n\r\nJust for my own curiosity, I had a play with a new version of \u0060CreateBaseKey\u0060 which doesn\u0027t require a StringBuilder and uses String.Create instead. My theory is that with the other methods updated also (if possible) then maybe the need to depend on an ObjectPoolProvider and StringBuilderPool could be removed?\r\n\r\nI did a very quick and basic version using String.Create and benchmarked it with the following results...\r\n\r\n\u0060\u0060\u0060\r\n|         Method |     Mean |     Error |    StdDev |  Gen 0 | Gen 1 | Gen 2 | Allocated |\r\n|--------------- |---------:|----------:|----------:|-------:|------:|------:|----------:|\r\n| GetKeyOriginal | 435.5 ns | 8.2836 ns | 8.1356 ns | 0.0191 |     - |     - |     120 B |\r\n|      GetKeyNew | 341.1 ns | 0.6806 ns | 0.5313 ns | 0.0191 |     - |     - |     120 B |\r\n\u0060\u0060\u0060\r\n\r\nIs there any value in pursuing this for this provider and perhaps others as part of the on-going performance work? If so, I\u0027d be keen to try and spend a little time looking deeper on this particular feature. Note that the code is untested and just a proof of concept at this point.\r\n\r\nPerhaps @davidfowl and @benaadams also have some thoughts on the value of this?\r\n\r\nFor completeness, my rough code used for the benchmark:\r\n\r\n\u0060\u0060\u0060csharp\r\npublic string CreateBaseKeyStringCreate(ResponseCachingContext context)\r\n{\r\n\tif (context == null)\r\n\t{\r\n\t\tthrow new ArgumentNullException(nameof(context));\r\n\t}\r\n\r\n\tvar request = context.HttpContext.Request;\r\n\r\n\tvar length = request.Method.Length \u002B\r\n\t\t\t\t 1 \u002B\r\n\t\t\t\t request.Scheme.Length \u002B\r\n\t\t\t\t 1 \u002B\r\n\t\t\t\t request.Host.Value.Length \u002B\r\n\t\t\t\t request.PathBase.Value.Length \u002B\r\n\t\t\t\t request.Path.Value.Length;\r\n\r\n\tvar key = string.Create(length, (request, _options), (chars, state) =\u003E \r\n\t{\r\n\t\tvar (request, options) = state;\r\n\t\tvar position = 0;\r\n\r\n\t\trequest.Method.AsSpan().ToUpperInvariant(chars);\r\n\t\tposition \u002B= request.Method.Length;\r\n\r\n\t\tchars[position\u002B\u002B] = KeyDelimiter;\r\n\r\n\t\trequest.Scheme.AsSpan().ToUpperInvariant(chars.Slice(position));\r\n\t\tposition \u002B= request.Scheme.Length;\r\n\r\n\t\tchars[position\u002B\u002B] = KeyDelimiter;\r\n\r\n\t\trequest.Host.Value.AsSpan().ToUpperInvariant(chars.Slice(position));\r\n\t\tposition \u002B= request.Host.Value.Length;\r\n\r\n\t\tvar pathBaseSpan = request.PathBase.Value.AsSpan();\r\n\t\tvar pathSpan = request.Path.Value.AsSpan();\r\n\r\n\t\tif (options.UseCaseSensitivePaths)\r\n\t\t{\r\n\t\t\tpathBaseSpan.ToUpperInvariant(chars.Slice(position));\r\n\t\t\tposition \u002B= pathBaseSpan.Length;\r\n\r\n\t\t\tpathSpan.ToUpperInvariant(chars.Slice(position));\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tpathBaseSpan.CopyTo(chars.Slice(position));\r\n\t\t\tposition \u002B= pathBaseSpan.Length;\r\n\r\n\t\t\tpathSpan.CopyTo(chars.Slice(position));\r\n\t\t}\r\n\t});\r\n\r\n\treturn key;\r\n}\r\n\u0060\u0060\u0060",
    "upvotes": 4,
    "labels": [
      "enhancement",
      "severity-nice-to-have",
      "affected-very-few",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzA5NjQzNg==",
        "parentId": null,
        "author": "rynowak",
        "content": "Generally perf improvments are something we want, especially if it\u0027s something that runs during request processing \uD83D\uDC4D \r\n\r\n\r\n@Tratcher @anurse - who can help steve figure out if this is a good approach?",
        "createdAt": "2019-05-16T14:41:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10290#issuecomment-493096436"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzEwODExNQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@JunTaoLuo ",
        "createdAt": "2019-05-16T15:09:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10290#issuecomment-493108115"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzE1NDMyOA==",
        "parentId": null,
        "author": "analogrelay",
        "content": "@rynowak is right, perf gains are generally awesome as long as they don\u0027t introduce large amounts of complexity (and even then it\u0027s a matter of risk/cost vs. reward). Switching from pooled StringBuilders to String.Create seems reasonable to me. I think the next step would be a PR to show the code change. If you don\u0027t want to iterate fully and produce a \u0022production-ready\u0022 PR but could hack something together that shows the approach you could throw a Draft PR up and put me, @Tratcher, @davidfowl and @JunTaoLuo as reviewers.\r\n\r\nIncluding a benchmark in the PR and the results of said benchmark would also be good in order to show the hard data that illustrates the improvement.",
        "createdAt": "2019-05-16T17:13:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10290#issuecomment-493154328"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzE1NDg1Nw==",
        "parentId": null,
        "author": "davidfowl",
        "content": "This looks pretty nice! We should avoid object pooling at all costs if we can find a simple alternative like this.",
        "createdAt": "2019-05-16T17:14:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10290#issuecomment-493154857"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzE1NjY5OA==",
        "parentId": null,
        "author": "stevejgordon",
        "content": "Thanks, @anurse and co! I\u0027m happy to take a look at this over the next week or so and get a PR pushed with some changes. I grabbed the code to a local solution just for this hack. I\u0027ll try to get the repo building properly if possible.",
        "createdAt": "2019-05-16T17:19:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10290#issuecomment-493156698"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzE1ODE2MQ==",
        "parentId": null,
        "author": "analogrelay",
        "content": "If you get stuck, feel free to open a draft PR and mention that you\u0027re stuck on some issue. As long as you don\u0027t need to add new projects it should be simple, adding new projects is [non-trivial but not too hard](https://github.com/aspnet/AspNetCore/blob/master/docs/ReferenceResolution.md).",
        "createdAt": "2019-05-16T17:23:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10290#issuecomment-493158161"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzE2MTMxNw==",
        "parentId": null,
        "author": "JunTaoLuo",
        "content": "Looks good, I can review the PR when it\u0027s ready.",
        "createdAt": "2019-05-16T17:32:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10290#issuecomment-493161317"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzIxNzA5OQ==",
        "parentId": null,
        "author": "stevejgordon",
        "content": "@anurse, with regards to including benchmarks. Is there a standard preferred approach? Or would just including a console app for now be fine? Presumably can remove before merging.",
        "createdAt": "2019-05-16T20:19:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10290#issuecomment-493217099"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzI0NzA4NA==",
        "parentId": null,
        "author": "analogrelay",
        "content": "We use [BenchmarkDotNet](https://github.com/dotnet/BenchmarkDotNet). A microbenchmark would probably be sufficient here. If there isn\u0027t already a project near the response caching project that\u0027s a bit unfortunate. Here\u0027s an example of one: https://github.com/aspnet/AspNetCore/tree/master/src/Http/perf/Microbenchmarks",
        "createdAt": "2019-05-16T22:01:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10290#issuecomment-493247084"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5MzQwMjkwMA==",
        "parentId": null,
        "author": "stevejgordon",
        "content": "I\u0027ll add a perf folder and a BenchmarkDotNet project for this.",
        "createdAt": "2019-05-17T10:17:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10290#issuecomment-493402900"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NTE5NTcxOQ==",
        "parentId": null,
        "author": "stevejgordon",
        "content": "A small update on this. I\u0027ve progressed with adding a benchmark project and an optimised version of the code. The saving for \u0060CreateBaseKeyStringCreate\u0060 is evident but the gain is a little less than my original test. \r\n\r\nI\u0027m working through a version of \u0060CreateStorageVaryByKey\u0060 too which so far allocates a little less, but is slower as there\u0027s more upfront work to calculate the length. I\u0027m going to play with that some more and see if there are better options.\r\n\r\nI\u0027ll be on vacation for a week or so from this weekend so I\u0027ll likely spend more time on this when I\u0027m back.",
        "createdAt": "2019-05-23T12:22:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10290#issuecomment-495195719"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NzE1Mzg0NQ==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Putting this in the backlog since we don\u0027t plan to do optimization ourselves here in 3.0. Definitely still interested in a PR any time you\u0027re ready!",
        "createdAt": "2019-05-30T00:16:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10290#issuecomment-497153845"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0NDUxMTE1NzU=",
    "title": "Have ForwardedHeaders send 400 responses for bad/missing forwarders",
    "url": "https://github.com/dotnet/aspnetcore/issues/10302",
    "createdAt": "2019-05-16T19:01:18Z",
    "lastUpdated": "2024-03-02T00:45:19Z",
    "body": "Today the ForwardedHeadersMiddleware no-ops if the expected headers are missing or invalid. For our common use cases though, we expect the headers to always be there or else the proxy is misconfigured (or the request is coming from a potentially malicious side-channel?). In these scenarios it makes sense to reject the request as invalid (400).\r\n\r\nThis would be optional and only enabled for our known scenarios (IIS out-of-proc, Azure Linux, Nginx \u0026 Apache docs, etc.) because we don\u0027t know how other customers may be using it.\r\n\r\nCompare to the HostFitlering middleware that sends a 400 and an optional HTML message.\r\n\r\nDesign note: Rather than making this a bool option, consider a ForwardMinimum count that would mirror the existing ForwardLimit. E.g. There must be at least ForwardMinimum headers applied or else we fail the request. However, for all of our usages this minimum would be 1 (ForwardLimit also defaults to 1). The default would be 0.\r\n\r\n@blowdart @davidfowl \r\n",
    "upvotes": 0,
    "labels": [
      "bug",
      "affected-few",
      "severity-minor",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgwMjkyNzA1Nw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Here\u0027s are some test cases from another report:\r\n\u0060\u0060\u0060\r\nX-Forwarded-For: \u00222.2.2.2, 1.1.1.1\r\nX-Forwarded-For: 2.2.2.2\u0022, 1.1.1.1\r\nX-Forwarded-For: 2.2\u00222.2, 1.1.1.1\r\n\u0060\u0060\u0060\r\nThe unpaired quote invalidates the whole header, not just the first value. See IHeaderDictionary.[GetCommaSeperatedValues](https://github.com/dotnet/aspnetcore/blob/36e5113de354b18a88113021996d0cad3e919867/src/Http/Http.Abstractions/src/Extensions/HeaderDictionaryExtensions.cs#L42).\r\n\r\nBumping from backlog for re-triage. @blowdart wants this fixed in 6.0.",
        "createdAt": "2021-03-19T15:45:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10302#issuecomment-802927057"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgwMzExMDE4OA==",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\nWe\u0027re moving this issue to the \u0060Next sprint planning\u0060 milestone for future evaluation / consideration. We will evaluate the request when we are planning the work for the next milestone. To learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-03-19T20:34:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10302#issuecomment-803110188"
      },
      {
        "id": "IC_kwDOAQzde841ImnY",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-08-03T01:51:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10302#issuecomment-891447768"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0NTA5MzE0MDk=",
    "title": "Measure overhead of Request Queuing middleware in Plaintext benchmark",
    "url": "https://github.com/dotnet/aspnetcore/issues/10704",
    "createdAt": "2019-05-31T18:40:33Z",
    "lastUpdated": "2023-08-28T23:10:10Z",
    "body": "Epic #10702 \r\n\r\nWe should measure the impact of the Request Queuing middleware in the Plaintext benchmark. We may need to tune the queue depth and concurrent request limit numbers as part of this.",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NzgxODgxMw==",
        "parentId": null,
        "author": "analogrelay",
        "content": "FYI @sebastienros (just a heads-up that @DylanDmitri may be coming your way to find out a bit more about our benchmarks later on)",
        "createdAt": "2019-05-31T18:41:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10704#issuecomment-497818813"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDQ5NzgxOTYyNA==",
        "parentId": null,
        "author": "sebastienros",
        "content": "I think I mentioned benchmarking to him, but didn\u0027t realize he had no idea what we can do already ;)",
        "createdAt": "2019-05-31T18:43:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/10704#issuecomment-497819624"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0NTA5MzIxNzU=",
    "title": "Request Queuing middleware should emit Event Counters",
    "url": "https://github.com/dotnet/aspnetcore/issues/10705",
    "createdAt": "2019-05-31T18:42:39Z",
    "lastUpdated": "2023-08-28T23:10:10Z",
    "body": "Epic #10702 \r\n\r\nWe want to emit event counters similar to the \u0022Requests Queued\u0022 Performance Counter in ASP.NET 4.x. I suggest:\r\n\r\n* Requests in Queue\r\n* Requests Currently Executing\r\n* Average time spent in queue\r\n\r\ncc @shirhatti (PM for Event Counters)",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "affected-few",
      "severity-minor",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "MDU6SXNzdWU0NTA5MzI2NTU=",
    "title": "Performance exploration in Request Queuing middleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/10706",
    "createdAt": "2019-05-31T18:43:57Z",
    "lastUpdated": "2023-08-28T23:10:09Z",
    "body": "Epic #10702 \r\n\r\nAfter #10703 and #10704, we\u0027ll have data to dive deeper into performance. Let\u0027s do some profiling and see if there are things we can do to make this as fast as possible. Also, we can do memory profiling to see if there are allocations to be removed (@davidfowl \u0027s favorite subject ;)).",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "severity-nice-to-have",
      "affected-very-few",
      "feature-rate-limit",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "MDU6SXNzdWU0NTc2MzQ5MDI=",
    "title": "Add benchmark scenarios to illustrate where Request Queuing benefits",
    "url": "https://github.com/dotnet/aspnetcore/issues/11339",
    "createdAt": "2019-06-18T18:37:34Z",
    "lastUpdated": "2023-08-28T23:10:08Z",
    "body": "Epic https://github.com/aspnet/AspNetCore/issues/10702\r\n\r\nIn general, we need scenarios that trigger thread-pool starvation (blocking thread-pool threads is the most common trigger). We suspect that I/O bound work won\u0027t necessarily improve RPS, but would improve memory usage. CPU bound work would likely improve RPS by reducing thread context switches.\r\n\r\nWe should evaluate both kinds of scenarios (I/O bound can be simulated with \u0060Thread.Sleep\u0060, CPU bound can be simulated by spinning the CPU).",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMzI2NDAwMw==",
        "parentId": null,
        "author": "benaadams",
        "content": "\u003E I/O bound can be simulated with \u0060Thread.Sleep\u0060\r\n\r\nWould simulate sync blocking; though if you wanted sync-over-async starvation (double speed) \u0060Task.Delay(nnn).Wait()\u0060 would be better",
        "createdAt": "2019-06-18T18:48:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11339#issuecomment-503264003"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwMzI5NzQ1Ng==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Ah yeah, because of ye olde \u0022need a thread to wake the thread\u0022. Good point.",
        "createdAt": "2019-06-18T20:24:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11339#issuecomment-503297456"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0NTgxMjkzNzk=",
    "title": "Convert existing middleware to use pipes",
    "url": "https://github.com/dotnet/aspnetcore/issues/11377",
    "createdAt": "2019-06-19T17:14:56Z",
    "lastUpdated": "2023-08-28T23:10:08Z",
    "body": "Now that we expose pipes from the request/response body we should consider converting additional middleware and components to use it:\r\n\r\n(This may be affected/invalidated by plans to unify Pipes and Stream)\r\n\r\n* Response Caching\r\n* Response Compression - Requires support for Pipes in the compression APIs\r\n* Form/Multipart reader\r\n* Request Buffering",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "affected-few",
      "severity-minor",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwNTA3MDE3Mw==",
        "parentId": null,
        "author": "jkotalik",
        "content": "@glennc IIRC there was a community member you talked to that was interested in this.",
        "createdAt": "2019-06-24T15:52:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11377#issuecomment-505070173"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxMDk0NzI0NA==",
        "parentId": null,
        "author": "realmont",
        "content": "I don\u0027t know what I do",
        "createdAt": "2019-07-12T16:20:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11377#issuecomment-510947244"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyNTY5MTEwOA==",
        "parentId": null,
        "author": "SARAVANA1501",
        "content": "Hi I would like to work on this issue, Can anyone explain me more?",
        "createdAt": "2019-08-28T10:51:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11377#issuecomment-525691108"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyNjI2NDE0Mw==",
        "parentId": null,
        "author": "jkotalik",
        "content": "@SARAVANA1501 so one place to look as an example is the updated for 3.0: https://github.com/aspnet/AspNetCore/blob/master/src/Http/WebUtilities/src/FormPipeReader.cs. This uses pipelines internally to reduce allocations when parsing a form. This doc will also give some background: https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/request-response?view=aspnetcore-3.0. ",
        "createdAt": "2019-08-29T16:32:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11377#issuecomment-526264143"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU0MDY2Mjg2Nw==",
        "parentId": null,
        "author": "gilmishal",
        "content": "Does this issue still need help or were there any changes in the last few months? I want to start contributing and it seems like a straightforward issue to start working on. ",
        "createdAt": "2019-10-10T16:19:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11377#issuecomment-540662867"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU0MDY4OTE2MQ==",
        "parentId": null,
        "author": "analogrelay",
        "content": "It\u0027s still an issue we\u0027d consider PRs for. Some of the components are not updated to use pipes. I don\u0027t know that I\u0027d say it\u0027s straightforward (probably shouldn\u0027t have the \u0022good first issue\u0022 label, I\u0027ll fix that) since it requires an understanding of the System.IO.Pipelines API and how it differs from System.IO.Stream.\r\n\r\nIf you\u0027re interested in looking at it, we can help out though! I just want to set the context that it may take quite a bit of back-and-forth and time to get it merged.",
        "createdAt": "2019-10-10T17:26:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11377#issuecomment-540689161"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU0MTQwOTEyOA==",
        "parentId": null,
        "author": "gilmishal",
        "content": "Ok, I will read more about System.IO.Pipelines, and will probably start with a PR for Form/Multipart readers over the next few days. ",
        "createdAt": "2019-10-13T11:10:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11377#issuecomment-541409128"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU0MTQzMDM4MA==",
        "parentId": null,
        "author": "gilmishal",
        "content": "Ok, Looked through the code for MultipartReader - I guess I should create a new MultipartPipeReader class and use the new _request.BodyReader - and replace the MultipartReader class with MultipartPipeReader that I had created.\r\n\r\nObviously I should recreate all the relevant tests as well, I will use FormPipeReader as reference.\r\n\r\nI would prefer to start working on the MultipartPipeReader class and create a pull request with what I had created to make sure with you guys that I am on the right track, and then I will create the Tests.\r\n\r\nIt totally depends on you though, if you want to review the pull request when it\u0027s finished including tests that\u0027s fine too.",
        "createdAt": "2019-10-13T15:51:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11377#issuecomment-541430380"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU0MTQ0MzA2NA==",
        "parentId": null,
        "author": "davidfowl",
        "content": "The multipart reader is a good one. You can make a draft PR without tests to get design feedback ",
        "createdAt": "2019-10-13T18:17:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11377#issuecomment-541443064"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU0MTQ5NDE5OQ==",
        "parentId": null,
        "author": "jkotalik",
        "content": "And we will definitely take an external contribution for the multipart reader. The man reason we want to do these refactors is for performance; we definitely want to make sure the performance is better in the new MultipartReader than the previous one. \r\n\r\nHowever, feel free to just make the draft PR first.",
        "createdAt": "2019-10-14T03:44:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11377#issuecomment-541494199"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU0MjIwNDMyNQ==",
        "parentId": null,
        "author": "gilmishal",
        "content": "Looking in a bit more it seems I should use the \u0060ParseFormValuesFast/ParseFormValuesSlow\u0060 from FormPipeReader in some way to read the headers - I am still not sure how it works since I am very new to all the Span related things. But I think it would make sense to create a utility Class to hold these functions, rather than having them as private functions.",
        "createdAt": "2019-10-15T13:12:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11377#issuecomment-542204325"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU1MjIyODI5NQ==",
        "parentId": null,
        "author": "alefranz",
        "content": "I had a look at migrating the \u0060ResponseCaching\u0060 middleware, however I am struggling to find the correct design to intercept the response without using a stream. I\u0027ve opened #16961 for discussion.\r\n",
        "createdAt": "2019-11-10T20:01:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11377#issuecomment-552228295"
      },
      {
        "id": "IC_kwDOAQzde843KT8G",
        "parentId": null,
        "author": "carlossanlop",
        "content": "\u003E Response Compression - Requires support for Pipes in the compression APIs\r\n\r\n@anurse @davidfowl It sounds like there\u0027s a missing feature we need to add to dotnet/runtime first. Can someone please add a bug in that repo with the details/requirements? I can help champion it if there\u0027s the need to propose new APIs.",
        "createdAt": "2021-09-23T01:46:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11377#issuecomment-925449990"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0NjE2MDM5NTA=",
    "title": "HttpMethodOverrideMiddleware is missing HEAD on GET requests.",
    "url": "https://github.com/dotnet/aspnetcore/issues/11654",
    "createdAt": "2019-06-27T15:40:34Z",
    "lastUpdated": "2023-08-28T23:10:07Z",
    "body": "As of right now, the [**HttpMethodOverrideMiddleware**](https://github.com/aspnet/AspNetCore/blob/c95ee2b051814b787b07f55ff224d03d550aafeb/src/Middleware/HttpOverrides/src/HttpMethodOverrideMiddleware.cs) only support overriding methods for \u0060POST\u0060 requests, and when the method is overridable by a \u0060HEAD\u0060 method the body is still returned.\r\n\r\nCurrently kestrel prevents body writing to \u0060HEAD\u0060 requests but since method overriding happens later in a middleware, Kestrel has no chance to prevent the output.\r\n\r\nUnfortunately there are some clients that doesn\u0027t support \u0060HEAD\u0060 verb and there are 2 issues with the current **HttpMethodOverrideMiddleware**\r\n\r\n1. Only support override for \u0060POST\u0060 verbs while \u0060HEAD\u0060 should be allowed on ANY type of request.\r\n2. It doesn\u0027t prevent body writing on \u0060HEAD\u0060.\r\n\r\nTo solve both issue I propose the following change to \u0060HttpMethodOverrideMiddleware\u0060 \u0060Invoke\u0060 method:\r\n\r\n\u0060\u0060\u0060c#\r\npublic async Task Invoke(HttpContext context)\r\n{\r\n    var xHttpMethodOverrideValue = context.Request.Headers[xHttpMethodOverride];\r\n    // New path that checks explicitly for HEAD verb.\r\n    if (string.Equals(xHttpMethodOverrideValue, HttpMethods.Head, StringComparison.OrdinalIgnoreCase))\r\n    {\r\n        context.Request.Method = HttpMethods.Head;\r\n        // Prevents body to include data, this also sets Content-Length to 0.\r\n        context.Response.Body = Stream.Null;\r\n    }\r\n    // Previous behavior.\r\n    else if (string.Equals(context.Request.Method, \u0022POST\u0022, StringComparison.OrdinalIgnoreCase))\r\n    {\r\n        // ... current code\r\n    }\r\n    await _next(context);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nIf there\u0027s interest in updating the current middleware I can submit a PR\r\n",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "affected-few",
      "severity-minor",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwNjUwMTUzNA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "It\u0027s not going to be that simple. The server has expectations based on the method and overriding the method is likely to cause the app to violate those expectations.\r\n\r\nContent-Length Example:\r\nRequest:\r\nGET [URL]\r\nx-Http-Method-Override: HEAD\r\n\r\nResponse:\r\n200 OK\r\nContent-Length: 200\r\n\r\nAt this point the server is expecting the app to provide 200 bytes or else it\u0027s an error and it will abort the connection. The client is also expecting 200 bytes, or else it\u0027s ambiguous when the next response starts.\r\n\r\nThese scenarios might work:\r\n- If the app ignores the method override and sends the body (with or without content-length). This is pretty common behavior, that\u0027s why kestrel suppresses the response body.\r\n- If the app doesn\u0027t specify the Content-Length and doesn\u0027t write any data. The server will default to Content-Length 0. This would work but is misleading for a HEAD request because the response headers are supposed to match a GET request.",
        "createdAt": "2019-06-27T20:36:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11654#issuecomment-506501534"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUwNjUzMDM4MQ==",
        "parentId": null,
        "author": "Bartmax",
        "content": "\u003E If the app doesn\u0027t specify the Content-Length and doesn\u0027t write any data. The server will default to Content-Length 0. This would work but is misleading for a HEAD request because the response headers are supposed to match a GET request.\r\n\r\nI think that\u0027s a fair trade off",
        "createdAt": "2019-06-27T22:13:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/11654#issuecomment-506530381"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0Njc4NzIyNjI=",
    "title": "HeaderPropagation middleware: MessageHandler throws when used outside of a request",
    "url": "https://github.com/dotnet/aspnetcore/issues/12169",
    "createdAt": "2019-07-14T18:52:19Z",
    "lastUpdated": "2023-08-28T23:10:06Z",
    "body": "### Describe the bug\r\nThe MessageHandler relies on the Middleware to initialize \u0060HeaderPropagationValues.Headers\u0060 to detect misconfiguration. However this means the Messagehandler can not be used outside of an http request and currently throws:\r\n\u0060\u0060\u0060\r\nSystem.InvalidOperationException: The HeaderPropagationValues.Headers property has not been initialized. If using this HttpClient as part of an http request, register the header propagation middleware by adding \u0027app.UseHeaderPropagation() in the \u0027Configure(...)\u0027 method. Otherwise, use HeaderPropagationProcessor.ProcessRequest() before using the HttpClient.\r\n\u0060\u0060\u0060\r\n\r\n### To Reproduce\r\nSteps to reproduce the behavior:\r\n\u003Cdetails\u003E\r\n\u003Csummary\u003ECode example\u003C/summary\u003E\r\n\r\n\u0060\u0060\u0060csharp\r\npublic void ConfigureServices(IServiceCollection services)\r\n{\r\n    services\r\n        .AddHttpClient(\u0022test\u0022)\r\n        .AddHeaderPropagation();\r\n    services.AddHostedService\u003CSampleHostedService\u003E();\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060csharp\r\npublic class SampleHostedService : IHostedService\r\n{\r\n    private readonly IHttpClientFactory _httpClientFactory;\r\n    private readonly HeaderPropagationProcessor _headerPropagationProcessor;\r\n    private readonly ILogger _logger;\r\n\r\n    public SampleHostedService(IHttpClientFactory httpClientFactory, HeaderPropagationProcessor headerPropagationProcessor, ILogger\u003CSampleHostedService\u003E logger)\r\n    {\r\n        _httpClientFactory = httpClientFactory ?? throw new ArgumentNullException(nameof(httpClientFactory));\r\n        _headerPropagationProcessor = headerPropagationProcessor ?? throw new ArgumentNullException(nameof(headerPropagationProcessor));\r\n        _logger = logger ?? throw new ArgumentNullException(nameof(logger));\r\n    }\r\n\r\n    public Task StartAsync(CancellationToken cancellationToken)\r\n    {\r\n        return DoWorkAsync();\r\n    }\r\n\r\n    private async Task DoWorkAsync()\r\n    {\r\n        _logger.LogInformation(\u0022Background Service is working.\u0022);\r\n\r\n        var client = _httpClientFactory.CreateClient(\u0022test\u0022);\r\n        var result = await client.GetAsync(\u0022http://localhost:62013/forwarded\u0022);\r\n\r\n        _logger.LogInformation(\u0022Background Service:\\n{result}\u0022, result);\r\n    }\r\n\r\n    public Task StopAsync(CancellationToken cancellationToken)\r\n    {\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\u003C/details\u003E\r\n\r\n### Expected behavior\r\nThe HttpClient should work if used outside of a request or, if we don\u0027t wont to support this use case, the exception should be updated to explain that such use case is not supported..\r\n\r\n### Possible solutions\r\nI had investigated possible solutions. Not sure what is your preferred options and if we are still in time to do breaking changes on this middleware.\r\nHere are some options:\r\n1. Remove the check that throws the exception which means we would not be able anymore to detect misconfiguration. Can this be replaced with an analyzer?\r\nOn top of the risk that the feature might not work due to misconfiguration, there is also the risk that having the valuefilter not execute (e.g. to set some headers with default values) when not called from outside a request can be unexpected.\r\n1. Update the exception message to also explain that a \u0060HttpClient\u0060 with the \u0060HeaderPropagationMessageHandler\u0060 can not be used outside of a request. This is not ideal as it means you end up duplicating your \u0060HttpClient\u0060s configuration.\r\n1. Extract the functionality from the Middleware to a generic Processor that can be called outside a http request. This will not change the middleware behaviour, but will allow to explicitly call the Processor when consuming an HttpClient outside of  a http request. Ideally this will also include changing the valueFactory to receive a headers collection instead of the HttpContext, so that headers can be passed in different scenarios, for example when consuming messages from a queue, however I guess this scenario is out of scope for a middleware. See draft PR #12170 . The main issue I see with this approach is that when the processor is used directly you must take extra care as you need a different async context per request.\r\n\r\nLooking forward for your feedback.\r\n\r\nThank you,\r\n Alessio\r\n\r\n/cc @rynowak ",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "affected-few",
      "severity-major",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxMTYyMzY5NA==",
        "parentId": null,
        "author": "rynowak",
        "content": "\u003E The HttpClient should work if used outside of a request or, if we don\u0027t wont to support this use case, the exception should be updated to explain that such use case is not supported..\r\n\r\nCan you describe what this would even mean to \u0022support this use case\u0022. Is the idea that you want to use header propagation *where possible* and then degrade gracefully?\r\n\r\nI guess I\u0027m more interested to hear about the scenario than the technical changes.",
        "createdAt": "2019-07-16T01:03:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12169#issuecomment-511623694"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxMjU4ODkzNQ==",
        "parentId": null,
        "author": "alefranz",
        "content": "Hi Ryan,\r\n\u003E Is the idea that you want to use header propagation where possible and then degrade gracefully?\r\nthat is what I meant. Apologies if my explanation was a bit convoluted.\r\n\r\nI believe having some background processing in an API is not so uncommon.\r\nAnd probably that background process will deal with the same dependent service that some controller\u0027s action deal with directly.\r\n\r\nWhen a user add the HeaderPropagation behavior to a client, does not probably realize that this means that the client can not be used anymore outside of a incoming HTTP request transaction (as we rely on the middleware initializing the headers collection to detect misconfiguration). \r\nSo there is a requirement of making this constraint more obvious.\r\n\r\nUnfortunately when using a typed client and relying on DI, it become convoluted to have to exact same clients just with a different configuration, so I am not sure that this behavior is acceptable.\r\n\r\nThe alternative that consuming the same client from a hosted service is made possible, but without propagating the headers, to me feels more user friendly, however there could be a scenario when the background processing is triggered by some incoming http request (e.g. storing some data on a queue for later processing by a hosted service in the same process) and a user will incorrectly assume that the headers are propagated and doesn\u0027t get any exception to warn about it.\r\nSo in this respect the current behavior is more safe, although can be a bit annoying to deal with it.\r\n\r\nDoes this answer your question or are you looking for an example?\r\n\r\nI don\u0027t have a real example of a service with such scenario (otherwise I would have caught this before \uD83D\uDE05) but it could be a service when you get a request that involve a minimum call to a service A to get the data required to fulfill the response, and it defer to later some more expensive call to service A which is a consequence of the original request but not required to return the response (as it is only a side effect or it will be sent back with a webhook). This could be for example achieved using a a TPL Dataflow ActionBlock or a queuing mechanism than consumed by a hosted service. The key part is that the processor will have to consume the same service A.\r\n\r\nI can put together an example if that will help.\r\n\r\nThank you,\r\n Alessio\r\n",
        "createdAt": "2019-07-17T22:15:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12169#issuecomment-512588935"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxMzQxNDQ5MA==",
        "parentId": null,
        "author": "rynowak",
        "content": "\u003E Extract the functionality from the Middleware to a generic Processor that can be called outside a http request. This will not change the middleware behaviour, but will allow to explicitly call the Processor when consuming an HttpClient outside of a http request. Ideally this will also include changing the valueFactory to receive a headers collection instead of the HttpContext, so that headers can be passed in different scenarios, for example when consuming messages from a queue, however I guess this scenario is out of scope for a middleware. \r\n\r\nI don\u0027t really want to do this I guess (anymore so than we already did). The idea of adding this feature to the core was that getting the capture \u002B propagation of values from the **current request** is a tricky problem that seemed worth ASP.NET Core solving for you.\r\n\r\nWriting a general purpose *run code to set headers* feature is too general, and something that anyone can do with a message handler in whichever way they please. \r\n\r\nPut another way: it\u0027s worth us providing opinions about how to integrate features of ASP.NET Core with each other, but it\u0027s not a great idea for us to provide opinions about all the code you write. It\u0027s better to just tell people to use the BCL features than to provide wrappers around them - for us to provide an alternative to some code you could write - there has to be some kind of value to it other than reduction in lines of code\r\n\r\n-------\r\n\r\nI think the scenario makes sense. It\u0027s a little surprising that once you opt-in to header forwarding, you can\u0027t use that client outside of a request - but it\u0027s also a reasonable explanation - but the workaround is painful (duplicate your config)\r\n\r\nI think are options are to either:\r\n- Do nothing (can always be fixed in the future)\r\n- Remove the sanity check\r\n- Add an option to bypass the sanity check\r\n\r\nWe have a few days left to address this before the release really locks down - I\u0027ve taken a while to respond because I\u0027m not sure which of the last two options is least surprising.\r\n\r\n@anurse @Tratcher @davidfowl @glennc ",
        "createdAt": "2019-07-19T23:55:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12169#issuecomment-513414490"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxNDY3NDQ1OQ==",
        "parentId": null,
        "author": "analogrelay",
        "content": "\u003E We have a few days left to address this before the release really locks down\r\n\r\nBarely that even. I think this might be a good candidate to reconsider when we open a branch for 3.1 next week. I\u0027m afraid I haven\u0027t been able to catch up on the thread, but is this something that will break customer scenarios if not resolved? If so, we can evaluate it for 3.0 (based on the impact of the bug). If this is just about expanding the usefulness of the HeaderPropagation message handler, I think we\u0027ll have to move this out of 3.0. It wouldn\u0027t meet the bar.",
        "createdAt": "2019-07-24T15:12:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12169#issuecomment-514674459"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxNDY3NDk1OQ==",
        "parentId": null,
        "author": "rynowak",
        "content": "There\u0027s no break here. \r\n\r\nWe\u0027re discussing how to best deal with a case that would throw an exception in 3.0 - and trying to decide if we want to make it more tolerant. I have no issue with moving this decision to 3.1",
        "createdAt": "2019-07-24T15:13:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12169#issuecomment-514674959"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxNDc0NDI0Nw==",
        "parentId": null,
        "author": "alefranz",
        "content": "Yes I agree we need to postpone it as we are waiting for more feedback on what is the best approach to take.\r\n\r\n@rynowak do we need to rephrase the exception message for 3.0? we could add something at the end to indicate that another possible reason of this exception is that the Http client is used outside of processing of a request which is unsupported.\r\n\r\nThanks!",
        "createdAt": "2019-07-24T18:21:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12169#issuecomment-514744247"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxNDc0NTY5OA==",
        "parentId": null,
        "author": "rynowak",
        "content": "Sure, if you want to send a PR that updates the exception message that would be fine. We have until monday to merge it. ",
        "createdAt": "2019-07-24T18:25:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12169#issuecomment-514745698"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUxNTYyNzc4MA==",
        "parentId": null,
        "author": "alefranz",
        "content": "Raised PR https://github.com/aspnet/AspNetCore/pull/12636",
        "createdAt": "2019-07-26T23:26:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12169#issuecomment-515627780"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzODc2NTQyMA==",
        "parentId": null,
        "author": "raphaabreu",
        "content": "Hello all, I am coming here from https://github.com/alefranz/HeaderPropagation/issues/6 as suggested by @alefranz.\r\n\r\nI am starting to upgrade some projects at my company and header forwarding is being an issue for us. It is awesome that there is a standard package from the AspNetCore team that we can reference and use as model to how to solve similar problems, however this particular implementation is breaking for us. The header forwarding functionality should not break the regular httpclient flow when used from outside a request context.\r\n\r\nWe can create middlewares and http message handlers to have the exact behaviour we expect, specially after seen how it is done, however it leaves me feeling this \u0022gap\u0022 where I see several packages officially supported by the AspNetCore team that don\u0027t play well with each other. I would never have expected to not be able to use the same typed httpclient on a service if that service is consumed by a controller and by a background service.\r\n\r\nWould it be a problem if the header forwarder message handler simply did nothing if there was no available http context to get headers from?",
        "createdAt": "2019-10-06T16:49:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12169#issuecomment-538765420"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY1OTUwOTUyMg==",
        "parentId": null,
        "author": "techgeek03",
        "content": "Any conclusion on this? I\u0027m with @raphaabreu on this. Throwing an exception if there is no available http context relay does not work in all cases. The best possible solution is to just remove the throwing of the exception and don\u0027t do anything.\r\n\r\nIn my case I\u0027m using Refit and also resolving the typed clients in integration tests. We mainly want to use this package to pass diagnostics headers from envoy used for distributed tracing. \r\n\r\nIf the point of that exception is to detect misconstructions; you will know the moment the headers are not being propagated :) \r\n",
        "createdAt": "2020-07-16T16:02:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12169#issuecomment-659509522"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MDUwMDg5NA==",
        "parentId": null,
        "author": "alefranz",
        "content": "Hi @techgeek03,\r\n\r\nThe goal of detecting misconfiguration is to avoid the problem when the headers are not propagating as expected but it goes unnoticed. I think it is about striking the right balance between pushing cusers in the right direction versus allowing maximum flexibility and, at the time, it looked like there wasn\u0027t much interesting in supporting other scenarios.\r\n\r\nRegarding your specific issues, you can use the HeaderPropagation middleware in the current state in integration tests. Are you including the middleware in your test server? Or what is the context in which you are experiencing this exception? Maybe I can help you find a workaround or having a concrete example could help make a case for this change.\r\n\r\nHowever, the recommended solution for distributed tracing in ASP.NET Core does not involve this middleware (although I believe it still doesn\u0027t support having different header names, but I could be wrong).\r\n",
        "createdAt": "2020-07-18T15:45:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12169#issuecomment-660500894"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxODIxNTkwNA==",
        "parentId": null,
        "author": "ththiem",
        "content": "We recently ran into this issue that broke the entire call flows of our services as a result of this exception. There are numerous real world scenarios where service A makes http calls to service B for different purposes: It could be as a direct result of an incoming request to service A, it could also be processing messages out of an event queue, it could be a background task spawned by a request in any asynchronous scenario. \r\n\r\nAnd the workaround of creating a duplicate http client just to not have the propagation is in direct violation of the [recommended guidelines](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-3.1#httpclient-and-lifetime-management) for proper httpclient lifetime management, where you are expected to reuse the same instance to take advantage of connection pooling to prevent socket exhaustion and reduce the delay in creation and teardown of the instances. So this really needs to be addressed sooner rather than later.",
        "createdAt": "2020-10-28T21:21:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12169#issuecomment-718215904"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxOTYzNDU4OQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E And the workaround of creating a duplicate http client just to not have the propagation is in direct violation of the recommended guidelines for proper httpclient lifetime management,\r\n\r\nYou\u0027re still expected to use a different HttpClient whenever the configuration is different. So long as you\u0027re re-using your clients and not throwing them away after each use you\u0027ll avoid the issues discussed in the guidelines.",
        "createdAt": "2020-10-30T15:50:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/12169#issuecomment-719634589"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0ODEyMDkxNTg=",
    "title": "Consider running user-provided exception handler even when response has started",
    "url": "https://github.com/dotnet/aspnetcore/issues/13170",
    "createdAt": "2019-08-15T15:35:04Z",
    "lastUpdated": "2023-08-28T23:10:05Z",
    "body": "Created from https://github.com/aspnet/AspNetCore/issues/12301\r\n\r\nIf the response has already started, the Exception Handler middleware exits early and doesn\u0027t write a response. This makes total sense. However, it also doesn\u0027t call the user-provided handler (if any) and it doesn\u0027t signal the diagnostic source. This makes diagnosing issues more difficult. We should consider refactoring this.",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "affected-few",
      "severity-minor",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyMTczMzExMw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "The user provided handler is also intended to generate a response, so running that seems problematic. Signaling the diagnostic source makes sense though.",
        "createdAt": "2019-08-15T17:49:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13170#issuecomment-521733113"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyMTczNDE2MQ==",
        "parentId": null,
        "author": "analogrelay",
        "content": "\u003E The user provided handler is also intended to generate a response\r\n\r\nI don\u0027t know that I\u0027d agree. The handler is a \u0060RequestDelegate\u0060 yes, but that\u0027s not inappropriate here. There\u0027s nothing that expects the handler to generate a response here. It\u0027s just giving it the full context (the request) and the opportunity to generate responses as necessary. The handler can just as easily check if the response has started. Or it could collect all the data it wants, send it to some error reporting service and then let the response proceed as it would have before. Plus, this would allow the user control over what response gets generated if an exception occurs mid-stream.\r\n\r\nI would agree that this could be a behavior break though since the handler may not have been expecting to run when the response has already started. We can talk further about how we want to do that (or if we want to call the handler at all). Signalling the diagnostic source definitely seems like a no-brainer here :).",
        "createdAt": "2019-08-15T17:52:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13170#issuecomment-521734161"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNDQ5NDc2Mw==",
        "parentId": null,
        "author": "TehWardy",
        "content": "@anurse Is that something I as a consumer of the framework can hook in to and have a block of code provide a response to the request with?\r\n\r\nNo matter what we need to be able to provide some sort of response that explains either that the request was somehow not valid or that the server was unable to handle it for what ever reason.",
        "createdAt": "2019-09-24T10:22:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13170#issuecomment-534494763"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNDU5NTE4MQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E No matter what we need to be able to provide some sort of response that explains either that the request was somehow not valid or that the server was unable to handle it for what ever reason.\r\n\r\nIf the response has already started it\u0027s not possible for you to provide a different response. You\u0027d be writing in the middle of the existing response and corrupting the HTML, JSON, etc.. If you want to be able to _replace_ a response then you have to fully buffer it to prevent it from being sent to the client. This adds a lot of overhead so we don\u0027t do it by default.",
        "createdAt": "2019-09-24T14:50:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13170#issuecomment-534595181"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNDYyMzYxNQ==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Yeah, I agree with @Tratcher here. This middleware is not designed to allow you to produce an error response **after the main response has already started**. If you want to be able to do that, you\u0027d need to build a new middleware that buffers the response in memory and then dumps that buffer *only* if there is no error executing the rest of the pipeline.\r\n\r\nWhat we are discussing here (and still not at all committed to) is the idea of allowing you to run code in the handler even after the response has started. You still *would not* be able to write a new response or affect the status code if the response has already started, but you could send the error to a diagnostic system of some kind (for example).",
        "createdAt": "2019-09-24T15:53:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13170#issuecomment-534623615"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNDYzNjEwNg==",
        "parentId": null,
        "author": "TehWardy",
        "content": "Yeh that\u0027s not unreasonable at all @Tratcher .\r\nI found a scenario where I could setup an OData controller (I know OData is not core aspnet but bear with me) ... in the business logic for the action I could construct an entity and not populate it correctly so the entity was not valid.\r\n\r\nEF for example would fail to put it in to the DB with a SQL exception.\r\nThe OData framework seems to validate properties as it serializes them resulting in the response failing during serialization so the response is literally a half backed blob of JSON.\r\n\r\nThe key issue I had there of course is that the framework just stopped processing at that point. \r\nBeing able to hook on to any part of the request lifecycle as a global catch all and at least log the true exception information is key to helping devs treat the framework right.\r\n\r\nI do also accept that some scenarios are just simply not resolvable (like my OData one) in the ideal manner.\r\n\r\n@anurse It sounds like you\u0027re proposal is much like what I would expect with some basic ability.\r\nSo a \u0022pseudo code\u0022 concept (with little detail of course) of what I think the framework should do as core behaviour ...\r\n\r\n\u0060\u0060\u0060\r\nMiddlewareObject stack;\r\ntry\r\n{\r\n     stack = BuildMiddlewareStack();\r\n     stack.ExecuteOn(request);\r\n}\r\ncatch(Exception ex)\r\n{\r\n      CallDefaultHandler(ex);\r\n      if(defined) { CallUserHandler(ex); }\r\n}\r\nfinally\r\n{\r\n     Cleanup(stack, request);\r\n}\r\n\u0060\u0060\u0060\r\n\r\n... I\u0027m sure it\u0027s way more complex than that but this at the root level ensures that \u0022worst case\u0022 the user still gets notified when the framework simply can\u0027t handle our garbage ;)",
        "createdAt": "2019-09-24T16:23:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13170#issuecomment-534636106"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNDY0MTAyMw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E and at least log the true exception information \r\n\r\nThe framework should already be logging the exception at the middleware or server level, even if it can\u0027t produce a response.",
        "createdAt": "2019-09-24T16:35:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13170#issuecomment-534641023"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNDY0NTIzMQ==",
        "parentId": null,
        "author": "TehWardy",
        "content": "The bulk of logging that has any value seems to be dropped in to the VS console ... is that what you mean by the \u0022middleware or server level\u0022?\r\n\r\nI\u0027m thinking take that VS console stuff too and be able to handle that with the global exception handler.\r\n\r\nI\u0027m already doing this ...\r\n\r\n\u0060\u0060\u0060\r\napp.UseExceptionHandler(errorApp =\u003E\r\n{\r\n    errorApp.Run(async context =\u003E\r\n    {\r\n        var ex = context.Features.Get\u003CIExceptionHandlerPathFeature\u003E();\r\n        log.Error(ex.Error.Message \u002B \u0022\\n\u0022 \u002B ex.Error.StackTrace);\r\n          // code clipped out here for berevity\r\n        var innerEx = ex.Error.InnerException;\r\n        while (innerEx != null)\r\n        {\r\n            log.Error(ex.Error.Message \u002B \u0022\\n\u0022 \u002B ex.Error.StackTrace);\r\n            innerEx = innerEx.InnerException;\r\n        }\r\n    });\r\n});\r\n\u0060\u0060\u0060\r\n\r\n... but I\u0027ve hit scenarios where the output window in VS has information that would really help and doesn\u0027t get passed to this handler.\r\nIt would be really cool if this middleware also got all the info passed to the VS console window ... maybe if that is the case though put some flag / logging level info  in the errorApp object as it might produce a lot of noise for some scenarios that people wouldn\u0027t want.\r\n\r\nI think @anurse was talking to me about this in another ticket actually. ah yeh, it\u0027s #12301 linked above. That would probably solve both of these tickets at least in part.",
        "createdAt": "2019-09-24T16:45:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13170#issuecomment-534645231"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNDY0NjA0MA==",
        "parentId": null,
        "author": "analogrelay",
        "content": "\u003E The bulk of logging that has any value seems to be dropped in to the VS console ... is that what you mean by the \u0022middleware or server level\u0022?\r\n\r\nIt\u0027s logged to the ASP.NET Core logging system. You can plug in a number of outputs, including custom ones.",
        "createdAt": "2019-09-24T16:47:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13170#issuecomment-534646040"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNDY0NjE1Mw==",
        "parentId": null,
        "author": "analogrelay",
        "content": "See https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-3.0 for more details on logging.",
        "createdAt": "2019-09-24T16:48:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13170#issuecomment-534646153"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNDY1MjM5MA==",
        "parentId": null,
        "author": "TehWardy",
        "content": "I use Log4Net as my logging framework (legacy reasons basically) ... This looks really good though ... I ma have to migrate to it and see if it\u0027s any better (anything that reduces further external dependencies can\u0027t be that bad right).\r\n\r\n",
        "createdAt": "2019-09-24T17:02:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13170#issuecomment-534652390"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNDY4NjQ4OA==",
        "parentId": null,
        "author": "analogrelay",
        "content": "The advantage to integrating with the built-in framework is that the *entire ASP.NET Core framework* logs to that system, at a variety of detail levels. There are third-party providers than integrate our system with other logging frameworks, more detail on that [in the docs](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/logging/?view=aspnetcore-3.0#third-party-logging-providers). I don\u0027t see log4net in that list, but a quick google search for \u0060log4net microsoft.extensions\u0060 (The logging framework is in the \u0060Microsoft.Extensions.Logging\u0060 namespace) does yield some results (though I don\u0027t know how well those integrations work). You can always integrate the two systems and then continue to log directly to log4net in your app, while also having \u0060ILogger\u0060 messages go through to log4net.",
        "createdAt": "2019-09-24T18:24:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13170#issuecomment-534686488"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU4MDc3Mjc2MA==",
        "parentId": null,
        "author": "TehWardy",
        "content": "As per this issue ...\r\nhttps://github.com/OData/WebApi/issues/1858\r\n\r\n... Is there any way I can \u0022turn off\u0022 result validation during the response serialization in OData controller response handling?\r\n\r\nThis is where it all began and I feel like the problem has moved in to an issue of logging when it\u0027s really an issue of response generation (the framework is forcing an exception that need not be one in the situation I have.\r\n\r\nSorry to drag an OData issue over here but I think the visibility of my issue is being lost somewhat and buried in a logging technicality (which is in all fairness not that important).",
        "createdAt": "2020-01-31T15:12:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13170#issuecomment-580772760"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU0ODMwMzY5NjA=",
    "title": "Rate Limit for Kestrel - Design mechanism to apply back pressure to accepting connections",
    "url": "https://github.com/dotnet/aspnetcore/issues/13295",
    "createdAt": "2019-08-20T19:19:38Z",
    "lastUpdated": "2024-02-14T20:21:20Z",
    "body": "### Is your feature request related to a problem? Please describe.\r\nTo match functionality with WCF on .NET Framework, CoreWCF needs to be able to control the number of pending accepts. When a client connects to WCF using the NetTcp transport, there is a handshake that needs to be completed which includes authentication and security upgrade negotiation. After a connection has been established and while the handshake is ongoing, a connection is considered to be a pending connection. WCF controls the maximum number of connections which are in the pending connection state by controlling the maximum number of pending accepts to never be more than how many more pending connections are possible. For example, if the maximum number of pending connections is configured to be 100 and there are currently 95 pending connections, we limit the number of pending accepts to be no more than 5.\r\n\r\n### Describe the solution you\u0027d like\r\nI believe there should be a generic throttling interface that can be added by DI for use at any layer within an app, and a derived interface (which adds no extra methods) which is used at the transport layer. The two interfaces would be defined as:\r\n\u0060\u0060\u0060c#\r\npublic interface IThrottle\r\n{\r\n    ValueTask\u003Cbool\u003E AcquireAsync(CancellationToken cancellationToken = default(CancellationToken));\r\n    void Release();\r\n}\r\n\r\npublic interface ITransportThrottle : IThrottle { }\r\n\u0060\u0060\u0060\r\nWhen calling AcquireAsync, one of four things can happen.\r\n1. The returned ValueTask\u003Cbool\u003E is completed with a value of true meaning the throttle was acquired.\r\n2. The returned ValueTask\u003Cbool\u003E is not completed and the call goes async. When a throttle can be acquired, the ValueTask is completed with a value of true meaning the throttle was acquired.\r\n3. The returned ValueTask\u003Cbool\u003E is completed with a value of false meaning the throttle can not be acquired immediately. This would be used for a throttle implementation which is used when you want to fail immediately such as returning a 503 throttled HTTP response.\r\n4. The returned ValueTak\u003Cbool\u003E is not completed and the call goes async. If the cancellation token is cancelled, the ValueTask is completed with a value of false meaning the throttle was not acquired. This would be used for scenarios where waiting for a throttle can time out or when shutting down the application and you need to complete the pending AcquireAsync call for cleanup.\r\n\r\nIn the code which calls Accept on the listening socket, if an ITransportThrottleexists in DI, in a loop it acquires the throttle and adds another pending accept until ITransportThrottle.AcquireAsync returns a non-completed ValueTask. It would be up to the implementation of the ITransportThrottleto ensure there\u0027s a sensible number of pending accepts. Basically the number of pending accepts is completely controlled by the ITransportThrottleif it exists.\r\n\r\nEdit: Changed IServiceThrottle to ITransportThrottle",
    "upvotes": 5,
    "labels": [
      "Needs: Design",
      "enhancement",
      "blocked",
      "\uD83E\uDD4C Bedrock",
      "feature-yarp",
      "severity-nice-to-have",
      "affected-very-few",
      "Priority:1",
      "feature-rate-limit",
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyNzA1NDk5MQ==",
        "parentId": null,
        "author": "tmds",
        "content": ":\u002B1: \r\n\r\nNote that backpressure exists at the OS level. This is the parameter that is passed to the \u0060Socket.Listen\u0060 call.\r\n\r\nI wonder if it makes sense to make \u0060IThrottle\u0060 explicit part of the bedrock abstractions. For example, a parameter on the \u0060IConnectionListener.Bind\u0060.\r\n\r\nCC @davidfowl @ReubenBond @halter73",
        "createdAt": "2019-09-02T08:30:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-527054991"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyNzM3MDQxNw==",
        "parentId": null,
        "author": "davidfowl",
        "content": "I see the value in this existing but I don\u0027t think it belongs on any of the existing APIs.",
        "createdAt": "2019-09-03T08:59:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-527370417"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyNzM3Mjc0OQ==",
        "parentId": null,
        "author": "tmds",
        "content": "Is the \u0060IConnectionListener\u0060 meant to call \u0060AquireAsync\u0060 or is it some other component?",
        "createdAt": "2019-09-03T09:06:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-527372749"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyNzM3OTIxMg==",
        "parentId": null,
        "author": "davidfowl",
        "content": "I can\u0027t see how that can be enforced at this point. I would assume it\u0027s the caller.",
        "createdAt": "2019-09-03T09:24:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-527379212"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyNzU1MzEwNA==",
        "parentId": null,
        "author": "mconnew",
        "content": "@tmds, the backlog argument to Socket.Listen isn\u0027t back pressure. That\u0027s a buffer to accommodate bursts of incoming connections that the app isn\u0027t calling Accept fast enough to handle. If you have 0 listen backlog configured, then the OS will deny any incoming connections if there isn\u0027t an available pending Accept. That isn\u0027t what I need solved. When you are CPU contended, the OS gives each thread a quanta of time to execute before preemptively switching out to another thread to execute. During the time that a thread has the CPU, it can issue multiple asynchronous Accept calls on a listening socket before it yields the thread. Those accepts complete on IO Threads which have a different scheduling priority and the preemptive behavior is very different in the OS. So basically you can have a CPU pegged at 100% and \u0022worker\u0022 threads will be preempted by IO Threads which handle the completed Accept and (hopefully) dispatch calling the handler on a worker thread. You should only be calling Accept on an IO thread (because Windows will cancel the pending IO if you close the thread so calling Accept on a worker thread causes the CLR to keep more threads alive in the thread pool so as not to cancel pending IO). So unless you have a mechanism to prevent new pending Accept calls from being made, you can get into the situation where the OS scheduling of IO threads results in you adding more work to your worker thread pool and you end up in the situation where you reduce performance because of more context switches, and any one request takes longer which can result in client timeouts which results in resubmitting of work and you can get into a death spiral.  \r\n\r\n@davidfowl, I\u0027m not suggesting adding this to an existing API. I\u0027m proposing a new interface API for throttling and suggesting a way how the connection listener (I presume the \u0060IConnectionListener\u0060 that @tmds mentioned) can use that API to allow an application to prevent the death spiral that you can get into without it. This is a very real scenario and not just academic as I have worked with customers who have had this happen when they have set their WCF transport limits too liberally.",
        "createdAt": "2019-09-03T17:14:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-527553104"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyNzU3Mzg5NQ==",
        "parentId": null,
        "author": "davidfowl",
        "content": "\u003E @davidfowl, I\u0027m not suggesting adding this to an existing API. I\u0027m proposing a new interface API for throttling and suggesting a way how the connection listener (I presume the IConnectionListener that @tmds mentioned) can use that API to allow an application to prevent the death spiral that you can get into without it. \r\n\r\nSounds like an implementation detail.\r\n\r\n",
        "createdAt": "2019-09-03T18:08:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-527573895"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyNzU4MDU5Mw==",
        "parentId": null,
        "author": "tmds",
        "content": "\u003E @tmds, the backlog argument to Socket.Listen isn\u0027t back pressure. That\u0027s a buffer to accommodate bursts of incoming connections that the app isn\u0027t calling Accept fast enough to handle.\r\n\r\nIn both cases it\u0027s implementing a limited queue. I\u0027m not sure when it fits the name backpressure and when not.\r\n\r\n\u003E For example, if the maximum number of pending connections is configured to be 100 and there are currently 95 pending connections, we limit the number of pending accepts to be no more than 5.\r\n\r\nHow do you prevent this being used to do some attack in the form: make a nr of connections that perform a handshake in the slowest way possible? This stops real clients from making connections.",
        "createdAt": "2019-09-03T18:26:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-527580593"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyNzYyMzczOA==",
        "parentId": null,
        "author": "mconnew",
        "content": "We have a configurable timeout which limits how long a connection is allowed to take to perform the handshake. net.tcp isn\u0027t an internet protocol, it\u0027s a LAN or WAN protocol so you are running inside a trusted network. If you have a malicious host in your LAN, it\u0027s already game over as it can do things like MAC address spoofing, mess with BGP routing, mess with DHCP to do MITM attacks, perform DNS poisoning, passively snoop on the network to pick up any unencrypted data and 1001 other ways to screw with your network.  \r\n\r\nIf you must expose a web service to a hostile environment, you generally run it behind a LB or firewall which does things like limit the number of concurrent requests from a single IP and other DoS attack mechanisms. At the end of the day, if a web service is exposed to malicious clients, the only way to prevent DoS attacks is to run at scale and/or have a smart front-end like a LB which is specialized in detecting attack patterns and preventing malicious clients from getting through to the server. But these generally aren\u0027t the problem domain of WCF\u0027s net.tcp protocol.  \r\n  \r\nWCF server in .NET Framework has customers with significantly more than 150,000 clients connected to a single server. When that WCF service needs to be restarted, e.g. with a software update, if you accept connections as fast as you can, you would have so many connection handshakes in flight at once that each handshake would exceed it\u0027s timeout. When the service sends some bytes as part of the handshake and then calls ReceiveAsync, the amount of time it would take for the await continuation to execute due to the amount of contention would exceed your timeout.  \r\n\r\nEven if CPU/thread contention wasn\u0027t a limitation (you are running on a 128 core system), the security process in windows (lsass) is single threaded and limited by the speed of a single core. So the security handshake bottlenecks on the single core which queues the authorization requests and when running at 100% CPU will result in exceeding the connection timeout. So the connection is killed, most likely by the client first as the timeout firing also requires a thread to run on, and the client attempts to reconnect again. So now you have the original connection attempt still in the lsass queue, which has been abandoned by the client but there\u0027s no way to cancel a pending authorization, and you throw another one into the queue. Rinse and repeat. \r\n\r\nIf you are CPU/thread contended due to too many concurrent connection handshakes, any clients which have been able to connect, their actual service requests are competing for CPU time with the connecting clients, so their requests time out. Which causes the channel to be faulted, which means the connection needs to be re-established and that client joins the party.  \r\n\r\nIf you have control of the number of pending accepts, you can limit the number of concurrent handshakes which means you can guarantee (by tuning your service) you are not overly contended on completing those handshakes. Sure you will have clients being denied connecting to the server socket, but nobody in the listen backlog will timeout as you configure things high enough that you can accept new requests at a fast sustainable rate and you size your listen backlog to that no connection stays in the listen backlog for more than a few seconds. But if you If you don\u0027t have a way to control how many outstanding accepts you have, if you have enough clients connecting at once you can get in a death spiral that makes itself worse.  \r\n\r\nI know I could asynchronously wait after a socket has been accepted and not start the handshake, but then you are allocating resources for each incoming connection just to wait there. With the rate of allocation with a large number of incoming connection, you would be running a Gen0 GC quite regularly so all those waiting connections are likely to have their allocations get to at least Gen1 before the connection times out. So now you are churning the GC heavily by having them waiting there. You also have a lot of timers registered for expiring the wait before starting the handshake. You also run the risk of a connection making it to the handshake with very little time left on it\u0027s timer and being aborted when part way through the handshake as the timer starts when you accept a connection. It\u0027s better to distribute the timers needed on the client with a retry backoff algorithm than have timer contention on the server.  \r\n\r\nOverall, without this capability, there are some existing large scale WCF workloads that an AspNetCore based WCF solution just wouldn\u0027t be able to handle without Accept throttling. WCF is used a lot in enterprises so we can have the start of the workday connection spike where everyone sits down at their desk at about the same time and logs into an app all at once.",
        "createdAt": "2019-09-03T20:21:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-527623738"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyNzgxMzYyNQ==",
        "parentId": null,
        "author": "tmds",
        "content": "@mconnew thanks for the interesting and detailed response. So this is to maintain performance with high nr of concurrent accepts, and not for security.",
        "createdAt": "2019-09-04T09:07:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-527813625"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUyODUyODc0MQ==",
        "parentId": null,
        "author": "mconnew",
        "content": "@tmds, correct, this is about scalability. I can\u0027t think of a scenario where this would affect regular HTTP but it could affect WebSockets or gRPC. Especially if using something like token based authentication.",
        "createdAt": "2019-09-05T19:04:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-528528741"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNzc4ODkxMQ==",
        "parentId": null,
        "author": "davidfowl",
        "content": "I\u0027m going to look into a design for this. It comes up because the \u0060ConnectionDelegate\u0060 is a push model and the server is accepting connections and dispatching. ",
        "createdAt": "2019-10-03T05:08:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-537788911"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNzkxOTU2Ng==",
        "parentId": null,
        "author": "tmds",
        "content": "@davidfowl at what point do you consider a connection _handled enough_ to allow a new accept?",
        "createdAt": "2019-10-03T12:16:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-537919566"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNzk2NDEwMA==",
        "parentId": null,
        "author": "davidfowl",
        "content": "That\u2019s policy that can be implemented ",
        "createdAt": "2019-10-03T14:13:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-537964100"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDUzNzk3MTQ1NQ==",
        "parentId": null,
        "author": "tmds",
        "content": "From discussing with @mconnew I think policies will be app specific, or would there be some that come with AspNetCore?",
        "createdAt": "2019-10-03T14:31:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-537971455"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwNDI0NDA4Ng==",
        "parentId": null,
        "author": "davidfowl",
        "content": "We might have a clean design for this and it looks like an \u0060IConnectionListener\u0060 implementation that wraps the transport is the way to go here. It would look like any other connection middleware:\r\n\r\n\r\n\u0060\u0060\u0060C#\r\noptions.ListenAnyIP(5000, listenOptions =\u003E\r\n{\r\n    listenOptions.UseConnectionThrottling(); // This is the throttling middleware\r\n    listenOptions.UseHttps(); // This is the existing HTTPS middleware\r\n});\r\n\u0060\u0060\u0060\r\n\r\nThis works by exposing a new method on \u0060ListenOptions\u0060:\r\n\r\n\u0060\u0060\u0060C#\r\npublic class ListenOptions\r\n{\r\n    public ListenOptions UseListenerFilter(Func\u003CIConnectionListener, IConnectionListener\u003E middleware);\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThis would allow you to wrap the previous \u0060IConnectionListener\u0060 in order to handle the calls to accept. That\u0027s where this logic can be plugged in. \r\n\r\n@halter73 spiked something very similar today (for different reasons) but I think this approach has legs and doesn\u0027t introduce new concepts.",
        "createdAt": "2020-03-26T05:53:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-604244086"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzczNjI2NA==",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\nWe\u0027re moving this issue to the \u0060Next sprint planning\u0060 milestone for future evaluation / consideration. We will evaluate the request when we are planning the work for the next milestone. To learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-07-24T21:12:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-663736264"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3MjEzMzM3MQ==",
        "parentId": null,
        "author": "Pilchie",
        "content": ":eyes:",
        "createdAt": "2020-08-11T17:49:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-672133371"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxNDY4NTkyNA==",
        "parentId": null,
        "author": "davidni",
        "content": "Does this issue account for throttling policies that rely on SNI host name? YARP scenarios would benefit from being able to apply throttling bucketed by host names.",
        "createdAt": "2020-10-22T18:41:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-714685924"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxNDgwOTgyNg==",
        "parentId": null,
        "author": "halter73",
        "content": "This can already be done using something like TlsFrameHelper.GetServerName() (see https://github.com/microsoft/reverse-proxy/pull/262) in Kestrel connection middleware. Connections need to be accepted before SNI-based throttling can take place in order to determine the requested server name.\r\n\r\n@mconnew wants a mechanism to throttle Kestrel\u0027s accept loop. Kestrel provides no mechanism to do this yet. Connection middleware cannot do this because connections are accepted before Kestrel invokes the connection middleware pipeline.",
        "createdAt": "2020-10-22T23:06:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-714809826"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc2MTIzNDEwNg==",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\nWe\u0027re moving this issue to the \u0060Next sprint planning\u0060 milestone for future evaluation / consideration. We will evaluate the request when we are planning the work for the next milestone. To learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-01-15T22:38:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-761234106"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg4MDI2OTc0MQ==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-07-14T23:12:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-880269741"
      },
      {
        "id": "IC_kwDOAQzde8485cB_",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 7 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-01-25T23:04:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/13295#issuecomment-1021689983"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3NTY2MTk0NjU=",
    "title": "Access the singleton ConnectionMultiplexer or have a new IDatabase while also using IDistributedCache interface",
    "url": "https://github.com/dotnet/aspnetcore/issues/28374",
    "createdAt": "2019-09-30T15:52:44Z",
    "lastUpdated": "2023-06-02T03:14:23Z",
    "body": "### Is your feature request related to a problem? Please describe.\r\nI\u0027m trying to use our Redis server from an ASP .NET Core Web Api via the IDistributedCache interface. While this is OK, I\u0027d also like to be able to use other data types/access modes from Redis via direct commands, i.e. I\u0027d like to be able to use the IDatabase private member directly, preserving the IDistributedCache interface.\r\n\r\n### Describe the solution you\u0027d like\r\nSome way to be able to use the same IDatabase _cached property directly or at least created a new one from a public Connect() method using the existing ConnectionMultiplexer object.\r\n\r\n### Describe alternatives you\u0027ve considered\r\nIn setup.cs, creating a singleton object RedisCache and keep a reference to it, also passing it as a service singleton instance. This may cause problems with the Connect() lock, though.\r\n\r\nThanks!",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "feature-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxOTI1Nzk1OQ==",
        "parentId": null,
        "author": "analogrelay",
        "content": "We won\u0027t expose the \u0060ConnectionMultiplexer\u0060 in DI. We don\u0027t put types we don\u0027t control into the DI container because it can mess with a **lot** of different DI services.\r\n\r\nWhat we could do instead is offer a \u0060Func\u003CConnectionMutiplexer\u003E\u0060 \u0022factory\u0022 option on the RedisCacheOptions. Then you could specify your own connection and share it with other components.",
        "createdAt": "2020-04-24T22:04:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28374#issuecomment-619257959"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczODM0MTUxNA==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-12-03T21:51:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28374#issuecomment-738341514"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczODM0ODQ4Nw==",
        "parentId": null,
        "author": "JunTaoLuo",
        "content": "Related: https://github.com/dotnet/aspnetcore/issues/28379",
        "createdAt": "2020-12-03T22:06:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28374#issuecomment-738348487"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU1MTQ2NzAyMTI=",
    "title": "Modify Rewrite Middleware RewriteOptions rules collection after Startup runs",
    "url": "https://github.com/dotnet/aspnetcore/issues/16658",
    "createdAt": "2019-10-30T13:29:49Z",
    "lastUpdated": "2023-08-28T23:10:05Z",
    "body": "Is there a recommended way to modify this rules collection after startup runs without having to store the RewriteOptions as a static variable before passing it to .UseRewriter(options)? The rewrite middleware builder extension method appears to call UseMiddleware\u003CRewriter\u003E(Options.Create(_options)) but the returning options wrapper is not registered anywhere.",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "feature-rewrite-middleware",
      "severity-minor",
      "affected-very-few",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU0Nzk1Njc5Ng==",
        "parentId": null,
        "author": "Tratcher",
        "content": "No, that\u0027s not supported. Even storing the RewriteOptions and trying to modify it later is dangerous because that object is being used by multiple threads.",
        "createdAt": "2019-10-30T15:13:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/16658#issuecomment-547956796"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY0MzM0NzY1Nw==",
        "parentId": null,
        "author": "xantari",
        "content": "I am also trying to do this, because we are building off of a headless CMS, where the rewrite rules are defined in the cloud hosted CMS, but our .NET Application is processing the rewrite rules from that cloud CMS system.\r\n\r\nWhen they make a change in the CMS system, we get a webhook notification of the change, but have no way of updating the rewrite rules.\r\n\r\nI tried injecting IOptions\u0026lt;RewriteOptions\u0026gt; into our controller, but the .Values is empty strangely. Even though on app startup we initialize entries into it and they work fine.\r\n\r\nThis really needs to be supported. Perhaps IOptionsSnapshot will allow you to modify the rewrites on the fly and be thread safe?",
        "createdAt": "2020-06-12T15:53:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/16658#issuecomment-643347657"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY0MzM1Mzc2Mg==",
        "parentId": null,
        "author": "xantari",
        "content": "Also, couldn\u0027t you just use a ConcurrentBag or some similar threadsafe collection to store the rules to eliminate the thread safety issue?\r\n\r\nIt looks like you could do this by just changing IList\u003CIRule\u003E in RewriteOptions to be IConcurrentBag instead...",
        "createdAt": "2020-06-12T16:05:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/16658#issuecomment-643353762"
      },
      {
        "id": "IC_kwDOAQzde848ezMB",
        "parentId": null,
        "author": "burtonrodman",
        "content": "so we haven\u0027t really answered the original question...  what is the recommended way of modifying rewrite rules after startup?  are we just expected to restart the site?\r\n\r\nI have also had the thought of using IOptionsSnapshot like @xantari .\r\n\r\nOr, if some of the internals (RewriteOptions.BranchedNext and all the rules) were made public, it would be much easier for anyone to create their own custom middleware.\r\n\r\nI am willing to collaborate on a design and submit a PR.",
        "createdAt": "2022-01-17T16:19:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/16658#issuecomment-1014706945"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU1NTA3MDczNjY=",
    "title": "No dynamic paths for UseStatusCodePages and UseExceptionHandler",
    "url": "https://github.com/dotnet/aspnetcore/issues/18383",
    "createdAt": "2020-01-16T10:16:07Z",
    "lastUpdated": "2023-08-28T23:10:04Z",
    "body": "### Is your feature request related to a problem? Please describe.\r\nCurrently UseStatusCodePages and UseExceptionHandler methods support only one handler path. But there are cases when handler path can vary depending on some conditions. For example, I have different areas and handler path should depend on the area name.\r\n\r\n### Describe the solution you\u0027d like\r\nBuilt-in extensions methods for ExceptionHandlerMiddleware and StatusCodePagesMiddleware should exist that accept path generation functions. For example, for UseStatusCodePagesWithReExecute it can be something like that:\r\n\u0060\u0060\u0060\r\npublic static IApplicationBuilder UseStatusCodePagesWithReExecute(\r\n\tthis IApplicationBuilder app,\r\n\tFunc\u003CStatusCodeContext, string\u003E generatePath,\r\n\tFunc\u003CStatusCodeContext, string\u003E generateQuery = null)\r\n{\r\n\tif (app == null)\r\n\t{\r\n\t\tthrow new ArgumentNullException(nameof(app));\r\n\t}\r\n\r\n\treturn app.UseStatusCodePages(async context =\u003E\r\n\t{\r\n\t\tvar newPath = generatePath(context);\r\n\t\tvar newQueryString = generateQuery == null ? QueryString.Empty : new QueryString(generateQuery(context));\r\n\r\n\t\tvar originalPath = context.HttpContext.Request.Path;\r\n\t\tvar originalQueryString = context.HttpContext.Request.QueryString;\r\n\t\t// Store the original paths so the app can check it.\r\n\t\tcontext.HttpContext.Features.Set\u003CIStatusCodeReExecuteFeature\u003E(new StatusCodeReExecuteFeature()\r\n\t\t{\r\n\t\t\tOriginalPathBase = context.HttpContext.Request.PathBase.Value,\r\n\t\t\tOriginalPath = originalPath.Value,\r\n\t\t\tOriginalQueryString = originalQueryString.HasValue ? originalQueryString.Value : null,\r\n\t\t});\r\n\r\n\t\t// An endpoint may have already been set. Since we\u0027re going to re-invoke the middleware pipeline we need to reset\r\n\t\t// the endpoint and route values to ensure things are re-calculated.\r\n\t\tcontext.HttpContext.SetEndpoint(endpoint: null);\r\n\t\tvar routeValuesFeature = context.HttpContext.Features.Get\u003CIRouteValuesFeature\u003E();\r\n\t\trouteValuesFeature?.RouteValues?.Clear();\r\n\r\n\t\tcontext.HttpContext.Request.Path = newPath;\r\n\t\tcontext.HttpContext.Request.QueryString = newQueryString;\r\n\t\ttry\r\n\t\t{\r\n\t\t\tawait context.Next(context.HttpContext);\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\tcontext.HttpContext.Request.QueryString = originalQueryString;\r\n\t\t\tcontext.HttpContext.Request.Path = originalPath;\r\n\t\t\tcontext.HttpContext.Features.Set\u003CIStatusCodeReExecuteFeature\u003E(null);\r\n\t\t}\r\n\t});\r\n}\r\n}\r\n\u0060\u0060\u0060\r\n\r\nI hope such methods will be added soon :)\r\n",
    "upvotes": 3,
    "labels": [
      "enhancement",
      "severity-minor",
      "affected-very-few",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU3NTIwNTA2OA==",
        "parentId": null,
        "author": "davidfowl",
        "content": "Already works for both of those pieces of middleware. Instead of a RequestDelegate, they take a new pipeline (which is a super set of the functionality).\r\n\r\nUseExceptionHandler - https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.exceptionhandlerextensions.useexceptionhandler?view=aspnetcore-3.1#Microsoft_AspNetCore_Builder_ExceptionHandlerExtensions_UseExceptionHandler_Microsoft_AspNetCore_Builder_IApplicationBuilder_System_Action_Microsoft_AspNetCore_Builder_IApplicationBuilder__\r\n\r\n\r\nUseStatusCodePages - https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.statuscodepagesextensions.usestatuscodepages?view=aspnetcore-3.1#Microsoft_AspNetCore_Builder_StatusCodePagesExtensions_UseStatusCodePages_Microsoft_AspNetCore_Builder_IApplicationBuilder_System_Action_Microsoft_AspNetCore_Builder_IApplicationBuilder__",
        "createdAt": "2020-01-16T15:29:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18383#issuecomment-575205068"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU3NTQ3NTE5Ng==",
        "parentId": null,
        "author": "Serproger",
        "content": "\u003E Already works for both of those pieces of middleware. Instead of a RequestDelegate, they take a new pipeline (which is a super set of the functionality).\r\n\r\nI have seen these overloads. But I don\u0027t understand how they can help. For example, I want to implement UseStatusCodePagesWithReExecute. I found only the way given in the first post that requires copypasting of nearly all the code of corresponding built-in extension method.",
        "createdAt": "2020-01-17T05:48:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18383#issuecomment-575475196"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDU3NTc1NjUzNw==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Triage: Backlogging this for now. It\u0027s a reasonable request, but it\u0027s not something we\u0027re likely to prioritize at this time.",
        "createdAt": "2020-01-17T19:10:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18383#issuecomment-575756537"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3NTY2MTgyODA=",
    "title": "Consider adding retries to Redis cache refresh",
    "url": "https://github.com/dotnet/aspnetcore/issues/28373",
    "createdAt": "2020-01-23T18:05:53Z",
    "lastUpdated": "2023-06-02T03:14:22Z",
    "body": "We have a number of reports of timeouts while doing \u0060RefreshAsync\u0060 in the Redis cache. These seem to be intermittent network issues. However, since we\u0027re generally doing refresh operations on behalf of the user, we should consider adding retry logic to improve our behavior in the presence of intermittent network issues.",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "feature-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczODM0MDcwNw==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-12-03T21:50:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28373#issuecomment-738340707"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU1NTQ2ODc5MDE=",
    "title": "ArgumentException \u0022unrecognized escape sequence\u0022 in RewriteOptions.AddApacheModRewrite in case of usage of regex shorthand character classes (like \\d)",
    "url": "https://github.com/dotnet/aspnetcore/issues/18555",
    "createdAt": "2020-01-24T11:39:09Z",
    "lastUpdated": "2023-10-28T14:08:19Z",
    "body": "### Description of the bug\r\nThe System.ArgumentException occurs while executing the method AddApacheModRewrite if passed file contains regex rules with shorthand character classes (like \\d).\r\n\r\n### To Reproduce\r\n\u0060\u0060\u0060 C#\r\npublic static class ApplicationExtensions\r\n{\r\n\tpublic static IApplicationBuilder UseUrlRewriter(this IApplicationBuilder builder)\r\n\t{\r\n\t\tusing (var fileReader = File.OpenText(\u0022apache_rewrite_rules.txt\u0022))\r\n\t\t{\r\n\t\t\tvar rewriteOptions = new RewriteOptions()\r\n\t\t\t\t.AddApacheModRewrite(fileReader);\r\n\r\n\t\t\treturn builder.UseRewriter(rewriteOptions);\r\n\t\t}\r\n\t}\r\n}\r\n\u0060\u0060\u0060\r\nWhere file \u0060apache_rewrite_rules.txt\u0060 contains:\r\n\u0060\u0060\u0060RewriteRule\t^/(\\d)$\t/?num=$1\u0060\u0060\u0060\r\n\r\nException message:\r\n\u0060\u0060\u0060System.ArgumentException: \u0027parsing \u0027^/(\\d)$\u0027 - Unrecognized escape sequence \\\\d.\u0027\u0060\u0060\u0060\r\nStack trace:\r\n\u0060\u0060\u0060\r\n   at System.Text.RegularExpressions.RegexParser.ScanCharEscape()\r\n   at System.Text.RegularExpressions.RegexParser.Unescape(String input)\r\n   at System.Text.RegularExpressions.Regex.Unescape(String str)\r\n   at Microsoft.AspNetCore.Rewrite.Internal.ApacheModRewrite.Tokenizer.RemoveQuotesAndEscapeCharacters(IList\u00601 tokens)\r\n   at Microsoft.AspNetCore.Rewrite.Internal.ApacheModRewrite.Tokenizer.Tokenize(String rule)\r\n   at Microsoft.AspNetCore.Rewrite.Internal.ApacheModRewrite.FileParser.Parse(TextReader input)\r\n   at Microsoft.AspNetCore.Rewrite.ApacheModRewriteOptionsExtensions.AddApacheModRewrite(RewriteOptions options, TextReader reader)\r\n   at Middleware.ApplicationExtensions.UseUrlRewriter(IApplicationBuilder builder, Action\u00601 configure) in D:\\workspace\\url-rewriter\\UrlRewriter.Middleware\\ApplicationExtensions.cs:line 17\r\n   at UrlRewriter.Tests.ApacheModRewriteTests.\u003C\u003Ec.\u003C.ctor\u003Eb__1_0(IApplicationBuilder app) in D:\\workspace\\url-rewriter\\UrlRewriter.Tests\\ApacheModRewriteTests.cs:line 22\r\n   at Microsoft.AspNetCore.Hosting.DelegateStartup.Configure(IApplicationBuilder app)\r\n   at Microsoft.AspNetCore.Hosting.Internal.AutoRequestServicesStartupFilter.\u003C\u003Ec__DisplayClass0_0.\u003CConfigure\u003Eb__0(IApplicationBuilder builder)\r\n   at Microsoft.AspNetCore.Hosting.Internal.WebHost.BuildApplication()\r\n\u0060\u0060\u0060\r\n\r\n### Comments\r\nRewriteRule statement implies to use regular expressions, so it\u0027s not clear why there is a call of \u0060Regex.Unescape\u0060 in \u0060ApacheModRewrite.Tokenizer.RemoveQuotesAndEscapeCharacters\u0060, seems like  it\u0027s a bug considering that \u0060Regex.Unescape\u0060 is unable to convert sequences such as \\w, \\d or \\s, it throws an ArgumentException.\r\n",
    "upvotes": 0,
    "labels": [
      "investigate",
      "good first issue",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxMzEwMjE4Ng==",
        "parentId": null,
        "author": "jaamison",
        "content": "Happy to take a crack at this if at all helpful. Looks like there are several other little quirks throughout the apache compatibility subsystem that break parity with apache itself that I\u0027d be happy to submit PRs for.",
        "createdAt": "2020-10-20T19:55:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18555#issuecomment-713102186"
      },
      {
        "id": "IC_kwDOAQzde85It80C",
        "parentId": null,
        "author": "jonagh",
        "content": "I just ran into this on a new proj. Simple things like \\d can be changed to [0-9] and \\. to [.] but \\w and \\s and others which represent a lot of chars are basically show-stoppers for using this feature with regex rules. \r\n\r\nAlso just realized RewriteMap is not supported :/\r\nGuess I\u0027ll convert all the rules to IISUrlRewrite format (hopefully that works fully).\r\n\r\nThis call should probably be renamed to AddApacheModRewriteWithOnlyLimitedSupport, so people like me know not to use it before we write a bunch of rules expected everything to work correctly.",
        "createdAt": "2022-08-18T21:53:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18555#issuecomment-1220005122"
      },
      {
        "id": "IC_kwDOAQzde85c_KOT",
        "parentId": null,
        "author": "danmoseley",
        "content": "\u003E Happy to take a crack at this if at all helpful.\r\n\r\n@jaamison it looks like we overlooked your offer, sorry about that. In the unlikely event you are still interested in offering PR\u0027s we\u0027d be happy to have them.",
        "createdAt": "2023-05-23T20:11:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/18555#issuecomment-1560060819"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3NTY2MTc5MDI=",
    "title": "Handling RedisCache is not connected.",
    "url": "https://github.com/dotnet/aspnetcore/issues/28372",
    "createdAt": "2020-01-28T18:47:17Z",
    "lastUpdated": "2023-06-02T03:14:21Z",
    "body": "### Is your feature request related to a problem? Please describe.\r\n\r\nhttps://github.com/StackExchange/StackExchange.Redis/issues/1120\r\nhttps://github.com/StackExchange/StackExchange.Redis/issues/1322\r\n\r\nCurrently when there is an exception in connection, it throws an exception \r\n\r\nhttps://github.com/dotnet/extensions/blob/3196f53061fcbe12fb2ebe81834124710d822a8d/src/Caching/StackExchangeRedis/src/RedisCache.cs#L173-L192\r\n\r\nand during get \r\n\r\nhttps://github.com/dotnet/extensions/blob/3196f53061fcbe12fb2ebe81834124710d822a8d/src/Caching/StackExchangeRedis/src/RedisCache.cs#L240\r\n\r\nIt will throw an exception as well.\r\n\r\n### Describe the solution you\u0027d like\r\n\r\nI think we should try to establish the connection during initialization and provide an event for connection status. So we can somehow check if Redis cache is available before using it.\r\n\r\n\r\n",
    "upvotes": 2,
    "labels": [
      "enhancement",
      "feature-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczODMzOTg5MQ==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-12-03T21:49:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28372#issuecomment-738339891"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3NTY2MTUxNDY=",
    "title": "SqlServerCache not emptying expired items",
    "url": "https://github.com/dotnet/aspnetcore/issues/28370",
    "createdAt": "2020-03-23T08:12:49Z",
    "lastUpdated": "2023-06-02T03:14:19Z",
    "body": "### Describe the bug\r\n\r\nI am seeing a scenario where the database table created for SqlServer-based DistributedCache is not being emptied properly. The number of items in the table seems to grow without bound.\r\n\r\n### To Reproduce\r\n\r\nWe are using ASP.NET Core 3.1.1:\r\n\r\n\u0060\u0060\u0060xml\r\n\u003CPackageReference Include=\u0022Microsoft.Extensions.Caching.SqlServer\u0022 Version=\u00223.1.1\u0022 /\u003E\r\n\u0060\u0060\u0060\r\n\r\nUnfortunately I don\u0027t know how we got into this situation as I observed it just now, and I don\u0027t have specific steps to reproduce.\r\n\r\nWe store items into the cache using \u0060AbsoluteExpirationRelativeToNow\u0060 and there is no sliding expiration.\r\n\r\n### Expected behavior\r\n\r\nI expect the cache to be emptied consistently to avoid growing out of bounds.\r\n\r\n### Screenshots\r\n\r\n\u0060\u0060\u0060sql\r\nSELECT COUNT(*) Count, MIN(ExpiresAtTime) Oldest\r\nFROM dbo.DistributedCache\r\nWHERE GETDATE() \u003E ExpiresAtTime;\r\n\u0060\u0060\u0060\r\n\r\nreturns\r\n\r\n| Count | Oldest |\r\n|-|-|\r\n| 139962 | 2020-03-21 02:12:05.8058460 \u002B00:00 |\r\n\r\n### Additional context\r\n\r\nI\u0027ve looked at the code that does the delete: [src/Caching/SqlServer/src/SqlQueries.cs#L56](https://github.com/dotnet/extensions/blob/f4066026ca06984b07e90e61a6390ac38152ba93/src/Caching/SqlServer/src/SqlQueries.cs#L56). This seems a bit naive to me if there are many entries to be deleted, for some reason. If I run the code, our database seems to choke. I do see an index on \u0060ExpiresAt\u0060 but it doesn\u0027t seem to help.",
    "upvotes": 0,
    "labels": [
      "investigate",
      "feature-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYwMzE5MDI5OA==",
        "parentId": null,
        "author": "DanielLidstromTicket",
        "content": "I should have included the time of the sql query invocation. Anyway, I\u0027ve solved this problem in our case with a database job that purges the queue on an hourly basis. Here\u0027s the SP:\r\n\r\n\u0060\u0060\u0060sql\r\nCREATE OR ALTER PROCEDURE dbo.ClearDistributedCache\r\nAS\r\nBEGIN\r\n    SELECT Id\r\n    INTO #ToDelete\r\n    FROM dbo.DistributedCache\r\n    WHERE GETDATE() \u003E ExpiresAtTime;\r\n\r\n    -- delete in pages to avoid consuming too much resources\r\n    deleteMore:\r\n    DELETE TOP (40)\r\n    FROM dbo.DistributedCache\r\n    WHERE Id IN\r\n          (\r\n              SELECT Id FROM #ToDelete\r\n          );\r\n    IF @@ROWCOUNT \u003C\u003E 0\r\n        GOTO deleteMore;\r\nEND;\r\nGO\r\n\u0060\u0060\u0060\r\n",
        "createdAt": "2020-03-24T11:40:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28370#issuecomment-603190298"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcwNzM2NDAwNQ==",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "Triage: We should log when DB operations fail. We\u0027re assuming there is some failure happening here, but any exceptions are currently ignored.\r\n\r\nDo you happen to have SQL logs that would show a failure?",
        "createdAt": "2020-10-12T21:51:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28370#issuecomment-707364005"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczODMzNzc5OA==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-12-03T21:44:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28370#issuecomment-738337798"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU2MDA5MDAzOTI=",
    "title": "LoadAsync on Session - when _isNewSessionKey is true",
    "url": "https://github.com/dotnet/aspnetcore/issues/20898",
    "createdAt": "2020-04-16T09:46:39Z",
    "lastUpdated": "2023-10-28T14:08:20Z",
    "body": "https://github.com/dotnet/aspnetcore/blob/8b000d961cd3ccfcc8090fb8368fd6598bace978/src/Middleware/Session/src/DistributedSession.cs\r\n\r\nShould Load/LoadAsync be a no-op when _isNewSessionKey is true. Taking the advice to call LoadAsync prior to accessing the session with get/trygetvalue/set  I would of thought we\u0027d guard against unnecsssary chitchat to the cache if we know the session is new?  \r\n\r\nI though about doing Request.Cookies[\u0022sesscoookie\u0022] != null then await LoadAsync but then doing Get/Set/Id/IsAvailable will simply call load anyway if not _loaded isnt marked.\r\n\r\n",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "Perf",
      "breaking-change",
      "severity-nice-to-have",
      "affected-few",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxNDg0Njk4MQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "That\u0027s an interesting point. The case that doesn\u0027t cover is if the session database is down, IsAvailable would not be set properly. That might be OK since that\u0027s not the general case, or we might have IsAvailable do its own check.",
        "createdAt": "2020-04-16T19:20:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20898#issuecomment-614846981"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxNDk2MTU5Mg==",
        "parentId": null,
        "author": "sitepodmatt",
        "content": "@Tratcher if people are depending on IsAvailable having that do it\u0027s own check would be better imo instead of attempting to fetch a known non-existant key for the sake of it. ",
        "createdAt": "2020-04-17T00:07:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20898#issuecomment-614961592"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxNDk2MjYyMQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "IsAvailable would have to do the same call, the distributed cache only offers read and write apis.",
        "createdAt": "2020-04-17T00:11:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20898#issuecomment-614962621"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxNTA0OTcyOA==",
        "parentId": null,
        "author": "sitepodmatt",
        "content": "I think we\u0027re getting our wires crossed here, possibly about different issues? \r\n\r\nWhat I\u0027m saying is that _cache.Get shouldn\u0027t be called if _isNewSessionKey \r\n\r\n\u0060\u0060\u0060\r\n  var data = _cache.Get(_sessionKey);\r\n                    if (data != null)\r\n                    {\r\n                        Deserialize(new MemoryStream(data));\r\n                    }\r\n                    else if (!_isNewSessionKey)\r\n                    {\r\n                        _logger.AccessingExpiredSession(_sessionKey);\r\n                    }\r\n\u0060\u0060\u0060",
        "createdAt": "2020-04-17T05:25:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20898#issuecomment-615049728"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxNTA1MjE5OA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "I understand, it just has side effects on IsAvailable.",
        "createdAt": "2020-04-17T05:34:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20898#issuecomment-615052198"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxNTA1MzI2NQ==",
        "parentId": null,
        "author": "sitepodmatt",
        "content": "_presumeAvailability flag?  I very much doubt people are implementing app/middleware and saying \u0027before we do work with this freshly basked session let\u0027s check the session store is actually available\u0027 or branching for both cases",
        "createdAt": "2020-04-17T05:38:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20898#issuecomment-615053265"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxNTM4NjEwMg==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Yeah, I don\u0027t know if anyone is actually using IsAvailable but it was designed to let your site gracefully degrade functionality if the session store was unavailable. E.g. disable the Add-To-Cart button if the cart was going to be stored in session.",
        "createdAt": "2020-04-17T18:01:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20898#issuecomment-615386102"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxNTQ0NDMzMg==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Flagging this as a \u0060breaking-change\u0060. We *think* it could be done in a non-breaking way but we need to ensure we don\u0027t break \u0060IsAvailable\u0060.",
        "createdAt": "2020-04-17T20:15:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20898#issuecomment-615444332"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY0MTE0MzgyMA==",
        "parentId": null,
        "author": "sitepodmatt",
        "content": "Has a fix/workaround been scheduled for .Net 5?  If not, I would like to propose a warning on the main docs along the lines:\r\n\r\n\u0022When optimizing for performance, and thus probably using an async request pipeline, combined with using an external session store, be aware the current implementation means that the session store will be \u0022getted\u0022 even for newly minted sessions, the implications (if any) will depend on your setup. \u0022 \r\n\r\nI accept it needs two pre-requisites to occur but in .NET 3.1\u002B where many developers are favoring an async request pipeline, are those using an external session store such a small number that this is considered a low-priority? ",
        "createdAt": "2020-06-09T09:06:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20898#issuecomment-641143820"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY0MTM5MTQ1OA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E Has a fix/workaround been scheduled for .Net 5?\r\n\r\nNo, it\u0027s on the backlog.\r\n\r\n\u003E where many developers are favoring an async request pipeline\r\n\r\nI don\u0027t follow, AspNetCore\u0027s request pipeline has always been async.\r\n\r\n\u003E are those using an external session store such a small number that this is considered a low-priority\r\n\r\nIt\u0027s considered low priority because:\r\n- It only affects performance, not functionality, and the severity of that performance impact has not been demonstrated. I assume fetching a non-existent key from the distributed cache is faster rather than slower than fetching an existing key?\r\n- It\u0027s been like this for multiple years and releases without causing significant issues.\r\n- It only affects the first request / new sessions. You\u0027ll have to pay the same access cost (or more) on all subsequent requests that do have session data. Amortized out, it\u0027s not clear you\u0027d save much in the long run.\r\n\r\nI\u0027m marking this as \u0022help wanted\u0022 if anyone wants to try fixing it in 5.0.",
        "createdAt": "2020-06-09T15:46:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/20898#issuecomment-641391458"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU2MDU4MTExMTA=",
    "title": "Support Header matching in Endpoint Routing",
    "url": "https://github.com/dotnet/aspnetcore/issues/21157",
    "createdAt": "2020-04-23T19:38:05Z",
    "lastUpdated": "2024-02-14T20:30:58Z",
    "body": "### Is your feature request related to a problem? Please describe.\r\nNo. In the context of YARP, some routes must support header matching. If there is interest, I can submit a PR to contribute that here.\r\n\r\n### Describe the solution you\u0027d like\r\nOur implementation handles the following:\r\n* Match on the presence of a given header\r\n* Match on a given value of a header (e.g. only match if header \u0060x-example\u0060 has value \u0060abc\u0060, \u0060def\u0060 or \u0060ace\u0060. Custom string comparison modes are supported)\r\n* Match on a given prefix of a header value (e.g. only match if header \u0060x-eample\u0060 starts with \u0060abc\u0060, \u0060def\u0060 or \u0060ace\u0060. Custom string comparison modes are supported).\r\n\r\n### Additional context\r\nWe have not implemented jump tables yet. We would hope the ASP .NET Core can take that on down the line if it seems relevant.",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "feature-yarp",
      "severity-major",
      "affected-medium",
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxODYzMTEyMA==",
        "parentId": null,
        "author": "davidni",
        "content": "@rynowak fyi as you helped in our internal implementation.",
        "createdAt": "2020-04-23T19:57:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21157#issuecomment-618631120"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxODY1Mjg3MA==",
        "parentId": null,
        "author": "rynowak",
        "content": "Yes, I think we\u0027d be very interested in having your implementation contributed \uD83D\uDC4D ",
        "createdAt": "2020-04-23T20:34:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21157#issuecomment-618652870"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxOTIyMTE0OQ==",
        "parentId": null,
        "author": "analogrelay",
        "content": "@davidni you were up to contribute this, right?",
        "createdAt": "2020-04-24T20:20:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21157#issuecomment-619221149"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYxOTI5MDM4Nw==",
        "parentId": null,
        "author": "davidni",
        "content": "@anurse yep, I filed the issue to confirm there is still interest in it and avoid unnecessary work if not. Expect something by mid next week, though no guarantees due to DRI duties.",
        "createdAt": "2020-04-25T00:27:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21157#issuecomment-619290387"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYzNzg1Mjk3Mw==",
        "parentId": null,
        "author": "tmbull",
        "content": "I\u0027m not sure if this is useful out side of reverse proxy applications, but I have a specialized reversed proxy that could use this feature. ",
        "createdAt": "2020-06-02T23:06:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21157#issuecomment-637852973"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY4MTExMDY2MA==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-08-26T20:37:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21157#issuecomment-681110660"
      },
      {
        "id": "IC_kwDOAQzde8444TyP",
        "parentId": null,
        "author": "Tratcher",
        "content": "This work was contributed to YARP and should now look at porting it into ASP.NET Core.\r\n\r\nSupport for query parameter routing was a contributed to YARP.",
        "createdAt": "2021-10-28T22:59:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21157#issuecomment-954285199"
      },
      {
        "id": "IC_kwDOAQzde85KP-Ya",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-13T17:09:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21157#issuecomment-1245701658"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU2MDg1NjU1OTA=",
    "title": "Enhance HTTPS redirect middleware for multi-hostname scenarios",
    "url": "https://github.com/dotnet/aspnetcore/issues/21291",
    "createdAt": "2020-04-28T19:40:44Z",
    "lastUpdated": "2023-08-28T23:10:01Z",
    "body": "See: https://github.com/dotnet/tye/issues/354\r\n\r\nThe HTTPS redirect middleware allows you to configure (via config) a single port to use for HTTPS redirects. There are cases where this isn\u0027t sophisticated enough because each hostname you\u0027re listening on has a different HTTPS port value.",
    "upvotes": 0,
    "labels": [
      "Needs: Design",
      "enhancement",
      "feature-yarp",
      "affected-few",
      "severity-minor",
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyMTM0MTQzOQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Can you clarify why each host has a different port? Hosts can share ports using host headers and SNI.",
        "createdAt": "2020-04-29T17:04:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21291#issuecomment-621341439"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyMTQ0NTExOA==",
        "parentId": null,
        "author": "analogrelay",
        "content": "@Tratcher well, if they\u0027re different ASP.NET Core apps, we still have the port sharing problem right? Regardless of feasibility, only one process can bind to the port.",
        "createdAt": "2020-04-29T20:28:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21291#issuecomment-621445118"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyMTQ2MTIyNg==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Nevermind, I just read the linked issue and it\u0027s a very different scenario. The app only has one local port. The app accepts requests directly and through a proxy. The host name is the same in both cases, but the public and internal ports are different.\n\nIn this example it needs to be able to redirect myhost:80 -\u003E 443 and myhost:4567 -\u003E 4568.",
        "createdAt": "2020-04-29T21:00:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21291#issuecomment-621461226"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyMTQ2MjE3Ng==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Why isn\u0027t the front end enforcing its own https?",
        "createdAt": "2020-04-29T21:02:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21291#issuecomment-621462176"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyMTQ5OTA0OQ==",
        "parentId": null,
        "author": "rynowak",
        "content": "As in, have the proxy responsible for the redirect? The proxy in this case is docker I think, not a dedicated proxy server.",
        "createdAt": "2020-04-29T22:25:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21291#issuecomment-621499049"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyMjU0MzcwOA==",
        "parentId": null,
        "author": "analogrelay",
        "content": "Is there a proposed new behavior here?",
        "createdAt": "2020-05-01T20:05:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21291#issuecomment-622543708"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyMjU1NzE0NA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "The middleware needs to be capable of doing a host\u002Bport lookup from IServerAddresses and/or a static list to get the matching https port. A collection of \u0060KVP\u003Cstring, int\u003E\u0060 is the basic structure.\r\n\r\nNote today it throws if trying to auto-configure and it finds more than one https endpoint in IServerAddresses.",
        "createdAt": "2020-05-01T20:35:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21291#issuecomment-622557144"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNjA0ODQwNw==",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "@jkotalik Does Tye have an API proposal for this? Also, how important is this API to Tye?",
        "createdAt": "2020-05-08T22:32:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21291#issuecomment-626048407"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYzNzExMjMxNw==",
        "parentId": null,
        "author": "jkotalik",
        "content": "I don\u0027t think this critical for Tye, we wouldn\u0027t be able to utilize an API change here as we are primarily targeting 3.1.",
        "createdAt": "2020-06-01T21:26:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21291#issuecomment-637112317"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2Mzc0NzgzMA==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-07-24T21:48:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21291#issuecomment-663747830"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU2MTI3NzYxMTM=",
    "title": "Only HTTPS redirect for a specific host (the one with a valid cert)",
    "url": "https://github.com/dotnet/aspnetcore/issues/21506",
    "createdAt": "2020-05-05T17:36:18Z",
    "lastUpdated": "2023-08-28T23:10:01Z",
    "body": "Currently the HTTPS redirection middleware always redirects to HTTPS, however this breaks stuff when the host is not the one for which the certificate has been issued or in my case when there is no certificate because the SSL termination has happened two proxies higher up.\r\n\r\nFor example, running an ASP.NET Core app hosted in Kubernetes means that there is normally 2 proxies in front of Kestrel. One is the ingress controller, which is normally configured to use a Let\u0027s Encrypt certificate and is doing the SSL termination and then a second proxy is an internal service load balancer in front of all the pods where the apps are running.\r\n\r\nKubernetes checks the health of a pod by doing readiness and liveness checks, but these are being done via the internal network on a local IP address (e.g. http://10.8.0.7/healthz). If the HTTPS redirect middleware is enabled then it will try to redirect this request to https://10.8.0.7/healthz, which cannot be resolved and the service will fail the health check and get subsequently killed.\r\n\r\nCurrently one can apply a workaround fix by specifying the X-Forwarded-Proto header for the health check inside Kubernetes, which will prevent the middleware from redirecting, but that only works in some instances. Other cloud infrastructure and 3rd party services which cannot be configured to send the X-Forwarded-Proto header will still fail to health check the service.\r\n\r\nThis could be easily prevented by configuring a list of hosts for which the https redirection middleware will redirect, otherwise not.\r\n\r\nCurrently I have to run a custom middleware before the https redirection middleware and check the host and then based on the host decide if I set the Request.Scheme to https or not in order to workaround this issue, but it would be nicer if this could be configured in one middleware.\r\n\r\nAny thoughts?\r\n\r\nEDIT:\r\n\r\nBasically what I want to do is to give the HTTPS redirect middleware a list of hosts for which it should redirect to https, otherwise do nothing:\r\n\r\n- \u0060api.example.org\u0060\r\n- \u0060www.example.org\u0060\r\n- \u0060example.org\u0060\r\n\r\notherwise don\u0027t redirect.",
    "upvotes": 5,
    "labels": [
      "Needs: Design",
      "enhancement",
      "affected-few",
      "severity-minor",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNDI3MTg0Ng==",
        "parentId": null,
        "author": "Tratcher",
        "content": "This looks like an expansion of https://github.com/dotnet/aspnetcore/issues/21291.",
        "createdAt": "2020-05-05T19:53:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21506#issuecomment-624271846"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNDI3Njg5OQ==",
        "parentId": null,
        "author": "dustinmoris",
        "content": "I saw that issue and I\u0027m not sure if it\u0027s necessarily a duplicate.\r\n\r\nThere is HTTPS redirect for multiple hosts and then there is NOT redirecting for hosts except {list}.\r\n\r\nYou commented on the other issue the following:\r\n\r\n\u003E In this example it needs to be able to redirect myhost:80 -\u003E 443 and myhost:4567 -\u003E 4568.\r\n\r\nThis wouldn\u0027t fix the problem which I\u0027ve listed, because I want http://example.org to get redirected, but http://127.0.0.1 or http://10.8.0.1 to just be left alone and not redirected so internal health checks can just continue to work.",
        "createdAt": "2020-05-05T20:03:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21506#issuecomment-624276899"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNDI3ODIxMQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "You\u0027re right. I edited my comment to clarify this is an expansion of that scenario that clarifies what to do if something isn\u0027t in the given list.",
        "createdAt": "2020-05-05T20:06:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21506#issuecomment-624278211"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYyNDI4MTM1Mg==",
        "parentId": null,
        "author": "dustinmoris",
        "content": "Great, thank you!",
        "createdAt": "2020-05-05T20:13:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/21506#issuecomment-624281352"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU2MjU4OTE2NTY=",
    "title": "CORS header not being set for internal server error response",
    "url": "https://github.com/dotnet/aspnetcore/issues/22281",
    "createdAt": "2020-05-27T17:37:04Z",
    "lastUpdated": "2024-10-08T07:03:18Z",
    "body": "For internal server error, there are no access-control-* headers in the response. As far as I know \r\n[this issue](https://github.com/dotnet/aspnetcore/issues/2378) should be fixed since ASP.NET Core 2.2.\r\n\r\nHere is my CORS configuration:\r\n\u0060\u0060\u0060 C#\r\nservices.AddCors(options =\u003E\r\n{\r\n    options.AddPolicy(name: \u0022AllowedOrigins\u0022,\r\n        policyBuilder =\u003E\r\n        {\r\n            var urls = Configuration.GetSection(\u0022Host:AllowedOrigins\u0022).Get\u003CList\u003Cstring\u003E\u003E();\r\n            policyBuilder.WithOrigins(urls.ToArray())\r\n                .AllowAnyMethod()\r\n                .AllowAnyHeader()\r\n                .SetIsOriginAllowed((host) =\u003E true)\r\n                .AllowCredentials();\r\n        });\r\n});\r\n\u0060\u0060\u0060\r\nAnd in \u0060Configure\u0060 method :\r\n\r\n\u0060\u0060\u0060C#\r\napp.UseRouting();\r\n\r\napp.UseCors(\u0022AllowedOrigins\u0022);\r\napp.UseAuthentication();\r\napp.UseAuthorization();\r\n\r\napp.UseEndpoints(endpoints =\u003E\r\n{\r\n    endpoints.MapControllers();\r\n});\r\n\u0060\u0060\u0060\r\n### Further technical details\r\n\u0060\u0060\u0060\r\n- ASP.NET Core version: 3.1\r\n\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   3.1.202\r\n Commit:    6ea70c8dca\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.18363\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\3.1.202\\\r\n\r\nHost (useful for support):\r\n  Version: 3.1.4\r\n  Commit:  0c2e69caa6\r\n\r\n.NET Core SDKs installed:\r\n  1.0.0 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.802 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.402 [C:\\Program Files\\dotnet\\sdk]\r\n  3.1.200 [C:\\Program Files\\dotnet\\sdk]\r\n  3.1.202 [C:\\Program Files\\dotnet\\sdk]\r\n- Visual Studio 15.6\r\n\u0060\u0060\u0060\r\n",
    "upvotes": 6,
    "labels": [
      "Needs: Design",
      "investigate",
      "enhancement",
      "triage-focus",
      "feature-cors",
      "severity-nice-to-have",
      "affected-very-few",
      "Priority:2",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDYzNTYwMDQ4Mw==",
        "parentId": null,
        "author": "sackri10",
        "content": "After seeing the Code fix done as part of Issue #2378. I feel like the fix is not considered for latest code.",
        "createdAt": "2020-05-28T20:50:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/22281#issuecomment-635600483"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY0MTU0MjY1OQ==",
        "parentId": null,
        "author": "mkArtakMSFT",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-06-09T20:09:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/22281#issuecomment-641542659"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg1NjU5ODI5MQ==",
        "parentId": null,
        "author": "Entroper",
        "content": "I know this seems insignificant, but this is a thorn in my side when helping newer developers debug.  Every 500, 404, 401/403 etc. is reported by the browser as a CORS error.  A lot of time is wasted chasing these red herrings when the real issue has nothing to do with CORS.",
        "createdAt": "2021-06-08T09:07:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/22281#issuecomment-856598291"
      },
      {
        "id": "IC_kwDOAQzde85AqKd5",
        "parentId": null,
        "author": "pavlexander",
        "content": "hey, I\u0027ve been struggling with the same issue and following solution seems to have worked:\r\n\r\n\u0060\u0060\u0060\r\napp.UseExceptionHandler(exceptionHandlerApp =\u003E\r\n{\r\n    exceptionHandlerApp.Run(async context =\u003E\r\n    {\r\n        context.Response.StatusCode = StatusCodes.Status500InternalServerError;\r\n    });\r\n});\r\n\r\napp.UseCors(...);\r\n\u0060\u0060\u0060\r\n\r\nI have made an answer on StackOverflow https://stackoverflow.com/a/71695813/1215913\r\n\r\nThere is also an explanation provided by another author why the solution works.\r\n\r\nHappy coding :)\r\n\r\n",
        "createdAt": "2022-03-31T16:09:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/22281#issuecomment-1084794745"
      },
      {
        "id": "IC_kwDOAQzde85xvCJ8",
        "parentId": null,
        "author": "dev-sareno",
        "content": "I had the same issue. As a workaround, I added a new middleware that act as a global exception handler:\r\n\u0060\u0060\u0060csharp\r\nvar app = builder.Build();\r\n\r\napp.Use(async (context, next) =\u003E\r\n{\r\n        try\r\n        {\r\n            await next(context);\r\n        }\r\n        catch (Exception e)\r\n        {\r\n            context.Response.StatusCode = StatusCodes.Status500InternalServerError;\r\n            await context.Response.WriteAsync(e.ToString());\r\n        }\r\n});\r\n\r\napp.UseCors();\r\n\u0060\u0060\u0060",
        "createdAt": "2024-01-24T13:46:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/22281#issuecomment-1908155004"
      },
      {
        "id": "IC_kwDOAQzde86O_gT9",
        "parentId": null,
        "author": "filipbekic01",
        "content": "We spent hours and hours trying to figure out what\u0027s wrong with internal server response. First we thought it\u0027s our proxy cutting the response but no, it\u0027s dotnet. Hope for the best. ",
        "createdAt": "2024-10-08T07:03:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/22281#issuecomment-2399012093"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3NTY2MTA3NTk=",
    "title": "IOptions\u003CRedisCacheOptions\u003E  When change RedisCacheOptions I dont see new connection",
    "url": "https://github.com/dotnet/aspnetcore/issues/28368",
    "createdAt": "2020-06-15T08:14:54Z",
    "lastUpdated": "2023-09-06T11:46:12Z",
    "body": "### Describe the bug\r\n\r\nWhen change RedisCacheOptions  RedisCache dont  connect again on runtime because RedisCache is Singleton and Singleton objects uses IOptionsMonitor when configuration changes. I  Think we must change IOptions\u003CRedisCacheOptions\u003E to IOptionsMonitor\u003CRedisCacheOptions\u003E and we must write IOptionsMonitor OnChange event\r\n",
    "upvotes": 3,
    "labels": [
      "feature-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY4MTEwNzY3OA==",
        "parentId": null,
        "author": "DavidParks8",
        "content": "This feature needs to be added to support runtime secret rotation of redis keys.",
        "createdAt": "2020-08-26T20:30:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28368#issuecomment-681107678"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY4MTEwOTA3OQ==",
        "parentId": null,
        "author": "DavidParks8",
        "content": "@Pilchie is there an owner of the stackexchange caching extension who could drive this feature?",
        "createdAt": "2020-08-26T20:33:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28368#issuecomment-681109079"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczODMzNTI4MA==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-12-03T21:38:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28368#issuecomment-738335280"
      },
      {
        "id": "IC_kwDOAQzde85l0N2D",
        "parentId": null,
        "author": "RoystonS",
        "content": "Without the ability to change the configuration of the singleton in place, how _are_ people working around it and coping with the rotation of keys?  In a server environment I don\u0027t really want to be having to restart my server each time I rotate a key on another database machine.",
        "createdAt": "2023-09-06T11:46:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28368#issuecomment-1708187011"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU2NDMwODQ2NTY=",
    "title": "It is not clear that UseCORS must come before UseResponseCaching",
    "url": "https://github.com/dotnet/aspnetcore/issues/23218",
    "createdAt": "2020-06-22T13:44:30Z",
    "lastUpdated": "2023-08-28T23:10:00Z",
    "body": "\u003C!--\r\n\r\nMore information on our issue management policies can be found here: https://aka.ms/aspnet/issue-policies\r\n\r\nPlease keep in mind that the GitHub issue tracker is not intended as a general support forum, but for reporting **non-security** bugs and feature requests.\r\n\r\nIf you believe you have an issue that affects the SECURITY of the platform, please do NOT create an issue and instead email your issue details to secure@microsoft.com. Your report may be eligible for our [bug bounty](https://www.microsoft.com/en-us/msrc/bounty-dot-net-core) but ONLY if it is reported through email.\r\nFor other types of questions, consider using [StackOverflow](https://stackoverflow.com).\r\n\r\n--\u003E\r\n\r\n### Describe the bug\r\nIf you call \u0060app.UseResponseCaching\u0060 before \u0060app.UseCORS\u0060 in the \u0060Startup.cs\u0060 of a .net core web api some users will see CORS errors because the response caching middle-ware fails to cache the headers produced by the CORS middle-ware.\r\n\r\nEither the the CORS middle-ware should be updated to inject the CORS headers in a way that can be cached, or the two modules should be able to generate an error if they are added in the wrong order to prevent developers making this mistake.\r\n\r\nAt the very least the documentation should point out what the required ordering is.\r\n\r\n### To Reproduce\r\n1) Run the API from this repo, it is just the basic .net core API template with CORS and ResponseCaching added, in the \u0027wrong\u0027 order, https://github.com/resgroup/CachingCORSErrorExample\r\n2) Run queries from curl on the command line to avoid client side caching getting in the way\r\n3) Run \u0060curl \u0022https://localhost:44331/weatherforecast\u0022 -i -H \u0022Origin:http://localhost:8080\u0022\u0060, you should see the \u0060Access-Control-Allow-Origin: http://localhost:8080\u0060 header that enables the browser to use the response.\r\n4) Run the same request again, the \u0060Access-Control-Allow-Origin: http://localhost:8080\u0060 header will be missing and there will be an \u0060age\u0060 header, showing that the result came from the cache.  This response would cause a CORS error in a browser.\r\n\r\nThis is unlikely to come up as an error in the browser for a single user because client side caching will successfully cache the \u0060Access-Control-Allow-Origin\u0027 header.  But if a second user access the API they will not see the header and get a CORS error.\r\n\r\nIf you move the call to \u0060app.UseCors\u0060 here https://github.com/resgroup/CachingCORSErrorExample/blob/7ff61a0f64a85c8f90c4838b6933f9e375631fb3/Startup.cs#L59 above the call to \u0060app.UseResponseCaching\u0060 and repeat the test you will see the \u0060Access-Control-Allow-Origin\u0027 header in both responses.\r\n\r\n### Exceptions (if any)\r\nNone\r\n\r\n### Further technical details\r\n- ASP.NET Core version = 3.1.3\r\n- Include the output of \u0060dotnet --info\u0060\r\n\u0060\u0060\u0060\r\nC:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\u003Edotnet --info\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   3.1.301\r\n Commit:    7feb845744\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.17134\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\3.1.301\\\r\n\r\nHost (useful for support):\r\n  Version: 3.1.5\r\n  Commit:  65cd789777\r\n\r\n.NET Core SDKs installed:\r\n  2.1.202 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.403 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.502 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.503 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.505 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.602 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.700 [C:\\Program Files\\dotnet\\sdk]\r\n  2.1.801 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.103 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.202 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.300 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.401 [C:\\Program Files\\dotnet\\sdk]\r\n  3.1.201 [C:\\Program Files\\dotnet\\sdk]\r\n  3.1.301 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET Core runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.19 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.2.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.2.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.2.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.2.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.2.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.19 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.2.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.2.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.2.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.2.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.2.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.1.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.1.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.11 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.12 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.19 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.2.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.2.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.2.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.2.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.2.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.1.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.1.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 3.1.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 3.1.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\nTo install additional .NET Core runtimes or SDKs:\r\n  https://aka.ms/dotnet-download\r\n\u0060\u0060\u0060\r\n- VS 2019 (16.6.2)\r\n",
    "upvotes": 4,
    "labels": [
      "bug",
      "area-mvc",
      "affected-few",
      "severity-minor",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY0NzU0ODMyNw==",
        "parentId": null,
        "author": "javiercn",
        "content": "@Alan-Hinton thanks for contacting us.\r\n\r\nWe have docs for this [here](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-3.1#built-in-middleware) that speak about the order, but you are right in that they are incomplete.\r\n\r\n@Rick-Anderson can you update the table here?\r\n\r\nAlso, not sure if there is a bug lurking here. CORS adds the appropriate caching headers [here](https://github.com/dotnet/aspnetcore/blob/adbedd2cfb8dea7b5af3fe9e1c0d49684596e6d5/src/Middleware/CORS/src/Infrastructure/CorsService.cs#L113-L123).\r\n\r\nIs your scenario that there are missing CORS headers in the response? Is the scenario that you ar e receiving non-cors responses on CORS requests or vice-versa?\r\n\r\nFrom what I can tell, response caching should be able to go before CORS. @JunTaoLuo @Tratcher, do you have any thoughts?",
        "createdAt": "2020-06-22T14:17:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/23218#issuecomment-647548327"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY0NzYwNTkxNQ==",
        "parentId": null,
        "author": "Alan-Hinton",
        "content": "From my understanding the reason Responsecaching before CORS doesn\u0027t work is because the code you point to is eventually called from a delegate [here](https://github.com/dotnet/aspnetcore/blob/adbedd2cfb8dea7b5af3fe9e1c0d49684596e6d5/src/Middleware/CORS/src/Infrastructure/CorsMiddleware.cs#L216) and the delegate doesn\u0027t actually get executed until just before the whole response returns, so after caching happens.  Therefore the results of the CORS middleware never get cached, whatever order you add the services in.\r\n\r\nHowever if you add CORS before ResponseCaching it means CORS will be executed on every request, even if the response is cached, and will successfully add the required headers.  Not caching CORS headers has the advantage that if you access the same endpoint from multiple origins they will all hit the same cache key and therefore the load on the server will be lower.",
        "createdAt": "2020-06-22T15:44:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/23218#issuecomment-647605915"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY0NzY3NzAyMg==",
        "parentId": null,
        "author": "Tratcher",
        "content": "@Alan-Hinton\u0027s right the issue is with when Cors adds the headers:\r\nhttps://github.com/dotnet/aspnetcore/blob/adbedd2cfb8dea7b5af3fe9e1c0d49684596e6d5/src/Middleware/CORS/src/Infrastructure/CorsMiddleware.cs#L214-L226\r\n\r\nThe caching middleware captures the headers before OnStarting is called rather than afterwards.\r\n\r\nOne fix would be for the caching middleware to shim OnStarting and run those callbacks before it captured the headers. (Complex)\r\n\r\nAnother option would be fore the cors middleware to apply the response headers before calling next. I\u0027m not sure why it\u0027s waiting for OnStarting today.",
        "createdAt": "2020-06-22T17:42:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/23218#issuecomment-647677022"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY0ODA5NDQ4Nw==",
        "parentId": null,
        "author": "javiercn",
        "content": "\u003E However if you add CORS before ResponseCaching it means CORS will be executed on every request, even if the response is cached, and will successfully add the required headers. Not caching CORS headers has the advantage that if you access the same endpoint from multiple origins they will all hit the same cache key and therefore the load on the server will be lower.\r\n\r\nI\u0027m not sure what this is necessarily desirable since you might want to have different contents server per origin, and this would prevent that.",
        "createdAt": "2020-06-23T11:46:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/23218#issuecomment-648094487"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY0ODA5NTA0OQ==",
        "parentId": null,
        "author": "javiercn",
        "content": "@Tratcher I\u0027m moving this to the Backlog for the time being, but lets sync on this to come up with a plan.",
        "createdAt": "2020-06-23T11:48:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/23218#issuecomment-648095049"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY0ODg0MzEzNw==",
        "parentId": null,
        "author": "Alan-Hinton",
        "content": "\u003E \u003E However if you add CORS before ResponseCaching it means CORS will be executed on every request, even if the response is cached, and will successfully add the required headers. Not caching CORS headers has the advantage that if you access the same endpoint from multiple origins they will all hit the same cache key and therefore the load on the server will be lower.\r\n\u003E \r\n\u003E I\u0027m not sure what this is necessarily desirable since you might want to have different contents server per origin, and this would prevent that.\r\n\r\nIf you did explicitly want to serve a different response to each origin then you could put \u0060VaryByHeader = \u0022Origin\u0022\u0060 in you response caching attribute and I think that it would work as expected.",
        "createdAt": "2020-06-24T14:07:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/23218#issuecomment-648843137"
      },
      {
        "id": "IC_kwDOAQzde844khDZ",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-10-22T00:19:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/23218#issuecomment-949096665"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU2NjQ3NDg2MjY=",
    "title": "Endpoint routing can not invoke a static file middleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/24252",
    "createdAt": "2020-07-23T20:34:51Z",
    "lastUpdated": "2024-11-27T07:25:07Z",
    "body": "### Describe the bug\r\nThe static file middleware does not allow any form of serving of files when used in combination with endpoint routing. Maybe I am missing something here, but this prevents me from doing stuff like this:\r\n\r\nNotice I am essentially trying to add auth to my Swagger UI without writing a custom middleware.\r\n\r\n\u0060\u0060\u0060\r\napp.UseEndpoints(endpoints =\u003E\r\n{\r\n    endpoints.MapControllers();\r\n\r\n    var swaggerUiDelegate = endpoints.CreateApplicationBuilder().UseSwaggerUI(options =\u003E\r\n    {\r\n        // Set documentation route to /docs\r\n        options.RoutePrefix = \u0022docs\u0022;\r\n    })\r\n    .Build();\r\n\r\n    endpoints.Map(\u0022docs/{*wildcard}\u0022, swaggerUiDelegate).RequireAuthorization(\u0022Swagger\u0022);\r\n});\r\n\u0060\u0060\u0060\r\n\r\n### To Reproduce\r\nThe above code should work if you essentially just add Swashbuckle to your project and attempt to add auth to your Swagger UI.\r\n\r\n### Exceptions (if any)\r\nInvalidOperationException: The request reached the end of the pipeline without executing the endpoint: \u0027docs/{*wildcard}\u0027. Please register the EndpointMiddleware using \u0027IApplicationBuilder.UseEndpoints(...)\u0027 if using routing.\r\n\r\n### Further technical details\r\n- ASP.NET Core version = 3.1\r\n- Include the output of \u0060dotnet --info\u0060\r\n\u0060\u0060\u0060\r\n.NET Core SDK (reflecting any global.json):\r\n Version:   3.1.201\r\n Commit:    b1768b4ae7\r\n\r\nRuntime Environment:\r\n OS Name:     Mac OS X\r\n OS Version:  10.15\r\n OS Platform: Darwin\r\n RID:         osx.10.15-x64\r\n Base Path:   /usr/local/share/dotnet/sdk/3.1.201/\r\n\r\nHost (useful for support):\r\n  Version: 5.0.0-preview.7.20364.11\r\n  Commit:  53976d38b1\r\n\r\n.NET SDKs installed:\r\n  2.1.805 [/usr/local/share/dotnet/sdk]\r\n  3.1.201 [/usr/local/share/dotnet/sdk]\r\n  3.1.302 [/usr/local/share/dotnet/sdk]\r\n  5.0.100-preview.7.20366.6 [/usr/local/share/dotnet/sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.17 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.17 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.1.3 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.1.6 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 5.0.0-preview.7.20365.19 [/usr/local/share/dotnet/shared/Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.1.17 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.20 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.1.3 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.1.6 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 5.0.0-preview.7.20364.11 [/usr/local/share/dotnet/shared/Microsoft.NETCore.App]\r\n\r\nTo install additional .NET runtimes or SDKs:\r\n  https://aka.ms/dotnet-download\r\n\u0060\u0060\u0060\r\n- The IDE (VS / VS Code/ VS4Mac) you\u0027re running on, and it\u0027s version\r\nVisual Studio 2019 for Mac",
    "upvotes": 2,
    "labels": [
      "bug",
      "area-mvc",
      "feature-routing",
      "affected-few",
      "severity-minor",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzI5ODQ1Nw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "What does this have to do with static files?\r\n*Edit* Nevermind, I see that Swagger UI embeds a StaticFile middleware. However, I don\u0027t think that\u0027s related to your issue here.\r\nhttps://github.com/domaindrivendev/Swashbuckle.AspNetCore/blob/e33dba2e416469fca6c2f4975c1c41dbac942804/src/Swashbuckle.AspNetCore.SwaggerUI/SwaggerUIMiddleware.cs#L70\r\n\r\nCan you provide a more complete Startup sample?",
        "createdAt": "2020-07-24T00:36:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-663298457"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzMyOTg3NQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Oh I get it.\r\n\r\n1. The request matches \u0060docs/{*wildcard}\u0060, gets assigned an Endpoint, and executes \u0060swaggerUiDelegate\u0060.\r\n2. The \u0060UseSwaggerUI\u0060 middleware runs but doesn\u0027t match the request, probably because the paths aren\u0027t configured the way you expect them to be. Note \u0060endpoints.Map\u0060 doesn\u0027t trim the matched portion off of the request path like \u0060IApplicationBuidler.Map\u0060 does.\r\n3. The request reaches the [implicit middleware](https://github.com/dotnet/aspnetcore/blob/4d45b1803b9412ca37d45cf3d6fb63a19c0056f4/src/Http/Http/src/Builder/ApplicationBuilder.cs#L85-L102) at end of the \u0060swaggerUiDelegate\u0060 pipeline. Normally it would 404 at this point, but because it was assigned an endpoint (that it\u0027s currently executing) you get this error message instead.\r\n\r\nI think this exception is due to a bug in \u0060endpoints.CreateApplicationBuilder()\u0060, it should return an app builder that only does 404s at the end, not check for endpoints again.\r\n\r\nYou\u0027ll still need to figure out your path issues, but at least you\u0027ll get the appropriate 404 rather than this weird exception.",
        "createdAt": "2020-07-24T03:19:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-663329875"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzM2NjM3MA==",
        "parentId": null,
        "author": "davidfowl",
        "content": "Hah this is the issue with baking things in at the potentially wrong level. Is there a reason changing this would break one?",
        "createdAt": "2020-07-24T06:22:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-663366370"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzQ2NDEzOQ==",
        "parentId": null,
        "author": "Tratcher",
        "content": "No, it\u0027s only a safety check. It\u0027s not like you can nest endpoints.",
        "createdAt": "2020-07-24T10:01:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-663464139"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzUxOTAxMg==",
        "parentId": null,
        "author": "APIWT",
        "content": "\u003E Oh I get it.\r\n\u003E \r\n\u003E     1. The request matches \u0060docs/{*wildcard}\u0060, gets assigned an Endpoint, and executes \u0060swaggerUiDelegate\u0060.\r\n\u003E \r\n\u003E     2. The \u0060UseSwaggerUI\u0060 middleware runs but doesn\u0027t match the request, probably because the paths aren\u0027t configured the way you expect them to be. Note \u0060endpoints.Map\u0060 doesn\u0027t trim the matched portion off of the request path like \u0060IApplicationBuidler.Map\u0060 does.\r\n\u003E \r\n\u003E     3. The request reaches the [implicit middleware](https://github.com/dotnet/aspnetcore/blob/4d45b1803b9412ca37d45cf3d6fb63a19c0056f4/src/Http/Http/src/Builder/ApplicationBuilder.cs#L85-L102) at end of the \u0060swaggerUiDelegate\u0060 pipeline. Normally it would 404 at this point, but because it was assigned an endpoint (that it\u0027s currently executing) you get this error message instead.\r\n\u003E \r\n\u003E \r\n\u003E I think this exception is due to a bug in \u0060endpoints.CreateApplicationBuilder()\u0060, it should return an app builder that only does 404s at the end, not check for endpoints again.\r\n\u003E \r\n\u003E You\u0027ll still need to figure out your path issues, but at least you\u0027ll get the appropriate 404 rather than this weird exception.\r\n\r\n@Tratcher \r\nI think we are talking about two different bugs, but I think both need to be fixed in order to accomplish my use case.\r\n\r\nInside \u0060UseSwaggerUI\u0060, the code looks like this:\r\nhttps://github.com/domaindrivendev/Swashbuckle.AspNetCore/blob/e33dba2e416469fca6c2f4975c1c41dbac942804/src/Swashbuckle.AspNetCore.SwaggerUI/SwaggerUIBuilderExtensions.cs#L10\r\nhttps://github.com/domaindrivendev/Swashbuckle.AspNetCore/blob/939ad54164af5820f93a926083d322899c09049f/src/Swashbuckle.AspNetCore.SwaggerUI/SwaggerUIMiddleware.cs#L71\r\n\r\nNotice that basically the SwaggerUIMiddleware will do this:\r\n1) Check if they are on \u0022/{prefix}\u0022 and if so redirect them to \u0022/{prefix}/index.html\u0022\r\n2) Check if they are on \u0022/{prefix}/index.html\u0022 and if so render some dynamic HTML.\r\n3) If neither of these are matched, invoke an instance of StaticFileMiddleware with an embedded resource used as the file provider: https://github.com/domaindrivendev/Swashbuckle.AspNetCore/blob/939ad54164af5820f93a926083d322899c09049f/src/Swashbuckle.AspNetCore.SwaggerUI/SwaggerUIMiddleware.cs#L86\r\n\r\nHowever, there are two problems at this point. The first problem is that StaticFileMiddleware checks if there is an endpoint set, and if so just nopes out: https://github.com/dotnet/aspnetcore/blob/19d2f6124f5d04859e350d1f5a01e994e14ef1ce/src/Middleware/StaticFiles/src/StaticFileMiddleware.cs#L71\r\n\r\nThe second issue is the bug you have highlighted.\r\n\r\nAll that being said... Is there a different way to accomplish what I am trying to do without building my own custom auth middleware that runs before \u0060UseSwaggerUI\u0060 (assuming I don\u0027t use endpoint routing).\r\n\r\nEDIT: I almost forgot to mention. Both step 1 and step 2 above work. In other words, the redirect from \u0022/{prefix}\u0022 and the dynamic \u0022/{prefix}/index.html\u0022 parts have no issues (and require an authenticated user with the policy I specify in my original post. It seems that the whole issue lies in the fact that the static file middleware specifically has a check that says \u0022if the context has an endpoint, log and exit.",
        "createdAt": "2020-07-24T12:41:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-663519012"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzU3ODk3NQ==",
        "parentId": null,
        "author": "APIWT",
        "content": "One more update. Sorry for the spam!\r\n\r\nSo I did a thing... lol:\r\n\u0060\u0060\u0060\r\nnamespace MyApp\r\n{\r\n    using System.Threading.Tasks;\r\n    using Microsoft.AspNetCore.Builder;\r\n    using Microsoft.AspNetCore.Hosting;\r\n    using Microsoft.AspNetCore.Http;\r\n    using Microsoft.AspNetCore.StaticFiles;\r\n    using Microsoft.Extensions.Logging;\r\n    using Swashbuckle.AspNetCore.SwaggerUI;\r\n\r\n    public sealed class SwaggerUIMiddlewareWithEndpointWorkaround\r\n    {\r\n        private readonly SwaggerUIMiddleware swaggerUiMiddleware;\r\n\r\n        public SwaggerUIMiddlewareWithEndpointWorkaround(\r\n            RequestDelegate next,\r\n            IWebHostEnvironment hostingEnv,\r\n            ILoggerFactory loggerFactory,\r\n            SwaggerUIOptions options)\r\n        {\r\n            this.swaggerUiMiddleware = new SwaggerUIMiddleware(next, hostingEnv, loggerFactory, options);\r\n        }\r\n\r\n        public async Task Invoke(HttpContext httpContext)\r\n        {\r\n            var originalEndpoint = httpContext.GetEndpoint();\r\n            httpContext.SetEndpoint(null);\r\n            await this.swaggerUiMiddleware.Invoke(httpContext);\r\n            httpContext.SetEndpoint(originalEndpoint);\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nthen in my startup:\r\n\u0060\u0060\u0060\r\napp.UseEndpoints(endpoints =\u003E\r\n{\r\n    endpoints.MapControllers();\r\n\r\n    var options = new SwaggerUIOptions();\r\n    options.RoutePrefix = \u0022docs\u0022;\r\n\r\n    var swaggerUiDelegate = endpoints.CreateApplicationBuilder()\r\n        .UseMiddleware\u003CSwaggerUIMiddlewareWithEndpointWorkaround\u003E(options)\r\n        .Build();\r\n\r\n    endpoints.Map(\r\n        \u0022docs/{*wildcard}\u0022,\r\n        swaggerUiDelegate)\r\n    .RequireAuthorization(\u0022Swagger\u0022);\r\n});\r\n\u0060\u0060\u0060\r\n\r\nAnd the good news is, it works fine! But I can\u0027t help but feel a little dirty doing it. As you can see, in my workaround middleware I am simply wrapping an instance of SwaggerUIMiddleware and hi-jacking the HTTP context\u0027s endpoint to temporarily set it to null (restored to the original endpoint value after the invoke call is completed).\r\n\r\nHopefully this helps you guys make a decision in what can/should be done here. You can also call me out if I am totally abusing the endpoint feature.",
        "createdAt": "2020-07-24T14:54:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-663578975"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzYxNjUyMw==",
        "parentId": null,
        "author": "Tratcher",
        "content": "Ah, nicely explained. Yes, that looks like a second bug.\r\n\r\nIt looks like the static files no-op was added back in 3.0 and it failed to account for placing static files within a route.\r\nhttps://github.com/dotnet/aspnetcore/commit/7e63e2da43c3a5f298e782482b2005179b8d2792\r\n\r\nI\u0027d suggest removing those checks, they only work as intended if the static files middleware is placed between UseRouting and UseEndpoints.",
        "createdAt": "2020-07-24T16:14:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-663616523"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzYxNzE4NA==",
        "parentId": null,
        "author": "APIWT",
        "content": "Awesome, I appreciate your prompt response and understanding. On that note... does my workaround raise any red flags for you? And even better question... am I abusing endpoint routing for the wrong reasons?",
        "createdAt": "2020-07-24T16:16:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-663617184"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzYyMDI5NA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "It should work but I think you can simplify it. You don\u0027t need a custom middleware, or to restore the endpoint value after the middleware.\r\n\r\n\u0060\u0060\u0060\r\napp.UseEndpoints(endpoints =\u003E\r\n{\r\n    endpoints.MapControllers();\r\n\r\n    var swaggerUiDelegate = endpoints.CreateApplicationBuilder()\r\n    .Use((context, next) =\u003E\r\n    {\r\n        context.SetEndpoint(null);\r\n        return next();\r\n    })\r\n    .UseSwaggerUI(options =\u003E\r\n    {\r\n        // Set documentation route to /docs\r\n        options.RoutePrefix = \u0022docs\u0022;\r\n    })\r\n    .Build();\r\n\r\n    endpoints.Map(\u0022docs/{*wildcard}\u0022, swaggerUiDelegate).RequireAuthorization(\u0022Swagger\u0022);\r\n});\r\n\u0060\u0060\u0060\r\n\r\nA completely different way of doing this is setting the FallbackPolicy so that all requests require authentication.\r\nhttps://docs.microsoft.com/en-us/aspnet/core/security/authorization/secure-data?view=aspnetcore-3.1#require-authenticated-users",
        "createdAt": "2020-07-24T16:22:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-663620294"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzYyMDk3MQ==",
        "parentId": null,
        "author": "APIWT",
        "content": "You rock! Thank you very much for your help. I will watch this issue to see how the team decides to handle this.",
        "createdAt": "2020-07-24T16:24:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-663620971"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY2MzczNDE5OA==",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\nWe\u0027re moving this issue to the \u0060Next sprint planning\u0060 milestone for future evaluation / consideration. We will evaluate the request when we are planning the work for the next milestone. To learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-07-24T21:06:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-663734198"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcwNjMxODQ4Ng==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-10-09T17:47:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-706318486"
      },
      {
        "id": "IC_kwDOAQzde85HLpaL",
        "parentId": null,
        "author": "alrz",
        "content": "The workaround @Tratcher posted works but this seems like something to be provided out-of-the-box.\r\n\r\nAny update here? although I think the swagger package should provide such APIs, e.g. \u0060endpoints.MapSwaggerUI()\u0060",
        "createdAt": "2022-07-25T15:41:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-1194235531"
      },
      {
        "id": "IC_kwDOAQzde85LnBTe",
        "parentId": null,
        "author": "miroslavgrozdanovski",
        "content": "Thanks for the workaround @APIWT and @Tratcher! We are building our own library and also wanted to use the static middleware together with endpoint routing. There aren\u0027t a lot of examples on this in the wild, so it was hard to find the cause for the error.\r\n\r\n\u002B1 for somehow supporting this out-of-the-box.\r\n\r\n",
        "createdAt": "2022-10-05T14:32:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-1268520158"
      },
      {
        "id": "IC_kwDOAQzde85LnH0l",
        "parentId": null,
        "author": "dazinator",
        "content": "It\u0027s interesting that \u0060endpoints.CreateApplicationBuilder()\u0060 is essentially creating a nested middleware pipeline, but when requests flow through that nested pipeline, they start of in a position where the request already has an endpoint mapped and that endpoint is basically the nested middleware pipeline itself as a match! To be more consistent, wouldn\u0027t it be better for \u0060endpoints.CreateApplicationBuilder()\u0060 to ensure that the endpoint was set to null initially with this context?\r\n\r\nalso @Tratcher with respect to this point:\r\n\u003E It should work but I think you can simplify it. You don\u0027t need a custom middleware, or to restore the endpoint value after the middleware.\r\n\r\nIn terms of not restoring the endpoint value.. as this is a nested middleware pipeline, there is a question as to whether the request should flow back into the parent middleware pipeline if it reaches the end without an endpoint being executed.. I think this would be a useful option to expose, i.e to enable the request space of an application to be subdivided, such that if the url space /foo was owned by some optional handler, when the handler isn\u0027t present / enabled, the request can flow back out of that space again rather than being consumed with a 404",
        "createdAt": "2022-10-05T14:48:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-1268546853"
      },
      {
        "id": "IC_kwDOAQzde85LnQ_1",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E there is a question as to whether the request should flow back into the parent middleware pipeline if it reaches the end without an endpoint being executed..\r\n\r\nRouting endpoints are considered terminal, there\u0027s no concept right now of an optional handler. Even if the request did re-enter the main pipeline, the endpoint executing middleware is itself terminal and placed at the end of the pipeline, there\u0027d be nowhere to go but 404.",
        "createdAt": "2022-10-05T15:15:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-1268584437"
      },
      {
        "id": "IC_kwDOAQzde85Lo8q5",
        "parentId": null,
        "author": "dazinator",
        "content": "@Tratcher ah of course! Apologies I\u0027m getting confused again. I\u0027ve done something similar with nesting middleware pipelines and rejoining, but never really properly integrated endpoint routing into that concept, and this must be why.",
        "createdAt": "2022-10-05T22:00:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-1269025465"
      },
      {
        "id": "IC_kwDOAQzde86VMlNT",
        "parentId": null,
        "author": "davidfowl",
        "content": "@javiercn is this still relevant with MapStaticAssests?",
        "createdAt": "2024-11-27T07:25:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24252#issuecomment-2503103315"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU2NzQyMzMyMTc=",
    "title": "Rewrite module - Rule action not working with rewrite maps",
    "url": "https://github.com/dotnet/aspnetcore/issues/24618",
    "createdAt": "2020-08-06T11:14:26Z",
    "lastUpdated": "2023-10-28T14:08:25Z",
    "body": "\u003C!--\r\n\r\nMore information on our issue management policies can be found here: https://aka.ms/aspnet/issue-policies\r\n\r\nPlease keep in mind that the GitHub issue tracker is not intended as a general support forum, but for reporting **non-security** bugs and feature requests.\r\n\r\nIf you believe you have an issue that affects the SECURITY of the platform, please do NOT create an issue and instead email your issue details to secure@microsoft.com. Your report may be eligible for our [bug bounty](https://www.microsoft.com/en-us/msrc/bounty-dot-net-core) but ONLY if it is reported through email.\r\nFor other types of questions, consider using [StackOverflow](https://stackoverflow.com).\r\n\r\n--\u003E\r\n\r\n### Describe the bug\r\nUsing rewrite maps in the URL attribute of a rewrite rule action doesn\u0027t seem to work.\r\nIf we have the following rules and rewrite maps defined:\r\n\r\n\u0060\u0060\u0060xml\r\n\u003C?xml version=\u00221.0\u0022 encoding=\u0022utf-16\u0022?\u003E\r\n\u003Crewrite xmlns:xsi=\u0022http://www.w3.org/2001/XMLSchema-instance\u0022 xmlns:xsd=\u0022http://www.w3.org/2001/XMLSchema\u0022\u003E\r\n  \u003Crules\u003E\r\n    \u003Crule name=\u0022blog redirects\u0022 stopProcessing=\u0022true\u0022\u003E\r\n      \u003Cmatch url=\u0022.*\u0022 /\u003E\r\n      \u003Cconditions logicalGrouping=\u0022MatchAll\u0022\u003E\r\n        \u003Cadd input=\u0022{blog-map:{REQUEST_URI}}\u0022 pattern=\u0022(.\u002B)\u0022 /\u003E\r\n      \u003C/conditions\u003E\r\n      \u003Caction type=\u0022Redirect\u0022 url=\u0022{C:1}\u0022 appendQueryString=\u0022true\u0022 redirectType=\u0022Permanent\u0022 /\u003E\r\n    \u003C/rule\u003E\r\n    \u003Crule name=\u0022query id redirect\u0022 stopProcessing=\u0022true\u0022\u003E\r\n      \u003Cmatch url=\u0022(.*)\u0022 /\u003E\r\n      \u003Cconditions logicalGrouping=\u0022MatchAll\u0022\u003E\r\n        \u003Cadd input=\u0022{QUERY_STRING}\u0022 pattern=\u0022(.*)(\\bid=([0-9]\u002B-[0-9]{4}))(.*)\u0022 /\u003E\r\n      \u003C/conditions\u003E\r\n      \u003Caction type=\u0022Redirect\u0022 url=\u0022{R:0}?{C:1}id={id-map:{C:3}}{C:4}\u0022 appendQueryString=\u0022false\u0022 redirectType=\u0022Permanent\u0022 /\u003E\r\n    \u003C/rule\u003E\r\n  \u003C/rules\u003E\r\n  \u003CrewriteMaps\u003E\r\n    \u003CrewriteMap name=\u0022blog-map\u0022 defaultValue=\u0022\u0022\u003E\r\n      \u003Cadd key=\u0022/somepage.html\u0022 value=\u0022/otherpage.html\u0022 /\u003E\r\n    \u003C/rewriteMap\u003E\r\n    \u003CrewriteMap name=\u0022id-map\u0022 defaultValue=\u0022\u0022\u003E\r\n      \u003Cadd key=\u00221234-1234\u0022 value=\u0022ABCD-ABCD\u0022 /\u003E\r\n    \u003C/rewriteMap\u003E\r\n  \u003C/rewriteMaps\u003E\r\n\u003C/rewrite\u003E\r\n\u0060\u0060\u0060\r\n\r\nThe first rule works correctly and performs the redirect from \u0060somepage.html\u0060 to \u0060otherpage.html\u0060.\r\nHowever, the second rules doesn\u0027t seem to work and a request to \u0060index.html?id=1234-1234\u0060 doesn\u0027t redirect to the expected \u0060index.html?id=ABCD-ABVD\u0060.\r\n\r\nAlso, if the URL value of the second rule is changed to something \u0022hardcoded\u0022 such as \u0022bing.com\u0022, then the redirect action is performed which indicates the issue seems not to be related to the condition pattern but to the action URL.\r\n\r\n### To Reproduce\r\n\u003C!--\r\nWe \u2764 code! Point us to a minimalistic repro project hosted in a GitHub repo.\r\nFor a repro project, create a new ASP.NET Core project using the template of your your choice, apply the minimum required code to result in the issue you\u0027re observing.\r\n\r\nWe will close this issue if:\r\n- the repro project you share with us is complex. We can\u0027t investigate custom projects, so don\u0027t point us to such, please.\r\n- if we will not be able to repro the behavior you\u0027re reporting\r\n--\u003E\r\n\r\n- Create a .net core web application (empty template)\r\n- Add the Microsoft.NetCore.Rewrite package \r\n- Create the rewrite file using the rules above\r\n- Configure startup.cs to load the iis rewrite file\r\n- Run the application and try with the requests mentioned on the description above\r\n\r\n[Link to the project in GitHub](https://github.com/nuno-barreiro/aspnetcore-issue-urlrewritemaps)\r\n\r\n### Exceptions (if any)\r\n\u003C!-- \r\nInclude the exception you get when facing this issue\r\n--\u003E\r\nN/A\r\n\r\n### Further technical details\r\n- ASP.NET Core version 2.1 (but it happens with 3.1 too)\r\n- Visual Studio Enterprise 2019 \r\n\r\n\u25B6 dotnet --info\r\n.NET SDK (reflecting any global.json):\r\n Version:   5.0.100-preview.4.20258.7\r\n Commit:    65f0fc2cad\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.19042\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\5.0.100-preview.4.20258.7\\\r\n\r\nHost (useful for support):\r\n  Version: 5.0.0-preview.4.20251.6\r\n  Commit:  47ec733ba7\r\n\r\n.NET SDKs installed:\r\n  2.1.806 [C:\\Program Files\\dotnet\\sdk]\r\n  3.1.300 [C:\\Program Files\\dotnet\\sdk]\r\n  5.0.100-preview.4.20258.7 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.18 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.1.20 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.18 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.1.20 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.1.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 5.0.0-preview.4.20257.10 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.1.18 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.1.20 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.1.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.1.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 5.0.0-preview.4.20251.6 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 3.1.4 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 5.0.0-preview.4.20251.1 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n",
    "upvotes": 0,
    "labels": [
      "bug",
      "feature-rewrite-middleware",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3MDcyNTY4NA==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-08-07T21:46:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24618#issuecomment-670725684"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3MDcyNTk2Ng==",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "Looks like a bug. Feel free to try fixing it if you\u0027re interested!\r\n\r\nSide-question: have you tried this rule with the IIS rewrite module?",
        "createdAt": "2020-08-07T21:48:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24618#issuecomment-670725966"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3MDcyNzQzMA==",
        "parentId": null,
        "author": "jkotalik",
        "content": "I think you may have to work around this for now by splitting up your rule to match on the \u00601234-1234\u0060 first.",
        "createdAt": "2020-08-07T21:53:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24618#issuecomment-670727430"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3MTgxMTM2NA==",
        "parentId": null,
        "author": "nuno-barreiro",
        "content": "\u003E Looks like a bug. Feel free to try fixing it if you\u0027re interested!\r\n\u003E \r\n\u003E Side-question: have you tried this rule with the IIS rewrite module?\r\n\r\nHi @BrennanConroy. \r\nYes... I\u0027ve initially created using the IIS rewrite module and worked fine.\r\n",
        "createdAt": "2020-08-11T08:35:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24618#issuecomment-671811364"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxMjM3Mzc5OQ==",
        "parentId": null,
        "author": "jaamison",
        "content": "Tracked it down to this: https://github.com/dotnet/aspnetcore/commit/65e7f7f44b5bf86d11e86e3cee70b85c56f23e76#diff-c09a7b0622d058c86ba9a1676b5c54dfe07101ced5fe769b4d5b3e433e036edeR59\r\n\r\nI first noticed that the Location header was being set in the response, even though the status was 200 (should never happen). With that premature return, the redirect status code is never set and RewriteContext.Result is never set, so RewriteMiddleware will continue evaluating subsequent rules.\r\n\r\nIt looks like the intent here was to fall back to redirecting to \u0060/\u0060 in cases where the redirect url pattern evaluates out to nothing. Setting the pattern manually and just letting the rest of the method do its thing seems to work fine.\r\n\r\nBut that brings up another question of why the pattern is evaluating to null/empty in the first place. Here\u0027s one clue: we already know that \u0060/index.html?id=1234-1234\u0060 =\u003E \u0060/index.html?id=1234-1234\u0060 even though we\u0027re expecting \u0060/index.html?id=1234-1234\u0060 =\u003E \u0060/index.html?id=ABCD-ABCD\u0060, but oddly, \u0060/index.html?id=1234-12345\u0060 =\u003E \u0060/5\u0060. Clearly something is off with the back reference indexing. Looks like \u0060ParserContext\u0060 is being thrown off by the nested tokens?",
        "createdAt": "2020-10-19T18:51:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24618#issuecomment-712373799"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxMjU0MjI2NA==",
        "parentId": null,
        "author": "jaamison",
        "content": "As for the remaining issues, it looks like contention over a shared \u0060StringBuilder\u0060 is to blame: https://github.com/dotnet/aspnetcore/blob/686150953f7ccd3f56afd4d7b2f0a934c3557a10/src/Middleware/Rewrite/src/Pattern.cs#L22\r\n\r\nLogically speaking, we\u0027re building a new independent string each time a \u0060Pattern\u0060 is evaluated, which implies a new \u0060StringBuilder\u0060 instance locally within the \u0060Pattern.Evaluate\u0060 method. This commit moved to a single shared StringBuilder on the \u0060RewriteContext\u0060 presumably for perf:\r\n\r\nhttps://github.com/dotnet/aspnetcore/commit/7a560738353690fa3c6d1f5eaff43b9d384af57b#diff-7c5cf0ee81f592c0e3d8f1f078853d170504dec39a91ec80792b5d443b7c0c8fR21\r\n\r\nHowever, pattern evaluations can be recursive, which will leave us with different invocations across the call stack all appending onto the same string.\r\n\r\nInstead of going back to the naive implementation with a new StringBuilder for each evaluation, a compromise might be to share StringBuilders per Pattern? More StringBuilders will be instantiated in total than the current design, but it should only be once at startup. And I don\u0027t believe there can ever be a scenario where a Pattern instance can contains itself, meaning we won\u0027t have the buggy behavior anymore. Thoughts?",
        "createdAt": "2020-10-20T02:08:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24618#issuecomment-712542264"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyMjU3NzI2OQ==",
        "parentId": null,
        "author": "JeremyLittle",
        "content": "I am working on rewriting an existing web application\u0027s ASP.NET rewrite module into .NET core using this middleware, and this bug is preventing a large number of existing rewrite files/rewrite maps from being used by our new system.\r\nIs there any timeline on fixing this issue?",
        "createdAt": "2020-11-05T19:02:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/24618#issuecomment-722577269"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3MDY3NDEzNTU=",
    "title": "app.UseExceptionHandler and ExceptionHandlerMiddleware.cs",
    "url": "https://github.com/dotnet/aspnetcore/issues/26206",
    "createdAt": "2020-09-22T22:52:52Z",
    "lastUpdated": "2023-08-28T23:09:58Z",
    "body": "I would like to know if it\u0027s possible to localize or set back the culture in the context when an Exception occure using app.UseExceptionHandler(\u0022/**{culture}**/error\u0022) in the config startup ?\r\n\r\nOr is there other ways to achieve that?\r\n\r\nthis is part of the Assembly Microsoft.AspNetCore.Diagnostics\r\n\r\nthanks\r\nMarc",
    "upvotes": 1,
    "labels": [
      "enhancement",
      "feature-diagnostics",
      "severity-nice-to-have",
      "affected-few",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY5NzE0MDY4MQ==",
        "parentId": null,
        "author": "davidfowl",
        "content": "No this doesn\u0027t work. What are you trying to achieve?",
        "createdAt": "2020-09-23T05:22:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/26206#issuecomment-697140681"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY5Nzk0ODY2Ng==",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "Is using the culture info in your error.cshtml not good enough?",
        "createdAt": "2020-09-23T20:16:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/26206#issuecomment-697948666"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY5ODA4NTAyNw==",
        "parentId": null,
        "author": "marcdumont3000",
        "content": "Just to give more context.....We are using localize routes like this:\r\n\r\n**Pattern**: /{culture}/home/index  and the default culture is en\r\nValide routes:\r\n/en/home/index\r\n/fr/home/index\r\n\r\nSo when an error occurs, the user is automatically redirected to the error page... I have this setup in the startup/configure:\r\n\u0060app.UseExceptionHandler(\u0022/error\u0022);\u0060\r\n\r\nBut, every time the user gets redirected to the error page..the culture info gets reset to the default... the context for the culture is not kept when we hit the error page.\r\n\r\nSo what can we do to fix this issue?\r\nthanks\r\n\r\n",
        "createdAt": "2020-09-24T03:11:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/26206#issuecomment-698085027"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcwMDMwMDM3Ng==",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "You can grab the original path from the features in your error page, see the docs at https://docs.microsoft.com/aspnet/core/fundamentals/error-handling?view=aspnetcore-3.1#access-the-exception-1",
        "createdAt": "2020-09-28T21:51:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/26206#issuecomment-700300376"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcwMDMwMDYyMA==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-09-28T21:52:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/26206#issuecomment-700300620"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcwNDc0MTIxMg==",
        "parentId": null,
        "author": "davidfowl",
        "content": "I forgot to follow up on this issue. It\u0027s difficult to do this today and we need some tweaks to the error page middleware to handle it. Ideally you would be able to re-execute the pipeline with a callback to customize the request. ",
        "createdAt": "2020-10-07T07:07:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/26206#issuecomment-704741212"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3NTY2MDk5OTk=",
    "title": ".Caching.StackExchangeRedis Sentinel support",
    "url": "https://github.com/dotnet/aspnetcore/issues/28367",
    "createdAt": "2020-10-13T15:49:03Z",
    "lastUpdated": "2023-06-02T03:14:16Z",
    "body": "Currently, the caching Redis plugin uses a simple \u0060ConnectionMultiplexer.ConnectAsync\u0060 call with the given configuration. Unfortunately, this does not combine well with clusters with a sentinel.\r\n\r\n- The current dependent version of \u0060StackExchange.Redis\u0060 requires two steps for connecting to a sentinel cluster: first to the sentinel, then to the appropriate master. This scenario cannot be implemented in the current API.\r\n- The latest version of \u0060StackExchange.Redis\u0060 (2.1.58) no longer requires two steps for connecting to a sentinel cluster (https://github.com/StackExchange/StackExchange.Redis/pull/1431): when using a normal Connect-call, the code will try and detect whether you connected to a sentinel and then automatically return a normal connection to the current master. However, once the master fails and another master is elected by the sentinels, this connection object is no longer valid and the caching breaks. There is currently no way to re-instantiate the connection easily.\r\n\r\nMy current workaround is using the new library version, implementing a Redis caching HealthCheck, and simply letting all application containers fail and be restarted by the orchestrator to connect to the new Redis master. This is, of course, not ideal.\r\n\r\nIt would be very much appreciated if support for sentinels can be incorporated into the library directly. For example, in the \u0060RedisCacheOptions\u0060 add a bool option indicating the use of sentinel, and add code to retrieve the correct master on the fly; and retry this when the connection to the current master fails.",
    "upvotes": 4,
    "labels": [
      "investigate",
      "feature-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczODMzNTA3NQ==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-12-03T21:38:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28367#issuecomment-738335075"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3MzQ4OTAyODU=",
    "title": "Response buffering",
    "url": "https://github.com/dotnet/aspnetcore/issues/27470",
    "createdAt": "2020-11-02T22:52:24Z",
    "lastUpdated": "2024-03-02T00:15:04Z",
    "body": "* Better dev experience for serialization errors\r\n* Don\u0027t block when using Sync-IO",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "severity-minor",
      "affected-medium",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyMDc3MDAxMA==",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\nWe\u0027re moving this issue to the \u0060Next sprint planning\u0060 milestone for future evaluation / consideration. We will evaluate the request when we are planning the work for the next milestone. To learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-11-02T22:52:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27470#issuecomment-720770010"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyMDc3MDkxMQ==",
        "parentId": null,
        "author": "halter73",
        "content": "We released a preview package that does this which was last updated in 2017. It has over 500,000 downloads. https://www.nuget.org/packages/Microsoft.AspNetCore.Buffering/",
        "createdAt": "2020-11-02T22:54:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27470#issuecomment-720770911"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgxODc5MzU5NQ==",
        "parentId": null,
        "author": "dionrhys",
        "content": "I\u0027d appreciate this feature. At the moment it\u0027s not straightforward to deal with exceptions that happen during serializing responses, e.g. exceptions that may happen while enumerating an \u0060IEnumerable\u003CT\u003E\u0060 collection that\u0027s present on a response object\u0027s type (in an API controller).\r\n\r\nIdeally we wouldn\u0027t have these exceptions, but mistakes happen. Right now an exception that occurs during response formatting/serialization will cause JSON output to be truncated mid-response and the 200 OK status code kept (as the response has already begun writing).\r\n\r\n\u003Cdetails\u003E\r\n\u003Csummary\u003EHere\u0027s an example of how that manifested for me today:\u003C/summary\u003E\r\n\r\n\u0060\u0060\u0060\r\n2021-04-12 12:50:52.252 \u002B01:00 [ERR] An unhandled exception has occurred while executing the request.\r\nSystem.NullReferenceException: Object reference not set to an instance of an object.\r\n   at *****.Web.Misc.*****.GetUserDefinedFields(Product product, IEnumerable\u00601 polygonList) in C:\\Projects\\*****\\src\\*****\\Misc\\*****.cs:line 163\r\n   at *****.Web.Controllers.EventsController.\u003C\u003Ec__DisplayClass4_0.\u003CGetDataAsync\u003Eb__3(ValueTuple\u00602 result) in C:\\Projects\\*****\\src\\*****\\Controllers\\EventsController.cs:line 266\r\n   at System.Linq.Enumerable.WhereSelectEnumerableIterator\u00602.MoveNext()\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.SerializeList(JsonWriter writer, IEnumerable values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.SerializeObject(JsonWriter writer, Object value, JsonObjectContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)\r\n   at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.Serialize(JsonWriter jsonWriter, Object value, Type objectType)\r\n   at Newtonsoft.Json.JsonSerializer.SerializeInternal(JsonWriter jsonWriter, Object value, Type objectType)\r\n   at Microsoft.AspNetCore.Mvc.Formatters.JsonOutputFormatter.WriteObject(TextWriter writer, Object value)\r\n   at Microsoft.AspNetCore.Mvc.Formatters.JsonOutputFormatter.\u003CWriteResponseBodyAsync\u003Ed__11.MoveNext()\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060\r\n2021-04-12 12:50:52.288 \u002B01:00 [WRN] The response has already started, the error page middleware will not be executed.\r\n\u0060\u0060\u0060\r\n\r\n\u003C/details\u003E\r\n\r\nIn order to be able to deal with unexpected exceptions during serialization right now, I have to pre-serialize the response object to JSON before returning it in a \u0060ContentResult\u0060:\r\n\r\n\u0060\u0060\u0060c#\r\nreturn Content(JsonHelper.Serialize(response).ToString(), \u0022application/json\u0022);\r\n\u0060\u0060\u0060\r\n\r\n This sidesteps using the built-in output formatting in ASP.NET Core, which isn\u0027t ideal from a dev perspective.\r\n\r\nI think this is a good workaround for now, but I think the right solution would be to add buffering, possibly. In this instance, I know I\u0027ll be sacrificing response writing performance (and extra memory usage) for correctness, and I\u0027m ok with that.\r\n\r\nI could just avoid having any \u0060IEnumerable\u003CT\u003E\u0060 in my response objects and ensure everything is fully-enumerated into \u0060List\u003CT\u003E\u0060 or something, however any dev mistake here would still cause the issue of a response being truncated mid-content while keeping 200 OK. Some people apparently experienced this issue if they had reference loops in their response objects for example: https://stackoverflow.com/questions/47419907/net-core-incomplete-json-response",
        "createdAt": "2021-04-13T14:44:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27470#issuecomment-818793595"
      },
      {
        "id": "IC_kwDOAQzde85KP-ej",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-13T17:09:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/27470#issuecomment-1245702051"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU3NTY2MDkxNzk=",
    "title": "SQL Server Distributed Cache Extensions suffering significant performance issues",
    "url": "https://github.com/dotnet/aspnetcore/issues/28366",
    "createdAt": "2020-11-19T06:11:46Z",
    "lastUpdated": "2023-10-28T14:08:28Z",
    "body": "### Describe the bug\r\nSerious performance issues when reading binary values, when using SQL Server Distributed Cache extension.\r\n\r\n### To Reproduce\r\nUsing SQL Server Distributed Cache, persist a value with an arbitrary value of 15MB.\r\nAccess the data using the async read operations.  Note this takes approximately 15 seconds in our environment.\r\n\r\n### Expected behavior\r\nThis should take milliseconds.\r\n\r\n### Additional context\r\nI suspect this is caused by an open SQL Client bug mentioned below.  Can you please verify if this is the case?  Is there a work-around that can be implemented in DatabaseOperations until this is resolved?\r\n\r\nhttps://github.com/dotnet/extensions/blob/master/src/Caching/SqlServer/src/DatabaseOperations.cs, line 229\r\nvalue = reader.GetFieldValue\u003Cbyte[]\u003E(Columns.Indexes.CacheItemValueIndex);\r\n\r\nReading binary data asynchronously is extremely slow\r\nhttps://github.com/dotnet/SqlClient/issues/593\r\n\r\nIt looks like the SqlClient team are suggesting people use the StreamAsync operation as a work-around?\r\n\r\nOne reasonably successful work-around we have tried is to increase the TDS Packet Size up to 32,767.  What are your thoughts on this?\r\n",
    "upvotes": 0,
    "labels": [
      "feature-caching",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczMDE5Mjc0NA==",
        "parentId": null,
        "author": "markholst",
        "content": "Actually, I\u0027ve changed our implementation over to use the synchronous Get method.  The more I thought about it, the more I realised this is a serious issue for scalability.\r\n\r\nIt doesn\u0027t need to be a large value being cached either, even responses of up to 1MB were enough to cause problems.\r\n\r\nUsing the asynchronous Get method allocates so much memory for a simple call, it wouldn\u0027t take many concurrent requests to take a system down.  The numbers in the related article suggest 13GB of memory was churned to service a 20MB request.  Yikes!\r\n\r\nGiven this is a front-end caching solution for ASP.NET Core based API and web applications, this can put an ASP.NET Core site at significant risk of a denial-of-service style attack.\r\n\r\nUsing the synchronous get method brings it down to \u003C 1sec for a cache read operation.",
        "createdAt": "2020-11-19T07:46:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28366#issuecomment-730192744"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczMTQ0NDMzMg==",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "\u003E The numbers in the related article suggest 13GB of memory was churned to service a 20MB request. Yikes!\r\n\r\nAssuming you\u0027re referring to [this](https://github.com/dotnet/SqlClient/issues/593#issuecomment-639801525) comment, this is only for Full framework it looks like. In a .NET Core app you\u0027ll get the lower 30MB allocations.\r\n\r\nIt looks like SQLClient should fix the issue and we could consider looking into SteamAsync in the meantime.",
        "createdAt": "2020-11-20T22:42:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28366#issuecomment-731444332"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczMjY5MzUyNA==",
        "parentId": null,
        "author": "markholst",
        "content": "Thanks @BrennanConroy, I have re-read and reached the same conclusion.\r\n\r\nI think if the SqlClient team are going to take a long time, I\u0027d suggest using the synchronous routines, as they\u0027re considerably faster!",
        "createdAt": "2020-11-24T06:54:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28366#issuecomment-732693524"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczODMzNDM3OQ==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2020-12-03T21:36:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/28366#issuecomment-738334379"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWUxMjU0NDI3Mzky",
    "title": "Add ability to leverage StackExchange.Redis.CommandFlags via IDistributedCache or IDistributedRedisCache (new)",
    "url": "https://github.com/dotnet/aspnetcore/issues/41948",
    "createdAt": "2021-02-05T19:10:40Z",
    "lastUpdated": "2024-09-28T07:43:17Z",
    "body": "### Is your feature request related to a problem? Please describe.\r\nI\u0027d like to be able to specify the usage of a Replica or Slave endpoint instead of always going to the Master.  This would allow me to offload traffic for read-only cache operations where the latest data is not critical resulting in improved performance.\r\n\r\nCurrently, the \u0060StackExchange.Redis.IDatabase\u0060 API allows for this by use of optional [\u0060StackExchange.Redis.CommandFlag\u0060 enum](https://github.com/StackExchange/StackExchange.Redis/blob/8612fb8a9278822c87d5476819325a7438e596ca/src/StackExchange.Redis/Enums/CommandFlags.cs#L47) that can be specified in API calls.  However, the implementation of \u0060Microsoft.Extensions.Caching.StackExchangeRedis.RedisCache\u0060 doesn\u0027t provide these optional params to be passed thru.\r\n\r\n### Describe the solution you\u0027d like\r\nI would like for the implementation of \u0060Microsoft.Extensions.Caching.StackExchangeRedis.RedisCache\u0060 to provide the ability to pass a flag that allows me to specify replica usage (master, slave, replica, etc.).  You would probably need to create a new interface to expose this which \u0060Microsoft.Extensions.Caching.StackExchangeRedis.RedisCache\u0060 would implement e.g. \u0060IDistributedRedisCache\u0060.\r\n\r\n### Describe alternatives you\u0027ve considered\r\nUsing \u0060StackExchange.Redis.IDatabase\u0060 directly instead of Microsoft\u0027s \u0060IDistributedCache\u0060 wrapper.  Unfortunately, it would be a lot of work to change for our applications and we do prefer the \u0060IDistributedCache\u0060 wrapper in general.  We also use this with [Polly](https://github.com/App-vNext/Polly) for caching and Polly provides a nice integration with \u0060IDistributedCache\u0060 already.\r\n",
    "upvotes": 16,
    "labels": [
      "Needs: Design",
      "enhancement",
      "feature-caching",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDExNDI2NDkwMDU=",
        "parentId": null,
        "author": "dotnet-issue-labeler",
        "content": "I couldn\u0027t figure out the best area label to add to this issue. If you have write-permissions please help me learn by adding exactly one [area label](https://github.com/dotnet/runtime/blob/master/docs/area-owners.md).",
        "createdAt": "2021-03-22T17:21:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1142649005"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDExNDI2NDkwMDk=",
        "parentId": null,
        "author": "udlose",
        "content": "I don\u0027t have write permissions but ill tag the lead for the area: @ericstj , @eerhardt ",
        "createdAt": "2021-03-22T17:50:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1142649009"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDExNDI2NDkwMTU=",
        "parentId": null,
        "author": "??",
        "content": "Tagging subscribers to this area: @eerhardt, @maryamariyan, @michaelgsharp\nSee info in area-owners.md if you want to be subscribed.\n\u003Cdetails\u003E\n\u003Csummary\u003EIssue Details\u003C/summary\u003E\n\u003Chr /\u003E\n\n### Is your feature request related to a problem? Please describe.\r\nI\u0027d like to be able to specify the usage of a Replica or Slave endpoint instead of always going to the Master.  This would allow me to offload traffic for read-only cache operations where the latest data is not critical resulting in improved performance.\r\n\r\nCurrently, the \u0060StackExchange.Redis.IDatabase\u0060 API allows for this by use of optional [\u0060StackExchange.Redis.CommandFlag\u0060 enum](https://github.com/StackExchange/StackExchange.Redis/blob/8612fb8a9278822c87d5476819325a7438e596ca/src/StackExchange.Redis/Enums/CommandFlags.cs#L47) that can be specified in API calls.  However, the implementation of \u0060Microsoft.Extensions.Caching.StackExchangeRedis.RedisCache\u0060 doesn\u0027t provide these optional params to be passed thru.\r\n\r\n### Describe the solution you\u0027d like\r\nI would like for the implementation of IDistributedCache to provide the ability to pass a flag that allows me to specify replica usage (master, slave, replica, etc.)\r\n\r\n### Describe alternatives you\u0027ve considered\r\nUsing \u0060StackExchange.Redis.IDatabase\u0060 directly instead of Microsoft\u0027s \u0060IDistributedCache\u0060 wrapper.  Unfortunately, it would be a lot of work to change for our applications and we do prefer the \u0060IDistributedCache\u0060 wrapper in general.  We also use this with [Polly](https://github.com/App-vNext/Polly) for caching and Polly provides a nice integration with \u0060IDistributedCache\u0060 already.\r\n\n\n\u003Ctable\u003E\n  \u003Ctr\u003E\n    \u003Cth align=\u0022left\u0022\u003EAuthor:\u003C/th\u003E\n    \u003Ctd\u003Eudlose\u003C/td\u003E\n  \u003C/tr\u003E\n  \u003Ctr\u003E\n    \u003Cth align=\u0022left\u0022\u003EAssignees:\u003C/th\u003E\n    \u003Ctd\u003E-\u003C/td\u003E\n  \u003C/tr\u003E\n  \u003Ctr\u003E\n    \u003Cth align=\u0022left\u0022\u003ELabels:\u003C/th\u003E\n    \u003Ctd\u003E\n\n\u0060area-Extensions-Caching\u0060, \u0060untriaged\u0060\n\n\u003C/td\u003E\n  \u003C/tr\u003E\n  \u003Ctr\u003E\n    \u003Cth align=\u0022left\u0022\u003EMilestone:\u003C/th\u003E\n    \u003Ctd\u003E-\u003C/td\u003E\n  \u003C/tr\u003E\n\u003C/table\u003E\n\u003C/details\u003E",
        "createdAt": "2021-03-22T18:16:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1142649015"
      },
      {
        "id": "IC_kwDOAQzde85EG3C6",
        "parentId": null,
        "author": "pranavacharya",
        "content": "Can adding support for an extra optional parameters to IDistributedCache interface\u0027s methods solve this ?",
        "createdAt": "2022-05-26T20:36:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1142649018"
      },
      {
        "id": "IC_kwDOAQzde85EG4LW",
        "parentId": null,
        "author": "maryamariyan",
        "content": "\u0060IDistributedCache\u0060 wouldnt be getting Redis or StackExchange related logic in. Transferring to aspnetcore repo to carry conversation forward.",
        "createdAt": "2022-05-31T21:24:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1142653654"
      },
      {
        "id": "IC_kwDOAQzde85EbRoJ",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@udlose Can you share more about why you need this? It seems strange to modify the interface to support implementation-specific parameters.",
        "createdAt": "2022-06-06T22:33:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1148000777"
      },
      {
        "id": "IC_kwDOAQzde85Ekt9w",
        "parentId": null,
        "author": "??",
        "content": "Hi @udlose. We have added the \u0022Needs: Author Feedback\u0022 label to this issue, which indicates that we have an open question for you before we can take further action. This issue will be closed automatically in 7 days if we do not hear back from you by then - please feel free to re-open it if you come back to this issue after that time.",
        "createdAt": "2022-06-08T22:28:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1150476144"
      },
      {
        "id": "IC_kwDOAQzde85Eojt3",
        "parentId": null,
        "author": "udlose",
        "content": "@adityamandaleeka, @maryamariyan  - perhaps the confusion is that I misspoke by asking that the implementation-agnostic interface of \u0060IDistributedCache\u0060 be modified to include implementation-specific parameters pertaining to \u0060[StackExchange.Redis.CommandFlag]\u0060(https://github.com/StackExchange/StackExchange.Redis/blob/8612fb8a9278822c87d5476819325a7438e596ca/src/StackExchange.Redis/Enums/CommandFlags.cs#L47).\r\n\r\nI\u0027ve updated the title and feature request details to help clarify.\r\n\r\nTo rephrase, for performance reasons, I\u0027d like to be able to specify whether my Redis API call is sent to a Replica, Slave, or Master instance.  As I mention, the \u0060Microsoft.Extensions.Caching.StackExchangeRedis.RedisCache\u0060 implementation doesn\u0027t allow for specifying these valuable params. So at a minimum, I think that ability should be added.  It would at least give users the ability to create an interface (e.g. \u0060IDistributedRedisCache\u0060) that exposes those params on the API interface.  Though I\u0027d argue that the \u0060IDistributedRedisCache\u0060 interface should be implemented in the \u0060Microsoft.Extensions.Caching.StackExchangeRedis\u0060 nuget and not place the responsibility on devs to have to create the interface.  IMO, an API should be able to be consumed without additional work on behalf of the API consumer.\r\n\r\nI am just throwing out an idea of what the implementation might look like. If you have an alternative that your more amenable to but still provides the ability to specify the \u0060[StackExchange.Redis.CommandFlag]\u0060, I\u0027d be happy just the same.\r\n\r\nPlease let me know if you have any more questions as I\u0027d really like to see this added.  It seems important from a performance perspective.",
        "createdAt": "2022-06-09T18:50:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1151482743"
      },
      {
        "id": "IC_kwDOAQzde85EtQqh",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Thanks @udlose. Adding this to the RedisCache implementation seems reasonable.\r\n\r\nWe don\u0027t want to create another new interface but as you mentioned, users can create that if they want it.",
        "createdAt": "2022-06-10T20:29:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1152715425"
      },
      {
        "id": "IC_kwDOAQzde85EtR6I",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "We\u0027d take a contribution to add this if you\u0027re interested. Feel free to copy/paste the [issue template](https://github.com/dotnet/aspnetcore/issues/new?assignees=\u0026labels=api-suggestion\u0026template=30_api_proposal.md\u0026title=) here into a comment on this issue and we will review it.",
        "createdAt": "2022-06-10T20:36:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1152720520"
      },
      {
        "id": "IC_kwDOAQzde85EtR7x",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-06-10T20:36:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1152720625"
      },
      {
        "id": "IC_kwDOAQzde85E85h4",
        "parentId": null,
        "author": "udlose",
        "content": "\u003E Thanks @udlose. Adding this to the RedisCache implementation seems reasonable.\r\n\u003E \r\n\u003E We don\u0027t want to create another new interface but as you mentioned, users can create that if they want it.\r\n\r\n@adityamandaleeka  why are you not open to adding this interface to the \u0060Microsoft.Extensions.Caching.StackExchangeRedis\u0060 nuget?",
        "createdAt": "2022-06-15T18:52:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1156814968"
      },
      {
        "id": "IC_kwDOAQzde85E9pG2",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "To clarify, we are open to updating \u0060Microsoft.Extensions.Caching.StackExchangeRedis.RedisCache\u0060 with the added parameter. The thing we don\u0027t think is useful is creating and consuming another new interface like IDistributedRedisCache.",
        "createdAt": "2022-06-15T22:23:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1157009846"
      },
      {
        "id": "IC_kwDOAQzde85HX3yr",
        "parentId": null,
        "author": "udlose",
        "content": "@adityamandaleeka, @maryamariyan so I\u0027m working on submitting a PR for this change and I have a question.  I\u0027m making changes as follows to \u0060Microsoft.Extensions.Caching.StackExchangeRedis.RedisCache\u0060:\r\n\r\n\u0060\u0060\u0060\r\n// THE METHOD BELOW IS EXISTING\r\n    /// \u003Cinheritdoc /\u003E\r\n    public byte[]? Get(string key)\r\n    {\r\n        if (key == null)\r\n        {\r\n            throw new ArgumentNullException(nameof(key));\r\n        }\r\n\r\n        return GetAndRefresh(key, getData: true);\r\n    }\r\n\r\n// THE METHOD BELOW IS NEW\r\n    /// \u003Cinheritdoc /\u003E\r\n    public byte[]? Get(string key, CommandFlags commandFlags)\r\n    {\r\n        if (key == null)\r\n        {\r\n            throw new ArgumentNullException(nameof(key));\r\n        }\r\n\r\n        return GetAndRefresh(key, getData: true, commandFlags: commandFlags);\r\n    }\r\n\r\n// THE METHOD BELOW IS EXISTING\r\n    /// \u003Cinheritdoc /\u003E\r\n    public async Task\u003Cbyte[]?\u003E GetAsync(string key, CancellationToken token = default(CancellationToken), CommandFlags commandFlags = CommandFlags.None)\r\n    {\r\n        //code elided\r\n    }\r\n\u0060\u0060\u0060\r\n\r\nWhen I add my default params, to the end of the \u0060GetAsync\u0060 method (so that I do not violate \u0060RS0027\u0060 (https://github.com/dotnet/roslyn/blob/main/docs/Adding%20Optional%20Parameters%20in%20Public%20API.md), I get a CompilerError: [CS 1068 (CancellationToken parameters must come last)](https://docs.microsoft.com/en-us/dotnet/fundamentals/code-analysis/quality-rules/ca1068).  \r\n\r\nIf I have the new \u0060CommandFlag\u0060 param before the optional \u0060CancellationToken\u0060 param to satisfy CA1068, I violate binary compatibility and \u0060RS0027\u0060.  I don\u0027t want to break binary compatibility but I don\u0027t like ignoring compiler warnings either. \r\n\r\nWhat are your suggestions?\r\n",
        "createdAt": "2022-07-27T22:31:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1197440171"
      },
      {
        "id": "IC_kwDOAQzde85HX5zr",
        "parentId": null,
        "author": "udlose",
        "content": "Actually it looks as if I won\u0027t be able to add the \u0060CommandFlags\u0060 param to this signature because it then no longer implements the \u0060IDistributedCache\u0060 signature of:\r\n\r\n\u0060    public async Task\u003Cbyte[]?\u003E GetAsync(string key, CancellationToken token = default(CancellationToken))\u0060\r\n\r\nIf I add another signature to not break the \u0060IDistributedCache\u0060 contract, I then break [RS0027 - Adding optional parameters to public methods](https://github.com/dotnet/roslyn/blob/main/docs/Adding%20Optional%20Parameters%20in%20Public%20API.md)\r\n\r\n\u0060    public async Task\u003Cbyte[]?\u003E GetAsync(string key, CommandFlags commandFlags, CancellationToken token)\u0060\r\n\r\nNot sure where to go from here.\r\n",
        "createdAt": "2022-07-27T22:39:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1197448427"
      },
      {
        "id": "IC_kwDOAQzde85N71kS",
        "parentId": null,
        "author": "udlose",
        "content": "@adityamandaleeka @maryamariyan any updates or suggestions on how to proceed? (see above comment)",
        "createdAt": "2022-11-08T16:59:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1307531538"
      },
      {
        "id": "IC_kwDOAQzde85x_OxR",
        "parentId": null,
        "author": "peterdrier",
        "content": "If I understand this right, since the IDistributedCache is using the IConnectionMultiplexer directly..  Perhaps a way forward would be to configure (or likely add a config option to ...) SE.Redis to PreferReplica on read operations when the multiplexer is created initially.   \r\n\r\nAnd/or adding a parameter to the RedisCacheOptions passed into AddStackExchangeRedisCache, specifying PreferReplica on reads.. \r\n\r\nThat way IDistributedCache\u0027s interface is none the wiser, but the underlying implementation can direct reads/writes appropriately.  \r\n\r\nCould that work? ",
        "createdAt": "2024-01-26T17:12:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1912400977"
      },
      {
        "id": "IC_kwDOAQzde85yNE9w",
        "parentId": null,
        "author": "udlose",
        "content": "\u003E If I understand this right, since the IDistributedCache is using the IConnectionMultiplexer directly.. Perhaps a way forward would be to configure (or likely add a config option to ...) SE.Redis to PreferReplica on read operations when the multiplexer is created initially.\r\n\u003E \r\n\u003E And/or adding a parameter to the RedisCacheOptions passed into AddStackExchangeRedisCache, specifying PreferReplica on reads..\r\n\u003E \r\n\u003E That way IDistributedCache\u0027s interface is none the wiser, but the underlying implementation can direct reads/writes appropriately.\r\n\u003E \r\n\u003E Could that work?\r\n\r\nAt a minimum,  that would provide at least some way to customize the behavior. It would be nice to be able to have flexibility to change behavior via API parameterss as the StackExchangeRedis API\u0027s have.",
        "createdAt": "2024-01-30T03:59:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1916030832"
      },
      {
        "id": "IC_kwDOAQzde85yNI-D",
        "parentId": null,
        "author": "davidfowl",
        "content": "You can\u0027t change the interface (it\u0027s a breaking change), you also can\u0027t add redis specific APIs to the  base interface, it would break the abstraction. It seems like you want a redis interface, IDistributedCache isn\u0027t it.",
        "createdAt": "2024-01-30T04:20:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1916047235"
      },
      {
        "id": "IC_kwDOAQzde85zK1NP",
        "parentId": null,
        "author": "peterdrier",
        "content": "\u003E You can\u0027t change the interface (it\u0027s a breaking change), you also can\u0027t add redis specific APIs to the base interface, it would break the abstraction. It seems like you want a redis interface, IDistributedCache isn\u0027t it.\r\n\r\nNot sure which \u0022You\u0022 that you\u0027re replying to here, so your message is ambiguous.  ",
        "createdAt": "2024-02-07T14:55:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1932219215"
      },
      {
        "id": "IC_kwDOAQzde85zLKHN",
        "parentId": null,
        "author": "davidfowl",
        "content": "My bad, I was looking referring to [this comment](https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1197448427). My read of the issue is that we\u0027re trying to flow a per call (Get/Set) flag from IDistributedCache to the underlying redis implementation and that breaks the abstraction.\r\n\r\nIt seems like there\u0027s a desire for a more lightweight redis specific interface.\r\n\r\n",
        "createdAt": "2024-02-07T15:35:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1932304845"
      },
      {
        "id": "IC_kwDOAQzde85zLLFo",
        "parentId": null,
        "author": "rwasef1830",
        "content": "There\u0027s an awkward workaround to use the factory option of redis distributed cache implementation to return a decorated connection multiplexer that returns decorated redis clients that can then take hints from the key name and set the appropriate flag...\r\n\r\nAwkward and tedious but would work.",
        "createdAt": "2024-02-07T15:37:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-1932308840"
      },
      {
        "id": "IC_kwDOAQzde86DUmXM",
        "parentId": null,
        "author": "Mindex-Brandon-Key",
        "content": "This is also causing us grief. All traffic is going to the writer and no load is able to go to the read replicas. \r\nInstead of modifying the interface, what if the CommandFlags are passed in the options during registration, then used by the RedisCache implementation?\r\n\r\nIn \u0060RedisCacheOptions.cs\u0060 add \u0060public CommandFlags ReadCommandFlags { get; set; }\u0060.\r\nIn \u0060RedisCache.GetAndRefresh\u0060 and  \u0060RedisCache.GetAndRefreshAsync\u0060 add \u0060_options.ReadCommandFlags\u0060 to the \u0060cache.HashGet\u0060 call. \r\n\r\nThe scope should be pretty small. Existing uses won\u0027t be impacted - the default CommandFlags value is None, matching the HashGet\u0027s default value. Users that want to use read replicas can set \u0060RedisCacheOptions.ReadCommandFlags = CommandFlags.PreferReplica\u0060.",
        "createdAt": "2024-07-02T13:46:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-2203215308"
      },
      {
        "id": "IC_kwDOAQzde86DVG9p",
        "parentId": null,
        "author": "acasciani",
        "content": "This is a pain point for us as well. The changes that @Mindex-Brandon-Key suggested would fit our use case as well.",
        "createdAt": "2024-07-02T14:17:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-2203348841"
      },
      {
        "id": "IC_kwDOAQzde86DVO8L",
        "parentId": null,
        "author": "Mindex-Brandon-Key",
        "content": "I just found https://github.com/dotnet/aspnetcore/issues/28375 which seems to echo the missing behavior",
        "createdAt": "2024-07-02T14:32:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-2203381515"
      },
      {
        "id": "IC_kwDOAQzde86N5F4A",
        "parentId": null,
        "author": "bartpio",
        "content": "Here\u0027s a [transitional approach](https://www.nuget.org/packages/StackExchangeRedisCache.Contrib/#readme-body-tab) I put together that takes advantage of the framework allowing us to supply a custom connection multiplexer, that in turn supplies \u0060IDatabase\u0060 instances, which can be wrapped to customize \u0060CommandFlags\u0060.",
        "createdAt": "2024-09-28T07:43:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/41948#issuecomment-2380553728"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU4MDM0MTY2NTk=",
    "title": "Use Response Caching for non-200 status codes",
    "url": "https://github.com/dotnet/aspnetcore/issues/29978",
    "createdAt": "2021-02-08T10:21:45Z",
    "lastUpdated": "2023-06-02T03:14:56Z",
    "body": "### Description\r\n\r\nI would like to enable Response Caching with the \u0060ResponseCachingMiddleware\u0060 for some specific non-\u0060200\u0060 responses. I would specifically need this for \u0060404\u0060 responses, but I could imagine scenarios where this would be useful for some other status codes as well, such as \u0060204\u0060, \u0060301\u0060, \u0060303\u0060.\r\n\r\n### Describe the solution you\u0027d like\r\n\r\nIt would be great if this could be enabled with configuration via \u0060ResponseCachingOptions\u0060, for example if it contained a property like this:\r\n\r\n\u0060\u0060\u0060\r\npublic List\u003CHttpStatusCodes\u003E EnabledStatusCodes { get; } = new List\u003CHttpStatusCodes\u003E { HttpStatusCode.OK };\r\n\u0060\u0060\u0060\r\n\r\nWhich would be consistent with the current behavior, and it could be adjusted when registering it in the \u0060Startup\u0060:\r\n\r\n\u0060\u0060\u0060\r\nservices.AddResponseCaching(opts =\u003E\r\n{\r\n    opts.EnabledStatusCodes.Add(HttpStatusCode.NotFound)\r\n});\r\n\u0060\u0060\u0060\r\n\r\nBut I\u0027m okay with any other kind of solution too.\r\n\r\n### Additional context\r\n\r\nI hope I\u0027m not missing anything related to this, and this is indeed not possible right now, I\u0027m seeing this in the docs: https://docs.microsoft.com/en-us/aspnet/core/performance/caching/middleware?view=aspnetcore-5.0#conditions-for-caching, and in the code: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/ResponseCaching/src/ResponseCachingPolicyProvider.cs#L117",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "feature-response-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3NTUwNzkxNA==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-02-08T22:32:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/29978#issuecomment-775507914"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU4NjE3NTI3MDU=",
    "title": "Add DecoderFallback for invalid/unrecognized characeters in HttpLogging Middleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/31943",
    "createdAt": "2021-04-19T19:23:11Z",
    "lastUpdated": "2023-08-24T23:42:37Z",
    "body": "https://github.com/dotnet/aspnetcore/pull/31816/files/a1364581f97f8a40e9baa0bbc9df6b99a8ed1fb2#diff-3b357eaf0c7f9256d16a88eb586e2bdb41cfff3a16989d9439d778c6ec0bc50aR15",
    "upvotes": 0,
    "labels": [
      "severity-minor",
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgyMzYwNzE5NA==",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\nWe\u0027re moving this issue to the \u0060Next sprint planning\u0060 milestone for future evaluation / consideration. Because it\u0027s not immediately obvious that this is a bug in our framework, we would like to keep this around to collect more feedback, which can later help us determine the impact of it. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-04-20T21:20:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/31943#issuecomment-823607194"
      },
      {
        "id": "IC_kwDOAQzde842FupM",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-08-27T20:56:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/31943#issuecomment-907471436"
      },
      {
        "id": "IC_kwDOAQzde85HX7nw",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-07-27T22:49:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/31943#issuecomment-1197455856"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU4NjE3NjUyMzA=",
    "title": "Don\u0027t always buffer if we have an invalid Encoding in HttpLogging middleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/31944",
    "createdAt": "2021-04-19T19:31:18Z",
    "lastUpdated": "2023-08-24T23:42:39Z",
    "body": "https://github.com/dotnet/aspnetcore/pull/31816/files#diff-b66c674ede53f3dab72344fe4d48b6e8238ab71c629aa2e4b3a3822dd57493f7R64",
    "upvotes": 0,
    "labels": [
      "Perf",
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgyNDMyODAyNA==",
        "parentId": null,
        "author": "JunTaoLuo",
        "content": "I\u0027ll volunteer to a look at this in preview5 since I missed part of the planning meeting.",
        "createdAt": "2021-04-21T20:12:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/31944#issuecomment-824328024"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg3NTA2NDM4OA==",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060Next sprint planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-07-06T20:36:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/31944#issuecomment-875064388"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg3NTA2NDUyMw==",
        "parentId": null,
        "author": "JunTaoLuo",
        "content": "Unlikely to get to this, let\u0027s review in planning.",
        "createdAt": "2021-07-06T20:36:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/31944#issuecomment-875064523"
      },
      {
        "id": "IC_kwDOAQzde842Fujw",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-08-27T20:55:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/31944#issuecomment-907471088"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU4NjQyMzc3MjA=",
    "title": "Use resource limits in Kestrel",
    "url": "https://github.com/dotnet/aspnetcore/issues/32033",
    "createdAt": "2021-04-21T20:03:18Z",
    "lastUpdated": "2024-02-14T20:21:22Z",
    "body": "This is part of the Epic: https://github.com/dotnet/aspnetcore/issues/27464\r\n\r\nThis issue tracks the adoption of the resource limit APIs in Kestrel which consists of:\r\n\r\n- Existing limits\r\n  - Min Data rates\r\n- New limits\r\n  - Rate limits for settings frames https://github.com/dotnet/aspnetcore/issues/7828\r\n  - Concurrency and rate limits for connections",
    "upvotes": 0,
    "labels": [
      "enhancement",
      "feature-kestrel",
      "feature-rate-limit",
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg3NTA2NjY3OA==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-07-06T20:40:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32033#issuecomment-875066678"
      },
      {
        "id": "IC_kwDOAQzde85KVkIJ",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-14T18:44:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32033#issuecomment-1247166985"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU4NjQzMzM3ODg=",
    "title": "Usage of resource limit APIs in BCL",
    "url": "https://github.com/dotnet/aspnetcore/issues/32039",
    "createdAt": "2021-04-21T21:54:54Z",
    "lastUpdated": "2024-03-02T00:19:53Z",
    "body": "Part of Epic: https://github.com/dotnet/aspnetcore/issues/27464.\r\n\r\nThis issue tracks identifying places in the BCL that can benefit from resource limits for example:\r\n- Pipelines\r\n- Channels\r\n-  Streams\r\n- HttpClient",
    "upvotes": 0,
    "labels": [
      "External",
      "enhancement",
      "feature-rate-limit",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg3NTA2NjQ5Mw==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-07-06T20:40:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32039#issuecomment-875066493"
      },
      {
        "id": "IC_kwDOAQzde85Keivt",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-16T15:44:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32039#issuecomment-1249520621"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU4NzAyMTQwOTc=",
    "title": "HttpLoggingMiddleware for quick debugging",
    "url": "https://github.com/dotnet/aspnetcore/issues/32246",
    "createdAt": "2021-04-28T18:07:29Z",
    "lastUpdated": "2024-02-14T20:24:10Z",
    "body": "Some developers will only add the http logging middleware temporarily for debugging. In that case we want it to be easy to log all request fields, headers, etc. with minimal config.\r\n\r\nThe current design requires the developer to list specific header names to log unredacted. We should add a \u0060bool DangerousSkipHeaderRedaction { get; set; }\u0060 for the quick debugging scenario.\r\n\r\nWe should also add a UseRequestLogging overload that directly accepts options so it can be enabled with a single code block sample. This also allows logging to be added to the pipeline multiple times to observe the effects middleware like UseForwardedHeaders have on the request.\r\n\r\n\u0060\u0060\u0060\r\napp.UseRequestLogging(options =\u003E \r\n{\r\n options.Fields = HttpLoggingOptions.AllFieldsAndHeaders; \r\n options.DangerousSkipHeaderRedaction = true; \r\n});\r\n\u0060\u0060\u0060\r\n\r\nHere\u0027s an example from our docs that could be replaced by this:\r\nhttps://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/proxy-load-balancer?view=aspnetcore-5.0#troubleshoot",
    "upvotes": 2,
    "labels": [
      "api-suggestion",
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgyODc1MTk0Mw==",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060Next sprint planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-04-28T20:21:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32246#issuecomment-828751943"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU4NzAyMTgyMDM=",
    "title": "HttpLoggingMiddleware log connection properties",
    "url": "https://github.com/dotnet/aspnetcore/issues/32247",
    "createdAt": "2021-04-28T18:12:49Z",
    "lastUpdated": "2024-03-02T00:43:42Z",
    "body": "HttpLoggingMiddleware will log headers, properties (method, path, query, etc.), and body. However it will not log any information about the connection (Remote IP, local IP, ports, client certificate, TLS version, etc.).\r\n\r\nHere\u0027s an example from our docs where the remote IP is relevant in the request logs:\r\nhttps://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/proxy-load-balancer?view=aspnetcore-5.0#troubleshoot\r\n\r\nWhich fields should we make available to log, and what granularity should we provide in the enum to enable them?",
    "upvotes": 1,
    "labels": [
      "feature-diagnostics",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgyODc1NjMxMg==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-04-28T20:29:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32247#issuecomment-828756312"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgyODc1NjgyOQ==",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "Triage: This will be possible with some upcoming work, question is do we want this to be a first-class feature\r\nBacklogging to see if there are customer asks for it.",
        "createdAt": "2021-04-28T20:29:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32247#issuecomment-828756829"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg1NDUyODU5NQ==",
        "parentId": null,
        "author": "Kahbazi",
        "content": "\u002B1 on logging remote IP in \u0060HttpLoggingMiddleware\u0060. \r\n\r\nAlso could there be a shared feature between this middleware and Forwarded header middleware so we could have both remote IP and the end-user client IP?",
        "createdAt": "2021-06-04T09:27:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32247#issuecomment-854528595"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg1NTAwOTkyNA==",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E \u002B1 on logging remote IP in \u0060HttpLoggingMiddleware\u0060.\r\n\u003E \r\n\u003E Also could there be a shared feature between this middleware and Forwarded header middleware so we could have both remote IP and the end-user client IP?\r\n\r\nDepending on the ordering, one of those values will be available in the headers.\r\n\r\nI do still want to re-do the forwarded headers middleware to store the original values in a feature, but that\u0027s out of scope here for now.",
        "createdAt": "2021-06-04T21:32:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32247#issuecomment-855009924"
      },
      {
        "id": "IC_kwDOAQzde85T4GJY",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-01-28T00:20:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32247#issuecomment-1407214168"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU4OTk5NzA2NzU=",
    "title": "DatabaseDeveloperPageExceptionFilter can be broken when DbContext is in a different assembly",
    "url": "https://github.com/dotnet/aspnetcore/issues/32976",
    "createdAt": "2021-05-06T12:06:18Z",
    "lastUpdated": "2023-08-28T23:09:55Z",
    "body": "### Describe the bug\r\nWhen using \u0060AddDatabaseDeveloperPageExceptionFilter()\u0060 a Database error should result in the  \u0022DatabaseErrorPage\u0022 being rendered, however in a configuration where the DbContext is in a different assembly which is not currently loaded, the DatabaseDeveloperPageExceptionFilter throws it\u0027s own exception and blank page is rendered with a 500 status code.\r\n\r\n\u0060\u0060\u0060\r\nfail: Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware[1]\r\n      An unhandled exception has occurred while executing the request.\r\n      Npgsql.PostgresException (0x80004005): .........\r\n\r\nfail: Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore.DatabaseDeveloperPageExceptionFilter[7]\r\n      An exception occurred while calculating the database error page content. Skipping display of the database error page.\r\n      System.IO.FileNotFoundException: Could not load file or assembly \u0027\u003Cname of migrations assembly\u003E, Culture=neutral, PublicKeyToken=null\u0027. The system cannot find the file specified.\r\n\u0060\u0060\u0060\r\n\r\nThe exception occurs here when attempting to get the service from the assembly:\r\nhttps://github.com/dotnet/aspnetcore/blob/e6998cb7bb7aba3b803fe8ed2622a090f3fa0fc1/src/Middleware/Diagnostics.EntityFrameworkCore/src/HttpContextDatabaseContextDetailsExtensions.cs#L47\r\n\r\n### To Reproduce\r\nYou need a solution which has a separate project containing the DbContext which is shared by more than 1 other project.\r\n\r\nWhen the DbContext is in a separate project, a migrations assembly needs to be specified, so for example,  one of the projects will need to be designated as the one from which migrations are performed, so this will need this to be specified in the project\u0027s AddDbContext options:\r\n\u0060\u0060\u0060\r\nservices.AddDbContext\u003CAppDataContext\u003E(options =\u003E\r\n                options.UseNpgsql(connectionString, npgsqlOptions =\u003E {\r\n                    npgsqlOptions.EnableRetryOnFailure();\r\n                    npgsqlOptions.MigrationsAssembly(\u0022\u003Cname of current assembly\u0022);\r\n                }));\r\n\u0060\u0060\u0060\r\n\r\nAs there can only be a single copy of the Migrations directory which will live inside one of the projects, the MigrationsAssembly name that is specified will have to be the same when the DbContext is used across other projects.\r\n\r\nThis is where the issue arises, if a database error occurs in a project which has the MigrationsAssembly set to a different project\u0027s assembly which is not a dependancy, it is not accessible as it\u0027s not loaded as part of the project.\r\n\r\nI quickly realised that the only reason the MigrationsAssembly was specified on the other project was due to copy and paste of the AddDbContext config, so I removed the MigrationsAssembly line as it was redundant in the other project, however this did not fully resolve the issue as although the DatabaseDeveloperPageExceptionFilter no longer throws an exception, a blank page is still produced with a 500 status code.\r\n\r\nThe DeveloperExceptionPageMiddleware is still kicking in and can be seen as the last entry in the log:\r\n\r\n\u0060\u0060\u0060\r\nfail: Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware[1]\r\n      An unhandled exception has occurred while executing the request.\r\n      Npgsql.PostgresException (0x80004005): .........\r\n\u0060\u0060\u0060\r\n\r\nThere could be another reason for this so I may have to do some more digging.\r\n\r\nThere would be no harm in wrapping \u0060var migrationsAssembly = context.GetService\u003CIMigrationsAssembly\u003E();\u0060 in a try catch and handling the null scenario to avoid this error?\r\n\r\n\r\n### Further technical details\r\n- ASP.NET Core version\r\n5.0.202\r\n- Include the output of \u0060dotnet --info\u0060\r\n.NET SDK (reflecting any global.json):\r\n Version:   5.0.202\r\n Commit:    db7cc87d51\r\n\r\nRuntime Environment:\r\n OS Name:     Mac OS X\r\n OS Version:  10.15\r\n OS Platform: Darwin\r\n RID:         osx.10.15-x64\r\n Base Path:   /usr/local/share/dotnet/sdk/5.0.202/\r\n\r\nHost (useful for support):\r\n  Version: 5.0.5\r\n  Commit:  2f740adc14\r\n",
    "upvotes": 0,
    "labels": [
      "feature-diagnostics",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgzMzQ3NTI5Ng==",
        "parentId": null,
        "author": "chrisckc",
        "content": "Also note that the obsolete DatabaseErrorPageMiddleware:\r\nhttps://github.com/aspnet/Announcements/issues/432\r\n\r\nWorks fine for me and does not have this issue, regardless of the MigrationsAssembly setting.\r\n\r\n**Update:**\r\nActually, the DatabaseErrorPageMiddleware does fall over, but the DeveloperExceptionPageMiddleware takes over and shows the correct error, so the end result it that it works fine and shows a meaningful error.\r\n\r\n\u0060\u0060\u0060\r\nfail: Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore.DatabaseErrorPageMiddleware[7]\r\n      An exception occurred while calculating the database error page content. Skipping display of the database error page.\r\n      System.IO.FileNotFoundException: Could not load file or assembly \u0027\u003Cname of migrations assembly\u003E, Culture=neutral, PublicKeyToken=null\u0027. The system cannot find the file specified.\r\n\r\nfail: Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware[1]\r\n      An unhandled exception has occurred while executing the request.\r\n      Npgsql.PostgresException (0x80004005): ..........\r\n\r\n\u0060\u0060\u0060\r\n\r\nNotice how the DatabaseErrorPageMiddleware is invoked before the DeveloperExceptionPageMiddleware which seems to be the correct way, unlike with the DatabaseDeveloperPageExceptionFilter which happens after the DeveloperExceptionPageMiddleware.\r\n",
        "createdAt": "2021-05-06T12:15:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32976#issuecomment-833475296"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgzMzQ3NjI1MQ==",
        "parentId": null,
        "author": "chrisckc",
        "content": "I mentioned it here in passing as I thought it might be related:\r\nhttps://github.com/dotnet/aspnetcore/issues/32076",
        "createdAt": "2021-05-06T12:17:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32976#issuecomment-833476251"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgzMzU0MzExOA==",
        "parentId": null,
        "author": "chrisckc",
        "content": "Update:\r\nI moved the migrations into the project where I have the DatabaseDeveloperPageExceptionFilter configured and set the MigrationsAssembly accordingly and then recreated the exact same same error conditions, this time it works fine.\r\n\r\nSo it seems that it\u0027s not possible to make use of the DatabaseDeveloperPageExceptionFilter in a project which does not handle migrations for a DbContext which is in a different assembly. The old DatabaseErrorPage middleware works fine in any case, so when Dotnet 6 comes out, if this isn\u0027t fixed by then I can just bring that over from 5.\r\n\r\nBtw. I notice this has been transferred to efcore repo, but I think it is actually related to AspNetCore as I originally posted it in because it is related to the way some AspNetCore middleware/filter is handling checks for outstanding migrations, its not an issue with migrations so not an issue with efcore?\r\n",
        "createdAt": "2021-05-06T13:54:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32976#issuecomment-833543118"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgzNjc0NjkwNw==",
        "parentId": null,
        "author": "ajcvickers",
        "content": "@chrisckc We are surprised that this configuration ever worked with the database error page. Given that the error page is intended as an easy way for people to get started, this seems like a reasonable limitation to have from the EF side.\r\n\r\n@JunTaoLuo Any thoughts from the ASP.NET side?\r\n",
        "createdAt": "2021-05-10T14:08:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32976#issuecomment-836746907"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0MzQ0NzcyNw==",
        "parentId": null,
        "author": "AndriySvyryd",
        "content": "We don\u0027t think there\u0027s a reliable way of improving this experience from the EF Core side.",
        "createdAt": "2021-05-18T18:51:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32976#issuecomment-843447727"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0NzMwNTI0NQ==",
        "parentId": null,
        "author": "JunTaoLuo",
        "content": "Hmm this seems like an issue we should address in aspnetcore",
        "createdAt": "2021-05-24T20:13:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32976#issuecomment-847305245"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg1MzM1ODA0Ng==",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060Next sprint planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-06-02T20:22:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32976#issuecomment-853358046"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg4MDI2OTkwNg==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-07-14T23:13:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32976#issuecomment-880269906"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU4OTYwMjM4MDQ=",
    "title": "Performance Improvements for Redis cache",
    "url": "https://github.com/dotnet/aspnetcore/issues/32857",
    "createdAt": "2021-05-19T22:55:35Z",
    "lastUpdated": "2023-06-02T03:16:42Z",
    "body": "\u003C!--\r\n\r\nMore information on our issue management policies can be found here: https://aka.ms/aspnet/issue-policies\r\n\r\n--\u003E\r\n\r\n### Is your feature request related to a problem? Please describe.\r\n\r\nI have begun using the Redis distributed cache implementation. I\u0027m wondering if there are some simple things that could be done to improve its performance.\r\n\r\n### Describe the solution you\u0027d like\r\n\r\nA couple of ideas spring to mind:\r\n\r\n1. Use the [FireAndForget](https://stackexchange.github.io/StackExchange.Redis/Basics.html#sync-vs-async-vs-fire-and-forget) option when performing write operations - since a cache doesn\u0027t often have the same consistency requirements as a typical datastore, it seems like setting EXPIRE/PEXPIRE, or even writing values, could use the \u0060FireAndForget\u0060 command flag, and return sooner to the caller.\r\n2. Encapsulate read and write options in Lua scripts - rather than the above, encapsulate all the Redis commands that need to take place to cache an item (or get it and refresh the timeout) within Lua scripts. There\u0027s a nice example I came across in this [NHibernate cache](https://github.com/TheCloudlessSky/NHibernate.Caches.Redis/blob/master/src/NHibernate.Caches.Redis/RedisCache.cs#L34-L41) that could serve as inspiration.",
    "upvotes": 0,
    "labels": [
      "feature-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0NDY1NjM0Nw==",
        "parentId": null,
        "author": "davidvedvick",
        "content": "3. Possibly [Transactions](https://stackexchange.github.io/StackExchange.Redis/Transactions.html) as well or instead of one of the above?",
        "createdAt": "2021-05-20T03:25:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32857#issuecomment-844656347"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0NjIyODk3NA==",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "Do you have any performance numbers? It\u0027d be interesting to see if/how much the perf can be improved.\r\n\r\nWe aren\u0027t planning on making any changes in this area, but if you are willing to contribute changes with improved performance numbers we would be willing to review.",
        "createdAt": "2021-05-21T20:15:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32857#issuecomment-846228974"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg0NjIyOTAyNQ==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-05-21T20:15:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/32857#issuecomment-846229025"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU5NDUwNTA0Mjk=",
    "title": "Re-Open of issue 2774: UseStaticFiles() will not serve files that are symbolic links",
    "url": "https://github.com/dotnet/aspnetcore/issues/34371",
    "createdAt": "2021-07-15T06:35:13Z",
    "lastUpdated": "2024-06-12T15:38:42Z",
    "body": "It\u0027s been 3 years since #2774 was closed. However, as of DotNet 6 Preview 6 is still appears not to have been addressed. Since apparently you are adding Symlink support to BCL, can this be addressed perhaps via an option (\u0060FollowSymLinks\u0060 property) in either \u0060StaticFileOptions\u0060 or \u0060PhysicalFileProvider\u0060?\r\n\r\n### Additional context\r\nSee original issue: https://github.com/dotnet/aspnetcore/issues/2774",
    "upvotes": 2,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg4MDUwMTcyMA==",
        "parentId": null,
        "author": "davidfowl",
        "content": "So 2 things:\r\n- We need an option on StaticFileOptions (new API)\r\n- PhysicalFileProvider needs to support it (new API).\r\n\r\nGiven that, it\u0027s unlikely that we\u0027d add it for .NET 6 this late in the cycle. That said, if there was an API proposal and a pull request, that might change things \uD83D\uDE04 ",
        "createdAt": "2021-07-15T08:26:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34371#issuecomment-880501720"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg4MTAyMDU5Ng==",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-07-15T21:19:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34371#issuecomment-881020596"
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg4MTAyMTE5Nw==",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Moved to backlog for now per @davidfowl\u0027s explanation.",
        "createdAt": "2021-07-15T21:20:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34371#issuecomment-881021197"
      },
      {
        "id": "IC_kwDOAQzde8444UCa",
        "parentId": null,
        "author": "Tratcher",
        "content": "Proposal: https://github.com/dotnet/aspnetcore/issues/5987",
        "createdAt": "2021-10-28T23:01:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34371#issuecomment-954286234"
      },
      {
        "id": "IC_kwDOAQzde8444UXE",
        "parentId": null,
        "author": "davidfowl",
        "content": "cc @carlossanlop ",
        "createdAt": "2021-10-28T23:04:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34371#issuecomment-954287556"
      },
      {
        "id": "IC_kwDOAQzde85Go0M8",
        "parentId": null,
        "author": "lonix1",
        "content": "When I reference a Razor Class Library using a symlink, it compiles without error, though at runtime it doesn\u0027t find or serve the library\u0027s pages. But if that library is referenced normally (not with a symlink) then it works perfectly.\r\n\r\nIs this the same underlying problem? (I didn\u0027t want to open a dupe issue.)",
        "createdAt": "2022-07-15T02:30:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34371#issuecomment-1185104700"
      },
      {
        "id": "IC_kwDOAQzde86A5hRQ",
        "parentId": null,
        "author": "fexxdev",
        "content": "### Issue Description\r\n\r\nI\u0027m encountering an issue with Kestrel 8.0.1 (.NET 8.0.1) on macOS where serving static files from symlinks results in incomplete files being served. This problem does not occur on Windows. When you manually copy the files into the destination directory, they are served correctly, indicating the problem lies with how Kestrel handles symlinks on macOS.\r\n\r\n### Directory Structure and Code\r\n\u0060\u0060\u0060\r\nmbp-fexxdev:timesheet fexxdev$ ls -lat\r\ntotal 0\r\ndrwxr-xr-x  14 fexxdev  staff  448 Jun 12 11:28 .\r\nlrwxr-xr-x   1 fexxdev  staff   96 Jun 12 11:15 styles.css.map -\u003E /Users/fexxdev/Desktop/Dev/Nebula/jarvis.automation.components/src/timesheet/dist/styles.css.map\r\nlrwxr-xr-x   1 fexxdev  staff   92 Jun 12 11:15 styles.css -\u003E /Users/fexxdev/Desktop/Dev/Nebula/jarvis.automation.components/src/timesheet/dist/styles.css\r\nlrwxr-xr-x   1 fexxdev  staff   98 Jun 12 11:15 polyfills.js.map -\u003E /Users/fexxdev/Desktop/Dev/Nebula/jarvis.automation.components/src/timesheet/dist/polyfills.js.map\r\nlrwxr-xr-x   1 fexxdev  staff   94 Jun 12 11:15 polyfills.js -\u003E /Users/fexxdev/Desktop/Dev/Nebula/jarvis.automation.components/src/timesheet/dist/polyfills.js\r\nlrwxr-xr-x   1 fexxdev  staff   87 Jun 12 11:15 media -\u003E /Users/fexxdev/Desktop/Dev/Nebula/jarvis.automation.components/src/timesheet/dist/media\r\nlrwxr-xr-x   1 fexxdev  staff   93 Jun 12 11:15 main.js.map -\u003E /Users/fexxdev/Desktop/Dev/Nebula/jarvis.automation.components/src/timesheet/dist/main.js.map\r\nlrwxr-xr-x   1 fexxdev  staff   89 Jun 12 11:15 main.js -\u003E /Users/fexxdev/Desktop/Dev/Nebula/jarvis.automation.components/src/timesheet/dist/main.js\r\nlrwxr-xr-x   1 fexxdev  staff   92 Jun 12 11:15 index.html -\u003E /Users/fexxdev/Desktop/Dev/Nebula/jarvis.automation.components/src/timesheet/dist/index.html\r\nlrwxr-xr-x   1 fexxdev  staff   93 Jun 12 11:15 favicon.ico -\u003E /Users/fexxdev/Desktop/Dev/Nebula/jarvis.automation.components/src/timesheet/dist/favicon.ico\r\nlrwxr-xr-x   1 fexxdev  staff  103 Jun 12 11:15 chunk-XSKKLE2R.js.map -\u003E /Users/fexxdev/Desktop/Dev/Nebula/jarvis.automation.components/src/timesheet/dist/chunk-XSKKLE2R.js.map\r\nlrwxr-xr-x   1 fexxdev  staff   99 Jun 12 11:15 chunk-XSKKLE2R.js -\u003E /Users/fexxdev/Desktop/Dev/Nebula/jarvis.automation.components/src/timesheet/dist/chunk-XSKKLE2R.js\r\nlrwxr-xr-x   1 fexxdev  staff   88 Jun 12 11:15 assets -\u003E /Users/fexxdev/Desktop/Dev/Nebula/jarvis.automation.components/src/timesheet/dist/assets\r\ndrwxr-xr-x@  4 fexxdev  staff  128 Jun 12 11:09 ..\r\nmbp-fexxdev:timesheet fexxdev$\r\n\u0060\u0060\u0060\r\n\r\n### ASP.NET Core Startup Configuration:\r\n\u0060\u0060\u0060\r\nif (Directory.Exists(ElsaServerOptions.StaticFilesLocation()))\r\n{\r\n    app.UseStaticFiles(new StaticFileOptions()\r\n    {\r\n        FileProvider = new PhysicalFileProvider(ElsaServerOptions.StaticFilesLocation()),\r\n        RequestPath = \u0022/static\u0022\r\n    });\r\n}\r\n\u0060\u0060\u0060\r\n\r\n### Screenshots:\r\n\r\n**Incomplete index.html when server from symlink**\r\n\r\n![Screenshot 2024-06-12 at 11 28 46](https://github.com/dotnet/aspnetcore/assets/26311786/106988ae-5972-443a-966e-61d773979d40)\r\n\r\n**index.html correctly served after manual copy**\r\n\r\n\u0060\u0060\u0060\r\ndrwxr-xr-x@  4 fexxdev  staff  128 Jun 12 11:09 ..\r\nmbp-fexxdev:timesheet fexxdev$ cp index.html index2.html\r\nmbp-fexxdev:timesheet fexxdev$ ls -lat\r\ntotal 8\r\n-rw-r--r--   1 fexxdev  staff  602 Jun 12 11:29 index2.html\r\ndrwxr-xr-x  15 fexxdev  staff  480 Jun 12 11:29 .\r\nlrwxr-xr-x   1 fexxdev  staff   96 Jun 12 11:15 styles.css.map -\u003E /Users/fexxdev/Desktop/Dev/Nebula/jarvis.automation.components/src/timesheet/dist/styles.css.map\r\nlrwxr-xr-x   1 fexxdev  staff   92 Jun 12 11:15 sty....\r\n\u0060\u0060\u0060\r\n\r\n![Screenshot 2024-06-12 at 11 29 48](https://github.com/dotnet/aspnetcore/assets/26311786/be3e697c-9513-413c-bbf0-af5e7229dc0d)\r\n_(don\u0027t mind the fact that the page is blank, it is expected. But the content is there as you can see)_\r\n\r\nAny thoughts? Thanks!",
        "createdAt": "2024-06-12T09:38:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34371#issuecomment-2162562128"
      },
      {
        "id": "IC_kwDOAQzde86A8PoS",
        "parentId": null,
        "author": "Tratcher",
        "content": "@fexxdev 2.2.0 is _way_ out of support, you need to be on .NET 6 or 8 these days.",
        "createdAt": "2024-06-12T15:05:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34371#issuecomment-2163276306"
      },
      {
        "id": "IC_kwDOAQzde86A8hpL",
        "parentId": null,
        "author": "fexxdev",
        "content": "@Tratcher  i\u0027m sorry for the confusion, i though one thing and wrote another \uD83D\uDE05 \r\nI\u0027m using .NET 8.0.1",
        "createdAt": "2024-06-12T15:38:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34371#issuecomment-2163350091"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU5NTUwMzk4MDU=",
    "title": "FileLoggerProcessor should update FileNumber suffix when FileName changes",
    "url": "https://github.com/dotnet/aspnetcore/issues/34809",
    "createdAt": "2021-07-28T16:38:37Z",
    "lastUpdated": "2023-08-28T23:09:53Z",
    "body": "https://github.com/dotnet/aspnetcore/blob/eb0f414830a5468d0fba0c885b0a9ed0227292f0/src/Middleware/HttpLogging/src/W3CLoggerOptions.cs#L17\r\n\r\nWhen FileName changes, we should reset FileNumber back to 0 instead of continuing where we left off.\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/eb0f414830a5468d0fba0c885b0a9ed0227292f0/src/Middleware/HttpLogging/src/FileLoggerProcessor.cs#L65-L80\r\n\r\n\u003E But it might be somewhat tricky - e.g. OnChange fires in the middle of execution of WriteMessagesAsync, causing the FileNumber to go back to zero. If this happens while we\u0027re scanning through some previous files to find out if they exist, it could cause us to suffix the first file with the new name with something nonzero. I\u0027ll file a follow-up issue for this one, for now I think it\u0027s fine if the numbering for the new file names pick up where the old ones left off.",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde8409MGs",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/master/docs/TriageProcess.md).",
        "createdAt": "2021-07-28T16:38:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/34809#issuecomment-888455596"
      }
    ]
  },
  {
    "id": "MDU6SXNzdWU5NjMzODY1Mzg=",
    "title": "Introduce a session metadata to load session asynchronously in session middleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/35154",
    "createdAt": "2021-08-08T08:55:14Z",
    "lastUpdated": "2024-03-02T00:45:20Z",
    "body": "## Background and Motivation\r\nThe default session provider in ASP.NET Core loads session records from the underlying IDistributedCache backing store asynchronously only if the ISession.LoadAsync method is explicitly called before the TryGetValue, Set, or Remove methods. If LoadAsync isn\u0027t called first, the underlying session record is loaded synchronously, which can incur a performance penalty at scale.\r\n\r\nWe could provide a new endpoint metadata with \u0060SessionState\u0060 property for session which controls the behavior of \u0060SessionMiddleware\u0060.\r\n\r\n- SessionState.Default:  The current behavior which creates a session key, set the session feature, set cookie if needed.\r\n- SessionState.EagerLoad: Calls LoadAsync in session middleware [Needs a better name than EagerLoad!]\r\n- SessionState.Disabled: Do nothing in session middleware, not even setting the session feature\r\n- SessionState.ReadOnly:  Calls LoadAsync in session middleware, but not CommitAsync and wrap ISession in a class which throw exception when Set, Remove or Clear called.\r\n\r\n## Proposed API\r\n\u0060\u0060\u0060diff\r\npublic class SessionOptions\r\n{\r\n     // The behavior of session middleware when \u0060ISessionStateMetadata\u0060 is not available.\r\n\u002B   public SessionState DefaultBehavior { get; set; }\r\n}\r\n\u0060\u0060\u0060\r\n\u0060\u0060\u0060csharp\r\npublic interface ISessionStateMetadata\r\n{\r\n    SessionState State { get; }\r\n}\r\n\r\npublic enum SessionState\r\n{\r\n    Default = 0,\r\n    EagerLoad = 1,\r\n    Disabled = 2,\r\n    ReadOnly = 3,\r\n}\r\n\r\npublic class SessionStateAttribute : ISessionStateMetadata\r\n{\r\n    SessionState State { get; }\r\n}\r\n\r\npublic static class RoutingEndpointConventionBuilderExtensions\r\n{\r\n    public static TBuilder SetSessionBehvior\u003CTBuilder\u003E(this TBuilder builder, SessionState sessionState) where TBuilder : IEndpointConventionBuilder;\r\n}\r\n\u0060\u0060\u0060\r\n## Usage Examples\r\n\r\n\u0060\u0060\u0060 C#\r\n[SessionState(SessionState.Disabled)]\r\npublic class CustomerController\r\n{\r\n    ...\r\n}\r\n\r\napp.MapGet(\u0022/nosession\u0022, (HttpContext context) =\u003E $\u0022Hello World!\u0022).SetSessionBehvior(SessionState.Disabled);\r\n\r\napp.MapGet(\u0022/nosession2\u0022, [SessionState(SessionState.Disabled)] (HttpContext context) =\u003E $\u0022Hello World!\u0022);\r\n\r\napp.MapGet(\u0022/\u0022, (HttpContext context) =\u003E $\u0022{context.Session.GetString(\u0022Hi\u0022)} World!\u0022).SetSessionBehvior(SessionState.ReadOnly);\r\n\u0060\u0060\u0060\r\n## Risks\r\nIf Endpoints are marked by mistake the session would load for all requests even when they don\u0027t need session.\r\n",
    "upvotes": 0,
    "labels": [
      "feature-session",
      "api-suggestion",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde841VQ0Z",
        "parentId": null,
        "author": "davidfowl",
        "content": "Prior art in this area:\r\n- https://docs.microsoft.com/en-us/dotnet/api/system.web.mvc.sessionstateattribute?view=aspnet-mvc-5.2\r\n- https://docs.microsoft.com/en-us/dotnet/api/system.web.sessionstate.sessionstatebehavior?view=netframework-4.8\r\n\r\nSome thoughts:\r\n- I think we can drop the metadata from the attribute. Not sure we explicitly use \u0022metadata\u0022 in these type names anywhere else either.\r\n- Does Required=false mean don\u0027t load? Or just don\u0027t eagerly load? I\u0027m trying to figure out if this is just a marker interface e.g. https://github.com/dotnet/aspnetcore/blob/ec504ed0130837873576de3d7eee804e4a0987f5/src/Http/Metadata/src/IAllowAnonymous.cs",
        "createdAt": "2021-08-08T09:02:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/35154#issuecomment-894766361"
      },
      {
        "id": "IC_kwDOAQzde841VSzU",
        "parentId": null,
        "author": "Kahbazi",
        "content": "\u003E Does Required=false mean don\u0027t load? Or just don\u0027t eagerly load? I\u0027m trying to figure out if this is just a marker interface e.g. https://github.com/dotnet/aspnetcore/blob/ec504ed0130837873576de3d7eee804e4a0987f5/src/Http/Metadata/src/IAllowAnonymous.cs\r\n\r\nIf not loading session at all could lead to not setting the session feature, it is a good idea, it\u0027s useful for application that both have state-full UI and state-less rest API. Specially with the current implementation which always allocate and create session key.\r\n\r\nI change the metadata and updated the proposal based on the https://docs.microsoft.com/en-us/dotnet/api/system.web.sessionstate.sessionstatebehavior?view=netframework-4.8.\r\n",
        "createdAt": "2021-08-08T10:13:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/35154#issuecomment-894774484"
      },
      {
        "id": "IC_kwDOAQzde841VTab",
        "parentId": null,
        "author": "davidfowl",
        "content": "I prefer a single method/attribute \u002B enum:\r\n\r\n\u0060\u0060\u0060C#\r\n[SessionStateAttribute(SessionState.Disabled)]\r\npublic class CustomerController\r\n{\r\n    ...\r\n}\r\n\r\napp.MapGet(\u0022/nosession\u0022, (HttpContext context) =\u003E $\u0022Hello World!\u0022).SetSessionBehvior(SessionState.Disabled);\r\n\r\napp.MapGet(\u0022/nosession2\u0022, [SessionStateAttribute(SessionState.Disabled)] (HttpContext context) =\u003E $\u0022Hello World!\u0022);\r\n\r\napp.MapGet(\u0022/\u0022, (HttpContext context) =\u003E $\u0022{context.Session.GetString(\u0022Hi\u0022)} World!\u0022).SetSessionBehvior(SessionState.ReadOnly);\r\n\u0060\u0060\u0060",
        "createdAt": "2021-08-08T10:35:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/35154#issuecomment-894776987"
      },
      {
        "id": "IC_kwDOAQzde841VTmw",
        "parentId": null,
        "author": "Kahbazi",
        "content": "\u003E I prefer a single method/attribute \u002B enum:\r\n\r\nI updated the proposal.\r\n",
        "createdAt": "2021-08-08T10:43:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/35154#issuecomment-894777776"
      },
      {
        "id": "IC_kwDOAQzde841aGf7",
        "parentId": null,
        "author": "Kahbazi",
        "content": "@adityamandaleeka Any chance this could be done in .Net 6.0? I can send a PR for this feature when the proposal is approved.",
        "createdAt": "2021-08-10T13:35:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/35154#issuecomment-896034811"
      },
      {
        "id": "IC_kwDOAQzde841aijZ",
        "parentId": null,
        "author": "davidfowl",
        "content": "This doesn\u0027t need to go into .NET 6. Even if you do the work, it needs to be reviewed by the team so it\u0027s not free. I suggest writing a middleware that does the same for now and can be shipped on nuget and we can revisit in .NET 7.",
        "createdAt": "2021-08-10T16:55:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/35154#issuecomment-896149721"
      },
      {
        "id": "IC_kwDOAQzde85ZdmSw",
        "parentId": null,
        "author": "danirzv",
        "content": "I\u0027m interested to help on this issue, may I send pull request?",
        "createdAt": "2023-04-08T16:49:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/35154#issuecomment-1500931248"
      },
      {
        "id": "IC_kwDOAQzde85ZkmRn",
        "parentId": null,
        "author": "mitchdenny",
        "content": "@danirzv thanks for the offer. I think before you picked this up we\u0027d want to make sure that the shape of the API here is something that we are comfortable with. @davidfowl - this is a some what old API proposal - is it developed enough to go through API review?",
        "createdAt": "2023-04-11T06:44:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/35154#issuecomment-1502766183"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde847_syT",
    "title": "HttpLoggingMiddleware does not log all response headers when log response body",
    "url": "https://github.com/dotnet/aspnetcore/issues/36920",
    "createdAt": "2021-09-24T14:58:11Z",
    "lastUpdated": "2024-03-02T01:01:40Z",
    "body": "### Describe the bug\r\n\r\nWhen I use the \u0060HttpLoggingMiddleware\u0060 to log the response body, the response header would not be logged as expected, not know if this is by design, guessing that it may caused by \u003Chttps://github.com/dotnet/aspnetcore/blob/v6.0.0-rc.1.21452.15/src/Middleware/HttpLogging/src/HttpLoggingMiddleware.cs#L172\u003E\r\n\r\n![image](https://user-images.githubusercontent.com/7604648/134696770-605a596a-a40b-4c5f-b4cd-1a991ba841b1.png)\r\n\r\n\r\n### To Reproduce\r\n\r\nJust create a api project with \u0060dotnet new webapi -n HttpLoggingMiddlewareSample --no-openapi --no-https\u0060, then add \u0060UseHttpLogging()\u0060 to the request pipeline, and customize the logging option, modified the sample likes follows:\r\n\r\n\u0060\u0060\u0060 csharp\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\nbuilder.Services.AddControllers();\r\nbuilder.Services.AddHttpLogging(options =\u003E\r\n{\r\n    options.LoggingFields = Microsoft.AspNetCore.HttpLogging.HttpLoggingFields.All;\r\n    options.RequestHeaders.Add(\u0022Cache-Control\u0022);\r\n    options.ResponseHeaders.Add(\u0022Server\u0022);\r\n});\r\nvar app = builder.Build();\r\n\r\n// Configure the HTTP request pipeline.\r\napp.UseHttpLogging();\r\napp.MapControllers();\r\n\r\napp.Run();\r\n\u0060\u0060\u0060\r\n\r\nsample project: \u003Chttps://github.com/WeihanLi/SamplesInPractice/blob/master/net6sample/HttpLoggingMiddlewareSample/Program.cs\u003E\r\n\r\nWhen I specific the logging fields with \u0060All\u0060, the response headers are not been logged, I got logs like below:\r\n\r\n\u0060\u0060\u0060\r\ninfo: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[1]\r\n      Request:\r\n      Protocol: HTTP/1.1\r\n      Method: GET\r\n      Scheme: http\r\n      PathBase:\r\n      Path: /weatherforecast\r\n      Host: localhost:5084\r\n      User-Agent: dotnet-HTTPie/0.1.1\r\ninfo: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[2]\r\n      Response:\r\n      StatusCode: 200\r\n      Content-Type: application/json; charset=utf-8\r\ninfo: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[4]\r\n      ResponseBody: [{\u0022date\u0022:\u00222021-09-25T22:37:45.0463903\u002B08:00\u0022,\u0022temperatureC\u0022:-2,\u0022temperatureF\u0022:29,\u0022summary\u0022:\u0022Mild\u0022},{\u0022date\u0022:\u00222021-09-26T22:37:45.0498642\u002B08:00\u0022,\u0022temperatureC\u0022:-20,\u0022temperatureF\u0022:-3,\u0022summary\u0022:\u0022Cool\u0022},{\u0022date\u0022:\u00222021-09-27T22:37:45.0498738\u002B08:00\u0022,\u0022temperatureC\u0022:-20,\u0022temperatureF\u0022:-3,\u0022summary\u0022:\u0022Freezing\u0022},{\u0022date\u0022:\u00222021-09-28T22:37:45.0498741\u002B08:00\u0022,\u0022temperatureC\u0022:-15,\u0022temperatureF\u0022:6,\u0022summary\u0022:\u0022Cool\u0022},{\u0022date\u0022:\u00222021-09-29T22:37:45.0498743\u002B08:00\u0022,\u0022temperatureC\u0022:23,\u0022temperatureF\u0022:73,\u0022summary\u0022:\u0022Balmy\u0022}]\r\n\u0060\u0060\u0060\r\n\r\nwhile when I commented the \u0060LoggingFields\u0060 config, the response headers would be logged, I get logs as follows:\r\n\r\n\u0060\u0060\u0060\r\ninfo: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[1]\r\n      Request:\r\n      Protocol: HTTP/1.1\r\n      Method: GET\r\n      Scheme: http\r\n      PathBase:\r\n      Path: /weatherforecast\r\n      Host: localhost:5084\r\n      User-Agent: dotnet-HTTPie/0.1.1\r\ninfo: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[2]\r\n      Response:\r\n      StatusCode: 200\r\n      Content-Type: application/json; charset=utf-8\r\n      Date: [Redacted]\r\n      Server: Kestrel\r\n      Transfer-Encoding: chunked\r\n\u0060\u0060\u0060\r\n\r\n### Exceptions (if any)\r\n\r\nThe response headers should be logged\r\n\r\n### Further technical details\r\n\r\n- ASP.NET Core version\uFF1A.NET 6 RC 1\r\n- The IDE: VS 2022 Preview 4/ dotnet cli(.NET 6 RC1)\r\n- Include the output of \u0060dotnet --info\u0060\r\n\r\n\u0060\u0060\u0060\r\n.NET SDK (reflecting any global.json):\r\n Version:   6.0.100-rc.1.21458.32\r\n Commit:    d7c22323c4\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.22463\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\6.0.100-rc.1.21458.32\\\r\n\r\nHost (useful for support):\r\n  Version: 6.0.0-rc.1.21451.13\r\n  Commit:  d7619cd4b1\r\n\r\n.NET SDKs installed:\r\n  2.1.802 [C:\\Program Files\\dotnet\\sdk]\r\n  2.2.300 [C:\\Program Files\\dotnet\\sdk]\r\n  3.1.300 [C:\\Program Files\\dotnet\\sdk]\r\n  3.1.301 [C:\\Program Files\\dotnet\\sdk]\r\n  3.1.412 [C:\\Program Files\\dotnet\\sdk]\r\n  5.0.400 [C:\\Program Files\\dotnet\\sdk]\r\n  6.0.100-rc.1.21458.32 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.All 2.1.13 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.All 2.2.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.All]\r\n  Microsoft.AspNetCore.App 2.1.13 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 2.2.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 3.1.18 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 5.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 6.0.0-rc.1.21452.15 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 2.1.13 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 2.2.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 3.1.18 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 5.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 6.0.0-rc.1.21451.13 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 3.1.18 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 5.0.9 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 6.0.0-rc.1.21451.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\u0060\u0060\u0060\r\n",
    "upvotes": 1,
    "labels": [
      "investigate",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde843P2R7",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Thanks for reporting this, we will investigate. It\u0027s interesting that we only log the headers if the body is empty.",
        "createdAt": "2021-09-24T20:29:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36920#issuecomment-926901371"
      },
      {
        "id": "IC_kwDOAQzde843QLuM",
        "parentId": null,
        "author": "Tratcher",
        "content": "The response headers are logged in your first example just not all of them.\r\n\u0060\u0060\u0060\r\ninfo: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[2]\r\n      Response:\r\n      StatusCode: 200\r\n      Content-Type: application/json; charset=utf-8\r\n\u0060\u0060\u0060\r\nThe missing headers are all ones added dynamically by the server when finalizing the response.\r\n\u0060\u0060\u0060\r\n      Date: [Redacted]\r\n      Server: Kestrel\r\n      Transfer-Encoding: chunked\r\n\u0060\u0060\u0060\r\n\r\nThe difference you observe between the scenarios is because of when the headers are logged. When body logging is enabled the header logging happens during the first body write, before the server generates those automatic values. When body logging is disabled the headers aren\u0027t logged until the end of the request.\r\n\r\nPossible fix: when body logging is enabled, log the headers just after the first write rather than before it. That will let them finish generating first.\r\n\r\nPriority: Low. While this is inconsistent, these automatic headers are less important than app headers in most scenarios.\r\n",
        "createdAt": "2021-09-25T01:24:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36920#issuecomment-926989196"
      },
      {
        "id": "IC_kwDOAQzde843QOFz",
        "parentId": null,
        "author": "WeihanLi",
        "content": "@Tratcher thanks for your investigation, currently, we may log before the request is handled, not sure if it\u0027s a good idea to log only when the request had been handled, and I think maybe it\u0027s better to add a try-finally clause to ensure the logs would be logged even when there\u0027s an exception",
        "createdAt": "2021-09-25T02:45:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36920#issuecomment-926998899"
      },
      {
        "id": "IC_kwDOAQzde85KP8Rn",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. Because it\u0027s not immediately obvious that this is a bug in our framework, we would like to keep this around to collect more feedback, which can later help us determine the impact of it. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-13T17:01:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36920#issuecomment-1245693031"
      },
      {
        "id": "IC_kwDOAQzde85M-dBy",
        "parentId": null,
        "author": "drew-cooper",
        "content": "I\u0027m also experience this issue, but in my case it\u0027s headers that are added in the \u0060HttpResponse.OnStarting\u0060 callback.\r\nThese headers are logged when Response Body logging is off, but not otherwise.\r\nThe callback is set up in Middleware which is after the \u0060HttpLoggingMiddleware\u0060 and before the ASP.Net Controller pipeline.",
        "createdAt": "2022-10-26T03:15:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36920#issuecomment-1291440242"
      },
      {
        "id": "IC_kwDOAQzde85M_73S",
        "parentId": null,
        "author": "Tratcher",
        "content": "Related: https://github.com/dotnet/aspnetcore/issues/39310",
        "createdAt": "2022-10-26T10:32:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/36920#issuecomment-1291828690"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde84-EfU2",
    "title": "Consider writing an analyzer that produces warnings when using sync APIs on IDistributedCache",
    "url": "https://github.com/dotnet/aspnetcore/issues/37991",
    "createdAt": "2021-11-01T16:33:03Z",
    "lastUpdated": "2023-06-02T03:19:38Z",
    "body": "\u0060IDistributedCache\u0060 has a few synchronous APIs\r\n\r\n* https://docs.microsoft.com/dotnet/api/microsoft.extensions.caching.distributed.idistributedcache.get?#Microsoft_Extensions_Caching_Distributed_IDistributedCache_Get_System_String_\r\n* https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.distributed.idistributedcache.refresh\r\n* https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.distributed.idistributedcache.remove\r\n* https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.caching.distributed.idistributedcache.set\r\n\r\nIn the SqlServer and RedisCache implementations this ends up making blocking calls: e.g. https://github.com/dotnet/aspnetcore/blob/main/src/Caching/SqlServer/src/DatabaseOperations.cs#L54-L62. The proposal is to add an analyzer that warns against the use of these APIs.",
    "upvotes": 0,
    "labels": [
      "analyzer",
      "feature-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde845A_c_",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2021-11-01T20:21:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/37991#issuecomment-956561215"
      },
      {
        "id": "IC_kwDOAQzde85TbPbz",
        "parentId": null,
        "author": "david-acker",
        "content": "I\u0027d be interesting in helping out with this if possible!\r\n\r\nI\u0027m assuming we would want a new shared analyzers project that would be included with the \u0060Microsoft.Extensions.Caching.StackExchangeRedis\u0060 and \u0060Microsoft.Extensions.Caching.SqlServer\u0060 NuGet packages?",
        "createdAt": "2023-01-23T00:09:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/37991#issuecomment-1399650035"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde84-KtBm",
    "title": "Add configuration option to \u0060RedisCache\u0060 to allow read-only access",
    "url": "https://github.com/dotnet/aspnetcore/issues/38046",
    "createdAt": "2021-11-03T01:36:51Z",
    "lastUpdated": "2023-10-28T14:07:49Z",
    "body": "Currently, \u0060RedisCache\u0060 resets expiry for keys on every read (https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/RedisCache.cs#L293 and in the async version as well).\r\n\r\nWhen using Redis as a session storage, this can lead to sessions getting invalidated unnecessarily on Redis failover. During a new leader election read-only access is preserved which would allow existing clients to continue. However due to the \u0060EXPIRE\u0060 command being issued alongside the read, the read command will fail.\r\n\r\nThis might be desired behaviour in other circumstances. For a session storage solution it would be fine to just ignore the exception on expire and carry on. In the case that Redis writes do not become available within expiry time, the session would then expire. It would also still expire when attempting other writes.\r\n\r\nA configuration option for the cache would be nice to allow expire to fail. Otherwise, changing the variables in the class to \u0060protected\u0060 so sensible overrides are possible might be another solution.",
    "upvotes": 2,
    "labels": [
      "feature-caching",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde845OCEH",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Triage: the configuration option seems possible, but we should discuss this further on this issue before implementing it in a PR. In particular, we should make sure the new option works well with the session implementation (which would do a write at the end of every request).",
        "createdAt": "2021-11-03T20:31:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38046#issuecomment-959979783"
      },
      {
        "id": "IC_kwDOAQzde845OCIc",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2021-11-03T20:31:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38046#issuecomment-959980060"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde84-uG8c",
    "title": "Consider updating AuthorizationMiddleware and CorsMiddleware to only set state in HttpContext if auth / cors metadata is present",
    "url": "https://github.com/dotnet/aspnetcore/issues/38342",
    "createdAt": "2021-11-12T18:23:32Z",
    "lastUpdated": "2023-08-24T23:55:39Z",
    "body": "Endpoint routing only checks for state in HttpContext if the route has Auth or CORs metadata:\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/EndpointMiddleware.cs#L38-L48\r\n\r\nHowever, the middlewares update HttpContext.Items any time it sees an endpoint:\r\n\r\n* https://github.com/dotnet/aspnetcore/blob/main/src/Security/Authorization/Policy/src/AuthorizationMiddleware.cs#L51-L58\r\n* https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/CORS/src/Infrastructure/CorsMiddleware.cs#L126-L133\r\n\r\nWe might benefit from slight improvements for endpoints with Auth or CORS metadata by updating these middlewares to only update context when they know EndpointMiddleware is going to observe it i.e.\r\n\r\n\u0060\u0060\u0060C#\r\n if (endpoint?..GetMetadata\u003CICorsMetadata\u003E() is not null)\r\n{\r\n        // EndpointRoutingMiddleware uses this flag to check if the CORS middleware processed CORS metadata on the endpoint.\r\n        // The CORS middleware can only make this claim if it observes an actual endpoint.\r\n        context.Items[CorsMiddlewareWithEndpointInvokedKey] = CorsMiddlewareWithEndpointInvokedValue;\r\n}\r\n\u0060\u0060\u0060\r\n\r\n",
    "upvotes": 0,
    "labels": [
      "Perf",
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde845qDLI",
        "parentId": null,
        "author": "pranavkm",
        "content": "/cc @davidfowl ",
        "createdAt": "2021-11-12T18:23:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38342#issuecomment-967324360"
      },
      {
        "id": "IC_kwDOAQzde845q2zj",
        "parentId": null,
        "author": "Tratcher",
        "content": "Which is more expensive on average, \u0060GetMetadata\u003CICorsMetadata\u003E()\u0060, or \u0060context.Items[CorsMiddlewareWithEndpointInvokedKey] = CorsMiddlewareWithEndpointInvokedValue;\u0060?",
        "createdAt": "2021-11-12T20:53:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38342#issuecomment-967535843"
      },
      {
        "id": "IC_kwDOAQzde845q8vR",
        "parentId": null,
        "author": "pranavkm",
        "content": "We know we are calling GetMetadata at least once now (in the routing middleware), so it calling it twice is likely come to out a bit better since the lookup gets cached: https://github.com/dotnet/aspnetcore/blob/main/src/Http/Http.Abstractions/src/Routing/EndpointMetadataCollection.cs#L75-L85. But yeah, I filed an issue versus making a code change because we probably need to verify the benefits of this change.",
        "createdAt": "2021-11-12T21:08:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38342#issuecomment-967560145"
      },
      {
        "id": "IC_kwDOAQzde845rB9t",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Triage: the change here is fairly small, but we need to have a good performance test to measure the impact.",
        "createdAt": "2021-11-12T21:22:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38342#issuecomment-967581549"
      },
      {
        "id": "IC_kwDOAQzde845rCKK",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2021-11-12T21:22:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38342#issuecomment-967582346"
      },
      {
        "id": "IC_kwDOAQzde845ttmM",
        "parentId": null,
        "author": "Kahbazi",
        "content": "While we are at it, how about also checking \u0060RouteOptions.SuppressCheckForUnhandledSecurityMetadata\u0060?",
        "createdAt": "2021-11-14T12:47:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/38342#issuecomment-968284556"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85BLdBz",
    "title": "Allow response caching cache to log",
    "url": "https://github.com/dotnet/aspnetcore/issues/39300",
    "createdAt": "2022-01-04T16:30:38Z",
    "lastUpdated": "2024-03-02T00:50:41Z",
    "body": "\u003C!--\r\n\r\nMore information on our issue management policies can be found here: https://aka.ms/aspnet/issue-policies\r\n\r\n--\u003E\r\n\r\n### Is your feature request related to a problem? Please describe.\r\nIn reviewing [a PR](https://github.com/dotnet/AspNetCore.Docs/pull/24444#discussion_r777626989) for updates to the ASP.NET Core Output Caching middleware docs, I realised the default limit of 100MB is quite small and we\u0027d likely be hitting that (turns out definitely, we estimate we should have a few GB \uD83D\uDE05). I was trying to figure out how we\u0027d know if we were hitting the limit, so dug down through the middleware and into the underlying \u0060MS.Extensions.Caching.Memory.MemoryCache\u0060 implementation and found it does log a few Debug level messages saying its cleaning house (\u0022Overcapacity compaction triggered\u0022).\r\n\r\nSo I tried to replicate that log entry locally and couldn\u0027t. I believe the issue is that the [ResponseCachingMiddleware ctor](https://github.com/dotnet/aspnetcore/blob/c85baf8db0c72ae8e68643029d514b2e737c9fae/src/Middleware/ResponseCaching/src/ResponseCachingMiddleware.cs#L39-L54) is spawning its own instance of MemoryCache directly and not giving it a logger, so it gets the no-op logger.\r\n\r\nI think this log message could provide value, and I\u0027m discussing on the docs PR about whether we mention that in the docs, so if we give it a logger I think we\u0027ll be OK here.\r\n\r\n### Describe the solution you\u0027d like\r\nFirst thought was to pass an instance of \u0060ILogger\u003CT\u003E\u0060 to \u0060MemoryCache\u0060 ctor, but actually it only accepts a logger factory.\r\n\r\nIt could be valuable to have another ctor that takes an \u0060ILogger\u0060 instance so that, for example in this case, the consumer can pass one with a more specific category like \u0022AspNetCoreResponseCache\u0022 (rather than being mixed in with the shared instance).\r\n\r\nI\u0027ll can whip up a PR with a seal of approval on the approach.\r\n\r\n### Additional context\r\nAdd any other context or screenshots about the feature request here.\r\n",
    "upvotes": 0,
    "labels": [
      "api-suggestion",
      "feature-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde8475z0v",
        "parentId": null,
        "author": "Tratcher",
        "content": "You can suggest the new API signature here in this issue, but note that MemoryCache lives over in https://github.com/dotnet/runtime. Not sure if that new overload would cause DI issues.\r\n\r\nhttps://github.com/dotnet/runtime/blob/ae2e360936eb0ee737fb81c872c87dd7794782d3/src/libraries/Microsoft.Extensions.Caching.Memory/src/MemoryCache.cs#L43",
        "createdAt": "2022-01-04T17:10:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39300#issuecomment-1005010223"
      },
      {
        "id": "IC_kwDOAQzde84750LG",
        "parentId": null,
        "author": "benmccallum",
        "content": "\u003E Not sure if that new overload would cause DI issues.\r\n\r\nWas also worried about this. ",
        "createdAt": "2022-01-04T17:12:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39300#issuecomment-1005011654"
      },
      {
        "id": "IC_kwDOAQzde84752I0",
        "parentId": null,
        "author": "benmccallum",
        "content": "I guess ideally this would be the change.\r\n\r\nAnother alternative if we\u0027re worried about \u0060ILogger\u0060 in the ctor would be \u0060ILoggerFactory loggerFactory, string loggerCategoryName\u0060 and the ctor use that if non-null. Feels a little weird though.\r\n\r\n**dotnet/aspnetcore**\r\n\u0060ResponseCachingMiddleware\u0060 creates a \u0060MemoryCache\u0060 instance passing through the \u0060ILogger\u0060 with a specific name.\r\n\r\n\u0060\u0060\u0060c#\r\npublic ResponseCachingMiddleware(\r\n        RequestDelegate next,\r\n        IOptions\u003CResponseCachingOptions\u003E options,\r\n        ILoggerFactory loggerFactory,\r\n        ObjectPoolProvider poolProvider)\r\n        : this(\r\n            next,\r\n            options,\r\n            loggerFactory,\r\n            new ResponseCachingPolicyProvider(),\r\n            new MemoryResponseCache(\r\n                new MemoryCache(\r\n                    new MemoryCacheOptions\r\n                    {\r\n                        SizeLimit = options.Value.SizeLimit\r\n                    },\r\n                    // pass it with a name here\r\n                    loggerFactory.CreateLogger(\u0022AspNetCoreResponseMemoryCache\u0022))),\r\n            new ResponseCachingKeyProvider(poolProvider, options))\r\n    { }\r\n\u0060\u0060\u0060\r\n\r\n**dotnet/runtime**\r\n\u0060MemoryCache\u0060 gets a new ctor for an \u0060ILogger\u0060 and the existing one calls into it.\r\n\r\n\u0060\u0060\u0060c#\r\n/// \u003Csummary\u003E\r\n/// Creates a new \u003Csee cref=\u0022MemoryCache\u0022/\u003E instance.\r\n/// \u003C/summary\u003E\r\n/// \u003Cparam name=\u0022optionsAccessor\u0022\u003EThe options of the cache.\u003C/param\u003E\r\n/// \u003Cparam name=\u0022loggerFactory\u0022\u003EThe factory used to create loggers.\u003C/param\u003E\r\npublic MemoryCache(IOptions\u003CMemoryCacheOptions\u003E optionsAccessor, ILoggerFactory loggerFactory)\r\n    : this(\r\n        optionsAccessor,\r\n        loggerFactory?.CreateLogger\u003CMemoryCache\u003E() ?? throw new ArgumentNullException(nameof(loggerFactory))\r\n    ) { }\r\n\r\n/// \u003Csummary\u003E\r\n/// Creates a new \u003Csee cref=\u0022MemoryCache\u0022/\u003E instance.\r\n/// \u003C/summary\u003E\r\n/// \u003Cparam name=\u0022optionsAccessor\u0022\u003EThe options of the cache.\u003C/param\u003E\r\n/// \u003Cparam name=\u0022logger\u0022\u003EA logger instance.\u003C/param\u003E\r\npublic MemoryCache(IOptions\u003CMemoryCacheOptions\u003E optionsAccessor, ILogger logger)\r\n{\r\n    if (optionsAccessor == null)\r\n    {\r\n        throw new ArgumentNullException(nameof(optionsAccessor));\r\n    }\r\n\r\n    if (logger == null)\r\n    {\r\n        throw new ArgumentNullException(nameof(logger));\r\n    }\r\n\r\n    _options = optionsAccessor.Value;\r\n    _logger = logger;\r\n\r\n    // ... exclude for brevity\r\n}\r\n\u0060\u0060\u0060",
        "createdAt": "2022-01-04T17:22:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39300#issuecomment-1005019700"
      },
      {
        "id": "IC_kwDOAQzde847957B",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@halter73 to follow up with the API proposal after thinking about this a bit more.",
        "createdAt": "2022-01-05T21:17:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39300#issuecomment-1006083777"
      },
      {
        "id": "IC_kwDOAQzde84795_t",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 7 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-01-05T21:17:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39300#issuecomment-1006084077"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85BMQLB",
    "title": "Response caching and output caching do not cache headers modified in OnStarting handler",
    "url": "https://github.com/dotnet/aspnetcore/issues/39310",
    "createdAt": "2022-01-04T20:32:20Z",
    "lastUpdated": "2024-03-02T00:50:42Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nResponse caching does not cache headers modified in the OnStarting delegate in middleware loaded after responsecaching middleware.\r\n\r\n\u0060\u0060\u0060 c#\r\ncontext.Response.OnStarting(CheckIfHeaderNeeded, context);\r\n\r\nprivate Task CheckIfHeaderNeeded(object state)\r\n    {\r\n        var context = (HttpContext)state;\r\n        context.Response.Headers.Remove(\u0022removeme\u0022);\r\n        return Task.CompletedTask;\r\n    }\r\n\u0060\u0060\u0060\r\n\r\nrevmoveme header will only be removed on the initial request\n\n### Expected Behavior\n\nResponse caching should cache the actual final headers sent to the client.  It cannot cache only headers created before the await(next) in middleware.\r\n\r\nThis will also fix #23218 if I understand the issue correctly.  \r\n\r\n@Tratcher mentioned one possible fix is\r\n\u003E One fix would be for the caching middleware to shim OnStarting and run those callbacks before it captured the headers. (Complex)\r\n\r\nThat seems to be the correct behavior \n\n### Steps To Reproduce\n\nhttps://github.com/lawrencek76/header-caching-issue\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n6.0.101\n\n### Anything else?\n\nInitially ran into this trying to cache security headers with a nonce in another middleware.\r\nhttps://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders/issues/117\r\n\r\nAfter attempting to make a pr to fix this in the other middleware I realized there is really no way I can find to really do this correctly outside of the caching middleware itself.\r\n\r\nhttps://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders/pull/118\r\n",
    "upvotes": 0,
    "labels": [
      "feature-response-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde8476e__",
        "parentId": null,
        "author": "Tratcher",
        "content": "One challenge with changing this is that response caching reads the current response headers to decide if it should cache, and then starts intercepting writes (or not). This will mean also delaying the decision to cache (or not) until after the first write completes.",
        "createdAt": "2022-01-04T21:34:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39310#issuecomment-1005187071"
      },
      {
        "id": "IC_kwDOAQzde847948h",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 7 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-01-05T21:11:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39310#issuecomment-1006079777"
      },
      {
        "id": "IC_kwDOAQzde85LMWJF",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-28T22:29:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39310#issuecomment-1261527621"
      },
      {
        "id": "IC_kwDOAQzde85LMWS-",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Triage: may be interesting to fix this in output caching. Consider capturing headers after the first write rather than during (or maybe in middleware unwind).",
        "createdAt": "2022-09-28T22:30:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/39310#issuecomment-1261528254"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85D1R1Y",
    "title": "Output-caching can return stale results",
    "url": "https://github.com/dotnet/aspnetcore/issues/40225",
    "createdAt": "2022-02-15T01:00:34Z",
    "lastUpdated": "2024-01-05T00:53:43Z",
    "body": "When the server returns an error, or a lock is acquired on this resource, the cache can return a stale entry depending on a timeout (grace period).\r\nWhen an entry is stale and refreshed, if \u0022If-Modified-Since\u0022 or \u0022If-None-Match\u0022 are set, and the content is identical a 304 will be returned and the cached entry refreshed.\r\n",
    "upvotes": 0,
    "labels": [
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85v73rU",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2024-01-05T00:53:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40225#issuecomment-1877965524"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85D1R3D",
    "title": "Output-caching has multiple data storage options",
    "url": "https://github.com/dotnet/aspnetcore/issues/40229",
    "createdAt": "2022-02-15T01:00:44Z",
    "lastUpdated": "2024-01-05T00:51:53Z",
    "body": "Cache entries should be stored in configurable locations.\r\nIn-memory, filesystem, and hybrid stores (metadata in memory and content on disk) are planned.\r\nSome stores are able to handle size limits.\r\n\r\nThe storage for cached entries can be extended by developers by implementing a service and registering it in DI. \r\nPotential implementations: Redis, database, CosmosDB, table/blob storage, sqlite",
    "upvotes": 8,
    "labels": [
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85FplBE",
        "parentId": null,
        "author": "Manish082007",
        "content": "As a developer, I desperately want the Output Caching storage options feature in Asp.Net Core 7. ",
        "createdAt": "2022-06-28T10:16:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40229#issuecomment-1168527428"
      },
      {
        "id": "IC_kwDOAQzde85Fznbz",
        "parentId": null,
        "author": "nixtar",
        "content": "\u003E As a developer, I desperately want the Output Caching storage options feature in Asp.Net Core 7.\r\n\r\nAgreed.\r\nI was really looking forward to finally replacing iis\u002BARR plugin with yarp \u002B output caching with disk backed storage across ~1500 remote sites.\r\n\r\nHopefully the storage is at least extendable in 7.\r\nIf so, perhaps an official nuget package for the \u0022built in\u0022 storage options so they can be released and updated on a separate cycle to dotnet itself?\r\n\r\nHowever, even with just memory storage this new output caching is very epic. Great job to everyone involved. \uD83D\uDC4D\uD83D\uDC4D",
        "createdAt": "2022-06-30T12:28:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40229#issuecomment-1171158771"
      },
      {
        "id": "IC_kwDOAQzde85OqXSJ",
        "parentId": null,
        "author": "h3rmanj",
        "content": "I\u0027m hoping it will integrate nicely with the already existing \u0060IDistributedCache\u0060 interface. This is the only thing stopping us from moving to the new .NET 7 Output Cache from a custom output cache implementation.",
        "createdAt": "2022-11-18T09:07:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40229#issuecomment-1319728265"
      },
      {
        "id": "IC_kwDOAQzde85v73De",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2024-01-05T00:49:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40229#issuecomment-1877962974"
      },
      {
        "id": "IC_kwDOAQzde85v73Zy",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "We implemented a Redis output cache store in .NET 8: https://github.com/dotnet/aspnetcore/pull/48450\r\n\r\nI\u0027m going to leave this issue open but change the milestone since .NET 8 has shipped already.",
        "createdAt": "2024-01-05T00:51:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40229#issuecomment-1877964402"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85D1R3e",
    "title": "Output-caching should support response substitution",
    "url": "https://github.com/dotnet/aspnetcore/issues/40230",
    "createdAt": "2022-02-15T01:00:47Z",
    "lastUpdated": "2024-01-05T00:49:22Z",
    "body": "When configured, cached entries can be altered before being stores or served.\r\nThis can allow custom services to implement doughnut caching or AFT substitution.",
    "upvotes": 4,
    "labels": [
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85LvJGE",
        "parentId": null,
        "author": "angel199321",
        "content": "I\u0027m trying Ouput caching with MVC pattern, will doughnut caching work with ViewComponent?",
        "createdAt": "2022-10-06T20:37:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40230#issuecomment-1270649220"
      },
      {
        "id": "IC_kwDOAQzde85v73Cl",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2024-01-05T00:49:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40230#issuecomment-1877962917"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85D1R4F",
    "title": "Output-caching should support byte-range caching",
    "url": "https://github.com/dotnet/aspnetcore/issues/40231",
    "createdAt": "2022-02-15T01:00:50Z",
    "lastUpdated": "2024-01-05T00:48:22Z",
    "body": "Optional behaviors\r\n- 206 responses can are stored directly.\r\n- Once a cached entry is stored, byte\u2011range requests are served directly from the cached entry (useful for edge proxies)\r\n",
    "upvotes": 0,
    "labels": [
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85v725a",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2024-01-05T00:48:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40231#issuecomment-1877962330"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85Ez6XE",
    "title": "Add a middleware to enforce request size limits",
    "url": "https://github.com/dotnet/aspnetcore/issues/40452",
    "createdAt": "2022-02-28T19:20:44Z",
    "lastUpdated": "2024-02-14T20:29:13Z",
    "body": "A couple of limits are enforced by MVC filters. In addition, part of the Request  Decompression middleware - https://github.com/dotnet/aspnetcore/issues/40080 limits specified by \u0060RequestSizeLimitAttribute\u0060 are enforced for compressed requests  if the middleware is present (e.g. \u0060Content-Encoding: gz\u0060), but not for regular requests.\r\n\r\nThe suggestion is to introduce a new middleware that can enforce request size limits. The middleware\u0027s primarily role is to configure existing HTTP features based on the presence of attributes on endpoints. In addition to this, we can have endpoint middleware enforce that the middleware was present if it detects endpoints with size limiting attributes.\r\n\r\n* https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/RequestSizeLimitAttribute.cs\r\n* https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/RequestFormLimitsAttribute.cs",
    "upvotes": 0,
    "labels": [
      "Needs: Design",
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde84-266c",
        "parentId": null,
        "author": "pranavkm",
        "content": "FYI @halter73 / @Tratcher ",
        "createdAt": "2022-02-28T19:21:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40452#issuecomment-1054584476"
      },
      {
        "id": "IC_kwDOAQzde84-28sV",
        "parentId": null,
        "author": "Tratcher",
        "content": "https://github.com/dotnet/aspnetcore/blob/main/src/Mvc/Mvc.Core/src/DisableRequestSizeLimitAttribute.cs",
        "createdAt": "2022-02-28T19:31:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40452#issuecomment-1054591765"
      },
      {
        "id": "IC_kwDOAQzde84-3Nyq",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 7 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-02-28T21:06:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40452#issuecomment-1054661802"
      },
      {
        "id": "IC_kwDOAQzde85KDuDM",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-09T21:19:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40452#issuecomment-1242489036"
      },
      {
        "id": "IC_kwDOAQzde85PWzwa",
        "parentId": null,
        "author": "Tratcher",
        "content": "YARP needs this too: https://github.com/microsoft/reverse-proxy/issues/640",
        "createdAt": "2022-11-29T22:03:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40452#issuecomment-1331379226"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85FkQN6",
    "title": "Design Proposal: Dynamic/Async paths for StatusCodePages and ExceptionHandler middleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/40677",
    "createdAt": "2022-03-12T01:15:15Z",
    "lastUpdated": "2024-08-04T18:52:22Z",
    "body": "## Issue\r\n\r\nAn issue exists requesting a solution to setting the re-execute path for the StatusCodePages and ExceptionHandler middleware.\r\nhttps://github.com/dotnet/aspnetcore/issues/18383\r\n\r\nWhile both middleware allow for a custom handler/pipeline to be used, if the original functionality provided by ASPNET Core is the goal, but a \u0022dynamic\u0022 path is needed, then developers will currently need to copy source from ASPNET Core to re-create the original functionality. If they want the ExceptionHandler middleware to be performant when acquiring a dynamic error path, they also need to re-create \u0060internal\u0060 framework code, chasing a breadcrumb trail (ex: \u0060DiagnosticsLoggerExtensions\u0060 and \u0060Resources.resx\u0060).\r\n\r\nBoth the \u0060UseStatusCodePagesWithReExecute\u0060 and \u0060UseExceptionHandler\u0060 are robust and the most convenient ways to gracefully handle errors in the framework, so copying ASPNET Core source into multiple applications is the route I\u0027ve taken and I\u0027d like to avoid this, while also limiting the impact to the framework to have this \u0027baked in\u0027.\r\n\r\n## Value\r\n\r\nNeeding dynamic path values for these middleware is common in Content Management Systems (or any application with runtime dynamic routes) where URLs are generated/stored in the database and need to be discovered at runtime.\r\n\r\nAnother scenario where dynamic paths would be important is if the re-executed path had culture information in it - a subdomain or a path prefix (ex: \u0060/es-mx/not-found\u0060) cannot be static as it\u0027s dependent on the request/culture.\r\n\r\n## Proposed Solution\r\n\r\nBoth of these middleware are customizable through their options:\r\n\r\n- [UseStatusCodePagesWithReExecute](https://github.com/dotnet/aspnetcore/blob/v6.0.3/src/Middleware/Diagnostics/src/StatusCodePage/StatusCodePagesExtensions.cs#L167) with \u0060pathFormat\u0060\r\n- [UseExceptionHandler](https://github.com/dotnet/aspnetcore/blob/v6.0.3/src/Middleware/Diagnostics/src/ExceptionHandler/ExceptionHandlerExtensions.cs#L89) with \u0060ExceptionHandlerOptions\u0060\r\n\r\nSince providing options through the extensions is the existing pattern, we could add a way to provide a \u0060Func\u003CSomeContext, Task\u003Cstring\u003E\u003E? PathRetriever\u0060.\r\n\r\nThe delegate, if not null, would be executed to acquire the path string. However, we also don\u0027t want to perform the potentially expensive operation of acquiring the path string until it is needed, so this value would need to be passed down to where the static path is used to setup the re-execution of the pipeline to handle the errors.\r\n\r\n### UseStatusCodePagesWithReExecute\r\n\r\n\u0060\u0060\u0060csharp\r\n//// New overload of extension method ////\r\npublic static IApplicationBuilder UseStatusCodePagesWithReExecute(\r\n    this IApplicationBuilder app,\r\n    Func\u003CStatusCodeContext, Task\u003Cstring\u003E\u003E pathRetriever)\r\n{\r\n    if (app == null)\r\n    {\r\n        throw new ArgumentNullException(nameof(app));\r\n    }\r\n\r\n    const string globalRouteBuilderKey = \u0022__GlobalEndpointRouteBuilder\u0022;\r\n    // Only use this path if there\u0027s a global router (in the \u0027WebApplication\u0027 case).\r\n    if (app.Properties.TryGetValue(globalRouteBuilderKey, out var routeBuilder) \u0026\u0026 routeBuilder is not null)\r\n    {\r\n        return app.Use(next =\u003E\r\n        {\r\n            /** Same as existing **/\r\n\r\n            return new StatusCodePagesMiddleware(next,\r\n                //// Pass the new delegate to the CreateHandler method ////\r\n                Options.Create(new StatusCodePagesOptions() { HandleAsync = CreateHandler(null, null, pathRetriever, newNext) })).Invoke;\r\n        });\r\n    }\r\n\r\n    //// Pass the new delegate to the CreateHandler method ////\r\n    return app.UseStatusCodePages(CreateHandler(null, null, pathRetriever));\r\n}\r\n\r\nprivate static Func\u003CStatusCodeContext, Task\u003E CreateHandler(string? pathFormat, string? queryFormat, Func\u003CStatusCodeContext, Task\u003Cstring\u003E\u003E? pathRetriever, RequestDelegate? next = null)\r\n{\r\n    var handler = async (StatusCodeContext context) =\u003E\r\n    {\r\n        //// New logic to retrieve path dynamically ////\r\n        pathFormat = pathRetriever is not null\r\n            ? await pathRetriever(context)\r\n            : pathFormat;\r\n\r\n        // Same as existing\r\n    };\r\n\r\n    return handler;\r\n}\r\n\u0060\u0060\u0060\r\n\r\n### UseExceptionHandler\r\n\r\n\u0060\u0060\u0060csharp\r\npublic class ExceptionHandlerOptions\r\n{\r\n    public PathString ExceptionHandlingPath { get; set; }\r\n\r\n    public RequestDelegate? ExceptionHandler { get; set; }\r\n\r\n    public bool AllowStatusCode404Response { get; set; }\r\n\r\n    //// New optional property ////\r\n    public Func\u003CHttpContext, Task\u003Cstring\u003E\u003E? PathRetriever { get; set; }\r\n}\r\n\r\npublic class ExceptionHandlerMiddleware\r\n{\r\n   /** Same as existing **/\r\n\r\n    private async Task HandleException(HttpContext context, ExceptionDispatchInfo edi)\r\n    {\r\n        _logger.UnhandledException(edi.SourceException);\r\n        // We can\u0027t do anything if the response has already started, just abort.\r\n        if (context.Response.HasStarted)\r\n        {\r\n            _logger.ResponseStartedErrorHandler();\r\n            edi.Throw();\r\n        }\r\n\r\n        PathString originalPath = context.Request.Path;\r\n   \r\n        //// New logic to retrieve path dynamically ////\r\n        if (_options.PathRetriever is not null)\r\n        {\r\n            context.Request.Path = await _options.PathRetriever(context);\r\n        }\r\n        else if (_options.ExceptionHandlingPath.HasValue)\r\n        {\r\n            context.Request.Path = _options.ExceptionHandlingPath;\r\n        }\r\n        \r\n        /** Same as existing **/\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThese additions would enable developers to specify the re-execute path dynamically, using the context of the error, incurring the cost of the \u0060async\u0060 delegate only when the errors occur.\r\n\r\nI\u0027d be happy to follow up this proposal with a PR if it seems there is enough value to these changes. If not, I\u0027ll continue copying source code and manually keeping it up to date as I upgrade TFMs in multiple projects over time.\r\n\r\nThanks!",
    "upvotes": 5,
    "labels": [
      "area-networking",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde84_hr4b",
        "parentId": null,
        "author": "KenticoDevTrev",
        "content": "This would awesome!",
        "createdAt": "2022-03-12T02:40:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40677#issuecomment-1065795099"
      },
      {
        "id": "IC_kwDOAQzde85ACZhz",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-03-21T20:13:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40677#issuecomment-1074370675"
      },
      {
        "id": "IC_kwDOAQzde85ACu5W",
        "parentId": null,
        "author": "seangwright",
        "content": "@adityamandaleeka I understand if the aspnet core team can\u0027t prioritize this change at the moment, but would a PR still be reviewed if I contributed something?\r\n\r\nI opened this design proposal to find out if this kind of feature enhancement was something that aligned with the goals of the framework.\r\n\r\nThanks!",
        "createdAt": "2022-03-21T21:53:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40677#issuecomment-1074458198"
      },
      {
        "id": "IC_kwDOAQzde85ACwVY",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@seangwright Yes, we\u0027d be open to reviewing a PR for this! \r\n\r\nI guess the bot\u0027s comment is a bit misleading in this case \uD83D\uDE04 . The intent behind putting it in \u0022Backlog\u0022 was for us to know it\u0027s not critical to do in 7, but since it\u0027s \u0022help wanted\u0022, you could send us a PR and we can give you feedback on it.",
        "createdAt": "2022-03-21T22:02:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40677#issuecomment-1074464088"
      },
      {
        "id": "IC_kwDOAQzde85ADA75",
        "parentId": null,
        "author": "seangwright",
        "content": "I read [Before writing code](https://github.com/dotnet/aspnetcore/blob/main/CONTRIBUTING.md#before-writing-code) in the Contributing doc. I want to know that this idea has legs and is worth exploring \uD83D\uDE01.\r\n\r\nI\u0027ll open a PR once I have a minute to author something.\r\n\r\nQuestion: I didn\u0027t cover the [UseStatusCodePagesWithRedirects](https://github.com/dotnet/aspnetcore/blob/v6.0.3/src/Middleware/Diagnostics/src/StatusCodePage/StatusCodePagesExtensions.cs#L111) extension in the design proposal. Would that need to be included in the PR?",
        "createdAt": "2022-03-21T23:48:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40677#issuecomment-1074532089"
      },
      {
        "id": "IC_kwDOAQzde85ADkgr",
        "parentId": null,
        "author": "Tratcher",
        "content": "A few more thoughts about the design first:\r\nInstead of \u0060Func\u003CHttpContext, Task\u003Cstring\u003E\u003E\u0060 returning the new path, how about \u0060Func\u003CHttpContext, Task\u003E\u0060 where you are responsible for updating the HttpContext directly? I\u0027d also consider something like \u0060Func\u003CHttpContext, Task\u003Cbool\u003E\u003E\u0060 where the return value could indicate if you even want to re-execute the request, or if you were able to handle the error inline.\r\n\r\nCan you try those variants and see how they work?",
        "createdAt": "2022-03-22T03:07:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40677#issuecomment-1074677803"
      },
      {
        "id": "IC_kwDOAQzde85P8zGL",
        "parentId": null,
        "author": "MadL1me",
        "content": "@seangwright what about this issue? Did you opened PR for it, or abandoned the Idea? If so, why?",
        "createdAt": "2022-12-07T17:44:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40677#issuecomment-1341337995"
      },
      {
        "id": "IC_kwDOAQzde85P9xGy",
        "parentId": null,
        "author": "seangwright",
        "content": "@MadL1me I haven\u0027t abandoned the idea. We are using a customized version of the status code pages/exception handler middleware for our applications that lets us handle this stuff dynamically (backed by a content management system) and it works great.\r\n\r\nI just never got around to designing the architecture that would be appropriate for a generalized solution in aspnet core, so there\u0027s no PR.\r\n\r\nI would like to come back to this - maybe over the holidays when I have some free time.",
        "createdAt": "2022-12-07T21:02:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40677#issuecomment-1341591986"
      },
      {
        "id": "IC_kwDOAQzde85P_XZa",
        "parentId": null,
        "author": "MadL1me",
        "content": "@seangwright would you mind, if I also try to implement this? Wanna get some practice in big open source project, and this feature looks interesting enough for me",
        "createdAt": "2022-12-08T04:43:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40677#issuecomment-1342010970"
      },
      {
        "id": "IC_kwDOAQzde85QCTcm",
        "parentId": null,
        "author": "seangwright",
        "content": "@MadL1me Go for it! Ping me on a PR when you create one.",
        "createdAt": "2022-12-08T14:00:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40677#issuecomment-1342781222"
      },
      {
        "id": "IC_kwDOAQzde86HDSPV",
        "parentId": null,
        "author": "FireflyInTheDusk",
        "content": "\u002B1 for this, the only way to get localized error pages right now is, as OP said, to pull .net code into your app and customize it.\r\n\r\nA simple\r\n\r\n\u0060\u0060\u0060\r\napp.UseStatusCodePagesWithReExecute(context =\u003E {\r\n   var locale = FigureOutLocale(context.Request);\r\n   return $\u0022/{locale}/error{context.Response.StatusCode}\u0022;\r\n});\r\n\u0060\u0060\u0060\r\n\r\nwould go a long way towards making this a more flexible feature.",
        "createdAt": "2024-08-02T16:49:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40677#issuecomment-2265785301"
      },
      {
        "id": "IC_kwDOAQzde86HKTg8",
        "parentId": null,
        "author": "FireflyInTheDusk",
        "content": "P.S. I\u0027d try to give implementing this a shot but it looks to me like there\u0027s still a discussion going on about what the design should look like.\r\n\r\nI posted some code above so that\u0027s the functionality that I\u0027d like to see from the middleware, but anything that solves the problem would be great.\r\n\r\nHowever I\u0027m not sure the \u0060Func\u003CHttpContext, Task\u003E\u0060 or \u0022here\u0027s the context, set props (that will presumably be explained in the docs?) on it\u0022 idea is an intuitive improvement here, a function that takes a context and sets values on it is more like a middleware itself so we end up writing a middleware inside another middleware when all that\u0027s wanted is to support more than just inserting the status code at a specific point in the string . i.e. the real issue for e.g. localization use cases, is that the current formatting rules are too restrictive.\r\n\r\nBut I like the idea of returning true or false to indicate if the rewrite should happen or not. Maybe useful if different middlewares handle different status codes. Though I\u0027d probably prefer that to be an overload available for that specific use case rather than something every user has to go through.",
        "createdAt": "2024-08-04T18:12:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40677#issuecomment-2267625532"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85GXyfU",
    "title": "Add support for Private Network Access (CORS header Access-Control-Allow-Private-Network)",
    "url": "https://github.com/dotnet/aspnetcore/issues/40869",
    "createdAt": "2022-03-25T10:55:51Z",
    "lastUpdated": "2024-03-05T22:43:11Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nI am trying to reach my ASP.NET core api running on https://localhost:5001/ from a SPA which is hosted on another domain (although same computer for me) and I get a CORS error.\n\n### Describe the solution you\u0027d like\n\nI would like to propose that we extend the \u0060CorsPolicy\u0060 with the boolean property \u0060AllowPrivateNetworkAccess\u0060 and \u0060CorsPolicyBuilder\u0060 with the method \u0060WithPrivateNetworkAccess\u0060 which the \u0060CorsService\u0060  uses to set the \u0060Access-Control-Allow-Private-Network: true\u0060 on preflight requests if the browser sends the \u0060Access-Control-Request-Private-Network: true\u0060 header in the request.\n\n### Additional context\n\nLink to WICG Draft: https://wicg.github.io/private-network-access/\r\nLink to Chrome developer article about the feature and roll out: https://developer.chrome.com/blog/private-network-access-preflight/",
    "upvotes": 2,
    "labels": [
      "feature-cors",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85ATsJP",
        "parentId": null,
        "author": "Andreas-Hjortland",
        "content": "For people who are having issues with the private network access cors header, you can add the following code snippet just before \u0060app.UseCors()\u0060 in your ASP.NET application to work around the issue until we get proper support through the \u0060CorsPolicyBuilder\u0060 interface:\r\n\r\n\u0060\u0060\u0060c#\r\n// Enable PNA preflight requests\r\napp.Use(async (ctx, next) =\u003E\r\n{\r\n    if (ctx.Request.Method.Equals(\u0022options\u0022, StringComparison.InvariantCultureIgnoreCase) \u0026\u0026 ctx.Request.Headers.ContainsKey(\u0022Access-Control-Request-Private-Network\u0022))\r\n    {\r\n        ctx.Response.Headers.Add(\u0022Access-Control-Allow-Private-Network\u0022, \u0022true\u0022);\r\n    }\r\n\r\n    await next();\r\n});\r\napp.UseCors();\r\n\u0060\u0060\u0060",
        "createdAt": "2022-03-25T10:57:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40869#issuecomment-1078903375"
      },
      {
        "id": "IC_kwDOAQzde85ATsjS",
        "parentId": null,
        "author": "Andreas-Hjortland",
        "content": "I am willing to try to implement this feature if you decide that you want to add it =)",
        "createdAt": "2022-03-25T11:00:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40869#issuecomment-1078905042"
      },
      {
        "id": "IC_kwDOAQzde85AUfm_",
        "parentId": null,
        "author": "blowdart",
        "content": "We tend not to add support for unoffical drafts as they are in flux, and can change at any time, and if they do so after we release we\u0027re in a bad position, having to support back compatibility as well as the updated standard.",
        "createdAt": "2022-03-25T14:59:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40869#issuecomment-1079114175"
      },
      {
        "id": "IC_kwDOAQzde85AguIJ",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-03-29T20:01:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40869#issuecomment-1082319369"
      },
      {
        "id": "IC_kwDOAQzde85ERcfY",
        "parentId": null,
        "author": "michaelakin",
        "content": "Thanks for the code @Andreas-Hjortland   That solved our issue, but it would be nice to see this a regular add on to the CORS configuration.",
        "createdAt": "2022-06-02T23:05:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40869#issuecomment-1145423832"
      },
      {
        "id": "IC_kwDOAQzde85M_23S",
        "parentId": null,
        "author": "jetersen",
        "content": "@blowdart This is now live in Chrome 104 and above \uD83D\uDE05",
        "createdAt": "2022-10-26T10:13:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40869#issuecomment-1291808210"
      },
      {
        "id": "IC_kwDOAQzde85NAKAl",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-10-26T11:26:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/40869#issuecomment-1291886629"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85Lk03f",
    "title": "Add path based exclusions to HSTS and Rewriter middleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/42132",
    "createdAt": "2022-06-10T19:55:34Z",
    "lastUpdated": "2023-08-28T23:09:51Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nDue to a long and woeful story I ended up having to recreate one of my websites in a new azure subscription.\r\n\r\nAs you may know Azure offers managed service certificates for free, much like Let\u0027s Encrypt, but from another provider.\r\n\r\nThe issuance checks failed due to HSTS - the agent the provider uses obeyed the HSTS directive, along with following the HTTPS redirect, which lead it to an invalid SSL certificate because it\u0027s the default one issued for the azurewebsites domain.\r\n\r\nThis puts you in an awkward position, you can\u0027t get a correct certificate, because the current one is invalid and you\u0027re stuck in a circle until you turn HSTS off.\n\n### Describe the solution you\u0027d like\n\nAdd the ability to exclude certain file paths from having the HSTS header added by app.UseHsts() and from the HTTP to HTTPS redirection middleware in app.UseRewriter(). Rewriter already has domain inclusion, so it\u0027d be an expansion of that.\r\n\r\nBy default you could consider having the following two paths in the exclusion list to allow for cert requests to proceed if the existing HTTPS certificate is invalid.\r\n\r\n\u0060/.well-known/pki-validation/\u0060 for azure\u0027s managed certificates\r\n\u0060/.well-known/acme-challenge/\u0060 for let\u0027s encrypt\r\n\r\n\n\n### Additional context\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85EtOgu",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Triage: Maybe we could do this but not have a list of defaults (just allow people to set what they want and provide some guidance for common use cases). We don\u0027t want to maintain a known set of defaults for this.",
        "createdAt": "2022-06-10T20:17:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42132#issuecomment-1152706606"
      },
      {
        "id": "IC_kwDOAQzde85EtOj3",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-06-10T20:18:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42132#issuecomment-1152706807"
      },
      {
        "id": "IC_kwDOAQzde85E84qO",
        "parentId": null,
        "author": "Tratcher",
        "content": "Note UseRewriter is not the default middleware used for HTTPS redirects, it\u0027s UseHttpsRedirection.\r\n\r\nWe\u0027ve discouraged re-inventing routing for matching/exclusions in each middleware. Here are some alternatives:\r\n- Make these middleware \u0022endpoint-aware\u0022 where routing happens first, then middleware reads metadata on the matched endpoint to decide if it should act or not. This can take the form of attributes like \u0060[SkipHsts]\u0060.\r\n- Add custom middleware ahead of UseHsts and UseHttpsRedirection to handle these special routes that need to be excluded.\r\n\u0060\u0060\u0060\r\napp.Use((context, next) =\u003E\r\n{\r\n  if (context.Request.Path.Equals(\u0022/.well-known/pki-validation/\u0022))\r\n  {\r\n    // TODO: Handle this request\r\n    return Task.CompletedTask;\r\n  }\r\n  return next(context);\r\n});\r\napp.UseHsts();\r\napp.UseHttpsRedirection();\r\n\u0060\u0060\u0060\r\n",
        "createdAt": "2022-06-15T18:48:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42132#issuecomment-1156811406"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85MNeM4",
    "title": "Use Inheritance instead of Composition to Reduce allocation in Request Decompression Middleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/42324",
    "createdAt": "2022-06-21T15:13:13Z",
    "lastUpdated": "2023-08-25T00:08:24Z",
    "body": "I\u0027ve opened this issue to discuss the idea that I\u0027ve mentioned in [here](https://github.com/dotnet/aspnetcore/pull/40279#discussion_r810507794) and [here](https://github.com/dotnet/aspnetcore/pull/40279#discussion_r816191725) now that Request Decompression Middleware is merged.\r\n\r\nAt the moment \u0060IDecompressionProvider\u0060 is creating a decompression stream and the middleware creates a \u0060SizeLimitedStream\u0060 which wraps the other one. We could reduce this two streams into one if the \u0060IDecompressionProvider\u0060 returns a stream that also handle size limit check, and the middleware only create \u0060SizeLimitedStream\u0060 if the returned stream from the \u0060IDecompressionProvider\u0060 is not marked with \u0060IDontNeedWrapper\u0060 interface.\r\n\r\n\u0060\u0060\u0060diff\r\n\u002Binternal interface IDontNeedWrapper {}\r\n\u002Binternal sealed class GZipRequestDecompressionBody : GZipStream, IDontNeedWrapper {}\r\n\u002Binternal sealed class DeflateRequestDecompressionBody : DeflateStream , IDontNeedWrapper {}\r\n\u002Binternal sealed class BrotliRequestDecompressionBody : BrotliStream, IDontNeedWrapper {}\r\n\u0060\u0060\u0060\r\nThe new types for this change are all private, so there\u0027s no new public types. By doing this we would reduce one allocation per requests when request body is compressed by \u0060GZip\u0060, \u0060Deflate\u0060 or \u0060Brotli\u0060. \r\n\r\n",
    "upvotes": 0,
    "labels": [
      "investigate",
      "Perf",
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85FXASF",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Triage: we\u0027d need to see perf numbers to decide whether the impact of this is worth the complexity. A small improvement in this decompression scenario may not be worth it...",
        "createdAt": "2022-06-22T22:08:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42324#issuecomment-1163658373"
      },
      {
        "id": "IC_kwDOAQzde85FXAXQ",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-06-22T22:09:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42324#issuecomment-1163658704"
      },
      {
        "id": "IC_kwDOAQzde85F5CSh",
        "parentId": null,
        "author": "david-acker",
        "content": "I made these changes locally and there only seems to be an allocation-related improvement for compressed requests when \u0060IRequestSizeLimitMetadata\u0060 exists (reduced from 3 KB to 2 KB). Apart from that, it doesn\u0027t look like much else changed, although I\u0027m not too familiar with interpreting these benchmarks.\r\n\r\n[Benchmark Results](https://gist.github.com/david-acker/b919b84290d9cc3b1df03711305e10eb)\r\n\r\nI also noticed a few complications when implementing and testing this:\r\n\r\n1. The \u0060BrotliStream\u0060 class is sealed, so we\u0027ll only be able to create new types for Deflate and GZip.\r\n2. The \u0060CopyTo\u0060 and \u0060CopyToAsync\u0060 methods on the \u0060GZipStream\u0060 pass their operations to [a \u0060DeflateStream\u0060 that\u0027s used internally](https://github.com/dotnet/runtime/blob/abc028d6018c17ece952de59feedcc489d2e95b2/src/libraries/System.IO.Compression/src/System/IO/Compression/GZipStream.cs#L237) which circumvented the size limit check I added and caused some test failures. I not sure if this was to be expected, but it doesn\u0027t seem like adding the size limit check will be as straight forward as overriding the \u0060Read\u0060 and \u0060ReadAsync\u0060 methods like it was for the original \u0060SizeLimitedStream\u0060. ",
        "createdAt": "2022-07-01T17:48:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42324#issuecomment-1172579489"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85Nn_0I",
    "title": "Support Multiple PartitionedRateLimiter Per Endpoint",
    "url": "https://github.com/dotnet/aspnetcore/issues/42691",
    "createdAt": "2022-07-12T16:28:08Z",
    "lastUpdated": "2025-01-05T04:41:48Z",
    "body": "### Is there an existing issue for this?\n\n- [x] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nRight now RateLimiting middleware has two \u0060PartitionedRateLimiter\u0060. A **global** and an **endpoint** limiter. This means for each endpoint there could be at most two level of rate limiters and also the global one is somehow limited because it must be same for all endpoints.\r\nSo I can not limit my endpoints based on more than two partitions. As an example I need to limit first based on request IP, then current user Id and then based on the current endpoint.\r\nLet\u0027s say I need to limit 10 requests per second per IP, no matter which endpoint. And also limit 5 requests per second per User Id.\r\n\r\nAlso I can\u0027t have different window and limit based on one partition. Again let\u0027s say I need to limit 10 requests per second per IP and also limit 40 requests per minute per IP.\n\n### Describe the solution you\u0027d like\n\nI\u0027m suggesting to create \u0060PartitionedRateLimiter\u003CHttpContext\u003E\u0060 based on policy and have a \u0060Dictionary\u003Cstring, PartitionedRateLimiter\u003CHttpContext\u003E\u0060 which policy is the key. The endpoints could have multiple \u0060IRequireRateLimitMetadata\u0060 and every one of them is a policy with its own \u0060PartitionedRateLimiter\u0060. And the middleware would always call Acquire on each of these limiters whether \u0060IsAcquired\u0060 is true or false and only limit the request if one of them has IsAcquired = false. \r\n\r\nThis way part of the limiter like checking based on User Id could be shared between multiple endpoints too.\n\n### Additional context\n\ncc @wtgodbe @BrennanConroy @halter",
    "upvotes": 19,
    "labels": [
      "feature-rate-limit",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85GdAQZ",
        "parentId": null,
        "author": "wtgodbe",
        "content": "This should be achievable through the [CreateChained](https://github.com/dotnet/runtime/blob/79874806d246670ee5fe76e73ce566578fe675c0/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/PartitionedRateLimiter.cs#L52-L64) API in runtime - it allows you to pass in multiple \u0060PartitionedRateLimiter\u0060s which it will combine into 1 \u0060PartitionedRateLimiter\u0060 that runs all of your input limiters in sequence. Then you could apply that single chained limiter to the endpoint.",
        "createdAt": "2022-07-12T16:51:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1182008345"
      },
      {
        "id": "IC_kwDOAQzde85GeTWS",
        "parentId": null,
        "author": "wtgodbe",
        "content": "Going to close this as I believe it\u0027s covered by the above comment - feel free to re-open if there\u0027s additional functionality in this request that I\u0027m missing.",
        "createdAt": "2022-07-12T19:26:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1182348690"
      },
      {
        "id": "IC_kwDOAQzde85GfiU_",
        "parentId": null,
        "author": "Kahbazi",
        "content": "@wtgodbe I believe the issue should be re-opened. It seems \u0060ChainedPartitionedRateLimiter\u0060 is the answer on how to implement my requirements (with a small change that I need to call \u0060Acquire\u0060 on every limiter whether IsAcquired is true or false), but I don\u0027t see any way to achieve that using the current implementation of the middleware. Is there any sample on how to do that? And also I can\u0027t use the global limiter because I would need different \u0060ChainedPartitionedRateLimiter\u0060 per endpoint.",
        "createdAt": "2022-07-13T01:56:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1182672191"
      },
      {
        "id": "IC_kwDOAQzde85GiblV",
        "parentId": null,
        "author": "wtgodbe",
        "content": "I see, I think you\u0027re right that we don\u0027t currently support that (endpoint policies are RateLimitPartition based, not PartitionedRateLimiter based). We\u0027ll consider this for future passes",
        "createdAt": "2022-07-13T16:26:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1183430997"
      },
      {
        "id": "IC_kwDOAQzde85Gjj0J",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Triage: we\u0027re open to this but we\u0027d like to see more use cases for this sort of pattern.",
        "createdAt": "2022-07-13T22:06:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1183726857"
      },
      {
        "id": "IC_kwDOAQzde85GjkAg",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-07-13T22:07:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1183727648"
      },
      {
        "id": "IC_kwDOAQzde85N3TWP",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "We have another request for this: https://github.com/dotnet/aspnetcore/issues/44907",
        "createdAt": "2022-11-07T23:05:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1306342799"
      },
      {
        "id": "IC_kwDOAQzde85OqqFs",
        "parentId": null,
        "author": "BondarencoM",
        "content": "I also want to rate limit an endpoint with one partition but multiple time spans (e.g. allow 3 requests per second but only 100 per hour). As far as I can tell this is currently not possible but feels like a very basic use case.",
        "createdAt": "2022-11-18T10:19:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1319805292"
      },
      {
        "id": "IC_kwDOAQzde85Tzv_0",
        "parentId": null,
        "author": "stefannikolei",
        "content": "\u002B100 for @BondarencoM. \r\n\r\nATM it seems not possible to create a policy, which calls PartitionedRateLimiter.CreateChained().\r\n\r\nI also have the usecase to create a policy for an endpoint which eg. allows 1 Request per Minute and 10 Requests per Hour. Atm this does not seem to be easy achievable.",
        "createdAt": "2023-01-27T06:24:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1406074868"
      },
      {
        "id": "IC_kwDOAQzde85T86qg",
        "parentId": null,
        "author": "juasanpar",
        "content": "Greetings,\r\n\r\nI have a very similar requirement of adding a RateLimiting policy of limiting the requests to 50 per minute and also not allowing more that 10 concurrent. At the moment this is only achievable using PartitionedRateLimiter.CreateChained() as you have already mentioned, but only for the global limiter. I have an API with several endpoints that need different limiting policies, so this is not the best option for me. Is there any progress on this request or is there any other way to achieve my purpose?\r\n\r\nThanks for your work and help!",
        "createdAt": "2023-01-30T11:45:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1408477856"
      },
      {
        "id": "IC_kwDOAQzde85UAyJ6",
        "parentId": null,
        "author": "wtgodbe",
        "content": "I agree we should do this for 8. Right now, you apply \u0060RateLimitPartition\u0060s to endpoints, not \u0060PartitionedRateLimiter\u0060s - the latter would be necessary to solve the problem. I think we could solve it by doing an internal \u0060CreateChained\u0060 for \u0060PartitionedRateLimiter\u0060s added to endpoints",
        "createdAt": "2023-01-30T23:03:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1409491578"
      },
      {
        "id": "IC_kwDOAQzde85UB1kI",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-01-31T05:09:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1409767688"
      },
      {
        "id": "IC_kwDOAQzde85ayuRS",
        "parentId": null,
        "author": "MrChriZ",
        "content": "I\u0027ve just come at this from exactly the same direction as @BondarencoM.  ",
        "createdAt": "2023-04-26T11:16:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1523246162"
      },
      {
        "id": "IC_kwDOAQzde85e_1ry",
        "parentId": null,
        "author": "LinqToException",
        "content": "I\u0027ve spent the last hour frustrated looking for a solution for this problem as well.\r\n\r\nIn my case, I have an endpoint that invokes another, 3rd party service, which has its own rate limiting. As such, I would have liked to create a policy on that single endpoint that\r\n\r\n- limits concurrent requests across all users to 5 (as specified by the 3rd party service),\r\n- limits requests by individual users using a token bucket or similar to allow burst-usage and\r\n- limits requests by individual users using a fixed window to a fixed amount per day",
        "createdAt": "2023-06-15T22:16:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1593793266"
      },
      {
        "id": "IC_kwDOAQzde85mplVc",
        "parentId": null,
        "author": "stukalin",
        "content": "I\u0027d like to \u002B1 on this one. We\u0027d like to migrate away from the https://github.com/stefanprodan/AspNetCoreRateLimit project and some of our policies will be expressed by a chain of fixed window validators but they should be a custom \u0060IRateLimiterPolicy\u0060 and apparenlty it\u0027s not possible to specify a chain as a non-global rate limiter.",
        "createdAt": "2023-09-16T08:32:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1722176860"
      },
      {
        "id": "IC_kwDOAQzde85qfvzW",
        "parentId": null,
        "author": "sizzle168",
        "content": "We face the same challenge that @stukalin describes. ",
        "createdAt": "2023-10-31T08:10:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1786707158"
      },
      {
        "id": "IC_kwDOAQzde85q6AoK",
        "parentId": null,
        "author": "GiampaoloGabba",
        "content": "\u002B1 for this. i tried to apply multiple policy to an endpoint but only the last one applied work.\r\nImho this is a very basic feature for a rate limiter, i see that didnt make it for .net8, i hope you consider it for future releases.\r\nI really wanted to use the rate limiting feature bundled with aspnetcore but is not flexible enough for my usecase.",
        "createdAt": "2023-11-05T00:28:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1793591818"
      },
      {
        "id": "IC_kwDOAQzde85uo4QU",
        "parentId": null,
        "author": "CreepMania",
        "content": "\u002B1\r\n\r\nWe tried to implement a token bucket policy on top of fixed window policy but hit a wall.",
        "createdAt": "2023-12-14T16:58:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1856209940"
      },
      {
        "id": "IC_kwDOAQzde85vUCmr",
        "parentId": null,
        "author": "odin568",
        "content": "Unfortunately did not make it in .NET 8 :(",
        "createdAt": "2023-12-22T10:37:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1867524523"
      },
      {
        "id": "IC_kwDOAQzde852bIo7",
        "parentId": null,
        "author": "MikeNolan678",
        "content": "\u002B1\r\n\r\nHas anyone been able to find a solution to this, which doesn\u0027t involve using the AspNetCoreRateLimit NuGet package? ",
        "createdAt": "2024-03-09T10:58:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-1986824763"
      },
      {
        "id": "IC_kwDOAQzde854oLPp",
        "parentId": null,
        "author": "atomaras",
        "content": "Personally planning on building my own and following this guide https://developer.redis.com/develop/dotnet/aspnetcore/rate-limiting/middleware which has the added benefit (aside from the ability to do distributed rate limiting) of sending all rate limit rules that apply to a single endpoint over to Redis in a single request.",
        "createdAt": "2024-03-27T19:24:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-2023797737"
      },
      {
        "id": "IC_kwDOAQzde854oU9t",
        "parentId": null,
        "author": "MikeNolan678",
        "content": "\u003E Personally planning on building my own and following this guide https://developer.redis.com/develop/dotnet/aspnetcore/rate-limiting/middleware which has the added benefit (aside from the ability to do distributed rate limiting) of sending all rate limit rules that apply to a single endpoint over to Redis in a single request.\n\nNice! Thanks for sharing. I ended up using the ASPNetCoreRateLimit package in the end. ",
        "createdAt": "2024-03-27T19:46:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-2023837549"
      },
      {
        "id": "IC_kwDOAQzde854p0uN",
        "parentId": null,
        "author": "atomaras",
        "content": "Spent a day so you don\u0027t have to. Here\u0027s the Redis Lua script (co-written by ChatGPT ofc) that implements the Sliding Window Rate Limit algo with support for multiple rules per invocation AND support for returning the remaining_tokens so you can power the X-Rate-Limit-Remaining header in your web api\r\nhttps://gist.github.com/atomaras/925a13f07c24df7f15dcc4fb7bc89c81",
        "createdAt": "2024-03-28T01:15:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-2024229773"
      },
      {
        "id": "IC_kwDOAQzde86XmsVg",
        "parentId": null,
        "author": "Kahbazi",
        "content": "@mkArtakMSFT Any plans to address this issue for .Net 10?",
        "createdAt": "2024-12-15T06:55:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-2543502688"
      },
      {
        "id": "IC_kwDOAQzde86Y9f8u",
        "parentId": null,
        "author": "code-jar",
        "content": "Any progress?",
        "createdAt": "2024-12-31T08:58:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-2566258478"
      },
      {
        "id": "IC_kwDOAQzde86ZRfcv",
        "parentId": null,
        "author": "Eli-Chandler",
        "content": "\u002B1",
        "createdAt": "2025-01-05T04:41:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42691#issuecomment-2571499311"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85No8Uh",
    "title": "Profile and performance test Diagnostics middleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/42700",
    "createdAt": "2022-07-12T20:20:05Z",
    "lastUpdated": "2023-06-21T00:12:02Z",
    "body": "During the #42384 I noticed that the Diagnostics middleware, mainly \u0060StatusCodePages\u0060 middleware, allocated much more than expected\r\n\r\n| application                             | statuscodepages | nostatuscodepages\u002Bcontent |            |\r\n| --------------------------------------- | --------------- | ------------------------- | ---------- |\r\n| Max Working Set (MB)                    |             179 |                       186 |     \u002B3.74% |\r\n| Max GC Heap Size (MB)                   |              90 |                        94 |     \u002B4.21% |\r\n| Size of committed memory by the GC (MB) |             117 |                       119 |     \u002B1.28% |\r\n| Max Number of Gen 0 GCs / sec           |           41.00 |                     25.00 |    -39.02% |\r\n| Max Number of Gen 1 GCs / sec           |            1.00 |                     13.00 | \u002B1,200.00% |\r\n| Max Number of Gen 2 GCs / sec           |            0.00 |                      1.00 |        \u002B\u221E% |\r\n| Max Time in GC (%)                      |            2.00 |                      1.00 |    -50.00% |\r\n| Max Gen 0 Size (B)                      |       3,152,512 |                 5,146,600 |    \u002B63.25% |\r\n| Max Gen 1 Size (B)                      |       9,309,256 |                 5,376,536 |    -42.25% |\r\n| Max Gen 2 Size (B)                      |       1,970,808 |                 6,406,424 |   \u002B225.07% |\r\n| Max LOH Size (B)                        |         411,320 |                   411,320 |      0.00% |\r\n| Max POH Size (B)                        |       3,472,456 |                 3,451,856 |     -0.59% |\r\n| Total Allocated Bytes                   |  96,805,446,920 |            57,737,869,840 |    -40.36% |\r\n| Max GC Heap Fragmentation               |              30 |                        41 |    \u002B36.47% |\r\n\r\n| load                   | statuscodepages | nostatuscodepages\u002Bcontent |         |\r\n| ---------------------- | --------------- | ------------------------- | ------- |\r\n| Requests/sec           |       1,354,620 |                 1,429,729 |  \u002B5.54% |\r\n| Requests               |      20,454,730 |                21,588,730 |  \u002B5.54% |\r\n\r\n**nostatuscodepages\u002Bcontent** =\u003E \u0060endpoints.MapGet(\u0022sample\u0022, () =\u003E Results.Content(new string(\u0027 \u0027, 500), statusCode: 415));\u0060\r\n\r\n\u0060new string(\u0027 \u0027, 500)\u0060 is similar to what the \u0060StatusCodePages\u0060 does.\r\n\r\nSince this middleware, and other Diagnostics middleware, will become more relevant after the introducing of \u0060ProblemDetails\u0060 Services, we should do some profiling and optimizing of these middleware, including scenarios that produce a \u0060ProblemDetails\u0060 payload.",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85WGO9N",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-02-24T20:57:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42700#issuecomment-1444474701"
      },
      {
        "id": "IC_kwDOAQzde85WGPDC",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-02-24T20:58:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/42700#issuecomment-1444475074"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85POOi3",
    "title": "Add more info to HttpLoggingMiddleware when response hasn\u0027t started, or request/response body are empty",
    "url": "https://github.com/dotnet/aspnetcore/issues/43101",
    "createdAt": "2022-08-04T20:13:24Z",
    "lastUpdated": "2024-03-02T01:07:05Z",
    "body": "The second case is, for example, here (should add an \u0060else\u0060): https://github.com/dotnet/aspnetcore/blob/80ea57377a90fa2750f46662be3642b59ad0feed/src/Middleware/HttpLogging/src/HttpLoggingMiddleware.cs#L186-L189",
    "upvotes": 1,
    "labels": [
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde85PwbmK",
    "title": "Response Caching should have a way of clearing a specific resource from the cache",
    "url": "https://github.com/dotnet/aspnetcore/issues/43272",
    "createdAt": "2022-08-14T00:40:15Z",
    "lastUpdated": "2024-07-26T12:44:25Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nI am trying to clear a resource from the response cache because I have a new updated version.\n\n### Describe the solution you\u0027d like\n\nTo be able to clear a resource from the cache (or, in the worst case, clear the whole thing)\n\n### Additional context\n\n_No response_",
    "upvotes": 2,
    "labels": [
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85IoYUQ",
        "parentId": null,
        "author": "sebastienros",
        "content": "Output Caching is a new feature in .NET 7 starting from preview 6 that handles this scenario. Can it be something that would work for you. It\u0027s driven by configuration and not by headers.\r\n\r\nThere is an intermediate package on NuGet that works with dotnet 6 if you can try it:\r\nhttps://www.nuget.org/packages/Preview.OutputCaching",
        "createdAt": "2022-08-17T22:16:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1218544912"
      },
      {
        "id": "IC_kwDOAQzde85Iv3F8",
        "parentId": null,
        "author": "ronniebarker",
        "content": "Perhaps - but I don\u0027t think it is a big enough issue for us yet to arrant trying a preview package. I am managing to clear items by returning a response with a \u0060max-age=1\u0060 (although the spec says you can use zero, the framework seems to reject that) but that requires a request from the resource which is fine for a single clear, but not for any bulk or service-driven clear.",
        "createdAt": "2022-08-19T10:19:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1220505980"
      },
      {
        "id": "IC_kwDOAQzde85IyEPU",
        "parentId": null,
        "author": "sebastienros",
        "content": "Are you setting the max-age header on the client? And in this case the server action will be hit even if it\u0027s cached (for longer in this case) and it will update the cache on its way back?",
        "createdAt": "2022-08-19T20:52:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1221084116"
      },
      {
        "id": "IC_kwDOAQzde85Iyeaj",
        "parentId": null,
        "author": "ronniebarker",
        "content": "I am making a request with a custom header, using that header to decide to\nset max-age on the response so that the response cache is replaced with the\n\u0022very soon to expire\u0022 version - effectively clearing that item in a second.\n\n\nOn Fri, Aug 19, 2022 at 21:52:41, S\u00E9bastien Ros ***@***.***\u003E\nwrote:\n\n\u003E Are you setting the max-age header on the client? And in this case the\n\u003E server action will be hit even if it\u0027s cached (for longer in this case) and\n\u003E it will update the cache on its way back?\n\u003E\n\u003E \u2014\n\u003E Reply to this email directly, view it on GitHub\n\u003E \u003Chttps://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1221084116\u003E,\n\u003E or unsubscribe\n\u003E \u003Chttps://github.com/notifications/unsubscribe-auth/AAA7RBNSRBPMJJJSLJL3BPDVZ7XZTANCNFSM56O6RWPQ\u003E\n\u003E .\n\u003E You are receiving this because you authored the thread.Message ID:\n\u003E ***@***.***\u003E\n\u003E\n",
        "createdAt": "2022-08-20T00:46:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1221191331"
      },
      {
        "id": "IC_kwDOAQzde85I6Umu",
        "parentId": null,
        "author": "halter73",
        "content": "There\u0027s debate among us in triage on whether you are setting the \u0060max-age\u0060 request header or setting some other header. Are you also setting any response headers? If so, are the response headers set on already-cached responses? Do the headers on already-cached responses affect the cache lifetime on the server?\r\n\r\nIf you could just provide a sample app that does the cache clearing with the \u0060max-age=1\u0060 workaround you are using today, that would really help explain the scenario.",
        "createdAt": "2022-08-22T22:30:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1223248302"
      },
      {
        "id": "IC_kwDOAQzde85I6gnb",
        "parentId": null,
        "author": "ronniebarker",
        "content": "So\u2026.\n\nI have an image that is generated from some parameters and stored in a\ndatabase whenever a request is made and it isn\u0027t found in the database.\n\nIf the internal parameters change so that the image needs to be regenerated\nthen the cache needs to be flushed for that item\n\nI have a  management web app sends an api request to clear the image (and\nactually is probably the same request that changes the parameters) from the\ndatabase;\n\nthen after that response completes it sends a javascript fetch (simulating\nthe browser making an image request) with \u0060Cache-Control:no-cache\u0060 to bust\nthrough the cache and hit the main image request handler and also\n\u0060x-generate=no\u0060 which tells my handler not to generate the actual image,\nbut to return an empty 200 response with \u0060Cache-Control: public,max-age=1\u0060\n\nThe response caching framework caches the empty response and  then expires\na second later.\n\nThe first new request after that second will cause the new image to be\ngenerated, stored in the database and then returned and cached by the\nresponse caching middleware.\n\n\n\nOn Mon, Aug 22, 2022 at 23:30:25, Stephen Halter ***@***.***\u003E\nwrote:\n\n\u003E There\u0027s debate among us in triage on whether you are setting the max-age\n\u003E request header or setting some other header? Are you also setting any\n\u003E response headers? If so, are the response headers set on already-cached\n\u003E responses? Do the headers on already-cached responses affect the cache\n\u003E lifetime on the server?\n\u003E\n\u003E If you could just provide a sample app that does the cache clearing with\n\u003E the max-age=1 workaround you are using today, that would really help\n\u003E explain the scenario.\n\u003E\n\u003E \u2014\n\u003E Reply to this email directly, view it on GitHub\n\u003E \u003Chttps://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1223248302\u003E,\n\u003E or unsubscribe\n\u003E \u003Chttps://github.com/notifications/unsubscribe-auth/AAA7RBMY6L2Z7TLCBTOFVXLV2P5QDANCNFSM56O6RWPQ\u003E\n\u003E .\n\u003E You are receiving this because you authored the thread.Message ID:\n\u003E ***@***.***\u003E\n\u003E\n",
        "createdAt": "2022-08-22T23:04:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1223297499"
      },
      {
        "id": "IC_kwDOAQzde85I6g7-",
        "parentId": null,
        "author": "ronniebarker",
        "content": "Sorry - I forgot to add what I would prefer:\n\n\n   1. For the api call to request the system to change the parameters to be\n   able to clear the cache\n   2. For me to be able to regenerate multiple images and clear their\n   caches without having to make multiple requests for each image from a\n   client.\n\n\n\n\nOn Mon, Aug 22, 2022 at 23:53:21, Ronnie Barker \u003C\n***@***.***\u003E wrote:\n\n\u003E So\u2026.\n\u003E\n\u003E I have an image that is generated from some parameters and stored in a\n\u003E database whenever a request is made and it isn\u0027t found in the database.\n\u003E\n\u003E If the internal parameters change so that the image needs to be\n\u003E regenerated then the cache needs to be flushed for that item\n\u003E\n\u003E I have a  management web app sends an api request to clear the image (and\n\u003E actually is probably the same request that changes the parameters) from the\n\u003E database;\n\u003E\n\u003E then after that response completes it sends a javascript fetch (simulating\n\u003E the browser making an image request) with \u0060Cache-Control:no-cache\u0060 to bust\n\u003E through the cache and hit the main image request handler and also\n\u003E \u0060x-generate=no\u0060 which tells my handler not to generate the actual image,\n\u003E but to return an empty 200 response with \u0060Cache-Control: public,max-age=1\u0060\n\u003E\n\u003E The response caching framework caches the empty response and  then expires\n\u003E a second later.\n\u003E\n\u003E The first new request after that second will cause the new image to be\n\u003E generated, stored in the database and then returned and cached by the\n\u003E response caching middleware.\n\u003E\n\u003E\n\u003E\n\u003E On Mon, Aug 22, 2022 at 23:30:25, Stephen Halter ***@***.***\n\u003E \u003E wrote:\n\u003E\n\u003E There\u0027s debate among us in triage on whether you are setting the max-age\n\u003E request header or setting some other header? Are you also setting any\n\u003E response headers? If so, are the response headers set on already-cached\n\u003E responses? Do the headers on already-cached responses affect the cache\n\u003E lifetime on the server?\n\u003E\n\u003E If you could just provide a sample app that does the cache clearing with\n\u003E the max-age=1 workaround you are using today, that would really help\n\u003E explain the scenario.\n\u003E\n\u003E \u2014\n\u003E Reply to this email directly, view it on GitHub\n\u003E \u003Chttps://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1223248302\u003E,\n\u003E or unsubscribe\n\u003E \u003Chttps://github.com/notifications/unsubscribe-auth/AAA7RBMY6L2Z7TLCBTOFVXLV2P5QDANCNFSM56O6RWPQ\u003E\n\u003E .\n\u003E You are receiving this because you authored the thread.Message ID:\n\u003E ***@***.***\u003E\n\u003E\n\u003E\n",
        "createdAt": "2022-08-22T23:06:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1223298814"
      },
      {
        "id": "IC_kwDOAQzde85I6rkE",
        "parentId": null,
        "author": "halter73",
        "content": "Got it. To summarize:\r\n\r\n1. You send a specially crafted \u0060Cache-Control: no-cache\u0060 request to an already-cached endpoint. This bypasses the cache.\r\n2. If you see this specially crafted request, in response you send \u0060Cache-Control: public,max-age=1\u0060. This overrides the previous cache entry with one that expires sooner (in 1 second).\r\n\r\n---\r\n\r\nBased on this, I have two main observations.\r\n\r\n\u003E I am managing to clear items by returning a response with a \u0060max-age=1\u0060 (although the spec says you can use zero, the framework seems to reject that)\r\n\r\nThis seems like a fair criticism. Given that you can override previous cache entries, why can\u0027t \u0060max-age=0\u0060 indicate both not to cache the response and to evict existing entries? It seems overly prescriptive not to allow this if the spec allows it when there\u0027s a valid use case presented here.\r\n\r\n\u003E Output Caching is a new feature in .NET 7 starting from preview 6 that handles this scenario. Can it be something that would work for you. It\u0027s driven by configuration and not by headers.\r\n\r\n@sebastienros How does output caching address this scenario? This issue is about having \u0022a way of clearing a specific resource from the cache.\u0022 I know you could \u0060OutputCacheContext.Tags\u0060 with \u0060IOutputCacheStore.EvictByTagAsync\u0060, but uniquely tagging each entry would be terribly inefficient.\r\n\r\nIs it possible to set \u0060OutputCacheContext.ResponseExpirationTimeSpan\u0060 to \u0060TimeSpan.Zero\u0060 on an already cached response to evict it? That sounds more in line with what @ronniebarker wants.",
        "createdAt": "2022-08-22T23:55:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1223342340"
      },
      {
        "id": "IC_kwDOAQzde85I6sQ9",
        "parentId": null,
        "author": "ronniebarker",
        "content": " Yes. That\u2019s right. Looking quickly at the Output Cache preview, clearing\ntags looks like it will do what I want. Also I think it will deal with my\nother issue which is the ability to ignore the host when generating the key\n\n\nOn Tue, Aug 23 2022 at 00:55, Stephen Halter ***@***.***\u003E\nwrote:\n\n\u003E Got it. To summarize:\n\u003E\n\u003E    1. You send a specially crafted Cache-Control: no-cache request to an\n\u003E    already-cached endpoint. This bypasses the cache.\n\u003E    2. If you see this specially crafted request, in response you send Cache-Control:\n\u003E    public,max-age=1. This overrides the previous cache entry with one\n\u003E    that expires sooner (in 1 second).\n\u003E\n\u003E ------------------------------\n\u003E\n\u003E Based on this, I have two main observations.\n\u003E\n\u003E I am managing to clear items by returning a response with a max-age=1\n\u003E (although the spec says you can use zero, the framework seems to reject\n\u003E that)\n\u003E\n\u003E This seems like a fair criticism. Given that you can override previous\n\u003E cache entries, why can\u0027t max-age=0 indicate both not to cache the\n\u003E response and to evict existing entries? It seems overly prescriptive not to\n\u003E allow this if the spec allows it when there\u0027s a valid use case presented\n\u003E here.\n\u003E\n\u003E Output Caching is a new feature in .NET 7 starting from preview 6 that\n\u003E handles this scenario. Can it be something that would work for you. It\u0027s\n\u003E driven by configuration and not by headers.\n\u003E\n\u003E @sebastienros \u003Chttps://github.com/sebastienros\u003E How does output caching\n\u003E address this scenario? This issue is about having \u0022a way of clearing a\n\u003E specific resource from the cache.\u0022 I know you could\n\u003E OutputCacheContext.Tags with IOutputCacheStore.EvictByTagAsync, but\n\u003E uniquely tagging each entry would be terribly inefficient.\n\u003E\n\u003E Is it possible to set OutputCacheContext.ResponseExpirationTimeSpan to\n\u003E TimeSpan.Zero on an already cached response to evict it? That sounds more\n\u003E in line with what @ronniebarker \u003Chttps://github.com/ronniebarker\u003E wants.\n\u003E\n\u003E \u2014\n\u003E Reply to this email directly, view it on GitHub\n\u003E \u003Chttps://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1223342340\u003E,\n\u003E or unsubscribe\n\u003E \u003Chttps://github.com/notifications/unsubscribe-auth/AAA7RBNNZYXVA6WTLCCSJE3V2QHONANCNFSM56O6RWPQ\u003E\n\u003E .\n\u003E You are receiving this because you were mentioned.Message ID:\n\u003E ***@***.***\u003E\n\u003E\n",
        "createdAt": "2022-08-23T00:00:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1223345213"
      },
      {
        "id": "IC_kwDOAQzde85I6zER",
        "parentId": null,
        "author": "halter73",
        "content": "@ronniebarker Would you give each cache entry its own unique tag, or is evicting a multiple entries at once using a tag preferrable? While tags probably could be used to evict single entries, I doubt it would be as efficient as finding the cache entry associated with the current request and adjusting the \u0060ResponseExpirationTimeSpan\u0060 to zero.",
        "createdAt": "2022-08-23T00:37:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1223373073"
      },
      {
        "id": "IC_kwDOAQzde85I63YM",
        "parentId": null,
        "author": "ronniebarker",
        "content": "I think that by tag would be useful (I have a \u0022code\u0022 that could map to a\ntag that covers a logical group of images). But also I was wondering about\nsome kind of URL/Path/Query/Key matcher which could have wildcards to wipe\nout batches based on the values used to generate the cache key\u2026\n\n\nOn Tue, Aug 23, 2022 at 01:38:03, Stephen Halter ***@***.***\u003E\nwrote:\n\n\u003E @ronniebarker \u003Chttps://github.com/ronniebarker\u003E Would you give each cache\n\u003E entry its own unique tag, or is evicting a multiple entries at once using a\n\u003E tag preferrable? While tags probably could be used to evict single entries,\n\u003E I doubt it would be as efficient as finding the cache entry associated with\n\u003E the current request and adjusting the ResponseExpirationTimeSpan to zero.\n\u003E\n\u003E \u2014\n\u003E Reply to this email directly, view it on GitHub\n\u003E \u003Chttps://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1223373073\u003E,\n\u003E or unsubscribe\n\u003E \u003Chttps://github.com/notifications/unsubscribe-auth/AAA7RBNKDWDEVUQUJDS7YLDV2QMOXANCNFSM56O6RWPQ\u003E\n\u003E .\n\u003E You are receiving this because you were mentioned.Message ID:\n\u003E ***@***.***\u003E\n\u003E\n",
        "createdAt": "2022-08-23T01:03:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1223390732"
      },
      {
        "id": "IC_kwDOAQzde85JGwoX",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@ronniebarker We\u0027d love it if you could try out OutputCaching in .NET 7 (RC 1 should ship in September) and let us know how this workflow works for you, or if you have any other feedback about it.",
        "createdAt": "2022-08-24T22:24:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1226508823"
      },
      {
        "id": "IC_kwDOAQzde85JGxSo",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Leaving open to collect feedback once you\u0027ve tried it :smile:",
        "createdAt": "2022-08-24T22:25:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43272#issuecomment-1226511528"
      },
      {
        "id": "IC_kwDOAQzde86B6cBV",
        "parentId": null,
        "author": "nquandt",
        "content": "@adityamandaleeka this might not be the best place to ask this, i can always make a new issue or discussion.. Is it bad practice or are there any performance implications to having a tag per resource?\r\n\r\nMy use case is I have OutputCaching enabled in YARP and need ways of clearing single pages from my application. My thought was in my custom CachingPolicy I just call \u0060context.Tags.Add(context.HttpContext.Request.Path);\u0060. That way later I can evict based on paths. Do you see any issues with that?\r\n\r\nMy full policy\r\n\r\n\u0060\u0060\u0060csharp\r\nservices.AddOutputCache(options =\u003E\r\n{\r\n    options.DefaultExpirationTimeSpan = TimeSpan.FromDays(1);\r\n    options.AddBasePolicy(builder =\u003E builder.Tag(\u0022__all_tag__\u0022));\r\n    options.AddPolicy(\u0022customPolicy\u0022, MyCustomPolicy.Instance);\r\n});\r\n\r\npublic sealed class MyCustomPolicy : IOutputCachePolicy\r\n{\r\n    public static readonly MyCustomPolicy Instance = new();\r\n\r\n    private MyCustomPolicy()\r\n    {\r\n    }\r\n\r\n    ValueTask IOutputCachePolicy.CacheRequestAsync(\r\n        OutputCacheContext context, \r\n        CancellationToken cancellationToken)\r\n    {\r\n        var attemptOutputCaching = AttemptOutputCaching(context);\r\n        context.EnableOutputCaching = true;\r\n        context.AllowCacheLookup = attemptOutputCaching;\r\n        context.AllowCacheStorage = attemptOutputCaching;\r\n        context.AllowLocking = true;\r\n\r\n        context.Tags.Add(context.HttpContext.Request.Path); // This is what we evict by..\r\n\r\n        // Vary by any query by default\r\n        context.CacheVaryByRules.QueryKeys = \u0022*\u0022;\r\n\r\n        return ValueTask.CompletedTask;\r\n    }\r\n\r\n    ValueTask IOutputCachePolicy.ServeFromCacheAsync\r\n        (OutputCacheContext context, CancellationToken cancellationToken)\r\n    {\r\n        return ValueTask.CompletedTask;\r\n    }\r\n\r\n    ValueTask IOutputCachePolicy.ServeResponseAsync\r\n        (OutputCacheContext context, CancellationToken cancellationToken)\r\n    {\r\n        var response = context.HttpContext.Response;\r\n\r\n        // Verify existence of cookie headers\r\n        if (!StringValues.IsNullOrEmpty(response.Headers.SetCookie))\r\n        {\r\n            context.AllowCacheStorage = false;\r\n            return ValueTask.CompletedTask;\r\n        }\r\n\r\n        // Check response code\r\n        if (response.StatusCode != StatusCodes.Status200OK \r\n            \u0026\u0026 response.StatusCode != StatusCodes.Status301MovedPermanently\r\n            \u0026\u0026 response.StatusCode != StatusCodes.Status302Found\r\n            \u0026\u0026 response.StatusCode != StatusCodes.Status404NotFound)\r\n        {\r\n            context.AllowCacheStorage = false;\r\n            return ValueTask.CompletedTask;\r\n        }\r\n\r\n        if (!context.HttpContext.IsResponseCacheable())\r\n        {\r\n            context.AllowCacheStorage = false;\r\n            return ValueTask.CompletedTask;\r\n        }\r\n\r\n        return ValueTask.CompletedTask;\r\n    }\r\n\r\n    private static bool AttemptOutputCaching(OutputCacheContext context)\r\n    {\r\n        // Check if the current request fulfills the requirements\r\n        // to be cached\r\n        var request = context.HttpContext.Request;\r\n\r\n        // Verify the method\r\n        if (!HttpMethods.IsGet(request.Method) \u0026\u0026 \r\n            !HttpMethods.IsHead(request.Method))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        // Verify existence of authorization headers\r\n        if (!StringValues.IsNullOrEmpty(request.Headers.Authorization) || \r\n            request.HttpContext.User?.Identity?.IsAuthenticated == true)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n",
        "createdAt": "2024-06-19T23:43:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43272#issuecomment-2179579989"
      },
      {
        "id": "IC_kwDOAQzde86GRUoV",
        "parentId": null,
        "author": "Rasmus715",
        "content": "\u003E @adityamandaleeka this might not be the best place to ask this, i can always make a new issue or discussion.. Is it bad practice or are there any performance implications to having a tag per resource?\r\n\u003E \r\n\u003E My use case is I have OutputCaching enabled in YARP and need ways of clearing single pages from my application. My thought was in my custom CachingPolicy I just call \u0060context.Tags.Add(context.HttpContext.Request.Path);\u0060. That way later I can evict based on paths. Do you see any issues with that?\r\n\u003E \r\n\u003E My full policy\r\n\u003E \r\n\u003E \u0060\u0060\u0060cs\r\n\u003E services.AddOutputCache(options =\u003E\r\n\u003E {\r\n\u003E     options.DefaultExpirationTimeSpan = TimeSpan.FromDays(1);\r\n\u003E     options.AddBasePolicy(builder =\u003E builder.Tag(\u0022__all_tag__\u0022));\r\n\u003E     options.AddPolicy(\u0022customPolicy\u0022, MyCustomPolicy.Instance);\r\n\u003E });\r\n\u003E \r\n\u003E public sealed class MyCustomPolicy : IOutputCachePolicy\r\n\u003E {\r\n\u003E     public static readonly MyCustomPolicy Instance = new();\r\n\u003E \r\n\u003E     private MyCustomPolicy()\r\n\u003E     {\r\n\u003E     }\r\n\u003E \r\n\u003E     ValueTask IOutputCachePolicy.CacheRequestAsync(\r\n\u003E         OutputCacheContext context, \r\n\u003E         CancellationToken cancellationToken)\r\n\u003E     {\r\n\u003E         var attemptOutputCaching = AttemptOutputCaching(context);\r\n\u003E         context.EnableOutputCaching = true;\r\n\u003E         context.AllowCacheLookup = attemptOutputCaching;\r\n\u003E         context.AllowCacheStorage = attemptOutputCaching;\r\n\u003E         context.AllowLocking = true;\r\n\u003E \r\n\u003E         context.Tags.Add(context.HttpContext.Request.Path); // This is what we evict by..\r\n\u003E \r\n\u003E         // Vary by any query by default\r\n\u003E         context.CacheVaryByRules.QueryKeys = \u0022*\u0022;\r\n\u003E \r\n\u003E         return ValueTask.CompletedTask;\r\n\u003E     }\r\n\u003E \r\n\u003E     ValueTask IOutputCachePolicy.ServeFromCacheAsync\r\n\u003E         (OutputCacheContext context, CancellationToken cancellationToken)\r\n\u003E     {\r\n\u003E         return ValueTask.CompletedTask;\r\n\u003E     }\r\n\u003E \r\n\u003E     ValueTask IOutputCachePolicy.ServeResponseAsync\r\n\u003E         (OutputCacheContext context, CancellationToken cancellationToken)\r\n\u003E     {\r\n\u003E         var response = context.HttpContext.Response;\r\n\u003E \r\n\u003E         // Verify existence of cookie headers\r\n\u003E         if (!StringValues.IsNullOrEmpty(response.Headers.SetCookie))\r\n\u003E         {\r\n\u003E             context.AllowCacheStorage = false;\r\n\u003E             return ValueTask.CompletedTask;\r\n\u003E         }\r\n\u003E \r\n\u003E         // Check response code\r\n\u003E         if (response.StatusCode != StatusCodes.Status200OK \r\n\u003E             \u0026\u0026 response.StatusCode != StatusCodes.Status301MovedPermanently\r\n\u003E             \u0026\u0026 response.StatusCode != StatusCodes.Status302Found\r\n\u003E             \u0026\u0026 response.StatusCode != StatusCodes.Status404NotFound)\r\n\u003E         {\r\n\u003E             context.AllowCacheStorage = false;\r\n\u003E             return ValueTask.CompletedTask;\r\n\u003E         }\r\n\u003E \r\n\u003E         if (!context.HttpContext.IsResponseCacheable())\r\n\u003E         {\r\n\u003E             context.AllowCacheStorage = false;\r\n\u003E             return ValueTask.CompletedTask;\r\n\u003E         }\r\n\u003E \r\n\u003E         return ValueTask.CompletedTask;\r\n\u003E     }\r\n\u003E \r\n\u003E     private static bool AttemptOutputCaching(OutputCacheContext context)\r\n\u003E     {\r\n\u003E         // Check if the current request fulfills the requirements\r\n\u003E         // to be cached\r\n\u003E         var request = context.HttpContext.Request;\r\n\u003E \r\n\u003E         // Verify the method\r\n\u003E         if (!HttpMethods.IsGet(request.Method) \u0026\u0026 \r\n\u003E             !HttpMethods.IsHead(request.Method))\r\n\u003E         {\r\n\u003E             return false;\r\n\u003E         }\r\n\u003E \r\n\u003E         // Verify existence of authorization headers\r\n\u003E         if (!StringValues.IsNullOrEmpty(request.Headers.Authorization) || \r\n\u003E             request.HttpContext.User?.Identity?.IsAuthenticated == true)\r\n\u003E         {\r\n\u003E             return false;\r\n\u003E         }\r\n\u003E \r\n\u003E         return true;\r\n\u003E     }\r\n\u003E }\r\n\u003E \u0060\u0060\u0060\r\n\r\nGood thinking! I\u0027ve been looking for a similar logic but haven\u0027t found anything, that will tag a cache based on the requested resource. \r\nLooking forward to a similar out-of-the-box implementation :)",
        "createdAt": "2024-07-26T12:44:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43272#issuecomment-2252687893"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85P0b0q",
    "title": "RateLimitingMiddleware test improvements",
    "url": "https://github.com/dotnet/aspnetcore/issues/43298",
    "createdAt": "2022-08-15T15:30:34Z",
    "lastUpdated": "2023-10-31T16:18:36Z",
    "body": "Update https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/RateLimiting/test/RateLimitingMiddlewareTests.cs to use \u0060RateLimiterEndpointConventionBuilderExtensions\u0060 where appropriate (see https://github.com/dotnet/aspnetcore/pull/43053/#discussion_r943681636)",
    "upvotes": 0,
    "labels": [
      "area-networking",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85J53Gz",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-07T21:23:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43298#issuecomment-1239904691"
      },
      {
        "id": "IC_kwDOAQzde85QM8ey",
        "parentId": null,
        "author": "MadL1me",
        "content": "@wtgodbe I read https://github.com/dotnet/aspnetcore/pull/43053 and created improvement on rate limiter tests. I hope I did everything right, and I would appreciate if you look at my PR",
        "createdAt": "2022-12-11T14:34:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43298#issuecomment-1345570738"
      },
      {
        "id": "IC_kwDOAQzde85qWMTP",
        "parentId": null,
        "author": "ladeak",
        "content": "Is this still an open issue to be picked up? I see @MadL1me has addressed issues, or anything left to do here @wtgodbe ?",
        "createdAt": "2023-10-29T19:21:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43298#issuecomment-1784202447"
      },
      {
        "id": "IC_kwDOAQzde85qi9bF",
        "parentId": null,
        "author": "wtgodbe",
        "content": "I don\u0027t think there\u0027s anything more to do here - @adityamandaleeka are there any other improvements the team wants to make in the tests at this point? From the original description of the issue, I believe the original intent was covered by https://github.com/dotnet/aspnetcore/pull/45541",
        "createdAt": "2023-10-31T16:18:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43298#issuecomment-1787549381"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85Q2Eab",
    "title": "Add support for metadata-only endpoints to support path-based authorization, output caching, etc.",
    "url": "https://github.com/dotnet/aspnetcore/issues/43642",
    "createdAt": "2022-08-30T21:48:01Z",
    "lastUpdated": "2024-03-01T22:48:51Z",
    "body": "Related #43352\r\n\r\nThere are scenarios where it is desirable to affect the behavior of endpoint-aware middleware that runs in a request pipeline that will be handled by a non-endpoint-aware middleware (rather than an actual endpoint) such that the endpoint-aware middleware performs its operations as if the request-handling middleware were actually an endpoint.\r\n\r\nFor example, the static files middleware handles requests but **does not do so via endpoints**. Rather, it is a terminal middleware for requests with paths that map to static files in the configured file provider. The authorization middleware is an endpoint-aware middleware that uses metadata from the current request endpoint to perform authorization actions and will no-op for requests with no active endpoint. This means that one can\u0027t use the authorization middleware to enforce authorization for static files. The output cache middleware is similar.\r\n\r\nThe repo [AspNetCorePathAuthorization](https://github.com/DamianEdwards/AspNetCorePathAuthorization#endpoint-metadata-decorators-implementation-points) demonstrates a concept of \u0022metadata-only endpoints\u0022 that allows endpoints to be registered that have only metadata, and no actual endpoint handler. These endpoints only exist for the purpose of effectively adding metadata to arbitrary route paths, either adding metadata to existing real endpoints, or providing metadata for requests with no real endpoint but with a matching path. This metadata can then be used by endpoint-aware middleware to perform operations relevant for the current request.\r\n\r\nAn example of what this API could look like:\r\n\r\n\u0060\u0060\u0060csharp\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\nvar app = builder.Build();\r\n\r\n// Add metadata to every request in the app\r\napp.MapMetadata(\u0022/{**subpath}\u0022, new { Whatever = \u0022This is on every request now!\u0022 });\r\n\r\n// Add metadata to all requests under /public in the app\r\napp.MapMetadata(\u0022/public/{**subpath}\u0022, new MessageMetadata(\u0022Hello from /public!\u0022));\r\n\r\n// Potentially terminal middleware\r\napp.Use(async (ctx, next) =\u003E\r\n{\r\n    // This obviously isn\u0027t a good example but something like the static files middleware effectively does this\r\n    if (ctx.Request.Path.StartsWithSegments(\u0022/public\u0022))\r\n    {\r\n        var message = ctx.GetEndpoint()?.Metadata.GetMetadata\u003CMessageMetadata\u003E()?.Message;\r\n\r\n        await ctx.Response.WriteAsync($\u0022{message ?? \u0022No message metadata found :(\u0022}\u0022);\r\n        return;\r\n    }\r\n\r\n    await next();\r\n});\r\n\r\napp.Run();\r\n\r\nrecord MessageMetadata(string Message);\r\n\u0060\u0060\u0060\r\n\r\nHigher level APIs like Authorization and Output Caching could be updated to leverage this with new top-level APIs for configuring authorization and output caching based on path, e.g.:\r\n\r\n\u0060\u0060\u0060csharp\r\n// Authorize all requests under /users\r\napp.RequireAuthorization(\u0022/users\u0022);\r\n\r\n// Disable authorization for all requests under /public\r\napp.AllowAnonymous(\u0022/public\u0022);\r\n\r\n// Cache all requests under /expensivestuff\r\napp.CacheOutput(\u0022/expensivestuff\u0022);\r\n\u0060\u0060\u0060 ",
    "upvotes": 0,
    "labels": [
      "Needs: Design",
      "feature-static-files",
      "feature-routing",
      "feature-output-caching",
      "area-minimal",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85Jcms0",
        "parentId": null,
        "author": "rynowak",
        "content": "I worry about examples like these, and user not understand the blast radius of making a change:\r\n\r\n\u0060\u0060\u0060C#\r\n// Disable authorization for all requests under /public\r\napp.AllowAnonymous(\u0022/public\u0022);\r\n\r\n\u0060\u0060\u0060\r\n\r\nIf my mental model is correct this does define an endpoint, and that endpoint would be a candidate for path matching along with all the other endpoints, including the ability to cause ambiguities (HTTP 500).\r\n\r\nBasically these features will only work the way you when they don\u0027t overlap with other endpoints in your app. The sample here with \u0060AllowAnonymous\u0060 *feels like* it\u0027s applying a path-matching rule, but it\u0027s actually changing your route table. \r\n\r\nSo my feedback is that this feels like it\u0027s going to be misunderstood. It puts a lot of burden on the user to understand what happens behind the scenes. \r\n\r\nTake this example (modified from yours):\r\n\r\n\u0060\u0060\u0060C#\r\n// Disable authorization for all requests under /public\r\napp.AllowAnonymous(\u0022/public\u0022);\r\n\r\n// Cache all requests under /public\r\napp.CacheOutput(\u0022/public\u0022);\r\n\u0060\u0060\u0060\r\n\r\nWhat happens? I think most users would expect paths under \u0060/public\u0060 to be public and cached. I think it will cause an ambiguity in the route table and throw.",
        "createdAt": "2022-08-30T22:29:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43642#issuecomment-1232235316"
      },
      {
        "id": "IC_kwDOAQzde85JcxJB",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "@rynowak the ambiguities are resolved via a [custom \u0060IEndpointSelectorPolicy\u0060](https://github.com/DamianEdwards/AspNetCorePathAuthorization/blob/main/src/AspNetCore.Authorization.PathBased/EndpointMetadataDecoratorMatcherPolicy.cs) to avoid the issues you refer to. ~In other words, metadata-only endpoints will never be selected as matches during routing~ *(see below).* Ideally this would happen during the building of the route graph, rather than per-request, via a custom \u0060INodeBuilderPolicy\u0060 or some such.\r\n\r\n**Edit:** metadata-only endpoints **can** be selected as the match during routing, but **only** in the case there are no other candidates available. When they do match, they have a null handler, so while there\u0027s an active endpoint for the request to carry the metadata, there\u0027s no request delegate to execute.",
        "createdAt": "2022-08-30T23:36:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43642#issuecomment-1232278081"
      },
      {
        "id": "IC_kwDOAQzde85JmpS1",
        "parentId": null,
        "author": "captainsafia",
        "content": "It seems like this feature lends itself nicely to the design of \u0022route-based endpoint conventions\u0022 given that \u0022metadata-only endpoints\u0022 doesn\u0027t apply exclusively to routes that do not map to an endpoint handler.\r\n\r\nLooking through this particular example:\r\n\r\n\u0060\u0060\u0060csharp\r\n// Authorize all requests under /users\r\napp.RequireAuthorization(\u0022/users\u0022);\r\n\u0060\u0060\u0060\r\n\r\nI wonder how this feature would intersect with route groups. When and why would a user use the syntax above when they could also do:\r\n\r\n\u0060\u0060\u0060csharp\r\nvar users = app.MapGroup(\u0022/users\u0022);\r\nusers.RequireAuthorization();\r\n\u0060\u0060\u0060\r\n\r\nIs the assumption that route group-based conventions would intersect with \u0022metadata-only endpoints\u0022 in some way via the implementation?\r\n\r\n\u003E a concept of \u0022metadata-only endpoints\u0022 that allows endpoints to be registered that have only metadata, and no actual endpoint handler. \r\n\r\nHow common are these types of endpoints? Static file support seems like a big one. Are there other scenarios in app where a path is not going to be tied to a handler?\r\n",
        "createdAt": "2022-09-01T22:53:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43642#issuecomment-1234867381"
      },
      {
        "id": "IC_kwDOAQzde85Jmvhg",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "One would use \u0060app.RequireAuthorization(\u0022/users\u0022);\u0060 when it is known that there will be requests served under that path that *aren\u0027t* implemented as endpoints *or* they wish not to use route groups for some reason, e.g. there are files served by the static files middleware under that path.\r\n\r\nUltimately, the metadata on metadata-only endpoints (MOE) applies to any request that matches the route pattern for the MOE, which for the cases outlined would almost certainly include greedily capturing any sub-path. This is true whether there are actual endpoints in play or not, so they interact in that they compose, i.e. the metadata from the MOE is copied to the actual endpoint (in the [prototype implementation the endpoint is actually replaced by the \u0060MatcherPolicy\u0060 per request](https://github.com/DamianEdwards/AspNetCorePathAuthorization/blob/main/src/AspNetCore.Authorization.PathBased/EndpointMetadataDecoratorMatcherPolicy.cs#L102-L124) but if this were a first-class feature I\u0027d expect this to be done during the building of the route graph).\r\n\r\n\u003E How common are these types of endpoints? Static file support seems like a big one. Are there other scenarios in app where a path is not going to be tied to a handler?\r\n\r\nHard to say. Prior to ASP.NET Core 3.0 it was everything that was request-handling. Anything that didn\u0027t move to be endpoint-based would count, and I think things like Swashbuckle still use terminal middleware too.",
        "createdAt": "2022-09-01T23:19:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43642#issuecomment-1234892896"
      },
      {
        "id": "IC_kwDOAQzde85V9865",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-02-23T19:16:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43642#issuecomment-1442303673"
      },
      {
        "id": "IC_kwDOAQzde85gE5jv",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-06-28T18:35:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43642#issuecomment-1611897071"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85RJZhh",
    "title": "OutputCaching make IOutputCacheKeyProvider public",
    "url": "https://github.com/dotnet/aspnetcore/issues/43747",
    "createdAt": "2022-09-05T05:17:44Z",
    "lastUpdated": "2025-01-18T10:18:47Z",
    "body": "Hello,\r\n\r\nI\u0027ve been playing around with using the new OutputCaching middleware that was introduced in dotnet 7 preview 6 and I have a requirement to implement my own cache key provider.\r\n\r\nBasically I would like to ignore the host header in the incoming request but I also conceive a scenario where I would like to do only path based keys.\r\n\r\nI\u0027m currently working around this by using middleware to set the host header to null before it goes to the endpoint that\u0027s being cached.\r\n\r\nIf IOutputCacheKeyProvider was public and injected in AddOutputCache() the same way as IOutputCacheStore then I could simply inject my own implementation before calling AddOutputCache().\r\n\r\n\r\nThanks,\r\nNick",
    "upvotes": 1,
    "labels": [
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85J00En",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "cc @sebastienros ",
        "createdAt": "2022-09-06T19:46:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43747#issuecomment-1238581543"
      },
      {
        "id": "IC_kwDOAQzde85KC_Nn",
        "parentId": null,
        "author": "sebastienros",
        "content": "I am looking into exposing this in policies so this can be configured globally or per endpoint. Would that work for you?\r\n\r\n\u0060\u0060\u0060\r\nbuilder.VaryByHost(false)\r\n\u0060\u0060\u0060",
        "createdAt": "2022-09-09T17:54:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43747#issuecomment-1242297191"
      },
      {
        "id": "IC_kwDOAQzde85KDc0e",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-09T20:14:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43747#issuecomment-1242418462"
      },
      {
        "id": "IC_kwDOAQzde85KIHEE",
        "parentId": null,
        "author": "nixtar",
        "content": "\u003E I am looking into exposing this in policies so this can be configured globally or per endpoint. Would that work for you?\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E builder.VaryByHost(false)\r\n\u003E \u0060\u0060\u0060\r\n\r\nYep, that looks prefect for our scenario.\r\n\r\n\r\nThanks for your work on Output Caching. \u2764\uFE0F",
        "createdAt": "2022-09-12T12:05:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43747#issuecomment-1243640068"
      },
      {
        "id": "IC_kwDOAQzde85KQVeH",
        "parentId": null,
        "author": "sebastienros",
        "content": "7.0 RC2 Output Caching will have \u0060SetVaryByHost(bool)\u0060\r\n\r\n",
        "createdAt": "2022-09-13T18:24:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43747#issuecomment-1245796231"
      },
      {
        "id": "IC_kwDOAQzde86a86Y-",
        "parentId": null,
        "author": "code-jar",
        "content": "@sebastienros If I want to customize the cache key when using the redis store cache, how do I adjust it? I want the key to be in a format that conforms to the redis key specification, such as Instance:Path:Key.",
        "createdAt": "2025-01-18T10:18:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43747#issuecomment-2599659070"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85RTVqq",
    "title": "OutputCaching \u002B YARP interoperability",
    "url": "https://github.com/dotnet/aspnetcore/issues/43791",
    "createdAt": "2022-09-07T03:04:04Z",
    "lastUpdated": "2024-09-13T21:51:33Z",
    "body": "Hello,\r\n\r\nAs per discussion over in the YARP repo https://github.com/microsoft/reverse-proxy/discussions/1851.\r\n\r\nIn the scenario where OutputCaching is being used with YARP I would like a way to be able to validate the cached items on request.\r\n\r\nI believe there would be value in having a way to make YARP and OutputCaching work together.\r\nHave YARP leverage OutputCaching instead of having OutputCaching on top of YARP.\r\n\r\nAt a high level I\u0027d like to achieve the following pipeline:\r\n\r\nGet request \u003E YARP processes its routes/clusters \u003E YARP/[custom middleware](https://microsoft.github.io/reverse-proxy/articles/middleware.html#custom-proxy-middleware) gets the output cache headers and performs a head request against the origin server with the \u0022If-Modified-Since\u0022 and \u0022If-None-Match\u0022 headers \u003E return the Output Cache data if valid else back to YARP to process the request per usual and the output is cached\r\n\r\nPerhaps something like the HttpContext.Features \u0060HttpContext.GetReverseProxyFeature()\u0060 extension method for YARP middleware but for output caching?\r\n\r\nEG:\r\n\u0060\u0060\u0060c#\r\nendpoints.MapReverseProxy(proxyPipeline =\u003E\r\n{\r\n    proxyPipeline.Use((context, next) =\u003E\r\n    {\r\n        var proxyFeature = context.GetReverseProxyFeature();\r\n        var outputCacheFeature = context.GetOutputCacheFeature();\r\n        var cluster = proxyFeature.Cluster;\r\n        var destinations = proxyFeature.AvailableDestinations;\r\n        var cachedHeaders = outputCacheFeature.GetHeaders(context.Request);\r\n        \r\n        if (cachedHeaders is not null)\r\n        {\r\n            // logic to validate and optionally return the cached item\r\n        }\r\n\r\n        return next();\r\n    });\r\n    proxyPipeline.UseSessionAffinity();\r\n    proxyPipeline.UseLoadBalancing();\r\n    proxyPipeline.UsePassiveHealthChecks();\r\n});\r\n\u0060\u0060\u0060\r\n\r\nThis could also be used by other non YARP things that have access to the HttpContext.\r\n\r\nMy end game goal is to be able to replace IIS\u002BARR/Nginx\u0027s disk based content caching with YARP and hopefully OutputCaching.\r\nIdeally I wont have to go down the path of writing my own caching mechanisms for YARP as the guts of OutputCaching appears to be solid as.",
    "upvotes": 0,
    "labels": [
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85J6DBK",
        "parentId": null,
        "author": "wtgodbe",
        "content": "@sebastienros could you take a look?",
        "createdAt": "2022-09-07T22:05:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43791#issuecomment-1239953482"
      },
      {
        "id": "IC_kwDOAQzde85KDey2",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-09T20:24:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43791#issuecomment-1242426550"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85RdS3r",
    "title": "Pass through response status codes from BadHttpRequestException in ExceptionHandlerMiddleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/43831",
    "createdAt": "2022-09-08T16:16:45Z",
    "lastUpdated": "2024-03-02T01:04:05Z",
    "body": "The default error handler for \u0060ExceptionHandlerMiddleware\u0060 always sets the response status code to 500. It is not uncommon for \u0060BadHttpRequestException\u0060 to be thrown by requests though which detail a different (usually 4xx) status code but this will get masked by the default error handler.\r\n\r\nWhile it\u0027s possible to customize the error handler via setting \u0060ExceptionHandlerOptions.ExceptionHandler\u0060, one has to reimplement the default feature logic for returning JSON Problem Details responses manually which is quite a bit of code, e.g.:\r\n\r\n\u0060\u0060\u0060csharp\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\nbuilder.Services.AddProblemDetails(options =\u003E\r\n{\r\n    options.CustomizeProblemDetails = static ctx =\u003E\r\n        ctx.ProblemDetails.Extensions[\u0022requestId\u0022] = Activity.Current?.Id ?? ctx.HttpContext.TraceIdentifier;\r\n});\r\n\r\nvar app = builder.Builder();\r\n\r\nif (!app.Environment.IsDevelopment())\r\n{\r\n    // Error handling\r\n    app.UseExceptionHandler(new ExceptionHandlerOptions\r\n    {\r\n        AllowStatusCode404Response = true,\r\n        ExceptionHandler = async (HttpContext context) =\u003E\r\n        {\r\n            // Pass-through status codes from BadHttpRequestException\r\n            var exceptionHandlerFeature = context.Features.Get\u003CIExceptionHandlerFeature\u003E();\r\n            var error = exceptionHandlerFeature?.Error;\r\n\r\n            if (error is BadHttpRequestException badRequestEx)\r\n            {\r\n                context.Response.StatusCode = badRequestEx.StatusCode;\r\n            }\r\n\r\n            if (context.RequestServices.GetRequiredService\u003CIProblemDetailsService\u003E() is { } problemDetailsService)\r\n            {\r\n                await problemDetailsService.WriteAsync(new()\r\n                {\r\n                    HttpContext = context,\r\n                    AdditionalMetadata = exceptionHandlerFeature?.Endpoint?.Metadata,\r\n                    ProblemDetails = { Status = context.Response.StatusCode }\r\n                });\r\n            }\r\n            else if (ReasonPhrases.GetReasonPhrase(context.Response.StatusCode) is { } reasonPhrase)\r\n            {\r\n                await context.Response.WriteAsync(reasonPhrase);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\napp.MapGet(\u0022/throw/{statusCode?}\u0022, (int? statusCode) =\u003E\r\n    {\r\n        throw statusCode switch\r\n        {\r\n            \u003E= 400 and \u003C 500 =\u003E new BadHttpRequestException(\r\n                $\u0022{statusCode} {ReasonPhrases.GetReasonPhrase(statusCode.Value)}\u0022,\r\n                statusCode.Value),\r\n            _ =\u003E new Exception(\u0022uh oh\u0022)\r\n        };\r\n    });\r\n\r\napp.Run();\r\n\u0060\u0060\u0060\r\n\r\nWe should consider adding support for passing through the response status code from \u0060BadHttpRequestException\u0060 in the default error handler. We can consider adding a boolean property to \u0060ExceptionHandlerOptions\u0060 to control this behavior if necessary.",
    "upvotes": 4,
    "labels": [
      "feature-diagnostics",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85J-ZaW",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-08T18:44:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43831#issuecomment-1241093782"
      },
      {
        "id": "IC_kwDOAQzde85J-ZcS",
        "parentId": null,
        "author": "Tratcher",
        "content": "Where are we generating BadHttpRequestException in the framework? I mainly see the ones generated by Kestrel.\r\n\r\nShould the dev exception page get the same treatment?",
        "createdAt": "2022-09-08T18:44:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43831#issuecomment-1241093906"
      },
      {
        "id": "IC_kwDOAQzde85J-y1o",
        "parentId": null,
        "author": "brunolins16",
        "content": "\u003E Should the dev exception page get the same treatment?\r\n\r\nIt is already there: https://github.com/dotnet/aspnetcore/blob/4dd59c8996437d4e0c2ffb5c9f1d60f69225b8e0/src/Middleware/Diagnostics/src/DeveloperExceptionPage/DeveloperExceptionPageMiddlewareImpl.cs#L115-L122",
        "createdAt": "2022-09-08T20:25:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43831#issuecomment-1241197928"
      },
      {
        "id": "IC_kwDOAQzde85J-4iP",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "\u003E Where are we generating BadHttpRequestException in the framework? I mainly see the ones generated by Kestrel.\r\n\r\nI think the only place is in \u0060RequestDelegateFactory\u0060 and even then only during development so it will likely be handled by the developer exception page, but given this is a public exception type in \u0060Microsoft.AspNetCore\u0060 that can be thrown by anyone it seems reasonable that the default error handler should special-case it and preserve the status code (or at least there should be an option to enable that behavior).",
        "createdAt": "2022-09-08T20:52:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43831#issuecomment-1241221263"
      },
      {
        "id": "IC_kwDOAQzde85Ssd6b",
        "parentId": null,
        "author": "liquidvapour",
        "content": "I am having this issue with a BadHttpRequestException being thrown because a request that is not valid JSON.\r\n\r\nAlthough the exception\u0027s StatusCode property is 400 I still get a 500 response to the client.\r\n\r\nI have included the stack trace here in case it is useful.\r\n\r\n\u0060\u0060\u0060\r\nMicrosoft.AspNetCore.Http.BadHttpRequestException: Failed to read parameter \\\u0022ConsentStatusDto consent\\\u0022 from the request body as JSON.\r\n ---\u003E System.Text.Json.JsonException: \u0027fred\\r\\n        }\\r\\n    ],\\r\\n    \\\u0022asDDOf\\\u0022: \\\u00222023-01-18T16:38:56.683Z\\\u0022\\r\\n}\\r\\n\u0027 is an invalid JSON literal. Expected the literal \u0027false\u0027. Path: $.consents[1].status | LineNumber: 8 | BytePositionInLine: 23.\r\n ---\u003E System.Text.Json.JsonReaderException: \u0027fred\\r\\n        }\\r\\n    ],\\r\\n    \\\u0022asDDOf\\\u0022: \\\u00222023-01-18T16:38:56.683Z\\\u0022\\r\\n}\\r\\n\u0027 is an invalid JSON literal. Expected the literal \u0027false\u0027. LineNumber: 8 | BytePositionInLine: 23.\r\n   at System.Text.Json.ThrowHelper.ThrowJsonReaderException(Utf8JsonReader\u0026 json, ExceptionResource resource, Byte nextByte, ReadOnlySpan\u00601 bytes)\r\n   at System.Text.Json.Utf8JsonReader.ThrowInvalidLiteral(ReadOnlySpan\u00601 span)\r\n   at System.Text.Json.Utf8JsonReader.CheckLiteral(ReadOnlySpan\u00601 span, ReadOnlySpan\u00601 literal)\r\n   at System.Text.Json.Utf8JsonReader.ConsumeLiteral(ReadOnlySpan\u00601 literal, JsonTokenType tokenType)\r\n   at System.Text.Json.Utf8JsonReader.ConsumeValue(Byte marker)\r\n   at System.Text.Json.Utf8JsonReader.ReadSingleSegment()\r\n   at System.Text.Json.Utf8JsonReader.Read()\r\n   at System.Text.Json.Serialization.Converters.ObjectWithParameterizedConstructorConverter\u00601.ReadConstructorArgumentsWithContinuation(ReadStack\u0026 state, Utf8JsonReader\u0026 reader, JsonSerializerOptions options)\r\n   at System.Text.Json.Serialization.Converters.ObjectWithParameterizedConstructorConverter\u00601.OnTryRead(Utf8JsonReader\u0026 reader, Type typeToConvert, JsonSerializerOptions options, ReadStack\u0026 state, T\u0026 value)\r\n   at System.Text.Json.Serialization.JsonConverter\u00601.TryRead(Utf8JsonReader\u0026 reader, Type typeToConvert, JsonSerializerOptions options, ReadStack\u0026 state, T\u0026 value)\r\n   at System.Text.Json.Serialization.JsonCollectionConverter\u00602.OnTryRead(Utf8JsonReader\u0026 reader, Type typeToConvert, JsonSerializerOptions options, ReadStack\u0026 state, TCollection\u0026 value)\r\n   at System.Text.Json.Serialization.JsonConverter\u00601.TryRead(Utf8JsonReader\u0026 reader, Type typeToConvert, JsonSerializerOptions options, ReadStack\u0026 state, T\u0026 value)\r\n   at System.Text.Json.Serialization.Converters.SmallObjectWithParameterizedConstructorConverter\u00605.TryRead[TArg](ReadStack\u0026 state, Utf8JsonReader\u0026 reader, JsonParameterInfo jsonParameterInfo, TArg\u0026 arg)\r\n   at System.Text.Json.Serialization.Converters.SmallObjectWithParameterizedConstructorConverter\u00605.ReadAndCacheConstructorArgument(ReadStack\u0026 state, Utf8JsonReader\u0026 reader, JsonParameterInfo jsonParameterInfo)\r\n   at System.Text.Json.Serialization.Converters.ObjectWithParameterizedConstructorConverter\u00601.ReadConstructorArgumentsWithContinuation(ReadStack\u0026 state, Utf8JsonReader\u0026 reader, JsonSerializerOptions options)\r\n   at System.Text.Json.Serialization.Converters.ObjectWithParameterizedConstructorConverter\u00601.OnTryRead(Utf8JsonReader\u0026 reader, Type typeToConvert, JsonSerializerOptions options, ReadStack\u0026 state, T\u0026 value)\r\n   at System.Text.Json.Serialization.JsonConverter\u00601.TryRead(Utf8JsonReader\u0026 reader, Type typeToConvert, JsonSerializerOptions options, ReadStack\u0026 state, T\u0026 value)\r\n   at System.Text.Json.Serialization.JsonConverter\u00601.ReadCore(Utf8JsonReader\u0026 reader, JsonSerializerOptions options, ReadStack\u0026 state)\r\n   --- End of inner exception stack trace ---\r\n   at System.Text.Json.ThrowHelper.ReThrowWithPath(ReadStack\u0026 state, JsonReaderException ex)\r\n   at System.Text.Json.Serialization.JsonConverter\u00601.ReadCore(Utf8JsonReader\u0026 reader, JsonSerializerOptions options, ReadStack\u0026 state)\r\n   at System.Text.Json.Serialization.JsonConverter\u00601.ReadCoreAsObject(Utf8JsonReader\u0026 reader, JsonSerializerOptions options, ReadStack\u0026 state)\r\n   at System.Text.Json.JsonSerializer.ReadCore[TValue](Utf8JsonReader\u0026 reader, JsonTypeInfo jsonTypeInfo, ReadStack\u0026 state)\r\n   at System.Text.Json.JsonSerializer.ContinueDeserialize[TValue](ReadBufferState\u0026 bufferState, JsonReaderState\u0026 jsonReaderState, ReadStack\u0026 readStack, JsonTypeInfo jsonTypeInfo)\r\n   at System.Text.Json.JsonSerializer.ReadFromStreamAsync[TValue](Stream utf8Json, JsonTypeInfo jsonTypeInfo, CancellationToken cancellationToken)\r\n   at Microsoft.AspNetCore.Http.HttpRequestJsonExtensions.ReadFromJsonAsync(HttpRequest request, Type type, JsonSerializerOptions options, CancellationToken cancellationToken)\r\n   at Microsoft.AspNetCore.Http.HttpRequestJsonExtensions.ReadFromJsonAsync(HttpRequest request, Type type, JsonSerializerOptions options, CancellationToken cancellationToken)\r\n   at Microsoft.AspNetCore.Http.RequestDelegateFactory.\u003CHandleRequestBodyAndCompileRequestDelegateForJson\u003Eg__TryReadBodyAsync|89_0(HttpContext httpContext, Type bodyType, String parameterTypeName, String parameterName, Boolean allowEmptyRequestBody, Boolean throwOnBadRequest)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.AspNetCore.Http.RequestDelegateFactory.Log.InvalidJsonRequestBody(HttpContext httpContext, String parameterTypeName, String parameterName, Exception exception, Boolean shouldThrow)\r\n   at Microsoft.AspNetCore.Http.RequestDelegateFactory.\u003CHandleRequestBodyAndCompileRequestDelegateForJson\u003Eg__TryReadBodyAsync|89_0(HttpContext httpContext, Type bodyType, String parameterTypeName, String parameterName, Boolean allowEmptyRequestBody, Boolean throwOnBadRequest)\r\n   at Microsoft.AspNetCore.Http.RequestDelegateFactory.\u003C\u003Ec__DisplayClass89_2.\u003C\u003CHandleRequestBodyAndCompileRequestDelegateForJson\u003Eb__2\u003Ed.MoveNext()\r\n--- End of stack trace from previous location ---\r\n   at Microsoft.AspNetCore.Routing.EndpointMiddleware.\u003CInvoke\u003Eg__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)\r\n   at Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware.InvokeInternal(HttpContext context)\r\n   at Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddlewareImpl.\u003CInvoke\u003Eg__Awaited|8_0(ExceptionHandlerMiddlewareImpl middleware, HttpContext context, Task task)\r\n\u0060\u0060\u0060",
        "createdAt": "2023-01-18T16:56:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43831#issuecomment-1387388571"
      },
      {
        "id": "IC_kwDOAQzde85TN1rC",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "@liquidvapour am I correct in assuming you\u0027re seeing this behavior only when running in the \u0022Development\u0022 environment, i.e. launching from Visual Studio or via \u0060dotnet run\u0060?",
        "createdAt": "2023-01-18T21:53:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/43831#issuecomment-1396136642"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85Sdkqy",
    "title": "Rate limiting middleware - Statistics about rate limiters",
    "url": "https://github.com/dotnet/aspnetcore/issues/44140",
    "createdAt": "2022-09-23T08:46:48Z",
    "lastUpdated": "2024-02-14T20:30:01Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Is your feature request related to a problem? Please describe the problem.\r\n\r\nThe ASP.NET Core rate limiting middleware is great, but \u0022limited\u0022 in terms of what you an communicate with your users. Let\u0027s start with some code that you can write today in .NET 7:\r\n\r\n\u0060\u0060\u0060csharp\r\nbuilder.Services.AddRateLimiter(options =\u003E\r\n{\r\n    options.OnRejected = async (context, token) =\u003E\r\n    {\r\n        context.HttpContext.Response.StatusCode = 429;\r\n        if (context.Lease.TryGetMetadata(MetadataName.RetryAfter, out var retryAfter))\r\n        {\r\n            await context.HttpContext.Response.WriteAsync(\r\n                $\u0022Too many requests. Please try again after {retryAfter.TotalMinutes} minute(s). \u0022 \u002B\r\n                $\u0022Read more about our rate limits at https://example.org/docs/ratelimiting.\u0022, cancellationToken: token);\r\n        }\r\n        else\r\n        {\r\n            await context.HttpContext.Response.WriteAsync(\r\n                \u0022Too many requests. Please try again later. \u0022 \u002B\r\n                \u0022Read more about our rate limits at https://example.org/docs/ratelimiting.\u0022, cancellationToken: token);\r\n        }\r\n    };\r\n\r\n    // ...\r\n});\r\n\u0060\u0060\u0060\r\n\r\nWhen rate limits are triggered, a response is returned that tells the user they are rate limited, where to find more information, and (if the \u0060MetadataName.RetryAfter\u0060 data is available), when to retry.\r\n\r\nThis is quite limited. There\u0027s no access to which rate limiter fired, and what its statistics are.\r\n\r\nAdditionally, the current \u0060RateLimitLease\u0060 is only accessible when rate limiting is fired - not for every request. If you would want to return statistics about your limits (e.g. [like GitHub does](https://docs.github.com/en/rest/overview/resources-in-the-rest-api#rate-limit-http-headers)), you\u0027ll find it impossible to get statistics about the current lease in a custom middleware that can write out these additional headers.\r\n\r\n### Describe the solution you\u0027d like\r\n\r\nHere\u0027s a middleware that has access to some of data that I\u0027d want to access:\r\n\r\n\u0060\u0060\u0060csharp\r\npublic class RateLimitStatisticsMiddleware\r\n{\r\n    private readonly RequestDelegate _next;\r\n    private readonly IOptions\u003CRateLimiterOptions\u003E _options;\r\n\r\n    public RateLimitStatisticsMiddleware(RequestDelegate next, IOptions\u003CRateLimiterOptions\u003E options)\r\n    {\r\n        _next = next;\r\n        _options = options;\r\n    }\r\n\r\n    public Task Invoke(HttpContext context)\r\n    {\r\n        // Note: This should also work on endpoint limiters, but those are not available.\r\n        // There is no current \u0022rate limit context\u0022 of sorts. Including the policy name etc.\r\n        var globalLimiter = _options.Value.GlobalLimiter;\r\n        if (globalLimiter != null)\r\n        {\r\n            var statistics = globalLimiter.GetStatistics(context);\r\n            if (statistics != null)\r\n            {\r\n                // Note: It would be great to be able to get the TokenLimit from the \u0022current rate limiter context\u0022\r\n                context.Response.Headers.Add(\u0022X-Rate-Limit-Limit\u0022, \u002220\u0022);\r\n\r\n                // Note: It would be great to be able to get the Window from the \u0022current rate limiter context\u0022\r\n                context.Response.Headers.Add(\u0022X-Rate-Limit-Reset\u0022, DateTimeOffset.UtcNow.ToString(\u0022O\u0022));\r\n\r\n                // This one is there today\r\n                context.Response.Headers.Add(\u0022X-Rate-Limit-Remaining\u0022, statistics.CurrentAvailablePermits.ToString());\r\n            }\r\n        }\r\n\r\n        return _next(context);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThe dream scenario for a better ASP.NET Core rate limiter middleware would be to:\r\n\r\n* Have access to more statistics about the rate limiter (which policy fired, what partition, what are the limiter\u0027s options so I can emit a message that says \u0022you can only make 10 requests per minute\u0022, ...) in the rejected callbacks.\r\n* Have a feature on the current \u0060HttpContext\u0060 that gives access to the current rate limit context, so these details can also be returned on successful requests, or added to telemetry.\r\n\r\n### Additional context\r\n\r\nMost rate limiters in \u0060System.Threading.RateLimiting\u0060 don\u0027t provide additional statistics. This feature will need changes in both ASP.NET Core and the .NET framework.",
    "upvotes": 64,
    "labels": [
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85K5q-w",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@BrennanConroy @wtgodbe @halter73 ",
        "createdAt": "2022-09-23T20:14:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44140#issuecomment-1256632240"
      },
      {
        "id": "IC_kwDOAQzde85K_-g0",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-26T16:13:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44140#issuecomment-1258285108"
      },
      {
        "id": "IC_kwDOAQzde85K_-ln",
        "parentId": null,
        "author": "wtgodbe",
        "content": "I definitely think we should do this for dotnet 8",
        "createdAt": "2022-09-26T16:13:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44140#issuecomment-1258285415"
      },
      {
        "id": "IC_kwDOAQzde85NxezT",
        "parentId": null,
        "author": "cristipufu",
        "content": "\u003E Have a feature on the current HttpContext that gives access to the current rate limit context, so these details can also be returned on successful requests, or added to telemetry.\r\n\r\nHow would we handle this for multiple policies (eg global \u002B endpoint)?",
        "createdAt": "2022-11-06T14:41:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44140#issuecomment-1304816851"
      },
      {
        "id": "IC_kwDOAQzde85NxfEF",
        "parentId": null,
        "author": "maartenba",
        "content": "How does the runtime handle such case? I assume the most strict is applied?",
        "createdAt": "2022-11-06T14:47:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44140#issuecomment-1304817925"
      },
      {
        "id": "IC_kwDOAQzde85Pp-8L",
        "parentId": null,
        "author": "cristipufu",
        "content": "I think that \r\n\r\n- we should have an \u0060OnAcquired\u0060 func where we would have access to the successful lease which stores metadata information about the current rate limiter, similar to the \u0060OnRejected\u0060 func (this should be sufficient to return rate limiting http headers on successful requests as well) - the issue here would be with multiple rate limiters on the same endpoint, I\u0027m not sure how easy it is to decide which one is the most strict, but I don\u0027t think it actually matters that much. \r\n\r\n- we should somehow have access to the cached rate limiters, I want to be able to call \u0060GetStatistics()\u0060 on the application\u0027s rate limiters once in a while (in a background job) and map that data with OpenTelemetry.Metrics and show a nice graph of successful/failed requests per rate limiter with Promotheus. Thinking about it, this could also be achieved by writing a metric when OnAcquired/OnRejected and adding metadata about the current PartitionKey",
        "createdAt": "2022-12-04T12:58:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44140#issuecomment-1336405771"
      },
      {
        "id": "IC_kwDOAQzde85QUIIt",
        "parentId": null,
        "author": "MadL1me",
        "content": "@maartenba you said: \r\n\r\n\u003E Most rate limiters in System.Threading.RateLimiting don\u0027t provide additional statistics. This feature will need changes in both ASP.NET Core and the .NET framework.\r\n\r\nCan you please explain on the process how to do this? Do I need to send link to this issue in PR to other repo? Where I can find BCL (with rate .net base rate limiting) repo on a github? Do I need somehow to contact devs via issue submitting, or should I right away submit a PR? It would be great to have answers to those  ",
        "createdAt": "2022-12-12T22:52:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44140#issuecomment-1347453485"
      },
      {
        "id": "IC_kwDOAQzde85QWiFL",
        "parentId": null,
        "author": "maartenba",
        "content": "@MadL1me The BCL classes are in https://github.com/dotnet/runtime/tree/main/src/libraries/System.Threading.RateLimiting\r\n\r\nI am not Microsoft, so no idea how to do a PR across multiple repos/how to suggest such changes. @wtgodbe may be able to comment on that?",
        "createdAt": "2022-12-13T09:52:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44140#issuecomment-1348084043"
      },
      {
        "id": "IC_kwDOAQzde85QblUe",
        "parentId": null,
        "author": "wtgodbe",
        "content": "We ingest changes from dotnet/runtime via automated dependency updates. If your change to the BCL base limiter classes requires API change, you\u0027ll need to open a [formal API proposal](https://github.com/dotnet/runtime/issues/new?assignees=\u0026labels=api-suggestion\u0026template=02_api_proposal.yml\u0026title=%5BAPI\u002BProposal%5D%3A\u002B). Otherwise you can just open PR in dotnet/runtime and ask for review from myself, @BrennanConroy, and @Tratcher. Once your PR in is merged into dotnet/runtime, after a few hours an automated dependency update PR should get opened in this repo (will look like https://github.com/dotnet/aspnetcore/pull/45448). Once that\u0027s merged, your changes from dotnet/runtime will be available in this repo, and you can open your follow-up PR here.",
        "createdAt": "2022-12-13T18:17:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44140#issuecomment-1349408030"
      },
      {
        "id": "IC_kwDOAQzde85RajyV",
        "parentId": null,
        "author": "anandsowm",
        "content": "Yes, would be very useful feature. Looking at the different classes involved, there is no way to know how many permits have been issued so far for a given partition key. That would be good to have. Also is there a way to retain the count of leases issued between system restarts? It is right now stored in-memory, try to provide a way to plug in a persistence component.",
        "createdAt": "2022-12-27T13:51:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44140#issuecomment-1365916821"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85Sg4Bv",
    "title": "Consider updating the static file middleware to return cache-control: no-cache in Development",
    "url": "https://github.com/dotnet/aspnetcore/issues/44153",
    "createdAt": "2022-09-23T22:06:45Z",
    "lastUpdated": "2024-06-03T14:28:02Z",
    "body": "The static files middleware currently doesn\u0027t return any cache control headers in development, which can lead to static files getting cached and content changes not being reflected in the app. It would be convenient if the static files middleware add the cache-control: no-cache header when running in development to prevent caching issues.",
    "upvotes": 1,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85K7gPC",
        "parentId": null,
        "author": "Tratcher",
        "content": "It already includes LastModified and ETag, both of which are used as part of caching and validation. Any updates to the content should cause the cached value to be replaced upon re-validation. Have you seen cases where this isn\u0027t working? Is the client not re-validating? Maybe \u0060must-revalidate\u0060 would be a better option than \u0060no-cache\u0060.\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/23ea496cee168bdd8f7ed3c6d85ec78dbecc99f4/src/Middleware/StaticFiles/src/StaticFileContext.cs#L256-L257",
        "createdAt": "2022-09-25T03:41:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44153#issuecomment-1257112514"
      },
      {
        "id": "IC_kwDOAQzde85K_q-k",
        "parentId": null,
        "author": "danroth27",
        "content": "I messed around with this a bit with caching enabled and I wasn\u0027t able to reproduce a case where the cache isn\u0027t correctly invalidated. Looks like there\u0027s nothing to do here as far as I can tell.",
        "createdAt": "2022-09-26T15:19:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44153#issuecomment-1258205092"
      },
      {
        "id": "IC_kwDOAQzde85L0OIf",
        "parentId": null,
        "author": "Tratcher",
        "content": "Re-opening. There are reports that last-modified isn\u0027t reliable enough because clients choose how long to way before re-validating.\r\nSuggestion:\r\n- Add \u0060string? CacheControl\u0060 to StaticFileOptions\r\n- Set this to \u0060Cache-Control: max-age=0, must-revalidate\u0060 in the default host builder for IsDevelopment, but make sure it\u0027s easy to override for other environments.",
        "createdAt": "2022-10-07T18:56:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44153#issuecomment-1271980575"
      },
      {
        "id": "IC_kwDOAQzde85n8kJU",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "This still seems to be an issue and browsers can decide to more aggressively cache static files even on localhost if \u0060cache-control\u0060 is not set.",
        "createdAt": "2023-10-02T23:47:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44153#issuecomment-1743929940"
      },
      {
        "id": "IC_kwDOAQzde85_3rxC",
        "parentId": null,
        "author": "javiercn",
        "content": "FYI, \u0060MapStaticAssets\u0060 takes care of this by setting a no-cache policy for non-fingerprinted assets and an \u0060immutable\u0060 policy for fingerprinted ones.\r\n\r\nOnce the fingerprinting changes land, I\u0027ll update aspire to take advantage of them.",
        "createdAt": "2024-06-03T14:10:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44153#issuecomment-2145303618"
      },
      {
        "id": "IC_kwDOAQzde85_32lF",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "\u003E Once the fingerprinting changes land, I\u0027ll update aspire to take advantage of them.\r\n\r\n@javiercn what\u0027s the relation to the Aspire scenario?",
        "createdAt": "2024-06-03T14:28:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44153#issuecomment-2145347909"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85SqAAh",
    "title": ".NET 7.0: Output Caching: Evaluate policy after other middleware processed the request",
    "url": "https://github.com/dotnet/aspnetcore/issues/44191",
    "createdAt": "2022-09-26T21:22:40Z",
    "lastUpdated": "2024-02-14T20:31:06Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nWhen providing APIs to be used publicly, some error code like \u0060404\u0060 might worth to be cache longer than success code since we know this state won\u0027t change anytime soon.\r\n\r\nIn my case, I provide an API to search for subtitle for shows.\r\n\r\nThe api take the searched show from the URL. It\u0027s more than possible that said show isn\u0027t available on my service yet.\r\nI return a 404 and like to cache that result for longer than a succesful found show with subtitles.\n\n### Describe the solution you\u0027d like\n\nDelay evaluation of policy to when we have a response to let the developer use \u0060HttpContext.Response\u0060 as part of rule for matching policy, like its status code.\n\n### Additional context\n\nCurrently we have access to the response using the \u0060 .With(context =\u003E context.HttpContext.Response.StatusCode == 404);\u0060 when defining a policy. The issue is, since the response isn\u0027t created yet, the status code is always 200.\r\n\r\nSince there isn\u0027t yet a full documentation of the capabilities of the \u0060With\u0060 method, it can leads to unexpected cases.",
    "upvotes": 0,
    "labels": [
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85LMR3I",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-28T22:03:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44191#issuecomment-1261510088"
      },
      {
        "id": "IC_kwDOAQzde85LMbYH",
        "parentId": null,
        "author": "Belphemur",
        "content": "I understand on that case, the doc should specify that the response can\u0027t be used to make output cache policies.",
        "createdAt": "2022-09-28T23:00:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44191#issuecomment-1261549063"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85S3F5p",
    "title": "[Analyzer] Detect adding middleware services but middleware isn\u0027t used",
    "url": "https://github.com/dotnet/aspnetcore/issues/44243",
    "createdAt": "2022-09-29T02:51:44Z",
    "lastUpdated": "2024-02-14T20:31:10Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Is your feature request related to a problem? Please describe the problem.\r\n\r\nDevelopers can add the services for middleware, e.g. \u0060AddCors\u0060, and not realize that the middleware needs to be registered in middleware with \u0060UseCors\u0060. There is no error or indication to the developer about what they\u0027re missing.\r\n\r\n### Describe the solution you\u0027d like\r\n\r\nAn analyzer that looks at what middleware services are registered, what middleware is used in request pipeline, and warns the developer about middleware that\u0027s unused.\r\n\r\nWe can\u0027t infer what these names are so we\u0027d hard code AddMiddleware and UseMiddleware method names.\r\n\r\n### Additional context\r\n\r\n_No response_",
    "upvotes": 0,
    "labels": [
      "analyzer",
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85LNH81",
        "parentId": null,
        "author": "davidfowl",
        "content": "What happens if it\u0027s called by another method that the analyzer can\u0027t see the body of?",
        "createdAt": "2022-09-29T04:14:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44243#issuecomment-1261731637"
      },
      {
        "id": "IC_kwDOAQzde85LNIqx",
        "parentId": null,
        "author": "JamesNK",
        "content": "Suppress the warning? The developer could suppress with pragma in code or add it to NoWarn.\r\n\r\nAre you thinking of the situation of WebApplication which automatically adds UseAuthN and UseAuthZ to the middleware pipeline? The analyzer could detect WebApplication and infer that auth middleware is used.",
        "createdAt": "2022-09-29T04:19:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44243#issuecomment-1261734577"
      },
      {
        "id": "IC_kwDOAQzde85LNJjC",
        "parentId": null,
        "author": "davidfowl",
        "content": "Yes this is the only analyzer suggestion I think shouldn\u0027t be a warning by default. People will refactor things into methods and the analyzer will get confused quickly.",
        "createdAt": "2022-09-29T04:27:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44243#issuecomment-1261738178"
      },
      {
        "id": "IC_kwDOAQzde85LNKlp",
        "parentId": null,
        "author": "JamesNK",
        "content": "We might not necessarily be limited to detecting UseMiddleware calls in Main. We could check to see if there is an appropriate Use call anywhere in app code.\r\n\r\nDepending how robust this is (i.e. minimal false positives) can determine the diagnostic level.",
        "createdAt": "2022-09-29T04:35:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44243#issuecomment-1261742441"
      },
      {
        "id": "IC_kwDOAQzde85LNLen",
        "parentId": null,
        "author": "davidfowl",
        "content": "I\u0027ll feel better when I see how we plan to tackle that \uD83D\uDE03 ",
        "createdAt": "2022-09-29T04:42:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44243#issuecomment-1261746087"
      },
      {
        "id": "IC_kwDOAQzde85LVtKg",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-30T20:14:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44243#issuecomment-1263981216"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85S3NPA",
    "title": "[Analyzer] Detect middleware in pipeline after terminal middleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/44244",
    "createdAt": "2022-09-29T03:36:25Z",
    "lastUpdated": "2024-02-14T20:31:10Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nSome middleware is terminal. That means it doesn\u0027t call the next middleware (if present) and starts the request returning back down the pipeline. For example, \u0060UseSpa\u0060 is terminal.\r\n\r\nDevelopers could place middleware after \u0060UseSpa\u0060, not realizing it isn\u0027t executed. For example, \u0060UseEndpoints\u0060 after \u0060UseSpa\u0060.\r\n\r\nThis problem also happens with \u0060WebApplication\u0060, which implicitly adds \u0060UseEndpoints\u0060 to the end of the pipeline. Any terminal middleware prevents endpoints from being executed.\n\n### Describe the solution you\u0027d like\n\n* Detect middleware after terminal middleware and warn the developer.\r\n* (maybe) Detect terminal middleware with \u0060WebApplication\u0060. Warn the developer they may need to add UseEndpoints before terminal middleware.\n\n### Additional context\n\n_No response_",
    "upvotes": 2,
    "labels": [
      "analyzer",
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85LVtMx",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-09-30T20:14:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44244#issuecomment-1263981361"
      },
      {
        "id": "IC_kwDOAQzde85NWgw7",
        "parentId": null,
        "author": "juliushardt",
        "content": "Possibly related: When terminal middleware is used with \u0060WebApplication\u0060, it is required to use \u0060UseEndpoints()\u0060, as described above. However, the [analyzer for ASP0014](https://github.com/dotnet/aspnetcore/blob/8dc432556c937465edb2cdff4ab2ad7cbb16bd92/src/Framework/AspNetCoreAnalyzers/src/Analyzers/WebApplicationBuilder/WebApplicationBuilderAnalyzer.cs) unconditionally suggests top level route registrations even in this case, which may be confusing.\r\n\r\nScenario: I created a new ASP.NET Core web application using the \u0022ASP.NET Core Web App\u0022 template in Visual Studio and added the \u0060Spa\u0060 middleware from \u0060Microsoft.AspNetCore.SpaServices.Extensions\u0060:\r\n\u0060\u0060\u0060cs\r\n// Program.cs from the template\r\n// ...\r\napp.MapRazorPages();\r\n\r\n// I added the following lines:\r\nif (app.Environment.IsDevelopment())\r\n{\r\n\tapp.UseSpa(spa =\u003E\r\n\t{\r\n\t\tspa.UseProxyToSpaDevelopmentServer(\u0022http://127.0.0.1:5173\u0022);\r\n\t});\r\n}\r\n\r\napp.Run();\r\n\r\n\u0060\u0060\u0060\r\nThis preceding code does not work as expected, since \u0060UseSpa\u0060 is terminal and, hence, the ASP.NET routes (e.g. Razor Pages) are never executed. To fix this, I changed the code such that \u0060UseEndpoints()\u0060 is called explicitly:\r\n\u0060\u0060\u0060cs\r\n//app.MapRazorPages();\r\n\r\napp.UseEndpoints(endpoints =\u003E\r\n{\r\n\tendpoints.MapRazorPages();\r\n});\r\n\r\n\r\nif (app.Environment.IsDevelopment())\r\n{\r\n\tapp.UseSpa(spa =\u003E\r\n\t{\r\n\t\tspa.UseProxyToSpaDevelopmentServer(\u0022http://127.0.0.1:5173\u0022);\r\n\t});\r\n}\r\n\u0060\u0060\u0060\r\nThe modified code works, but results in code style warning [ASP0014](https://learn.microsoft.com/aspnet/core/diagnostics/asp0014?view=aspnetcore-7.0). As far as I can tell, there is no way to use \u0060UseSpa()\u0060 with the new hosting model without calling \u0060UseEndpoints()\u0060 explicitly. Therefore, when this issue is addressed, I suggest updating the analyzer for ASP0014 as well, such that is does not issue a warning if \u0060UseEndpoints()\u0060 is called before the registration of terminal middleware.",
        "createdAt": "2022-10-31T22:08:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44244#issuecomment-1297747003"
      },
      {
        "id": "IC_kwDOAQzde85RlgwU",
        "parentId": null,
        "author": "jornhd",
        "content": "I have a similar problem with Swagger. If I use app.MapGet(), I get \u0022No operations defined in spec!\u0022. When I wrap it in app.UseEndpoints() like before, Swagger works as expected, but then I get the AP0014 warning.\r\n\r\nEDIT:\r\nAfter further investigation, I found that that the problem is that I have a custom filter reading api description: \u0060app.Services.GetService\u003CIApiDescriptionGroupCollectionProvider\u003E().ApiDescriptionGroups.Items.ToList();\u0060 If I remove this it works, but as soon as I access the ApiDescriptionGroupCollectionProvider, I get \u0022No operations defined in spec!\u0022.\r\nAgain, no problem when wrapping the registrations in .UseEndpoints().",
        "createdAt": "2023-01-02T09:51:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44244#issuecomment-1368787988"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85UWV_B",
    "title": "RewriteMiddleware sets endpoint in pipeline before routing middleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/44639",
    "createdAt": "2022-10-19T15:04:57Z",
    "lastUpdated": "2024-02-14T21:10:26Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nI\u0027m attempting to use the RewriteMiddleware to (in part) select alternate paths for static files.  If I use the [UseRewriter](https://github.com/dotnet/aspnetcore/blob/14c39984660a8cefb09a8d77331b47ffc48d7a22/src/Middleware/Rewrite/src/RewriteBuilderExtensions.cs#L58) extension to register the middleware in the pipeline, endpoint evaluation/selection occurs sooner than expected on rewritten requests, which causes StaticFilesMiddleware to be [bypassed](https://github.com/dotnet/aspnetcore/blob/25ffef8fe5ad0ed67e0ad33b02379c2d3c1a890f/src/Middleware/StaticFiles/src/StaticFileMiddleware.cs#L75) when an alternate endpoint is found. I\u0027m using YARP to route all unserviceable requests to another application, so the YARP endpoint will always be selected in my case.\r\n\r\n\r\n### Expected Behavior\r\n\r\nI would expect the rewrite middleware to simply rewrite the request path and let the pipeline continue as configured.\r\n\r\n### Steps To Reproduce\r\n\r\nExample code here: https://github.com/bgulrich/rewrite-bug\r\n\r\nI took the template ASP.NET Core 6 WebApplication and moved \u0060wwwroot/favicon.ico\u0060 -\u003E \u0060wwwroot/test/favicon.ico\u0060 and configured the rewrite middlware to point \u0060/favicon.ico\u0060 request to this new location.  I also added the \u0060TestController\u0060 with an endpoint on the \u0060/test/favicon.ico\u0060 route.  My expectation is that this endpoint should not be reachable because it should be serviced by the static files middleware that appears earlier in the pipeline, but issuing a request to \u0060/favicon.ico\u0060 hits this endpoint instead because the RewriteMiddleware is setting the endpoint (checked with breakpoint in dummy middleware between rewrite and static files), causing StaticFilesMiddleware to bypass.\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n6.0.400\r\n\r\n### Anything else?\r\n\r\nMy current workaround is to register my RewriteOptions with the service provider and to register the RewriteMiddleware manually with \u0060app.Use\u003CRewriteMiddleware\u003E()\u0060 to avoid the UseRewrite extension that tweaks the pipline.",
    "upvotes": 0,
    "labels": [
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85MjdAi",
        "parentId": null,
        "author": "Tratcher",
        "content": "@BrennanConroy ",
        "createdAt": "2022-10-19T17:41:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44639#issuecomment-1284362274"
      },
      {
        "id": "IC_kwDOAQzde85Mke0g",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Triage: We want to keep the behavior of \u0060UseRewriter\u0060 but we should fix this so that the case that @bgulrich shared (where \u0060UseRouting()\u0060 is explicitly called) just works.\r\n\r\n@bgulrich Glad you found a workaround for it; that seems reasonable (though it\u0027s unfortunate that it\u0027s necessary).",
        "createdAt": "2022-10-19T22:19:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44639#issuecomment-1284631840"
      },
      {
        "id": "IC_kwDOAQzde85MkfDt",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-10-19T22:21:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44639#issuecomment-1284632813"
      },
      {
        "id": "IC_kwDOAQzde85MoKXf",
        "parentId": null,
        "author": "bgulrich",
        "content": "\u003E Triage: We want to keep the behavior of \u0060UseRewriter\u0060 but we should fix this so that the case that @bgulrich shared (where \u0060UseRouting()\u0060 is explicitly called) just works.\r\n\r\nMaybe just a flag in the options to opt-out of [this branching](https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/Rewrite/src/RewriteMiddleware.cs#L85).",
        "createdAt": "2022-10-20T13:59:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/44639#issuecomment-1285596639"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85WHlLP",
    "title": "OutputCaching not returning API version headers",
    "url": "https://github.com/dotnet/aspnetcore/issues/45016",
    "createdAt": "2022-11-11T02:23:39Z",
    "lastUpdated": "2024-09-13T21:51:12Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nWhen returning an item from the cache, the response headers are different based on cached vs non-cache. Specifically, the \u0022api-supported\u0022 header is missing.\r\n\r\n// First call - not cached\r\n api-supported-versions: 1.0 \r\n content-type: application/json; charset=utf-8 \r\n date: Fri,11 Nov 2022 02:18:26 GMT \r\n server: Kestrel \r\n\r\n// Second call - item cached\r\n age: 22 \r\n content-length: 39 \r\n content-type: application/json; charset=utf-8 \r\n date: Fri,11 Nov 2022 02:18:26 GMT \r\n server: Kestrel \n\n### Expected Behavior\n\nAll relevant headers that the client might need to inspect are present. in this case, the \u0022api-version\u0022\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n7.0.100\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85OWpB8",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@RoySalisbury it\u0027s likely that \u0060api-supported-versions\u0060 is being injected later in the pipeline than the output caching middleware runs, and therefore output caching can\u0027t cache it. \r\n\r\nWe have an issue to track addressing this: https://github.com/dotnet/aspnetcore/issues/39310",
        "createdAt": "2022-11-14T23:47:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45016#issuecomment-1314558076"
      },
      {
        "id": "IC_kwDOAQzde85OWpGC",
        "parentId": null,
        "author": "sebastienros",
        "content": "Note to myself, repro by inject a header by using \u0060OnStarting\u0060",
        "createdAt": "2022-11-14T23:47:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45016#issuecomment-1314558338"
      },
      {
        "id": "IC_kwDOAQzde85OjFz5",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-11-16T23:34:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45016#issuecomment-1317821689"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85W8hHQ",
    "title": "[Analyzer] Add missing services for registered middlewares",
    "url": "https://github.com/dotnet/aspnetcore/issues/45221",
    "createdAt": "2022-11-21T22:48:17Z",
    "lastUpdated": "2024-02-14T21:05:11Z",
    "body": "- Add the matching middleware when services have been registered (Cors, Ratelimiting, Authn, Authz)\r\n- Add required services when middlewares are registered\r\n- Enumerate scenarios where we warn for missing services in middleware at runtime based on a sentinel\r\n  - Using an analyzer instead of automatically registering at runtime gives the flexibility to the user to control ordering ",
    "upvotes": 0,
    "labels": [
      "api-suggestion",
      "analyzer",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85O2Mc2",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E * Add required services when middlewares aren\u0027t registered\r\n\r\n*are?",
        "createdAt": "2022-11-22T00:20:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45221#issuecomment-1322829622"
      },
      {
        "id": "IC_kwDOAQzde85O2f4A",
        "parentId": null,
        "author": "captainsafia",
        "content": "\u003E \u003E * Add required services when middlewares aren\u0027t registered\r\n\u003E \r\n\u003E *are?\r\n\r\nFixed! Thanks.",
        "createdAt": "2022-11-22T02:02:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45221#issuecomment-1322909184"
      },
      {
        "id": "IC_kwDOAQzde85UA3dE",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-01-30T23:24:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45221#issuecomment-1409513284"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85XfePS",
    "title": "Unable to remove Output Cache defaults",
    "url": "https://github.com/dotnet/aspnetcore/issues/45339",
    "createdAt": "2022-11-29T11:03:41Z",
    "lastUpdated": "2024-03-02T00:50:43Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nI\u0027m reading the article at: https://learn.microsoft.com/en-us/aspnet/core/performance/caching/output?view=aspnetcore-7.0#default-output-caching-policy. In particular, I\u0027m doing some tests about the default caching policy. According to it, by default: \r\n\r\n\u003E Responses to authenticated requests aren\u0027t cached.\r\n\r\nAnd then:\r\n\r\n\u003E The following code removes these defaults while applying caching to all of an app\u0027s endpoints:\r\n\u003E \r\n\u003E \u0060builder.Services.AddOutputCache();\u0060\r\n\r\nHowever, even with the above code, the following request isn\u0027t cached:\r\n\r\n\u0060\u0060\u0060\r\n\r\napp.UseOutputCache();\r\n\r\n// ...\r\n\r\napp.MapGet(\u0022/withcache\u0022, () =\u003E DateTime.UtcNow);\r\n\r\napp.Run();\r\n\u0060\u0060\u0060\r\n\r\nSo, if I don\u0027t call the \u0060.CacheOutput(\u0060) method after \u0060MapGet\u0060, the endpoint isn\u0027t cached, even if the documentation tells the opposite (because I have used \u0060builder.Services.AddOutputCache();\u0060, that applies caching to all of an app\u0027s endpoints). Moreover, it doesn\u0027t work also if I add \u0060CacheOutput()\u0060 and then \u0060RequireAuthorization()\u0060:\r\n\r\napp.MapGet(\u0022/withcache\u0022, () =\u003E DateTime.UtcNow).CacheOutput().RequireAuthorization();\r\n\r\n It seems that, despite the documentation, defaults aren\u0027t removed at all. The only way I manage to use cache output for authenticated requests is providing a custom \u0060IOutputCachePolicy \u0060implementation.\n\n### Expected Behavior\n\nAccording to the documentation, using \u0060builder.Services.AddOutputCache()\u0060; all the output caching defaults should be removed, so authenticated request should be cached as well.\n\n### Steps To Reproduce\n\nMinimal repro here: https://github.com/marcominerva/OutputCacheIssue.\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n7.0.100\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85PcfkF",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-11-30T23:26:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45339#issuecomment-1332869381"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85XvY-4",
    "title": "Add/Remove/Update rate limits from config, reloadable",
    "url": "https://github.com/dotnet/aspnetcore/issues/45407",
    "createdAt": "2022-12-01T22:26:18Z",
    "lastUpdated": "2024-03-02T00:51:25Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nApplications encountering issues in production will want to add, remove, or tune their rate limits on endpoints without recompiling their application, or even better, without restarting.\n\n### Describe the solution you\u0027d like\n\nEstablish a pattern and APIs for defining rate limits in config and associating them with endpoints. Ideally these would reload on change, but avoiding a recompilation is the minimum requirement.\n\n### Additional context\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "feature-rate-limit",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85P4Q4m",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-12-06T23:22:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45407#issuecomment-1340149286"
      },
      {
        "id": "IC_kwDOAQzde85P4RA0",
        "parentId": null,
        "author": "captainsafia",
        "content": "Triage: Will place in planning for prioritization.\r\n\r\n@Tratcher Did this come out of a user scenario or is it an original proposal?",
        "createdAt": "2022-12-06T23:23:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45407#issuecomment-1340149812"
      },
      {
        "id": "IC_kwDOAQzde85P8iMl",
        "parentId": null,
        "author": "Tratcher",
        "content": "This came from @sebastienros\u0027s designs for pre-built exe\u0027s that enable \u0026 configure middleware via config. It would also be useful for YARP.",
        "createdAt": "2022-12-07T16:52:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45407#issuecomment-1341268773"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85YqwYZ",
    "title": "Make Source Generator for UseMiddleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/45528",
    "createdAt": "2022-12-09T23:12:40Z",
    "lastUpdated": "2024-03-02T00:43:17Z",
    "body": "When I \u0060dotnet publish -c Release -p:PublishAot=true\u0060 the following app:\n\n\u0060\u0060\u0060C#\nvar app = new ApplicationBuilder(serviceProvider: null);\n\nUseMiddlewareExtensions.UseMiddleware\u003CHiMiddleware\u003E(app);\n\npublic class HiMiddleware\n{\n    public Task Invoke(HttpContext context)\n    {\n        Console.WriteLine(\u0022hi\u0022);\n        return Task.CompletedTask;\n    }\n}\n\u0060\u0060\u0060\n\nWe should create a Source Generator for \u0060UseMiddleware\u0060 so we don\u0027t need to use Reflection on NativeAOT. See #45890\n\n### Original issue (outdated)\n\nI get the following AOT warnings stemming from the \u0060UseMiddleware\u0060 method:\n\n\u0060\u0060\u0060\n/_/src/libraries/System.Linq.Expressions/src/System/Linq/Expressions/Interpreter/ArrayOperations.cs(23): AOT analysis warning IL3050: System.Linq.Expressions.Interpreter.NewArrayInitInstruction.Run(InterpretedFrame): Using member \u0027System.Array.CreateInstance(Type,Int32)\u0027 which has \u0027RequiresDynamicCodeAttribute\u0027 can break functionality when AOT compiling. The code for an array of the specified type might not be available. [C:\\DotNetTest\\AspNetTest\\AspNetTest.csproj]\n/_/src/libraries/System.Linq.Expressions/src/System/Linq/Expressions/Interpreter/ArrayOperations.cs(52): AOT analysis warning IL3050: System.Linq.Expressions.Interpreter.NewArrayInstruction.Run(InterpretedFrame): Using member \u0027System.Array.CreateInstance(Type,Int32)\u0027 which has \u0027RequiresDynamicCodeAttribute\u0027 can break functionality when AOT compiling. The code for an array of the specified type might not be available. [C:\\DotNetTest\\AspNetTest\\AspNetTest.csproj]\n/_/src/libraries/System.Linq.Expressions/src/System/Linq/Expressions/Interpreter/ArrayOperations.cs(87): AOT analysis warning IL3050: System.Linq.Expressions.Interpreter.NewArrayBoundsInstruction.Run(InterpretedFrame): Using member \u0027System.Array.CreateInstance(Type,Int32[])\u0027 which has \u0027RequiresDynamicCodeAttribute\u0027 can break functionality when AOT compiling. The code for an array of the specified type might not be available. [C:\\DotNetTest\\AspNetTest\\AspNetTest.csproj]\n/_/src/libraries/System.Linq.Expressions/src/System/Dynamic/Utils/TypeUtils.cs(28): AOT analysis warning IL3050: System.Dynamic.Utils.TypeUtils.GetNullableType(Type): Using member \u0027System.Type.MakeGenericType(Type[])\u0027 which has \u0027RequiresDynamicCodeAttribute\u0027 can break functionality when AOT compiling. The native code for this instantiation might not be available at runtime. [C:\\DotNetTest\\AspNetTest\\AspNetTest.csproj]\n/_/src/libraries/System.Linq.Expressions/src/System/Linq/Expressions/MethodCallExpression.cs(1379): AOT analysis warning IL3050: System.Linq.Expressions.Expression.ApplyTypeArgs(MethodInfo,Type[]): Using member \u0027System.Reflection.MethodInfo.MakeGenericMethod(Type[])\u0027 which has \u0027RequiresDynamicCodeAttribute\u0027 can break functionality when AOT compiling. The native code for this instantiation might not be available at runtime. [C:\\DotNetTest\\AspNetTest\\AspNetTest.csproj]\n/_/src/libraries/System.Linq.Expressions/src/System/Linq/Expressions/BinaryExpression.cs(2239): AOT analysis warning IL3050: System.Linq.Expressions.Expression.GetResultTypeOfShift(Type,Type): Using member \u0027System.Type.MakeGenericType(Type[])\u0027 which has \u0027RequiresDynamicCodeAttribute\u0027 can break functionality when AOT compiling. The native code for this instantiation might not be available at runtime. [C:\\DotNetTest\\AspNetTest\\AspNetTest.csproj]\n\u0060\u0060\u0060\u0060\n\nThis causes AOT warnings for ASP.NET apps that want to use EndPoints and Routing because we call \u0060UseMiddleware\u0060 to enable these features:\n\nhttps://github.com/dotnet/aspnetcore/blob/f543e3552514c5c420eeddd55c505bbc131f10a6/src/Http/Routing/src/Builder/EndpointRoutingApplicationBuilderExtensions.cs#L62\n\nhttps://github.com/dotnet/aspnetcore/blob/f543e3552514c5c420eeddd55c505bbc131f10a6/src/Http/Routing/src/Builder/EndpointRoutingApplicationBuilderExtensions.cs#L113\n\nAt a minimum, we should remove the AOT warnings from the above 2 callsites, so we can publish an ASP.NET Web API application for NativeAOT with no warnings.\n\nAs a follow up after that, we should consider a mechanism for solving this warning generally, for example with a source generator that generates the necessary code at compile-time.",
    "upvotes": 1,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85QUpWp",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2022-12-13T00:51:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45528#issuecomment-1347589545"
      },
      {
        "id": "IC_kwDOAQzde85Rw6kM",
        "parentId": null,
        "author": "JamesNK",
        "content": "@eerhardt How come these warnings are coming from System.Linq.Expressions files? Has that project not been annotated for AOT yet?",
        "createdAt": "2023-01-05T04:47:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45528#issuecomment-1371777292"
      },
      {
        "id": "IC_kwDOAQzde85RzoXW",
        "parentId": null,
        "author": "eerhardt",
        "content": "\u003E Has that project not been annotated for AOT yet?\r\n\r\nNo, it hasn\u0027t. There are a lot of libraries in dotnet/runtime that haven\u0027t been annotated for AOT. See https://github.com/dotnet/runtime/issues/75480.",
        "createdAt": "2023-01-05T17:07:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45528#issuecomment-1372489174"
      },
      {
        "id": "IC_kwDOAQzde85ST1NI",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-01-12T19:56:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45528#issuecomment-1380930376"
      },
      {
        "id": "IC_kwDOAQzde85ST1Py",
        "parentId": null,
        "author": "captainsafia",
        "content": "Triage: Parking this back in .NET 8 Planning to avoid it surfacing in the triage query.",
        "createdAt": "2023-01-12T19:56:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45528#issuecomment-1380930546"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85ZhBpI",
    "title": "Rate limiter context HttpContext feature API proposal",
    "url": "https://github.com/dotnet/aspnetcore/issues/45658",
    "createdAt": "2022-12-18T09:22:31Z",
    "lastUpdated": "2024-03-02T00:50:43Z",
    "body": "## Background and Motivation\r\n\r\nIn https://github.com/dotnet/aspnetcore/issues/44140 issue, one of The dream scenario for a better ASP.NET Core rate limiter middleware as @maartenba says, would be able Have a feature on the current HttpContext that gives access to the current rate limit context, so these details can also be returned on successful requests, or added to telemetry.. This API proposal addresses this concern.\r\n\r\n## Proposed API\r\n\r\n\u003C!--\r\nPlease provide the specific public API signature diff that you are proposing. For example:\r\nYou may find the [Framework Design Guidelines](https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/framework-design-guidelines-digest.md) helpful.\r\n--\u003E\r\n\r\nBelow API supposes, that we have \u0060RateLimiterMiddleware\u0060 in our app, which responsibility is to create \u0060IRateLimiterContextFeature\u0060 for each request:\r\n\r\n\u0060\u0060\u0060csharp\r\nvar app = builder.Build();\r\n\r\napp.UseRateLimiter();\r\n\u0060\u0060\u0060\r\n\r\nNow we can access to this interface in any custom middleware or controller:\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace Microsoft.AspNetCore.RateLimiting.Features;\r\n\r\npublic interface IRateLimiterContextFeature\r\n{\r\n     HttpContext HttpContext { get; set; }\r\n\r\n     RateLimitLease Lease { get; set; } \r\n\r\n     PartitionedRateLimiter\u003CHttpContext\u003E? GlobalLimiter { get; set; }\r\n\r\n     PartitionedRateLimiter\u003CHttpContext\u003E EndpointLimiter { get; set; }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n## Usage Examples\r\n\r\n### Scenario 1: get statistics from limiters in custom telemetry middleware:\r\n\r\n\u0060\u0060\u0060csharp\r\npublic Task Invoke(HttpContext context)\r\n{\r\n    var rlContext = context.Features.Get\u003CIRateLimiterContextFeature\u003E();\r\n\r\n    var globalStatistics = rlContext.GlobalLimiter.GetStatistics(context);\r\n    var endpointStatistics = rlContext.EndpointLimiter.GetStatistics(context);\r\n\r\n    _someTelemetryService.PushStatisticsToPrometheus(globalStatistics);\r\n    _someTelemetryService.PushStatisticsToPrometheus(endpointStatistics);\r\n}\r\n\u0060\u0060\u0060\r\n\r\n### Scenario 2: Get metadata from successful RateLimiterLease for this request\r\n\r\n\u0060\u0060\u0060csharp\r\npublic Task Invoke(HttpContext context)\r\n{\r\n    var rlContext = context.Features.Get\u003CIRateLimiterContextFeature\u003E();\r\n\r\n    if (rlContext.Lease.TryGetMetadata(\u0022SOME_METADATA\u0022, out var metadata)\r\n    {\r\n        // Do some additional stuff, depends on metadata\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n## Alternative Design - 1\r\n\r\nAs @Tratcher said, there is a risk, that \u0060RateLimitLease\u0060 would be disposed early. To prevent that, we can introduce facade-like class to wrap Lease with undisposable entity:\r\n\r\n\u0060\u0060\u0060cs\r\n\r\npublic interface IRateLimiterContextFeature\r\n{\r\n         HttpContext HttpContext { get; }\r\n\r\n         RateLimitLeaseInfo LeaseInfo { get; } \r\n\r\n         PartitionedRateLimiter\u003CHttpContext\u003E? GlobalLimiter { get; }\r\n\r\n         PartitionedRateLimiter\u003CHttpContext\u003E EndpointLimiter { get; }\r\n}\r\n\r\npublic abstract class RateLimitLeaseInfo \r\n{\r\n        // Same props as RateLimitLease, but without Dispose()\r\n}\r\n\u0060\u0060\u0060\r\n\r\n## Alternative Design - 2\r\n\r\nAlso, Instead of using \u0060HttpContext\u0060 Features, we can use \u0060HttpContext.Items\u0060 and Extension methods, like its done in \u0060Microsoft.AspNetCore.Authentication\u0060 extention methods (\u0060HttpContext.SingIn\u0060, \u0060HttpContext.ChallangeAsync\u0060, etc).\r\nSo, we use the Alternative Design - 1 approach with Facade-like api, but implemented with extension methods \r\n\r\n\u0060\u0060\u0060cs\r\n// very simple example of implementation (for only 1 method) just to show the API\r\npublic static class HttpContextRateLimiterExtentions\r\n{\r\n    public static RateLimiterStatistics GetRateLimiterStatistics(this HttpContext context)\r\n    {\r\n        // just for example - the code is not correct\r\n        var limiter = (PartitionedRateLimiter\u003CHttpContext\u003E)context.Items[\u0022SomeGlobalLimiter\u0022];\r\n        var stats = limiter?.GetStatistics(context);\r\n        return stats;\r\n    }\r\n}\r\n\r\n// and then in some middleware:\r\nvar statistics = HttpContext.GetRateLimiterStatistics();\r\n\u0060\u0060\u0060\r\n\r\n## Risks\r\n\r\nIn Design 1: \r\n- would anyone use this to dispose of the lease early? Would that have any strange side-effects, especially if it got double-disposed by the middleware later?",
    "upvotes": 0,
    "labels": [
      "api-needs-work",
      "feature-rate-limit",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85Q3mUj",
        "parentId": null,
        "author": "MadL1me",
        "content": "Related to #45652 ",
        "createdAt": "2022-12-18T09:24:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1356752163"
      },
      {
        "id": "IC_kwDOAQzde85Q8Xia",
        "parentId": null,
        "author": "Tratcher",
        "content": "Risk\r\n- would anyone use this to dispose of the lease early? Would that have any strange side-effects, especially if it got double-disposed by the middleware later?",
        "createdAt": "2022-12-19T17:28:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1358002330"
      },
      {
        "id": "IC_kwDOAQzde85Q-J4v",
        "parentId": null,
        "author": "Tratcher",
        "content": "IRateLimiterContextFeature - Consider making all of the properties read only. There\u0027s no scenario for replacing them, correct?",
        "createdAt": "2022-12-19T22:06:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1358470703"
      },
      {
        "id": "IC_kwDOAQzde85RAzk0",
        "parentId": null,
        "author": "MadL1me",
        "content": "Yep, I think making them read only would be best way to do. At firstly, I thought we can provide more flexibility by not restricting it, but there is really no way to use setters in any adequate scenario",
        "createdAt": "2022-12-20T10:45:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1359165748"
      },
      {
        "id": "IC_kwDOAQzde85RA6kb",
        "parentId": null,
        "author": "MadL1me",
        "content": "\u003E Risk\r\n\u003E \r\n\u003E * would anyone use this to dispose of the lease early? Would that have any strange side-effects, especially if it got double-disposed by the middleware later?\r\n\r\nInvestigated dotnet/runtime. All limiters there correctly implement IDisposable, and can\u0027t be disposed twice:\r\n- [ConcurrencyLimiter](https://github.com/dotnet/runtime/blob/3ce96fa45a536273f5e61600acd9868d5b34aeaf/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/ConcurrencyLimiter.cs#L373)\r\n- [SlidingWindowRateLimiter](https://github.com/dotnet/runtime/blob/3ce96fa45a536273f5e61600acd9868d5b34aeaf/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/SlidingWindowRateLimiter.cs#L381)\r\n- [TokenBucketRateLimiter](https://github.com/dotnet/runtime/blob/3ce96fa45a536273f5e61600acd9868d5b34aeaf/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/TokenBucketRateLimiter.cs#L383)\r\n- [DefaultPartitionedRateLimiter](https://github.com/dotnet/runtime/blob/3ce96fa45a536273f5e61600acd9868d5b34aeaf/src/libraries/System.Threading.RateLimiting/src/System/Threading/RateLimiting/DefaultPartitionedRateLimiter.cs#L102)\r\n\r\nYour point about disposing is right - yes, someone can dispose it later in middleware. I don\u0027t know about any scenarios how that can be used, all my thought about use case of this - add some (\u0022admin\u0022/\u0022user\u0022 filtering logic - something we can already do with partitioned rate limiter)\r\n",
        "createdAt": "2022-12-20T11:09:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1359194395"
      },
      {
        "id": "IC_kwDOAQzde85RK3qT",
        "parentId": null,
        "author": "MadL1me",
        "content": "After more thought, I think we can do this:\r\n\r\n\u0060\u0060\u0060csharp\r\nnamespace Microsoft.AspNetCore.RateLimiting.Features;\r\n\r\npublic interface IRateLimiterContextFeature\r\n{\r\n         HttpContext HttpContext { get; }\r\n\r\n         RateLimitLeaseInfo LeaseInfo { get; } \r\n\r\n         PartitionedRateLimiter\u003CHttpContext\u003E? GlobalLimiter { get; }\r\n\r\n         PartitionedRateLimiter\u003CHttpContext\u003E EndpointLimiter { get; }\r\n}\r\n\r\npublic abstract class RateLimitLeaseInfo \r\n{\r\n        public abstract bool IsAcquired { get; }\r\n\r\n        public abstract bool TryGetMetadata(string metadataName, out object? metadata);\r\n\r\n        public bool TryGetMetadata\u003CT\u003E(MetadataName\u003CT\u003E metadataName, [MaybeNull] out T metadata)\r\n        {\r\n            if (metadataName.Name == null)\r\n            {\r\n                metadata = default;\r\n                return false;\r\n            }\r\n\r\n            bool successful = TryGetMetadata(metadataName.Name, out object? rawMetadata);\r\n            if (successful)\r\n            {\r\n                metadata = rawMetadata is null ? default : (T)rawMetadata;\r\n                return true;\r\n            }\r\n\r\n            metadata = default;\r\n            return false;\r\n        }\r\n\r\n        public abstract IEnumerable\u003Cstring\u003E MetadataNames { get; }\r\n\r\n        public virtual IEnumerable\u003CKeyValuePair\u003Cstring, object?\u003E\u003E GetAllMetadata()\r\n        {\r\n            foreach (string name in MetadataNames)\r\n            {\r\n                if (TryGetMetadata(name, out object? metadata))\r\n                {\r\n                    yield return new KeyValuePair\u003Cstring, object?\u003E(name, metadata);\r\n                }\r\n            }\r\n        }\r\n}\r\n\u0060\u0060\u0060\r\nThere is 2 important changes:\r\n\r\n- All properties are read-only now (as @Tratcher proposed)\r\n- Instead of using RateLimitLease - we can use facade-like abstraction which have almost the same API, but without IDisposable, so problem with disposing and breaking invariants dissapear",
        "createdAt": "2022-12-21T18:14:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1361803923"
      },
      {
        "id": "IC_kwDOAQzde85RbFKj",
        "parentId": null,
        "author": "MadL1me",
        "content": "@Tratcher is there anything I can research/investigate for this issue to continue in discussing? I think #44140 is pretty wanted as feature set ",
        "createdAt": "2022-12-27T17:12:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1366053539"
      },
      {
        "id": "IC_kwDOAQzde85RbF-g",
        "parentId": null,
        "author": "Tratcher",
        "content": "We\u0027ll review the API in a week or two when people are back from the holidays.",
        "createdAt": "2022-12-27T17:18:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1366056864"
      },
      {
        "id": "IC_kwDOAQzde85RdZZA",
        "parentId": null,
        "author": "cristipufu",
        "content": "Let\u0027s imagine the statistics are stored in Redis/SQL, I wouldn\u0027t want to call GetStatistics() on every http request ",
        "createdAt": "2022-12-28T13:39:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1366660672"
      },
      {
        "id": "IC_kwDOAQzde85RqQSE",
        "parentId": null,
        "author": "Tratcher",
        "content": "Having HttpContext on a Feature interface is weirdly circular, normally you\u0027re retrieving features from the HttpContext. Why would you need to store the context?",
        "createdAt": "2023-01-03T17:20:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1370031236"
      },
      {
        "id": "IC_kwDOAQzde85Rq3Fh",
        "parentId": null,
        "author": "MadL1me",
        "content": "GetStatistics() require context as parameter, because limiters in middleware are PartitionedLimiter\u003CHttpContext\u003E and require context as parameter. I think it would be better for API , because for example, you only need to pass IRateLimiterContextFeature to method without HttpContext to do the job - get the statistics. All required things are stored in one interface.",
        "createdAt": "2023-01-03T20:22:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1370190177"
      },
      {
        "id": "IC_kwDOAQzde85Rq3SH",
        "parentId": null,
        "author": "MadL1me",
        "content": "Also, I added alternative design in first message: https://github.com/dotnet/aspnetcore/issues/45658#issue-1501829704",
        "createdAt": "2023-01-03T20:23:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1370190983"
      },
      {
        "id": "IC_kwDOAQzde85RvHqD",
        "parentId": null,
        "author": "??",
        "content": "Thank you for submitting this for API review. This will be reviewed by @dotnet/aspnet-api-review at the next meeting of the ASP.NET Core API Review group. Please ensure you take a look at [the API review process documentation](https://github.com/dotnet/aspnetcore/blob/main/docs/APIReviewProcess.md) and ensure that:\n\n* The PR contains changes to the reference-assembly that describe the API change. **Or**, you have included a snippet of reference-assembly-style code that illustrates the API change.\n* The PR describes the impact to users, both positive (useful new APIs) and negative (breaking changes).\n* Someone is assigned to \u0022champion\u0022 this change in the meeting, and they understand the impact and design of the change.",
        "createdAt": "2023-01-04T19:02:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1371306627"
      },
      {
        "id": "IC_kwDOAQzde85RvSNk",
        "parentId": null,
        "author": "halter73",
        "content": "How important is it to expose the global and endpoint \u0060PartitionedRateLimiter\u003CHttpContext\u003E\u0060 instances directly? Do we expect anyone will want to manually acquire additional leases with these? If that\u0027s something people really want to do, we might be able to expose both of these instances as services instead of features. Both \u0060PartitionedRateLimiter\u0060 instances are basically singletons, although you could have multiple if you\u0027re using multiple instances of the rate limiting middleware.\r\n\r\nIf acquiring additional leases is not a goal, it might be cleaner to expose \u0060RateLimiterStatistics? GetGlobalStatistics()\u0060 and \u0060RateLimiterStatistics? GetEndpointStatistics()\u0060 methods on the feature directly. That way we wouldn\u0027t have to worry about flowing the \u0060HttpContext\u0060. Do you have any thoughts on this @BrennanConroy ?",
        "createdAt": "2023-01-04T19:49:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1371349860"
      },
      {
        "id": "IC_kwDOAQzde85R1dF6",
        "parentId": null,
        "author": "halter73",
        "content": "API Review Notes:\r\n\r\n- Given that it might not be optimal to query statistics on every request, do we have a good way to query these statistics in the background? Putting the \u0060PartitionedRateLimiter\u003CHttpContext\u003E\u0060 instances in a singleton service might help with getting the limiters outside a request context, but you still need an HttpContext to call GetStatistics. Could we parameters the EndpointRateLimiter on Endpoint instead of HttpContext?\r\n  - In the future, the EndpointRateLimiter may partition within an endpoint. This doesn\u0027t happen today, but we\u0027d be locking ourselves in a bit if we expose a \u0060PartitionedRateLimiter\u003CEndpoint\u003E\u0060 instead of \u0060PartitionedRateLimiter\u003CHttpContext\u003E\u0060.\r\n  - And in the case of the global rate limiter we cannot really use any key other than \u0060HttpContext\u0060 because there could be a completely custom partitioning scheme.\r\n- What about \u0060RateLimitLeaseInfo\u0060 in Alternative Design - 1? We don\u0027t want people calling Dispose() on it themselves, but we\u0027re not sure this warrants a mostly redundant type.\r\n- An issue with making the rate limiters services is there could be multiple instances of the middleware.\r\n- Do we need the \u0060IRateLimiterContextFeature.HttpContext\u0060 property? It could be convenient to save passing around an extra object sometimes, but it seem unnecessary. It could always be added later if it\u0027s too difficult to use without it.\r\n- Do we want to make this opt-in? It could save an allocation if we don\u0027t pool. You don\u0027t have to opt in at the \u0060PartitionRateLimiter\u0060 level, but \u0060MemoryCache\u0060 has an opt-in API to avoid perf regressions. (https://github.com/dotnet/runtime/issues/50406#issuecomment-1074521694). We could pool \u0060IRateLimiterContextFeature\u0060 if we really want to.\r\n  - We could add an opt-out later in a non-breaking way, but that\u0027d be ugly for the majority of users who might not need this feature.\r\n  - Let\u0027s make it opt in.\r\n- We\u0027d like to provide \u0060GetStatistics()\u0060 APIs rather than expose the entire \u0060PartitionedRateLimiter\u003CHttpContext\u003E\u0060 yet. If it\u0027s the global one, it should be accessible to the user because they set it on the options.\r\n- Can we come up with a better name than IRateLimiterContextFeature? Can we segregate the interface?\r\n- Do we prefer \u0060IRateLimitLeaseFeature\u0060 or \u0060IRateLimiterLeaseFeature\u0060? Let\u0027s stick with \u0022RateLimiter\u0022 even though it doesn\u0027t appear in the \u0060RateLimitLease\u0060 type.\r\n- Should \u0060IRateLimiterLeaseFeature.Lease\u0060 be nullable? \u0060Endpoint\u0060 is nullable for the endpoint feature. And there won\u0027t be any lease if you disable rate limiting with the attribute, so yes.\r\n- Are we concerned about exposing the the RateLimitLease after it\u0027s disposed? Yes. Let\u0027s unset it. This means it\u0027s only accessible in inner middleware and OnRejected, but then we can pool.\r\n\r\nThe following version the the API is approved!\r\n\r\n\u0060\u0060\u0060diff\r\n\u002B namespace Microsoft.AspNetCore.RateLimiting.Features;\r\n\r\n\u002B public interface IRateLimiterStatisticsFeature\r\n\u002B {\r\n\u002B     RateLimiterStatistics? GetGlobalStatistics();\r\n\u002B     RateLimiterStatistics? GetEndpointStatistics();\r\n\u002B }\r\n\r\n\u002B public interface IRateLimiterLeaseFeature\r\n\u002B {\r\n\u002B      RateLimitLease? Lease { get; } \r\n\u002B }\r\n\r\nnamespace Microsoft.AspNetCore.RateLimiting;\r\n\r\npublic sealed class RateLimiterOptions\r\n{\r\n    // IRateLimiterStatisticsFeature won\u0027t be set unless this is opted into, but will not be unset after the rate limiting middleware exits.\r\n    // IRateLimiterLeaseFeature will always be set, but we should be able to pool it since we unset to avoid exposing a disposed lease.\r\n\u002B    public bool TrackStatistics { get; set; }\r\n}\r\n\u0060\u0060\u0060",
        "createdAt": "2023-01-06T00:21:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1372967290"
      },
      {
        "id": "IC_kwDOAQzde85R5ZHu",
        "parentId": null,
        "author": "MadL1me",
        "content": "@halter73 thank you for review, and sorry if my proposal wasted a lot of time to rethinking my design. I\u0027ll try to learn from your thought process, and I hope I\u0027ll make better API proposals next time ",
        "createdAt": "2023-01-06T18:44:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1373999598"
      },
      {
        "id": "IC_kwDOAQzde85R5jum",
        "parentId": null,
        "author": "halter73",
        "content": "@MadL1me Your proposal was really good and got us thinking in the right direction. Thanks!\r\n\r\nAnd the API review notes are not from me specifically. I\u0027m summarizing feedback from a bunch of engineers who discussed this in an API review meeting. I don\u0027t think any one of us would have come up with this exact design initially. It\u0027s a process.",
        "createdAt": "2023-01-06T19:36:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1374043046"
      },
      {
        "id": "IC_kwDOAQzde85SC2rp",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@MadL1me Will you be updating your PR (https://github.com/dotnet/aspnetcore/pull/45652/files) based on this API review feedback?",
        "createdAt": "2023-01-09T23:20:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1376479977"
      },
      {
        "id": "IC_kwDOAQzde85SDyOp",
        "parentId": null,
        "author": "MadL1me",
        "content": "Yes! I have an exam in 2 days, after that I\u0027ll submit a PR \n@adityamandaleeka ",
        "createdAt": "2023-01-10T04:36:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1376723881"
      },
      {
        "id": "IC_kwDOAQzde85SLcuf",
        "parentId": null,
        "author": "MadL1me",
        "content": "Decided to make proposed this API with 2 separate PR\u0027s for each feature, so I\u0027m closed this old PR (https://github.com/dotnet/aspnetcore/pull/45652). All work is moved to https://github.com/dotnet/aspnetcore/pull/46028",
        "createdAt": "2023-01-11T13:13:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1378732959"
      },
      {
        "id": "IC_kwDOAQzde85SO15e",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-01-11T23:40:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1379622494"
      },
      {
        "id": "IC_kwDOAQzde85SO7eA",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@MadL1me Thanks, and feel free to ignore the bot message above. Look forward to seeing your PRs go in!",
        "createdAt": "2023-01-12T00:14:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1379645312"
      },
      {
        "id": "IC_kwDOAQzde85SUOJ3",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E \u0060\u0060\u0060diff\r\n\u003E \u002B namespace Microsoft.AspNetCore.RateLimiting.Features;\r\n\u003E \u0060\u0060\u0060\r\n\r\n@halter73 why did we decide to put this in the Features namespace? That\u0027s not something we\u0027ve done for other components like \r\nhttps://github.com/dotnet/aspnetcore/blob/334da01db159058defbd39f128d659ddf3ae3f7e/src/Middleware/OutputCaching/src/IOutputCacheFeature.cs#L4-L9\r\nhttps://github.com/dotnet/aspnetcore/blob/334da01db159058defbd39f128d659ddf3ae3f7e/src/Middleware/Diagnostics.Abstractions/src/IExceptionHandlerFeature.cs#L7-L12",
        "createdAt": "2023-01-12T21:50:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1381032567"
      },
      {
        "id": "IC_kwDOAQzde85SUzKE",
        "parentId": null,
        "author": "davidfowl",
        "content": "Agreed",
        "createdAt": "2023-01-13T01:16:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1381184132"
      },
      {
        "id": "IC_kwDOAQzde85SVLqU",
        "parentId": null,
        "author": "halter73",
        "content": "I think we added the namespace because most of our HTTP and connection-level features live in Features namespaces, and we wanted to be consistent. However, I agree we should move the new features middleware\u0027s primary namespace considering we\u0027ve already done that for output caching and exception handler middleware. It\u0027s nice to have less namespaces, and it\u0027s not like it\u0027s too cluttered.",
        "createdAt": "2023-01-13T03:56:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1381284500"
      },
      {
        "id": "IC_kwDOAQzde85SVLqr",
        "parentId": null,
        "author": "??",
        "content": "Thank you for submitting this for API review. This will be reviewed by @dotnet/aspnet-api-review at the next meeting of the ASP.NET Core API Review group. Please ensure you take a look at [the API review process documentation](https://github.com/dotnet/aspnetcore/blob/main/docs/APIReviewProcess.md) and ensure that:\n\n* The PR contains changes to the reference-assembly that describe the API change. **Or**, you have included a snippet of reference-assembly-style code that illustrates the API change.\n* The PR describes the impact to users, both positive (useful new APIs) and negative (breaking changes).\n* Someone is assigned to \u0022champion\u0022 this change in the meeting, and they understand the impact and design of the change.",
        "createdAt": "2023-01-13T03:56:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1381284523"
      },
      {
        "id": "IC_kwDOAQzde85SXg8C",
        "parentId": null,
        "author": "MadL1me",
        "content": "@halter73 in your message (https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1372967290) you wrote: \r\n\u003E IRateLimiterLeaseFeature will always be set, but we should be able to pool it since we unset to avoid exposing a disposed lease.\r\n\r\nCan you please clarify what that means? How is object pooling corresponds with avoiding exposing disposed lease?",
        "createdAt": "2023-01-13T13:57:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1381895938"
      },
      {
        "id": "IC_kwDOAQzde85SmP5U",
        "parentId": null,
        "author": "halter73",
        "content": "\u003E Can you please clarify what that means? How is object pooling corresponds with avoiding exposing disposed lease?\r\n\r\nI wouldn\u0027t do this as part of the initial change. But if we wanted to later, we could return the object to the pool in the rate limiting middleware after we unset the feature. We do not want to pool anything that is still accessible via the HttpContext.",
        "createdAt": "2023-01-17T17:14:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1385758292"
      },
      {
        "id": "IC_kwDOAQzde85SmnCt",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "Thinking about this a little, the \u0060GetEndpointStatistics\u0060 and \u0060GetGlobalStatistics\u0060 methods imply getting statistics for the specific Endpoint and for the whole app respectively. But in reality, they are getting statistics for a **specific request type** at the app level and at the \u0060Endpoint\u0060 level.\r\n\r\nWhat that means is that the statistics can be very different per request even if the requests end up on the same \u0060Endpoint\u0060. For example, if you partition based on \u0060User\u0060 or query string you\u0027ll get a completely different limiter, even though the request goes to the same \u0060Endpoint\u0060, which means when you call one of the statistics methods you will get completely different statistics.\r\n\r\nThe method naming/usage does little to suggest this behavior which I would argue is going to be confusing to users.",
        "createdAt": "2023-01-17T18:30:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1385853101"
      },
      {
        "id": "IC_kwDOAQzde85TSoTo",
        "parentId": null,
        "author": "halter73",
        "content": "That is a good point about the naming not indicating that the statistics are arbitrarily partitioned based on how the policies and/or global limiters are configured.\r\n\r\nDo you have any suggestions for names that would make this clearer? Maybe something like \u0060GetCurrentPartitionStatistics()\u0060? The downside is that you couldn\u0027t query *just* the global or endpoint statistics for the given request, but I think that might be okay.\r\n\r\n\u0060\u0060\u0060diff\r\n\u002B namespace Microsoft.AspNetCore.RateLimiting;\r\n\r\n\u002B public interface IRateLimiterStatisticsFeature\r\n\u002B {\r\n\u002B     RateLimiterMiddlewareStatistics GetCurrentPartitionStatistics();\r\n\u002B }\r\n\r\n\u002B public sealed class RateLimiterMiddlewareStatistics\r\n\u002B {\r\n\u002B     RateLimiterStatistics? GlobalStatistics { get; init; }\r\n\u002B     RateLimiterStatistics? EndpointStatistics { get; init; }\r\n\u002B }\r\n\u0060\u0060\u0060",
        "createdAt": "2023-01-19T18:00:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1397392616"
      },
      {
        "id": "IC_kwDOAQzde85TT8Cn",
        "parentId": null,
        "author": "halter73",
        "content": "API Review Notes:\r\n\r\n- We like removing the \u0060Microsoft.AspNetCore.RateLimiting.Features\u0060 namespace.\r\n- We still are not sure what we want to do about the confusing nature of \u0060IRateLimiterStatisticsFeature\u0060 only referencing the partition of the current request. We think it\u0027s fine to do that, but it might not be obvious enough what\u0027s really going on given the current API naming.\r\n\r\nWe will try to get back to this in API review Monday. I\u0027m leaving it to @BrennanConroy to improve the proposal since he doesn\u0027t like my proposal \uD83D\uDE06 .",
        "createdAt": "2023-01-19T23:20:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1397735591"
      },
      {
        "id": "IC_kwDOAQzde85Ycu_b",
        "parentId": null,
        "author": "MadL1me",
        "content": "\u003E Thinking about this a little, the GetEndpointStatistics and GetGlobalStatistics methods imply getting statistics for the specific Endpoint and for the whole app respectively. But in reality, they are getting statistics for a specific request type at the app level and at the Endpoint level.\r\n\r\nWhat if we try to do it that way? For example, we could return a \u0060List\u0060 of statistics, because we know that Middleware always uses \u0060PartitionedRateLimiter\u0060:\r\n\r\n\u0060\u0060\u0060cs\r\npublic sealed class RateLimiterMiddlewareStatistics\r\n{\r\n     // new props, contain statistics for ALL limiters in PartitonedRateLimiter\r\n     List\u003CRateLimiterStatistics?\u003E GlobalStatistics { get; init; }\r\n     List\u003CRateLimiterStatistics?\u003E EndpointStatistics { get; init; }\r\n      \r\n     // props proposed before, renamed to indicate that partition is used\r\n     RateLimiterStatistics? PartitionGlobalStatistics{ get; init; }\r\n     RateLimiterStatistics? PartitionEndpointStatistics { get; init; }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nHowever, this probably would require add methods to fetch all statistics from \u0060PartitionedRateLimiter\u0060.",
        "createdAt": "2023-03-25T21:36:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1483927515"
      },
      {
        "id": "IC_kwDOAQzde85ZBTti",
        "parentId": null,
        "author": "mitchdenny",
        "content": "@halter73 bubbling this to the top of your stack. See issue #47456 where a scenario involving accessing the rate limiter from the feature came up. Basically the idea is that in addition to getting a ticket to execute the endpoint, the developer might decide to eat up some additional tickets after execution IF the request warranted it.\r\n\r\nSometimes it\u0027s hard to know whether a given request will be expensive in advance, so deducting the tickets after execution.",
        "createdAt": "2023-04-03T01:35:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1493515106"
      },
      {
        "id": "IC_kwDOAQzde85ZEGR-",
        "parentId": null,
        "author": "MadL1me",
        "content": "@halter73 @mitchdenny  I think we should combine statistics solution with #47456 idea.\r\n\r\nIf we create and expose entire \u0060IRateLimiterFeature\u0060, it\u0027ll make possible for a custom \u0060RateLimiterMiddleware\u0060 to be made, which we can use with #47456 scenario as well as \u0022fetching Statistics\u0022 problem. ",
        "createdAt": "2023-04-03T12:37:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1494246526"
      },
      {
        "id": "IC_kwDOAQzde85geRbc",
        "parentId": null,
        "author": "mitchdenny",
        "content": "It looks like this hasn\u0027t been implemented yet. I\u0027d like to revisit the conversation in light of the following issue:\r\n\r\nhttps://github.com/dotnet/aspnetcore/issues/47456\r\n\r\nThis issue illustrates a scenario where being able to access the global/endpoint limiters via a feature inside some middleware could be useful. For example you might use rate limiters to automatically consume a token for every request, but after a request has been processed you might decide that particular request was more expensive so you want to take more tokens.\r\n\r\nIf we exposed the rate limiters via a feature this could be easily implemented. Even though this API proposal was more about statistics, by exposing the rate limiters we would allow both scenarios.\r\n\r\n/cc @halter73 ",
        "createdAt": "2023-07-03T14:58:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1618548444"
      },
      {
        "id": "IC_kwDOAQzde85gx7zc",
        "parentId": null,
        "author": "MadL1me",
        "content": "@mitchdenny agreed, I think exposing limiters via features would add a great flexibility to feature usage. I would like to continue to work on this issue, after .net team discussion.",
        "createdAt": "2023-07-06T13:40:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1623702748"
      },
      {
        "id": "IC_kwDOAQzde85v6NSX",
        "parentId": null,
        "author": "hacst",
        "content": "It seems like some parts of this proposal are still stuck in the discussion phase. Personally I am not that interested in the \u0060IRateLimiterStatisticsFeature\u0060 portion right now but in accessing the current lease using the proposed \u0060IRateLimiterLeaseFeature\u0060.\r\n\r\nIn https://github.com/cristipufu/aspnetcore-redis-rate-limiting/wiki/Rate-Limiting-Headers when acquiring the lease remaining/limit/reset information is cheaply available, stored in the lease and made available as metadata on the lease. Having \u0060IRateLimiterLeaseFeature\u0060 would solve the initial idea behind #44140 on its own for these rate limiters and others using a similar approach. As far as I can tell it is also the only approach to return exact values from the time of acquire if they are available. It would of course also unlock any other use-case that can be built based on the lease information on its own.\r\n\r\n@BrennanConroy (or whoever can decide this): Is it possible to approve and pursue \u0060IRateLimiterLeaseFeature\u0060 independently of the statistics specific parts of the proposal?",
        "createdAt": "2024-01-04T17:56:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1877529751"
      },
      {
        "id": "IC_kwDOAQzde85v6Ni_",
        "parentId": null,
        "author": "hacst",
        "content": "Independent of my previous question I have some thoughts on the statistics portion of the proposal: [RateLimiter.GetStatistics](https://learn.microsoft.com/en-us/dotnet/api/system.threading.ratelimiting.ratelimiter.getstatistics?view=aspnetcore-8.0) is a blocking method without any specific guidance on how it should behave. \r\n\r\nIf the expectation is to be able to readily call it for every request to populate RateLimiterStatistics fields this has to be clarified as that is not easily achieved in distributed scenarios. E.g. just doing a redis query in there as https://github.com/cristipufu/aspnetcore-redis-rate-limiting/ does will lead to thread pool exhaustion with a bit of load. https://github.com/dotnet/runtime/issues/88592 proposes an async variant of \u0060GetStatistics\u0060 but it hasn\u0027t progressed yet and it might still be an expensive call.\r\n\r\nIf the expectation is to do updates in the background around the calls as hinted at in the review discussion from Jan 6th 23 I am unsure how that could be achieved generically in an efficient way for a heavily partitioned rate limiter. It could always serve stale data from the last call and schedule a refresh after but that might get very stale and will not work for the first call. Doing regular updates outside of that would retrieve a lot of statistics for rate limiters you might not end up needing for any request in that timeframe. Also bound to be a bit stale but more predictable.\r\n\r\nThe rate limiter itself might be able to get up-to-date statistics and cache them for \u0060GetStatistics\u0060 calls when a lease is acquired. Where possible that would give the best results for this proposal and #44140. But then what about other uses of \u0060GetStatistics\u0060 outside of a specific request context that expect to get a current snapshot?\r\n\r\nTL;DR: Imo behavior of [RateLimiter.GetStatistics](https://learn.microsoft.com/en-us/dotnet/api/system.threading.ratelimiting.ratelimiter.getstatistics?view=aspnetcore-8.0) has to be clarified before it is possible to say whether it can be safely and efficiently used to retrieve statistics here.",
        "createdAt": "2024-01-04T17:57:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1877530815"
      },
      {
        "id": "IC_kwDOAQzde85v_yC9",
        "parentId": null,
        "author": "abergs",
        "content": "Came across this issue while googling and I\u0027ll just add on here that I\u0027ve been experimenting with consuming a variable amount of tokens, but also to manually acquire leases and expect the statistics. So I\u0027d very much like a nice way to get access to active limiters.",
        "createdAt": "2024-01-05T17:04:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45658#issuecomment-1878991037"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85ZpcXy",
    "title": "Rate Limiting configuration - policy validation",
    "url": "https://github.com/dotnet/aspnetcore/issues/45684",
    "createdAt": "2022-12-20T06:08:21Z",
    "lastUpdated": "2024-02-14T20:59:04Z",
    "body": "## Background and Motivation\r\n\r\nThe ASP.NET Core rate limiting middleware is great, but \u0022limited\u0022 in terms of policy validation. Let\u0027s start with some code that you can write today in .NET 7:\r\n\r\n\u0060\u0060\u0060cs\r\nbuilder.Services.AddRateLimiter(options =\u003E\r\n{\r\n    options.AddFixedWindowLimiter(\u0022customPolicy\u0022, opt =\u003E\r\n    {\r\n        opt.PermitLimit = 4;\r\n        opt.Window = TimeSpan.FromSeconds(12);\r\n        opt.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;\r\n        opt.QueueLimit = 2;\r\n    });\r\n    // ...\r\n});\r\n\u0060\u0060\u0060\r\n\r\nThere is no way to validate that \u0060customPolicy\u0060 actually exists. This is useful when configuring multiple routes from configuration such as is the case for YARP. See https://github.com/microsoft/reverse-proxy/pull/1967\r\n\r\n## Proposed API\r\n\r\nIt would be preferred to something similar to [\u0060IAuthorizationPolicyProvider\u0060](https://github.com/dotnet/aspnetcore/blob/2b63a5fc7fee6944af03723767be2335f1d9bf9c/src/Security/Authorization/Core/src/IAuthorizationPolicyProvider.cs) implemented via [\u0060DefaultAuthorizationPolicyProvider\u0060](https://github.com/dotnet/aspnetcore/blob/2b63a5fc7fee6944af03723767be2335f1d9bf9c/src/Security/Authorization/Core/src/DefaultAuthorizationPolicyProvider.cs) and [\u0060ICorsPolicyProvider\u0060](https://github.com/dotnet/aspnetcore/blob/2b63a5fc7fee6944af03723767be2335f1d9bf9c/src/Middleware/CORS/src/Infrastructure/ICorsPolicyProvider.cs) implemented via [\u0060DefaultCorsPolicyProvider\u0060](https://github.com/dotnet/aspnetcore/blob/2b63a5fc7fee6944af03723767be2335f1d9bf9c/src/Middleware/CORS/src/Infrastructure/DefaultCorsPolicyProvider.cs)\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.AspNetCore.RateLimiting;\r\n\r\n-  internal struct DefaultKeyType \r\n\u002B  public struct DefaultKeyType \r\n{\r\n// omitted ...\r\n}\r\n\u002B\r\n\u002B public interface IRateLimiterPolicyProvider\r\n\u002B {\r\n\u002B     ValueTask\u003CIRateLimiterPolicy\u003CDefaultKeyType\u003E?\u003E GetDefaultPolicyAsync();\r\n\u002B     ValueTask\u003CIRateLimiterPolicy\u003CDefaultKeyType\u003E?\u003E GetPolicyAsync(string policyName);\r\n\u002B }\r\n\u002B\r\n\u002B public class DefaultRateLimiterPolicyProvider : IRateLimiterPolicyProvider\r\n\u002B {\r\n\u002B     private readonly RateLimiterOptions _options;\r\n\u002B     \r\n\u002B     public DefaultRateLimiterPolicyProvider(IOptions\u003CRateLimiterOptions\u003E options)\r\n\u002B     {\r\n\u002B     \r\n\u002B     }\r\n\u002B     \r\n\u002B     public ValueTask\u003CIRateLimiterPolicy\u003CDefaultKeyType\u003E?\u003E GetPolicyAsync(string policyName)\r\n\u002B     {\r\n\u002B         options.PolicyMap[policyName] ?? options.UnactivatedPolicyMap[policyName];\r\n\u002B     }\r\n\u002B }\r\n\u0060\u0060\u0060\r\n\r\n\u0060RateLimiterOptions.PolicyMap\u0060 is internal hence this feature cannot be added in another library or the final application. \r\n\r\n## Usage Examples\r\n\r\nSee YARP: https://github.com/microsoft/reverse-proxy/blob/26ce1d15f868cb8da1891d65db1e59a20fd6ecbf/src/ReverseProxy/Configuration/ConfigValidator.cs#L312-L318\r\n\r\n## Alternative Designs\r\n\r\nNone\r\n\r\n## Risks\r\n\r\nNone\r\n",
    "upvotes": 0,
    "labels": [
      "api-needs-work",
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85Rv_pb",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Triage: this seems like a reasonable suggestion (a way to find out about these issues at load-time rather than run-time).\r\n\r\nWould an API that returned a bool (indicating whether the policy exists) be sufficient?",
        "createdAt": "2023-01-04T23:16:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45684#issuecomment-1371535963"
      },
      {
        "id": "IC_kwDOAQzde85Rv_05",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@mburumaxwell Can you update your comment to make it follow the API proposal template here? https://github.com/dotnet/aspnetcore/issues/new?assignees=\u0026labels=api-suggestion\u0026template=30_api_proposal.md\u0026title=",
        "createdAt": "2023-01-04T23:17:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45684#issuecomment-1371536697"
      },
      {
        "id": "IC_kwDOAQzde85SE2Tq",
        "parentId": null,
        "author": "mburumaxwell",
        "content": "@adityamandaleeka this is done",
        "createdAt": "2023-01-10T09:59:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45684#issuecomment-1377002730"
      },
      {
        "id": "IC_kwDOAQzde85SIK5e",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Thanks @mburumaxwell ",
        "createdAt": "2023-01-10T21:17:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45684#issuecomment-1377873502"
      },
      {
        "id": "IC_kwDOAQzde85SXpSA",
        "parentId": null,
        "author": "mburumaxwell",
        "content": "What steps follow to get this to be in the next version of AspNetCore?",
        "createdAt": "2023-01-13T14:24:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45684#issuecomment-1381930112"
      },
      {
        "id": "IC_kwDOAQzde85SZc5Q",
        "parentId": null,
        "author": "??",
        "content": "Thank you for submitting this for API review. This will be reviewed by @dotnet/aspnet-api-review at the next meeting of the ASP.NET Core API Review group. Please ensure you take a look at [the API review process documentation](https://github.com/dotnet/aspnetcore/blob/main/docs/APIReviewProcess.md) and ensure that:\n\n* The PR contains changes to the reference-assembly that describe the API change. **Or**, you have included a snippet of reference-assembly-style code that illustrates the API change.\n* The PR describes the impact to users, both positive (useful new APIs) and negative (breaking changes).\n* Someone is assigned to \u0022champion\u0022 this change in the meeting, and they understand the impact and design of the change.",
        "createdAt": "2023-01-13T21:20:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45684#issuecomment-1382403664"
      },
      {
        "id": "IC_kwDOAQzde85SZd0J",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "This proposal will be discussed by our team in an upcoming API review meeting, after which we\u0027ll provide feedback/suggestions.\r\n\r\nOnce a proposal gets to the \u0060api-approved\u0060 state, we\u0027ll be ready to take a PR to implement the change.",
        "createdAt": "2023-01-13T21:24:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45684#issuecomment-1382407433"
      },
      {
        "id": "IC_kwDOAQzde85UA5v7",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-01-30T23:34:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45684#issuecomment-1409522683"
      },
      {
        "id": "IC_kwDOAQzde85iP7ey",
        "parentId": null,
        "author": "halter73",
        "content": "API Review Notes:\r\n\r\n- We don\u0027t like making the DefaultKeyType public if possible.\r\n- It\u0027s not clear what you\u0027d use the \u0060IRateLimiterPolicy\u003CDefaultKeyType\u003E\u0060 for other than just checking that it exists like YARP does.\r\n\r\nWe think the API needs work. Maybe it could be combined with the rate limit feature proposal. #45658 ",
        "createdAt": "2023-07-24T17:47:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45684#issuecomment-1648342962"
      },
      {
        "id": "IC_kwDOAQzde85mkB2l",
        "parentId": null,
        "author": "mburumaxwell",
        "content": "The proposal in #45658 cannot work because the validation would only be available where a HttpContext is yet YARP needs validation elsewhere.\r\n\r\nIf I understand correctly, the main issue is making \u0060DefaultKeyType\u0060 public. What if instead we just have boolean values?\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.AspNetCore.RateLimiting;\r\n\r\n\u002B public interface IRateLimiterPolicyProvider\r\n\u002B {\r\n\u002B     bool DefaultPolicyExists();\r\n\u002B     bool PolicyExists(string policyName);\r\n\u002B }\r\n\u002B\r\n\u002B public class DefaultRateLimiterPolicyProvider : IRateLimiterPolicyProvider\r\n\u002B {\r\n\u002B     private readonly RateLimiterOptions _options;\r\n\u002B     \r\n\u002B     public DefaultRateLimiterPolicyProvider(IOptions\u003CRateLimiterOptions\u003E options)\r\n\u002B     {\r\n\u002B     \r\n\u002B     }\r\n\u002B     \r\n\u002B     public bool PolicyExists(string policyName)\r\n\u002B     {\r\n\u002B         options.PolicyMap.ContainsKey(policyName) || options.UnactivatedPolicyMap.ContainsKey(policyName);\r\n\u002B     }\r\n\u002B }\r\n\u0060\u0060\u0060",
        "createdAt": "2023-09-15T05:59:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45684#issuecomment-1720720805"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85ZwjSD",
    "title": "Additional Events for RateLimitOptions",
    "url": "https://github.com/dotnet/aspnetcore/issues/45705",
    "createdAt": "2022-12-21T08:27:44Z",
    "lastUpdated": "2024-02-13T01:47:17Z",
    "body": "## Background and Motivation\r\n\r\nWe have memory intensive application hosted in Kubernetes, this application\u0027s memory is directly proportional to the number of requests it can handle. We were using \u0060Semaphore\u0060 to limit the concurrency and create internal queues for processing.\r\n\r\nNow that .Net7 has a \u0060ConcurrencyLimiter\u0060 we started investigating on the same, the idea (although non-proven) was to turn off the \u0060Readiness\u0060 probe once the concurrency limit had reached so that the traffic wouldn\u0027t flow to that instance, once the limit is replenished we could turn on the \u0060Readiness\u0060 probe to start allowing the traffic back to the pod.\r\n\r\nUnfortunately, the RateLimiter option has only one event, and that occurs on the rejection of the request since the limit was breached. \r\n\r\n\u0060\u0060\u0060csharp\r\npublic Func\u003COnRejectedContext, CancellationToken, ValueTask\u003E? OnRejected { get; set; }\r\n\u0060\u0060\u0060\r\nEven if we consume this event to turn off the probe, there is no way to bring the readiness probe back as there is no apparent way to check if the limits are replenished.\r\n\r\n\u0060\u0060\u0060csharp\r\nbuilder.Services.AddRateLimiter(_ =\u003E\r\n    {\r\n        _.AddConcurrencyLimiter(policyName: \u0022LimiterPolicy\u0022, options =\u003E\r\n        {\r\n            options.PermitLimit = 10;\r\n            // Only allow 10 request every 10 seconds\r\n            options.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;\r\n            // Only queue 3 requests when we go over that limit\r\n            options.QueueLimit = 3;\r\n        });\r\n        _.OnRejected = async (context, token) =\u003E\r\n        {\r\n            context.HttpContext.Response.StatusCode = 429;\r\n            ConcurrencyLimitHolder.HasLimitReached = true;\r\n        };\r\n    });\r\n\r\n///in the probe controller\r\n[HttpGet(\u0022ready\u0022)]\r\n    public IActionResult GetReadiness()\r\n    {\r\n        if (ConcurrencyLimitHolder.HasLimitReached)\r\n            return BadRequest();\r\n        \r\n        return Ok();\r\n    }\r\n\u0060\u0060\u0060\r\n\r\nThis isn\u0027t very useful, because the instance has already started rejecting the requests and the clients would have to retry, but the chances are that it would end up in the same instance.\r\n\r\n\r\n## Proposed API\r\nAn event triggered as soon as the rate limit is replenished/reset\r\n\u0060\u0060\u0060csharp\r\npublic sealed class RateLimiterOptions\r\n{\r\n     public Func\u003COnReplinshedContext, CancellationToken, ValueTask\u003E? OnReplinished { get; set; }\r\n}\r\n\u0060\u0060\u0060\r\n## Usage Examples\r\nusing the same example as above\r\n\r\n\u0060\u0060\u0060csharp\r\nbuilder.Services.AddRateLimiter(_ =\u003E\r\n    {\r\n        _.AddConcurrencyLimiter(policyName: \u0022LimiterPolicy\u0022, options =\u003E\r\n        {\r\n            options.PermitLimit = 10;\r\n            // Only allow 10 request every 10 seconds\r\n            options.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;\r\n            // Only queue 3 requests when we go over that limit\r\n            options.QueueLimit = 3;\r\n        });\r\n        _.OnRejected = async (context, token) =\u003E\r\n        {\r\n            context.HttpContext.Response.StatusCode = 429;\r\n            ConcurrencyLimitHolder.HasLimitReached = true;\r\n        };\r\n        _.OnReplenished = async(context,token) =\u003E\r\n       {\r\n            ConcurrencyLimitHolder.HasLimitReached = false;\r\n       }\r\n    });\r\n\r\n///in the probe controller\r\n[HttpGet(\u0022ready\u0022)]\r\n    public IActionResult GetReadiness()\r\n    {\r\n        if (ConcurrencyLimitHolder.HasLimitReached)\r\n            return BadRequest();\r\n        \r\n        return Ok();\r\n    }\r\n\u0060\u0060\u0060\r\n\r\n\r\n",
    "upvotes": 0,
    "labels": [
      "api-suggestion",
      "feature-rate-limit",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85RwBi4",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@BrennanConroy PTAL. ",
        "createdAt": "2023-01-04T23:29:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45705#issuecomment-1371543736"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85bELcV",
    "title": "Output caching should always vary by Accept-Encoding ",
    "url": "https://github.com/dotnet/aspnetcore/issues/45998",
    "createdAt": "2023-01-10T18:20:53Z",
    "lastUpdated": "2024-03-02T00:50:44Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nWhen both response compression and output caching are enabled, it appears that ASP.NET Core caches the first encoding to be generated, then always returns content with that encoding.\n\n### Expected Behavior\n\nI expected each encoding to be cached separately so responses are correct while avoiding the overhead of compressing each response.\n\n### Steps To Reproduce\n\nThis project has a simple repro:\r\nhttps://github.com/jonpayne/AspNetCacheIssue/tree/main/src\r\n\r\nUsing this repro, if I first request the text file with Brotli compression, I get the expected result:\r\n \r\n\u0060\u0060\u0060bash\r\ncurl -s -D - https://localhost:5000/test.txt -H \u0022Accept-Encoding: br\u0022 -o br.dat\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060http\r\nHTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nDate: Tue, 10 Jan 2023 05:33:16 GMT\r\nServer: Kestrel\r\nAccept-Ranges: bytes\r\nContent-Encoding: br\r\nETag: \u00221d924af6fef9583\u0022\r\nLast-Modified: Tue, 10 Jan 2023 04:53:10 GMT\r\nTransfer-Encoding: chunked\r\nVary: Accept-Encoding\r\n\u0060\u0060\u0060\r\n \r\nBut if I then request the same content with GZip compression, the response uses Brotli compression:\r\n\r\n\u0060\u0060\u0060bash\r\ncurl -s -D - https://localhost:5000/test.txt -H \u0022Accept-Encoding: gzip\u0022 -o gzip.dat\r\n\u0060\u0060\u0060\r\n\r\n\u0060\u0060\u0060http\r\nHTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nDate: Tue, 10 Jan 2023 05:33:16 GMT\r\nServer: Kestrel\r\nAccept-Ranges: bytes\r\nAge: 9\r\nContent-Encoding: br\r\nETag: \u00221d924af6fef9583\u0022\r\nLast-Modified: Tue, 10 Jan 2023 04:53:10 GMT\r\nTransfer-Encoding: chunked\r\nVary: Accept-Encoding\r\n\u0060\u0060\u0060\r\n\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n7.0.101\n\n### Anything else?\n\nI can work around this using this code:\r\n\r\n\u0060\u0060\u0060csharp \r\nbuilder.Services.AddOutputCache(options =\u003E\r\n{\r\n    options.AddBasePolicy(builder =\u003E\r\n    {\r\n        builder.SetVaryByQuery(string.Empty);\r\n        builder.VaryByValue(context =\u003E\r\n        {\r\n            var responseCompressionProvider = context.RequestServices.GetService\u003CIResponseCompressionProvider\u003E()!;\r\n            var encodingName = responseCompressionProvider.GetCompressionProvider(context)?.EncodingName ?? \u0022none\u0022;\r\n            return new KeyValuePair\u003Cstring, string\u003E(\u0022compression\u0022, encodingName);\r\n        });\r\n        builder.Cache();\r\n    });\r\n});\r\n\u0060\u0060\u0060\r\n\r\nWhile this works, it feels like something that should be provided by the framework.",
    "upvotes": 0,
    "labels": [
      "feature-caching",
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85SPenO",
        "parentId": null,
        "author": "mitchdenny",
        "content": "The order of how you register the middleware is significant here (and in many cases). Move \u0060\u0060\u0060app.UseOutputCache()\u0060\u0060\u0060 above \u0060\u0060\u0060app.UseResponseCompression()\u0060\u0060\u0060 and you should get the behavior you want.",
        "createdAt": "2023-01-12T04:12:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45998#issuecomment-1379789262"
      },
      {
        "id": "IC_kwDOAQzde85STL8w",
        "parentId": null,
        "author": "jonpayne",
        "content": "The repo has \u0060app.UseOutputCache()\u0060 above \u0060app.UseResponseCompression()\u0060. If I try this the other way around (\u0060app.UseResponseCompression()\u0060 above \u0060app.UseOutputCache()\u0060), the compressed responses are not cached and performance is much worse. I\u0027ve updated the repro code to log when requests are cached and increased the compression level to make the effect more noticeable.\r\n\r\nWith \u0060app.UseOutputCache()\u0060 followed by \u0060app.UseResponseCompression()\u0060:\r\n\u003Cpre\u003E\r\n./wrk https://172.18.16.1:5000/test.txt -H \u0022Accept-Encoding: br\u0022 -d 10 -t 100 -c 100\r\n\r\nRunning 10s test @ https://172.18.16.1:5000/test.txt\r\n  100 threads and 100 connections\r\n  Thread Stats   Avg      Stdev     Max   \u002B/- Stdev\r\n    Latency    56.57ms   41.42ms 301.67ms   86.66%\r\n    Req/Sec    20.88     10.08   171.00     79.51%\r\n  18167 requests in 10.10s, 6.08MB read\r\n\u003Cb\u003ERequests/sec:   1798.69\u003C/b\u003E\r\nTransfer/sec:    616.77KB\r\n\u003C/pre\u003E\r\n\r\nWith \u0060app.UseResponseCompression()\u0060 followed by \u0060app.UseOutputCache()\u0060:\r\n\u003Cpre\u003E\r\n./wrk https://172.18.16.1:5000/test.txt -H \u0022Accept-Encoding: br\u0022 -d 10 -t 100 -c 100\r\n\r\nRunning 10s test @ https://172.18.16.1:5000/test.txt\r\n  100 threads and 100 connections\r\n  Thread Stats   Avg      Stdev     Max   \u002B/- Stdev\r\n    Latency   102.50ms   67.71ms 706.20ms   83.32%\r\n    Req/Sec    11.63      5.74    55.00     65.24%\r\n  9473 requests in 10.10s, 3.23MB read\r\n\u003Cb\u003ERequests/sec:    937.92\u003C/b\u003E\r\nTransfer/sec:    327.95KB\r\n\u003C/pre\u003E",
        "createdAt": "2023-01-12T17:29:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45998#issuecomment-1380761392"
      },
      {
        "id": "IC_kwDOAQzde85VKnNo",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Triage: we should do this (vary by the Accept-Encoding).",
        "createdAt": "2023-02-13T23:18:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45998#issuecomment-1428845416"
      },
      {
        "id": "IC_kwDOAQzde85VKnRb",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-02-13T23:18:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45998#issuecomment-1428845659"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85bEMtd",
    "title": "\u0060Accept-Ranges\u0060 should not be returned when output caching is used",
    "url": "https://github.com/dotnet/aspnetcore/issues/45999",
    "createdAt": "2023-01-10T18:25:31Z",
    "lastUpdated": "2024-03-02T00:50:45Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nWhen output caching is used with static content, the \u0060Accept-Ranges\u0060 header is returned, but requests with the \u0060Ranges\u0060 header are not served correctly.\n\n### Expected Behavior\n\nThe \u0060Accept-Ranges\u0060 header should not be set when output caching is enabled. The \u0060Ranges\u0060 header in requests should be ignored when output caching is enabled.\n\n### Steps To Reproduce\n\nThis project has a simple repro:\r\nhttps://github.com/jonpayne/AspNetCacheIssue/tree/main/src\r\n\r\nUsing this example:\r\n\u0060\u0060\u0060bash\r\ncurl -s -D - https://localhost:5000/test.txt -H \u0022Range: bytes=0-32\u0022   // returns a range\r\ncurl -s -D - https://localhost:5000/test.txt -H \u0022Range: bytes=0-40\u0022   // returns a different range\r\ncurl -s -D - https://localhost:5000/test.txt                          // returns the full content\r\ncurl -s -D - https://localhost:5000/test.txt -H \u0022Range: bytes=0-32\u0022   // returns the full content (unexpected)\r\ncurl -s -D - https://localhost:5000/test.txt -H \u0022Range: bytes=0-40\u0022   // returns the full content (unexpected)\r\n\u0060\u0060\u0060\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n7.0.101\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "feature-caching",
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85SPa2E",
        "parentId": null,
        "author": "mitchdenny",
        "content": "I\u0027ve confirmed the behavior that you are reporting here, but I think it is compliant. It is important to observe the response code for the requests above. Based on what you have there, and what I\u0027ve observed it should look like:\r\n\r\n- 206\r\n- 206\r\n- 200\r\n- 200\r\n- 200\r\n\r\nThe way that output caching works is that it won\u0027t even consider storing the response unless the response code is 200. So in the first two requests it returned a 206 so the output cache wasn\u0027t populated and the ranged responses were returned. Then you did a request to get the full file and it returned a 200, so the cache was populated. Then on subsequent requests output caching decided not to observe the Range header (which is compliant). \r\n\r\nSo whilst the server can process the range header, it decided not to respond with a partial response which the client can figure out by looking at the response code.",
        "createdAt": "2023-01-12T03:44:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45999#issuecomment-1379773828"
      },
      {
        "id": "IC_kwDOAQzde85SPbPe",
        "parentId": null,
        "author": "mitchdenny",
        "content": "@sebastienros I seem to recall an issue/pr related to output caching on static files ... something along the lines of not using output caching on static files becuase OS-level caching of files might be better than loading the static files into the web app memory?",
        "createdAt": "2023-01-12T03:48:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45999#issuecomment-1379775454"
      },
      {
        "id": "IC_kwDOAQzde85SSh7i",
        "parentId": null,
        "author": "jonpayne",
        "content": "I have two concerns here:\r\n- A simple GET request can make a large change to the behavior and performance of a server. For example, a server could serve small range requests for many hours using very little bandwidth, then a single request for the complete content would prevent any future range requests.\r\n- The server should not return the \u0022Accept-Ranges\u0022 header, if it does not accept ranges.",
        "createdAt": "2023-01-12T15:45:49Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45999#issuecomment-1380589282"
      },
      {
        "id": "IC_kwDOAQzde85SdDOJ",
        "parentId": null,
        "author": "mitchdenny",
        "content": "\u003E * A simple GET request can make a large change to the behavior and performance of a server. For example, a server could serve small range requests for many hours using very little bandwidth, then a single request for the complete content would prevent any future range requests.\r\n\r\nI think this is a fair concern @jonpayne. I would like to get @sebastienros\u0027s input though since he has more domain expertise in this area and there may be an explicit reason for the current behavior.",
        "createdAt": "2023-01-16T01:51:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45999#issuecomment-1383347081"
      },
      {
        "id": "IC_kwDOAQzde85SoNX8",
        "parentId": null,
        "author": "sebastienros",
        "content": "Two options I see:\r\n- define the static file middleware before the output caching one such that the files are not impacted bu caching.\r\n- the same way we said we should vary by accept-encoding if present, we might need to add accept-ranges.\r\n\r\nAnother option would be to support accept-ranges but I don\u0027t think it\u0027s useful since the whole response would still be loaded before being trimmed to the client.",
        "createdAt": "2023-01-18T00:15:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45999#issuecomment-1386272252"
      },
      {
        "id": "IC_kwDOAQzde85SoTDM",
        "parentId": null,
        "author": "mitchdenny",
        "content": "I think option 1 makes the most sense. Because output caching of static files is a bit dubious anyway - for a few reasons. First of all we don\u0027t know that output caching is going to be that much more efficient than executing the code and relying on any OS level caching of file access.\r\n\r\nThe other thing is that files that tend to need range support to efficiently download probably need some kind of out of band integrity check. Two different requests would end up grabbing two different versions of the file resulting in a corrupted result. When this occurs, you don\u0027t want output caching getting in the road of you getting the updated chunks.\r\n\r\n(drawing on some of my experience here from Azure Artifacts and importance of knowing what you are downloading when a single file across multiple requests).",
        "createdAt": "2023-01-18T00:43:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45999#issuecomment-1386295500"
      },
      {
        "id": "IC_kwDOAQzde85SoTft",
        "parentId": null,
        "author": "sebastienros",
        "content": "Could also be part of the default policy to not cache accept-ranges requests.",
        "createdAt": "2023-01-18T00:45:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45999#issuecomment-1386297325"
      },
      {
        "id": "IC_kwDOAQzde85SoUZ_",
        "parentId": null,
        "author": "jonpayne",
        "content": "I detailed my reasons for wanting to cache static content here: https://github.com/dotnet/aspnetcore/issues/45998#issuecomment-1380761392",
        "createdAt": "2023-01-18T00:50:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45999#issuecomment-1386301055"
      },
      {
        "id": "IC_kwDOAQzde85TOKMU",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-01-18T23:17:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45999#issuecomment-1396220692"
      },
      {
        "id": "IC_kwDOAQzde85TOKVg",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Triage:\r\n- We should send the byte range from the cached entry.\r\n- If the response has a Range on it, it doesn\u0027t make sense to cache it.",
        "createdAt": "2023-01-18T23:18:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/45999#issuecomment-1396221280"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85csJvm",
    "title": "Can\u0027t modify OutputCacheContext.Tags from IOutputCachePolicy.ServeResponseAsync",
    "url": "https://github.com/dotnet/aspnetcore/issues/46243",
    "createdAt": "2023-01-24T14:20:53Z",
    "lastUpdated": "2024-09-12T00:11:30Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nAssigning tags in \u0060ServeResponseAsync\u0060 doesn\u0027t work; the tags don\u0027t get attached to the entries, so retrieving or evicting them does nothing.\r\n\r\nIt makes sense to be able to add tags to the cache entry in \u0060ServeResponseAsync\u0060 (in a custom \u0060IOutputCachePolicy\u0060). \r\n\r\nWork might be done during the request which resolves the value to be used in the tag, which is why it can\u0027t be assigned in \u0060CacheRequestAsync\u0060 before the request has actually executed.\r\n\r\nI believe the source of the issue is this block in \u0060OutputCacheMiddleware\u0060:\r\n\r\n\u0060\u0060\u0060\r\n// Hook up to listen to the response stream\r\nShimResponseStream(context);\r\n\r\ntry\r\n{\r\n    await _next(httpContext);\r\n\r\n    // The next middleware might change the policy\r\n    foreach (var policy in policies)\r\n    {\r\n        await policy.ServeResponseAsync(context, httpContext.RequestAborted);\r\n    }\r\n\r\n    // If there was no response body, check the response headers now. We can cache things like redirects.\r\n    StartResponse(context);\r\n\r\n    // Finalize the cache entry\r\n    await FinalizeCacheBodyAsync(context);\r\n\u0060\u0060\u0060\r\n\r\n\u0060ShimResponseStream\u0060 triggers \u0060FinalizeCacheHeaders\u0060 which creates a copy of the tags (\u0060ToArray()\u0060) before the request gets executed in \u0060await _next\u0060 - then even though the policy\u0027s \u0060ServeResponseAsync\u0060 is using the request data to modify the tags, they don\u0027t get persisted by the call to FinalizeCacheBodyAsync, which uses the copy of the tags made in \u0060ShimResponseStream\u0060.\r\n\r\nFor a fix, what about removing this line in \u0060FinalizeCacheHeaders\u0060: \u0060Tags = context.Tags.ToArray()\u0060\r\n\r\nAnd adding this one in \u0060FinalizeCacheBodyAsync\u0060:  \u0060context.CachedResponse.Tags = context.Tags.ToArray();\u0060\r\n\r\nFor now I\u0027m working around it by using reflection to set the \u0060OutputCacheContext.CachedResponse.Tags\u0060 array inside \u0060ServerResponseAsync\u0060 - reflection being necessary because CachedResponse (both the property and the class \u0060OutputCacheEntry\u0060) are internal\r\n\r\n\r\n### Expected Behavior\r\n\r\nAssigning tags in \u0060ServeResponseAsync\u0060 should attach them to the stored cache entry.\r\n\r\n### Steps To Reproduce\r\n\r\nCreate an implementation of \u0060IOutputCachePolicy\u0060 and add:\r\n\r\n\u0060\u0060\u0060\r\n        public ValueTask ServeResponseAsync(OutputCacheContext context, CancellationToken cancellation)\r\n        {\r\n            context.AllowCacheStorage = true;\r\n            context.Tags.Add(\u0022MyTagHere\u0022);\r\n            return ValueTask.CompletedTask;\r\n        }\r\n\u0060\u0060\u0060\r\n\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n7.0.101\r\n\r\n### Anything else?\r\n\r\nASP.NET Core 7.0.2\r\nVisual Studio Professional 2022",
    "upvotes": 7,
    "labels": [
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85VXeZv",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-02-15T23:22:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46243#issuecomment-1432217199"
      },
      {
        "id": "IC_kwDOAQzde85VdSRW",
        "parentId": null,
        "author": "pecoult",
        "content": "Hello,\r\nWe have the same issue with custom output cache policies.\r\n\r\n.NET Version: 7.0.102\r\n\r\nThe scenario we tried to achieve:\r\n- We want to cache our MVC controller Http Get endpoint response (the action gives access to a list of resources linked to a user). The action is in charge of adding a Response Header: \u0027Cache-Tags\u0027 with calculated values based on request parameters and resource types.\r\n- Our custom cache policy (used as a base policy) is in charge of retrieving those response headers and add their values as OutputCacheContext tags. We tried to update OutputCacheContext tags through ServeResponseAsync implementation but it didn\u0027t work. Tags are not stored with cached entries in this case. For information, we tried to use this method because the IOutputCachePolicy interface method signature comment is quite explicit: _Updates the \u003Csee cref=\u0022OutputCacheContext\u0022/\u003E before the response is served and can be cached. At that point cacheability of the response can be updated._\r\n- In our scenario, we would then want to invalidate cache entries based on Tags (by using IOutputCacheStore.EvictByTagAsync method on HttpPost and HttpUpdate successful MVC controller actions)\r\n\r\nAs a fallback we think about using IOutputCachePolicy CacheRequestAsync method but we will only be able to create dynamic tags based on request data. It is not ideal in our case.\r\nIf you see any other way to manage and purge cache entries based on calculated tags please give advices. \r\nI will give a try to your workaround @DanielStout5 with reflection. Thank you!\r\n\r\nSample (simplified code example):\r\nStartup.cs:\r\n\u0060\u0060\u0060\r\nservices.AddOutputCache(c =\u003E \r\n    {\r\n        c.AddBasePolicy(builder =\u003E builder.AddPolicy\u003CCustomOutputCachePolicy\u003E().Cache());\r\n    });\r\n\u0060\u0060\u0060\r\n\r\nCustomOutputCachePolicy.cs\r\n\u0060\u0060\u0060\r\npublic class CustomOutputCachePolicy : IOutputCachePolicy\r\n    {\r\n        public ValueTask CacheRequestAsync(OutputCacheContext context, CancellationToken cancellation) =\u003E ValueTask.CompletedTask;\r\n\r\n        public ValueTask ServeFromCacheAsync(OutputCacheContext context, CancellationToken cancellation) =\u003E ValueTask.CompletedTask;\r\n\r\n        public ValueTask ServeResponseAsync(OutputCacheContext context, CancellationToken cancellation)\r\n        {\r\n            if (context.HttpContext.Response.Headers.ContainsKey(\u0022Cache-Tags\u0022))\r\n            {\r\n                var tag = context.HttpContext.Response.Headers[\u0022Cache-Tags\u0022].First();\r\n                context.Tags.Add(tag);\r\n            }\r\n            return ValueTask.CompletedTask;\r\n        }\r\n    }\r\n\u0060\u0060\u0060\r\n\r\nResourceController.cs\r\n\u0060\u0060\u0060\r\n[...]\r\n        [HttpGet]\r\n        [OutputCache]\r\n        public IActionResult GetResources(string userId)\r\n        {\r\n            var resources = _service.GetResourcesByUserId(userId);\r\n\r\n            Response.Headers.Add(\u0022Cache-Tags\u0022, $\u0022Resources-{userId}\u0022);\r\n\r\n            return Ok(resources);\r\n        }\r\n\r\n        [HttpPost]\r\n        public async Task\u003CIActionResult\u003E CreateResourceAsync(Resource resource, string userId)\r\n        {\r\n            var resourceId = _service.CreateResource(resource, userId);\r\n\r\n            await _outputCacheStore.EvictByTagAsync($\u0022Resources-{userId}\u0022, CancellationToken.None);\r\n            return Created(uri: resourceId, value: resourceId);\r\n        }\r\n[...]\r\n\u0060\u0060\u0060\r\n",
        "createdAt": "2023-02-16T21:31:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46243#issuecomment-1433740374"
      },
      {
        "id": "IC_kwDOAQzde85eJIab",
        "parentId": null,
        "author": "KathigitAnguras",
        "content": "I came across this issue today. Totally agree with @DanielStout5.\r\n\r\nI understand setting the headers in \u0060StartResponse()\u0060, but tags should not be treated the same, considering **tags** is the only good way to apply eviction. And as far as I can see, generating dynamic tags (that accurately represent the cached entry) can only be done from within the context of the response. \r\n\r\nWithout the context of the response, we are left with applying generic tags and evict cache entries unnecessarily (this becomes more apparent when the cached output contains other related entities, thus creating more complex eviction scenarios). \r\n\r\nIn summary, without this, **output cache** becomes less flexible to accurately applying eviction to ... **cached output** and considering the relatively low effort to fix this, I am surprised this is not treated with a higher priority.",
        "createdAt": "2023-06-06T21:06:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46243#issuecomment-1579452059"
      },
      {
        "id": "IC_kwDOAQzde85eK_bq",
        "parentId": null,
        "author": "therealkungfury",
        "content": "I also stumbled into this one recently. Had to listen to my co-worker moan about this for two hours :)\r\n\r\nIt does seem like a very reasonable improvement which would make the output cache a lot more flexible. Got my vote. ",
        "createdAt": "2023-06-07T05:43:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46243#issuecomment-1579939562"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85dL_zF",
    "title": "DeveloperExceptionMiddleware shouldn\u0027t have dependencies to \u0060ProblemDetails\u0060",
    "url": "https://github.com/dotnet/aspnetcore/issues/46339",
    "createdAt": "2023-01-31T00:33:29Z",
    "lastUpdated": "2024-02-13T01:44:02Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nIn https://github.com/dotnet/aspnetcore/issues/42212 was introduced the \u0060IProblemDetailsService\u0060 and the \u0060DeveloperExceptionPageMiddleware\u0060 updated to include \u0060ProblemDetails\u0060 payload generation. \r\n\r\nHowever, it introduced an unnecessary dependency to \u0060JsonOptions\u0060 and \u0060ProblemDetails\u0060 that could have been avoided if the the \u0060ProblemDetails\u0060 generation was implemented using an \u0060IDeveloperPageExceptionFilter\u0060.\r\n\r\n### Expected Behavior\r\n\r\n\u0060DeveloperExceptionPageMiddleware\u0060 should not have dependencies to \u0060JsonOptions\u0060 or \u0060ProblemDetails\u0060 but should have the \u0060ProblemDetails\u0060 payload generated when \u0060AddProblemDetails\u0060 is called.\r\n\r\n### .NET Version\r\n\r\n.NET 7",
    "upvotes": 0,
    "labels": [
      "feature-problem-details",
      "area-minimal",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85XjsL3",
        "parentId": null,
        "author": "captainsafia",
        "content": "Triage: @mitchdenny As part of https://github.com/dotnet/aspnetcore/issues/46969, can you see if \u0060ProblemDetails\u0060 is a big contributor to the size accounting for DeveloperExceptionPage? If it is a big contributor, we may consider doing this work.",
        "createdAt": "2023-03-14T22:53:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46339#issuecomment-1468973815"
      },
      {
        "id": "IC_kwDOAQzde85Y2qcU",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-03-30T18:13:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46339#issuecomment-1490724628"
      },
      {
        "id": "IC_kwDOAQzde85eKVmV",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-06-07T02:22:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46339#issuecomment-1579768213"
      },
      {
        "id": "IC_kwDOAQzde85eKVoX",
        "parentId": null,
        "author": "mitchdenny",
        "content": "Moving to backlog due to reprioritization.",
        "createdAt": "2023-06-07T02:22:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46339#issuecomment-1579768343"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85fuHIx",
    "title": "Reduce the size of the Developer Exception Page in NativeAOT",
    "url": "https://github.com/dotnet/aspnetcore/issues/46969",
    "createdAt": "2023-03-02T00:44:14Z",
    "lastUpdated": "2024-03-02T01:07:20Z",
    "body": "In investigating size of NativeAOT apps, one area of additional size is app.UseDeveloperExceptionPage().\r\n\r\nWhen comparing the win-x64 sizes before and after adding the \u0060app.UseDeveloperExceptionPage()\u0060 line, I see the following sizes:\r\n\r\n\u0060\u0060\u0060\r\n8.99 MB (9,428,480 bytes) - AddRoutingCore()\u002Bapp.UseRouting()\u002BUseEndpoints\u002BMapGet\r\n9.56 MB (10,031,616 bytes) - AddRoutingCore()\u002Bapp.UseRouting()\u002BUseEndpoints\u002BMapGet\u002Bapp.UseDeveloperExceptionPage()\r\n\u0060\u0060\u0060\r\n\r\nThis means adding \u0060app.UseDeveloperExceptionPage()\u0060 adds about 550 KB of app size.\r\n\r\nWe should investigate if there is a way to make this feature smaller. One way to make it smaller is https://github.com/dotnet/aspnetcore/issues/46915. There may be other optimization we could make to reduce app size. For example, maybe eliminating \u0060System.Linq\u0060 usages. Another option is removing \u0060UseDeveloperExceptionPage()\u0060 from CreateSlimBuilder and make it optional for the app to add it (possibly putting it into the \u0060dotnet new api\u0060 template).\r\n\r\ncc @DamianEdwards @halter73 @amcasey @captainsafia ",
    "upvotes": 1,
    "labels": [
      "investigate",
      "feature-diagnostics",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85XFtkH",
        "parentId": null,
        "author": "brunolins16",
        "content": "Maybe  this is helping to the size increase https://github.com/dotnet/aspnetcore/issues/46339",
        "createdAt": "2023-03-09T01:15:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46969#issuecomment-1461115143"
      },
      {
        "id": "IC_kwDOAQzde85XKtJ1",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "@brunolins16 yeah good point.\r\n\r\n@eerhardt I think we need to strive to keep the developer exception page in the experience one way or another, whether it\u0027s by reducing its size, removing it from slim builder and adding it to the template, or whatever we end up doing for #46096. Seems prudent to first start with trying to reduce the size via the identified leads.",
        "createdAt": "2023-03-09T17:01:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46969#issuecomment-1462424181"
      },
      {
        "id": "IC_kwDOAQzde85bKVDv",
        "parentId": null,
        "author": "??",
        "content": "To learn more about what this message means, what to expect next, and how this issue will be handled you can read our [Triage Process document](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).\nWe\u0027re moving this issue to the .NET 8 Planning milestone for future evaluation / consideration. Because it\u0027s not immediately obvious what is causing this behavior, we would like to keep this around to collect more feedback, which can later help us determine how to handle this. We will re-evaluate this issue, during our next planning meeting(s).\nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact work.",
        "createdAt": "2023-05-01T07:22:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46969#issuecomment-1529434351"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85fx2LR",
    "title": "Add custom format support to HttpLogging middleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/46989",
    "createdAt": "2023-03-02T14:25:21Z",
    "lastUpdated": "2024-08-02T22:25:37Z",
    "body": "\r\n\r\nIn production i want to log each http request in the format I select. With HttpLogging I can selected Headers and LoggingFields but I cannot format the result, which looks something like this.\r\n\r\n![image](https://user-images.githubusercontent.com/45663203/222454574-319c5b93-f584-4aad-88cb-a6d8cedc6d12.png)\r\n\r\nI need to be able create single line logs and reorder logged properties\r\n\r\n### Describe the solution you\u0027d like\r\n\r\nIn \u0060HttpLoggingOptions\u0060 I would like to be able to specify string format. It would look something like this:\r\n\r\n\u0060\u0060\u0060\r\nbuilder.Services.AddHttpLogging(options =\u003E\r\n{\r\n    options.LogFormat = \u0022Protocol {HttpProtocol} Scheme: {RequestScheme} \\n Path: {Path}\u0022;\r\n});\r\n\r\n\u0060\u0060\u0060\r\n\r\n### Additional context\r\n\r\n_No response_",
    "upvotes": 39,
    "labels": [
      "feature-diagnostics",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85WjeYM",
        "parentId": null,
        "author": "Tratcher",
        "content": "The 1-line format is available with the W3C logger.\r\nhttps://learn.microsoft.com/en-us/aspnet/core/fundamentals/w3c-logger/?view=aspnetcore-7.0\r\nThe Hosting logs also provide a 1-line request/response log.",
        "createdAt": "2023-03-02T16:15:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46989#issuecomment-1452140044"
      },
      {
        "id": "IC_kwDOAQzde85WkdD1",
        "parentId": null,
        "author": "Martinn2",
        "content": "W3C format looks good, but it seems it supports only logging to the file. I need to use standard ILogger as HttpLogging does",
        "createdAt": "2023-03-02T18:56:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46989#issuecomment-1452396789"
      },
      {
        "id": "IC_kwDOAQzde85W2eCD",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Triage: customizing the HttpLogging this way seems reasonable as something we should consider, but we won\u0027t be able to get to this in the near future.\r\n\r\nIn the meantime, you can achieve what you\u0027re looking for by writing your own middleware for this purpose.",
        "createdAt": "2023-03-06T22:29:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46989#issuecomment-1457119363"
      },
      {
        "id": "IC_kwDOAQzde85W2eZK",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "If anyone else is interested in this, please leave a comment or a \uD83D\uDC4D on the first comment.",
        "createdAt": "2023-03-06T22:30:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46989#issuecomment-1457120842"
      },
      {
        "id": "IC_kwDOAQzde86HE6Ma",
        "parentId": null,
        "author": "vecera-vojtech",
        "content": "I\u0027d love this functionality since as of now I have to do a custom implementation of the logger just because of it.\r\n\r\nIt would also by nice to have option to enforce logging of only Headers specified in \u0060RequestHeaders\u0060. Atm values of those which are not added to the list are redacted. That pollutes and logs and makes us log values with no added value for us (and lets not mention the additional cost for the log storage if we would use it all our microservices). There is workaround, where I can prune the LogContext Parameters in OnResponse method. But I disslike the fact, that the values are even added to the list to just be deleted, seems like unnecessary overhead to me. \r\n\r\nAlso setting the LogLevel via interceptor would be nice, so we can log responses with HTTP Status code \u003E=400 as warning/errors instead of having all as information.",
        "createdAt": "2024-08-02T22:21:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/46989#issuecomment-2266211098"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85gBSII",
    "title": "Custom base policy for OutputCache not triggered when API is called",
    "url": "https://github.com/dotnet/aspnetcore/issues/47044",
    "createdAt": "2023-03-06T08:59:07Z",
    "lastUpdated": "2024-02-13T01:41:02Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nI think this is the same issue as #45564.\r\n\r\nWhen attempting to use a custom base policy for the OutputCache, the policy is not triggered or used when the API is called. Instead, a named policy must be created for caching to work correctly.\r\n\r\n### Expected Behavior\r\n\r\nThe custom base policy should be triggered and used when making requests to the API.\r\n\r\n### Steps To Reproduce\r\n\r\nAdd the custom policy to program.cs\r\n\r\n\u0060\u0060\u0060csharp\r\nbuilder.Services.AddOutputCache(options =\u003E\r\n{\r\n    options.AddBasePolicy(builder =\u003E builder.AddPolicy\u003CCustomBasePolicy\u003E(), true);   //Doesn\u0027t work\r\n    options.AddBasePolicy(builder =\u003E builder.AddPolicy\u003CCustomBasePolicy\u003E());         //Doesn\u0027t work\r\n    options.AddPolicy(\u0022PolicyA\u0022, builder =\u003E builder.AddPolicy\u003CCustomBasePolicy\u003E(), true);  //Works\r\n});\r\n\u0060\u0060\u0060\r\n\r\nThe app builder:\r\n\r\n\u0060\u0060\u0060csharp\r\nvar app = builder.Build();\r\n\r\napp.UseDeveloperExceptionPage();\r\n\r\napp.UseCors();\r\n\r\napp.UseAuthentication();\r\napp.UseAuthorization();\r\n\r\n//This needs to be after Swagger, Middlewares and Authentication\r\napp.UseOutputCache();\r\n\r\n// app.MapControllers().CacheOutput().RequireAuthorization();  //Relying on the custom base policy doesn\u0027t work\r\napp.MapControllers().CacheOutput(\u0022PolicyA\u0022).RequireAuthorization();\r\n\r\napp.Run();\r\n\u0060\u0060\u0060\r\n\r\nThis is the CustomBasePolicy I used to test:\r\n\r\n\u0060\u0060\u0060csharp\r\npublic class CustomBasePolicy : IOutputCachePolicy\r\n{\r\n    public ValueTask CacheRequestAsync(OutputCacheContext context, CancellationToken cancellation)\r\n    {\r\n        // always cache\r\n        context.EnableOutputCaching = true;\r\n        context.AllowCacheLookup = true;\r\n        context.AllowCacheStorage = true;\r\n        context.AllowLocking = true;\r\n\r\n        // Vary by any query by default\r\n        context.CacheVaryByRules.QueryKeys = \u0022*\u0022;\r\n\r\n        return ValueTask.CompletedTask;\r\n    }\r\n\r\n        public ValueTask ServeFromCacheAsync(OutputCacheContext context, CancellationToken cancellation) =\u003E ValueTask.CompletedTask;\r\n        public ValueTask ServeResponseAsync(OutputCacheContext context, CancellationToken cancellation) =\u003E ValueTask.CompletedTask;\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n7.0.200\r\n\r\n### Anything else?\r\n\r\nI tried to enable debug logs in my project and tried to look for specific logs that I found in the [OutputCacheMiddleware](https://github.com/dotnet/aspnetcore/blob/5d10dceeaf5d1d4ac945356f580cce5cf0486c40/src/Middleware/OutputCaching/src/OutputCacheMiddleware.cs#L228), however it never looks like the middleware was hit when I tried to use the base policy.\r\n\r\n\r\ndotnet --info\r\n\r\n\u0060\u0060\u0060\r\n.NET SDK:\r\n Version:   7.0.200\r\n Commit:    534117727b\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.22621\r\n OS Platform: Windows\r\n RID:         win10-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\7.0.200\\\r\n\r\nHost:\r\n  Version:      7.0.3\r\n  Architecture: x64\r\n  Commit:       0a2bda10e8\r\n\r\n.NET SDKs installed:\r\n  7.0.103 [C:\\Program Files\\dotnet\\sdk]\r\n  7.0.200 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.App 6.0.14 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 7.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 6.0.14 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 7.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 6.0.14 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 7.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\nEnvironment variables:\r\n  Not set\r\n\r\nglobal.json file:\r\n  Not found\r\n\u0060\u0060\u0060",
    "upvotes": 1,
    "labels": [
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85WyT0x",
        "parentId": null,
        "author": "h3rmanj",
        "content": "It seems like the [\u0060CacheOutput\u0060](https://github.com/dotnet/aspnetcore/blob/61bc2aabbc8952727c38a8fba1c36bceb26bebc5/src/Middleware/OutputCaching/src/Policies/OutputCacheConventionBuilderExtensions.cs#L25) extension on \u0060IEndpointConventionBuilder\u0060 always adds the default policy if no argument is provided.\r\n\r\nMaybe we are misunderstanding what \u0060BasePolicy\u0060 is actually referring to? Is it the default policy if no other is specified? Or a policy that gets appended to every other policy, but can\u0027t be used alone?",
        "createdAt": "2023-03-06T12:16:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47044#issuecomment-1456028977"
      },
      {
        "id": "IC_kwDOAQzde85ZNj33",
        "parentId": null,
        "author": "sebastienros",
        "content": "BasePolicy is additive to \u0060DefaultPolicy\u0060 unless specified otherwise.\r\nBasePolicy is called when an endpoint is cached without any specific policy defined (fallback).\r\n\r\n\u003E Is it the default policy if no other is specified? \r\n\r\nThen yes, but for endpoints that have caching enabled, like by using \u0060.CacheOutput()\u0060",
        "createdAt": "2023-04-04T23:39:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47044#issuecomment-1496727031"
      },
      {
        "id": "IC_kwDOAQzde85ZPLb6",
        "parentId": null,
        "author": "h3rmanj",
        "content": "\u003E BasePolicy is additive to \u0060DefaultPolicy\u0060 unless specified otherwise. BasePolicy is called when an endpoint is cached without any specific policy defined (fallback).\r\n\r\nSo if I add a base policy with the \u0060excludeDefaultPolicy\u0060 like so;\r\n\r\n\u0060\u0060\u0060csharp\r\nbuilder.Services.AddOutputCache(options =\u003E\r\n{\r\n    options.AddBasePolicy(builder =\u003E builder.AddPolicy\u003CCustomBasePolicy\u003E(), excludeDefaultPolicy: true);\r\n});\r\n\u0060\u0060\u0060\r\n\r\nThe default policy should be excluded from the base policy.\r\n\r\n\u003E \u003E Is the base policy the default policy if no other is specified?\r\n\u003E \r\n\u003E Then yes, but for endpoints that have caching enabled, like by using \u0060.CacheOutput()\u0060\r\n\r\nSo if I cache the output of all my endpoints, like so;\r\n\r\n\u0060\u0060\u0060csharp\r\napp.MapEndpoints().CacheOutput();\r\n\u0060\u0060\u0060\r\n\r\nOnly the Base Policy should be invoked? (Which has excluded the default policy)\r\n\r\nThat is not the case, as the default policy will still be hit. @sebastienros\r\n\r\nI set up a [codesandbox here](https://codesandbox.io/p/sandbox/wandering-monad-7m9dvo?file=Program.cs) (open preview on port 5000, and run project logs to see output), where I\u0027ve followed the steps, and added a mock for authentication (something the Default Policy doesn\u0027t like, but shouldn\u0027t matter). If you keep calling the enpoint, you\u0027ll see the controller will always be hit.",
        "createdAt": "2023-04-05T08:59:01Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47044#issuecomment-1497151226"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85hAppE",
    "title": "Output cache middleware does not vary by query params specified at runtime",
    "url": "https://github.com/dotnet/aspnetcore/issues/47251",
    "createdAt": "2023-03-16T14:03:50Z",
    "lastUpdated": "2024-02-13T01:39:56Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nThe current way to specify to vary by query params(using a custom cache policy) is this:\r\n\r\n\u0060\u0060\u0060c#\r\n\r\nclass CustomCachePolicy : IOutputCachePolicy\r\n{\r\n    public ValueTask CacheRequestAsync(OutputCacheContext context, CancellationToken cancellation)\r\n    {\r\n        var httpContext = context.HttpContext;\r\n\r\n        context.AllowCacheLookup = true;\r\n        context.AllowCacheStorage = true;\r\n        context.AllowLocking = true;\r\n        context.EnableOutputCaching = true;\r\n        context.CacheVaryByRules.QueryKeys = \u0022page\u0022;\r\n\u0060\u0060\u0060\r\n\r\nHowever more dynamic scenarios require the query params to be specified during execution of a controller:\r\n\r\n\u0060\u0060\u0060c#\r\n\r\n    [OutputCache(PolicyName = \u0022default\u0022)]\r\n    public IActionResult Index()\r\n    {\r\n        var ocFeature = this.HttpContext.Features.Get\u003CIOutputCacheFeature\u003E();\r\n\r\n        if (ocFeature != null)\r\n        {\r\n            ocFeature.Context.CacheVaryByRules.QueryKeys = new Microsoft.Extensions.Primitives.StringValues(\u0022page\u0022);\r\n        }\r\n\r\n        return this.View();\r\n    }\r\n\u0060\u0060\u0060\r\n\r\nI would expect the page to vary by query params specified during an execution of a controller/handler.\n\n### Expected Behavior\n\nI would expect the page to vary by query params specified during an execution of a controller/handler.\n\n### Steps To Reproduce\n\nOpen [this github project ](https://github.com/Gebov/aspnetcore-7-cache-issue)and run it. Then browse through the pages\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n7.0.202\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde85hwRyh",
    "title": "Add support for X-Azure-FDID as a UseForwardedHeaders \u0022Known Proxy\u0022",
    "url": "https://github.com/dotnet/aspnetcore/issues/47408",
    "createdAt": "2023-03-24T21:09:30Z",
    "lastUpdated": "2024-02-13T01:39:08Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nI am trying to use UseForwardedHeaders in an app behind Azure Front Door, but the remote ip address received on the application is random.  The only options I see right now are to either restrict known networks to a class B (147.243.x.x based on observations) or remove all known proxies from the configuration.  Basically, drastically reduce security or remove it completely.\r\n\r\n\r\n\n\n### Describe the solution you\u0027d like\n\nA great feature would be to configure ForwardedHeadersOptions with an expected header and value as an alternate security mechanism to remote ip address.\r\n\r\nEx. options.KnownHeaders.Add(\u0022X-Azure-FDID\u0022, \u002255ce4ed1-4b06-4bf1-b40e-4638452104da\u0022);\r\n\n\n### Additional context\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85Yi5nj",
        "parentId": null,
        "author": "Tratcher",
        "content": "That seems like a check that could be added as its own middleware. E.g. if this header/value is missing, refuse the request (400). That would be independent of UseForwardedHeaders, it doesn\u0027t modify any part of the request.",
        "createdAt": "2023-03-27T17:24:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47408#issuecomment-1485543907"
      },
      {
        "id": "IC_kwDOAQzde85Yjyck",
        "parentId": null,
        "author": "raramer",
        "content": "That would be case if I wanted to only respond to requests coming through the proxy.  In my case, I want the application to also respond to requests that aren\u0027t proxied.\r\n\r\nLooking at the existing UseForwardedHeaders code, the KnownProxies and KnownNetworks are only restricting whether the host, remote ip address, and protocol are replaced, and don\u0027t do anything to block the inbound request itself.  KnownHeaders would do the same; only restrict replacements, and not the entire request.  \r\n",
        "createdAt": "2023-03-27T19:55:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47408#issuecomment-1485776676"
      },
      {
        "id": "IC_kwDOAQzde85YkWeG",
        "parentId": null,
        "author": "Tratcher",
        "content": "Note there is a proposal for UseForwardedHeaders to reject requests that don\u0027t match its criteria rather than no-op: https://github.com/dotnet/aspnetcore/issues/10302",
        "createdAt": "2023-03-27T22:08:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47408#issuecomment-1485924230"
      },
      {
        "id": "IC_kwDOAQzde85YxU_2",
        "parentId": null,
        "author": "Tratcher",
        "content": "[UseWhen](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.usewhenextensions.usewhen) is another option for you, skip the forwarder middleware when the expected header is not present.\r\n\r\nTriage: I don\u0027t recommend implementing this until we get more feedback about it and possible variations.",
        "createdAt": "2023-03-29T21:09:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47408#issuecomment-1489326070"
      },
      {
        "id": "IC_kwDOAQzde85ZNjjh",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-04-04T23:37:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/47408#issuecomment-1496725729"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85kyxey",
    "title": "ALWAYS include the \u0060Vary: Accept-Encoding\u0060 header when response compression is enabled",
    "url": "https://github.com/dotnet/aspnetcore/issues/48008",
    "createdAt": "2023-05-01T16:25:28Z",
    "lastUpdated": "2024-03-02T01:40:26Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nCurrently, the response compression middleware only adds a \u0060Vary: Accept-Encoding\u0060 header to the response, if and only if the request contains an \u0060Accept-Encoding\u0060 header.\r\n\r\n**This is wrong.** The \u0060Vary: Accept-Encoding\u0060 header should be included in the response regardless of whether or not \u0060Accept-Encoding\u0060 was part of the original request. This is because otherwise, if the very first request is one without the \u0060Accept-Encoding\u0060 header (and by extension there is no \u0060Vary: Accept-Encoding\u0060 in the response), an HTTP cache would not know that if a subsequent request came in that _did_ include an \u0060Accept-Encoding\u0060 header, it should NOT use the previous cache entry to satisfy that request.\r\n\r\nThe value of the \u0060Vary\u0060 header shouldn\u0027t be \u0027conditional\u0027 (for a request to the same URL). That\u0027s incorrect behavior and would cause issues especially with proxy caches (e.g. CDNs).\r\n\r\nThis principle is something that was explicitly pointed out in [this article by Fastly](https://www.fastly.com/blog/best-practices-using-vary-header#:~:text=Vary%3A%20Accept%2DEncoding**-,Note%20that%20the%20Vary%20header%20is%20present%20in%20the%20response%20regardless%20of%20whether%20or%20not%20compression%20is%20used.,-Why%20is%20this) \u2014 which is also mentioned in the [MDN page for \u0060Vary\u0060](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Vary#see_also).\r\n\r\n### Expected Behavior\r\n\r\nThe \u0060Vary: Accept-Encoding\u0060 header should be included in every response whose \u0060Content-Type\u0060 MIME type is supported by the response compression middleware, regardless of the presence of \u0060Accept-Encoding\u0060 in the request.\r\n\r\nThis same principle also applies to any middleware that might add a value to the \u0060Vary\u0060 header of the response, there could be some others in the ASP.NET Core codebase as well, although the response compression middleware is the one I stumbled into.\r\n\r\nThe relevant piece of code seems to be the following:\r\nhttps://github.com/dotnet/aspnetcore/blob/86817b0c9fbb9b730bf3ce63da34b75570ee5696/src/Middleware/ResponseCompression/src/ResponseCompressionBody.cs#L202-L225\r\n\r\n### Steps To Reproduce\r\n\r\n_No response_\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n_No response_\r\n\r\n### Anything else?\r\n\r\n_No response_",
    "upvotes": 0,
    "labels": [
      "bug",
      "help wanted",
      "feature-response-compression",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85bMP3j",
        "parentId": null,
        "author": "aradalvand",
        "content": "@Tratcher This is actually a bug report rather than a feature request. Is the \u0022feature-middleware\u0022 label really appropriate?",
        "createdAt": "2023-05-01T16:47:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48008#issuecomment-1529937379"
      },
      {
        "id": "IC_kwDOAQzde85bMSCF",
        "parentId": null,
        "author": "Tratcher",
        "content": "That label just means it\u0027s part of a middleware feature area, response compression.",
        "createdAt": "2023-05-01T16:55:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48008#issuecomment-1529946245"
      },
      {
        "id": "IC_kwDOAQzde85dNBwR",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Thanks for reporting this @aradalvand, I just looked at this and you\u0027re right that this is a bug.\r\n\r\nIt looks like we bail in invoking the middleware entirely if the Accept-Encoding header is not set in the request.\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/f56c242d037e7a11626151e78333caa26c3b5d00/src/Middleware/ResponseCompression/src/ResponseCompressionMiddleware.cs#L37-L45\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/f56c242d037e7a11626151e78333caa26c3b5d00/src/Middleware/ResponseCompression/src/ResponseCompressionProvider.cs#L219-L229\r\n\r\nWe\u0027ll need to fix this logic so that the \u0060Vary: Accept-Encoding\u0060 header is included regardless.",
        "createdAt": "2023-05-26T01:27:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48008#issuecomment-1563696145"
      },
      {
        "id": "IC_kwDOAQzde85dNByM",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 8 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-05-26T01:27:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48008#issuecomment-1563696268"
      },
      {
        "id": "IC_kwDOAQzde85dNIGE",
        "parentId": null,
        "author": "aradalvand",
        "content": "Hi @adityamandaleeka, thank you for looking into this.\r\n\r\nNote that one important point that\u0027s easy to overlook (which I did [hint at in my original comment](https://github.com/dotnet/aspnetcore/issues/48008#:~:text=should%20be%20included-,in%20every%20response%20whose%20Content%2DType%20MIME%20type%20is%20supported%20by%20the%20response%20compression%20middleware,-%2C%20regardless%20of%20the) but I think is worth reiterating), is that \u0060Vary: Accept-Encoding\u0060 should be added **only** to responses with a \u0060Content-Type\u0060 supported by the response compression middleware, and not to every response \u2014 but irrespective of whether or not the request includes \u0060Accept-Encoding\u0060, which is the original bug, of course.\r\n\r\nI just wanted to point this out again because I think it\u0027s easy to miss and consequently introduce another bug.",
        "createdAt": "2023-05-26T02:13:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48008#issuecomment-1563722116"
      },
      {
        "id": "IC_kwDOAQzde85zIPDT",
        "parentId": null,
        "author": "aradalvand",
        "content": "Any updates on this one?",
        "createdAt": "2024-02-07T08:41:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48008#issuecomment-1931538643"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85lFjx6",
    "title": "OutputCache - SetVaryByRouteValue doesn\u0027t work",
    "url": "https://github.com/dotnet/aspnetcore/issues/48066",
    "createdAt": "2023-05-04T12:55:32Z",
    "lastUpdated": "2024-02-13T01:36:32Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nI fetch the page by id and use slug like this:\r\n[https://example.com/123/slug-a](https://example.com/123/slug-a)\r\n[https://example.com/123/slug-b](https://example.com/123/slug-b )\r\n[https://example.com/123/slug-c](https://example.com/123/slug-c )\r\nAll these routes should get the same page from output cache regardless of the slug value.\r\nI use the \u0060SetVaryByRouteValue(\u0022id\u0022)\u0060 but it doesn\u0027t work.\r\n\r\n\u0060\u0060\u0060\r\n     services.AddOutputCache(options =\u003E\r\n            {\r\n                options.AddBasePolicy(builder =\u003E builder.AddPolicy\u003CMyCustomPolicy\u003E().Expire(TimeSpan.FromSeconds(10000)), true);\r\n                options.AddPolicy(\u0022VaryById\u0022, builder =\u003E builder.SetVaryByRouteValue(\u0022id\u0022));\r\n            });\r\n\u0060\u0060\u0060\r\n\r\nThe method:\r\n\u0060\u0060\u0060\r\n [Route(\u0022text/{id:int}/{textSlug?}\u0022)]\r\n [OutputCache(PolicyName = \u0022VaryById\u0022)]\r\n public async Task\u003CIActionResult\u003E TextPage(int id, string textSlug)\r\n\u0060\u0060\u0060\r\n\r\nWhen I use \u0060SetVaryByQuery(\u0022id\u0022)\u0060 I get the cached version of the page as long I don\u0027t change the id, but then I need to change my url to look like this:\r\n[https://example.com/123?slug=slug-a](https://example.com/123?slug=slug-a)\r\n[https://example.com/123?slug=slug-b](https://example.com/123?slug=slug-b)\r\n[https://example.com/123?slug=slug-c](https://example.com/123?slug=slug-c)\r\n\r\n### Expected Behavior\r\n\r\nI expect to get the cached version as long that I don\u0027t change the id route value.\r\nSo for:\r\n[https://example.com/123/slug-a](https://example.com/123/slug-a)\r\n[https://example.com/123/slug-b](https://example.com/123/slug-b )\r\n[https://example.com/123/slug-c](https://example.com/123/slug-c )\r\nI should get the same page from Output Cache.\r\n\r\n### Steps To Reproduce\r\n\r\nThese are my settings:\r\n\r\n\u0060\u0060\u0060\r\nusing Microsoft.AspNetCore.Http;\r\nusing Microsoft.AspNetCore.OutputCaching;\r\nusing Microsoft.Extensions.Primitives;\r\nusing System.Threading.Tasks;\r\nusing System.Threading;\r\nusing Microsoft.AspNetCore.Mvc.Controllers;\r\nusing Microsoft.AspNetCore.Mvc.Abstractions;\r\nusing Microsoft.AspNetCore.Authorization;\r\nusing System.Reflection;\r\nusing System.Linq;\r\n\r\nnamespace Cache;\r\n\r\npublic sealed class MyCustomPolicy : IOutputCachePolicy\r\n{\r\n    public static readonly MyCustomPolicy Instance = new();\r\n\r\n    public MyCustomPolicy()\r\n    {\r\n    }\r\n\r\n    ValueTask IOutputCachePolicy.CacheRequestAsync(OutputCacheContext context, CancellationToken cancellationToken)\r\n    {\r\n        var attemptOutputCaching = AttemptOutputCaching(context);\r\n        context.EnableOutputCaching = true;\r\n        context.AllowCacheLookup = attemptOutputCaching;\r\n        context.AllowCacheStorage = attemptOutputCaching;\r\n        context.AllowLocking = true;\r\n\r\n        // Vary by any query by default\r\n        context.CacheVaryByRules.QueryKeys = \u0022*\u0022;\r\n\r\n        return ValueTask.CompletedTask;\r\n    }\r\n\r\n    ValueTask IOutputCachePolicy.ServeFromCacheAsync(OutputCacheContext context, CancellationToken cancellationToken)\r\n    {\r\n        return ValueTask.CompletedTask;\r\n    }\r\n\r\n    ValueTask IOutputCachePolicy.ServeResponseAsync(OutputCacheContext context, CancellationToken cancellationToken)\r\n    {\r\n        var response = context.HttpContext.Response;\r\n\r\n        // Verify existence of cookie headers\r\n        if (!StringValues.IsNullOrEmpty(response.Headers.SetCookie))\r\n        {\r\n            context.AllowCacheStorage = false;\r\n        }\r\n\r\n        // Check response code\r\n        if (response.StatusCode != StatusCodes.Status200OK)\r\n        {\r\n            context.AllowCacheStorage = false;\r\n        }\r\n\r\n        return ValueTask.CompletedTask;\r\n    }\r\n\r\n    private static bool AttemptOutputCaching(OutputCacheContext context)\r\n    {\r\n        // Check if the current request fulfills the requirements to be cached\r\n        var request = context.HttpContext.Request;\r\n\r\n        // Verify the method\r\n        if (!HttpMethods.IsGet(request.Method) \u0026\u0026 !HttpMethods.IsHead(request.Method))\r\n        {\r\n            return false;\r\n        }\r\n\r\n        // Verify existence of authorization attribute\r\n        var controllerActionDescriptor = context.HttpContext.GetEndpoint()?.Metadata.GetMetadata\u003CControllerActionDescriptor\u003E()?.MethodInfo;\r\n        var hasAuthorizeAttribute = controllerActionDescriptor?.GetCustomAttributes()?.OfType\u003CAuthorizeAttribute\u003E().Any() ?? false;\r\n        if (hasAuthorizeAttribute)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nAdd the service:\r\n\r\n\u0060\u0060\u0060\r\n   services.AddOutputCache(options =\u003E\r\n            {\r\n                options.AddBasePolicy(builder =\u003E builder.AddPolicy\u003CMyCustomPolicy \u003E().Expire(TimeSpan.FromSeconds(10000)), true);\r\n                options.AddPolicy(\u0022VaryById\u0022, builder =\u003E builder.SetVaryByRouteValue(\u0022id\u0022));\r\n                //options.AddPolicy(\u0022Query\u0022, builder =\u003E builder.SetVaryByQuery(\u0022id\u0022));\r\n            });\r\n\u0060\u0060\u0060\r\n\r\nThe method:\r\n\r\n\u0060\u0060\u0060\r\n    [Route(\u0022text/{id:int}/{textSlug?}\u0022)]\r\n        [OutputCache(PolicyName = \u0022VaryById\u0022)]\r\n        public async Task\u003CIActionResult\u003E TextPage(int id, string textSlug)\r\n\u0060\u0060\u0060\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n7.0.203\r\n\r\n### Anything else?\r\n\r\nI tried to add to the base policy the following and it didn\u0027t work:\r\n\r\n\u0060context.CacheVaryByRules.RouteValueNames = \u0022id\u0022;\u0060",
    "upvotes": 0,
    "labels": [
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde85lj9K8",
    "title": "AddSession Sets wrong Cookie Path",
    "url": "https://github.com/dotnet/aspnetcore/issues/48165",
    "createdAt": "2023-05-10T13:21:03Z",
    "lastUpdated": "2024-10-25T01:57:57Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nSessionServiceCollectionExtensions.AddSession creates a cookie with the Path of \u0022/\u0022, ignoring the path base of the web application.  This is further complicated in that AddSession does not provide a way to access the HttpContext, so my code cannot easily set the cookie path to the desired value. \r\n\r\nDocuments cookie behavior of AddSession:\r\nhttps://learn.microsoft.com/en-us/aspnet/core/fundamentals/app-state?view=aspnetcore-7.0#session-options\r\n\r\nDocuments the problem:\r\nhttps://stackoverflow.com/q/54362266/4194514\n\n### Expected Behavior\n\nThe cookie created by SessionServiceCollectionExtensions.AddSession should use the path base of the web application, similarly to how antiforgery token does.\n\n### Steps To Reproduce\n\nGive your web application a path base and use SessionServiceCollectionExtensions.AddSession to add session to the website, but do not specify a path of the session cookie.  You will see in code that the path of the cookie is set by the framework to \u0022/\u0022, which I believe comes from SessionDefaults.CookiePath.\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n_No response_\n\n### Anything else?\n\nI see 3 different ways to fix this issue.\r\n1. Automatically set the cookie Path to the application\u0027s PathBase, instead of SessionDefaults.CookiePath.\r\n2. Change the value of SessionDefaults.CookiePath from \u0022/\u0022 to the application\u0027s path base.\r\n3. Add an additional signature to SessionServiceCollectionExtensions.AddSession that accepts the http context, so my custom code can determine the PathBase and set it as the cookie path.",
    "upvotes": 1,
    "labels": [
      "breaking-change",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85b9fhi",
        "parentId": null,
        "author": "Tratcher",
        "content": "Here is what Antiforgery does:\r\nhttps://github.com/dotnet/aspnetcore/blob/4afe7f612d104b43b690e71d83c18a8bc48aae2d/src/Antiforgery/src/Internal/DefaultAntiforgeryTokenStore.cs#L79-L99\r\n\r\nChanging the default for Session would be breaking. ~~Note we also use / for auth. I\u0027m not sure why Antiforgery does something different.~~\r\n\r\n*edit* nevermind, auth also uses path base by default.\r\nhttps://github.com/dotnet/aspnetcore/blob/4afe7f612d104b43b690e71d83c18a8bc48aae2d/src/Security/Authentication/Core/src/RequestPathBaseCookieBuilder.cs#L22-L38",
        "createdAt": "2023-05-10T21:43:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48165#issuecomment-1542846562"
      },
      {
        "id": "IC_kwDOAQzde85cBdLr",
        "parentId": null,
        "author": "Coder3333",
        "content": "@Tratcher , I haven\u0027t tracked down the Microsoft source code, yet, but in my application AddAuthentication and AddAntiforgery are creating their cookies with the proper path base, even though I am not doing anything to control that value.  So far, AddSession is the only one of these that is creating the cookie at \u0022/\u0022.",
        "createdAt": "2023-05-11T12:12:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48165#issuecomment-1543885547"
      },
      {
        "id": "IC_kwDOAQzde85za1Eq",
        "parentId": null,
        "author": "ahaeber",
        "content": "/azp run",
        "createdAt": "2024-02-09T18:29:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48165#issuecomment-1936412970"
      },
      {
        "id": "IC_kwDOAQzde86RPFul",
        "parentId": null,
        "author": "wessleym",
        "content": "I also would appreciate if \u0060AddSession\u0060 acted in the same way as \u0060AddAuthentication\u0060 and \u0060AddAntiforgery\u0060. Thank you.",
        "createdAt": "2024-10-25T01:57:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48165#issuecomment-2436651941"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85l85LU",
    "title": "Could not load file or assembly \u0027Microsoft.AspNetCore.Diagnostics.Abstractions\u0027 with .net 7.0.5",
    "url": "https://github.com/dotnet/aspnetcore/issues/48244",
    "createdAt": "2023-05-12T21:11:09Z",
    "lastUpdated": "2024-02-13T01:35:57Z",
    "body": "### Description\n\nWe are experiencing a problem with our .net mvc api running in service fabric which is getting the error \u0060Could not load file or assembly \u0027Microsoft.AspNetCore.Diagnostics.Abstractions\u0060.\r\n\r\nThe compile target is .net 7.\r\n\r\nI search for other bugs and found the issue dotnet/runtime#3252 and searched for direct package references in our project, but found none.\r\n\r\nWe deploy the api as a self contained package, so the host runtime shouldn\u0027t matter?\n\n### Reproduction Steps\n\nThe problem is, that I can\u0027t reproduce it locally. It just happens, when it is deployed. But we can\u0027t find the cause.\n\n### Expected behavior\n\nNot seeing an error\n\n### Actual behavior\n\nThrows an exception: \r\n\r\n\u0060\u0060\u0060\r\nCould not load file or assembly \u0027Microsoft.AspNetCore.Diagnostics.Abstractions, Version=7.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\u0027. The system cannot find the file specified.\r\nType: System.IO.FileNotFoundException\r\nFile not found: Microsoft.AspNetCore.Diagnostics.Abstractions, Version=7.0.0.0, Culture=neutral, PublicKeyToken=adb9793829ddae60\r\nStack Trace: at Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddlewareImpl.HandleException(HttpContext context, ExceptionDispatchInfo edi)\r\nat System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[TStateMachine](TStateMachine\u0026 stateMachine)\r\nat Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddlewareImpl.HandleException(HttpContext context, ExceptionDispatchInfo edi)\r\nat Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddlewareImpl.\u003CInvoke\u003Eg__Awaited|8_0(ExceptionHandlerMiddlewareImpl middleware, HttpContext context, Task task)\r\nat Microsoft.AspNetCore.Server.HttpSys.RequestContext\u00601.ExecuteAsync()\r\nat Microsoft.AspNetCore.Server.HttpSys.RequestContext\u00601.ExecuteAsync()\r\n\u0060\u0060\u0060\n\n### Regression?\n\nIt worked for month using .net 6 before. We just started to see this happen after upgrading to .net 7\n\n### Known Workarounds\n\nWe don\u0027t have one.\n\n### Configuration\n\n- Which version of .NET is the code running on?\r\n.net 7.0.5\r\n\r\n- What OS and version, and what distro if applicable?\r\nWindows Server 2022\r\n\r\n- What is the architecture (x64, x86, ARM, ARM64)?\r\nx64\n\n### Other information\n\nIf you need more information, please let me know.",
    "upvotes": 1,
    "labels": [
      "feature-diagnostics",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85cYS7Y",
        "parentId": null,
        "author": "LTAravindh92",
        "content": "I\u0027m also facing the same issue.",
        "createdAt": "2023-05-16T15:14:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48244#issuecomment-1549872856"
      },
      {
        "id": "IC_kwDOAQzde85cZFiA",
        "parentId": null,
        "author": "tygore587",
        "content": "We also started to experience this issue with other packages even locally. \r\n\r\nWe have some wrapper code around the azure service bus sdk. They are located in a .net standard project.\r\n\r\nThe workaround we found was to directly instantiate a class from the package that was not found. If we do this the problem disappears.\r\nBut we are not comfortable to use .net 7 with these kind of issues because they appeared out of nowhere. We never had a problem before even with .net 7 and .net 6 was stable for month on our prod system. \r\n\r\nJust scrolled through the issues and it looks like these problems are in general similar to #48199 ",
        "createdAt": "2023-05-16T17:26:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48244#issuecomment-1550080128"
      },
      {
        "id": "IC_kwDOAQzde85q9E6w",
        "parentId": null,
        "author": "moellerm",
        "content": "These problems could be related to the issue https://github.com/dotnet/runtime/issues/60144 if the exceptions occur after upgrading the dotnet runtime (for example by Windows Update or another service/installer/update) while the application/service is running.",
        "createdAt": "2023-11-06T09:24:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48244#issuecomment-1794395824"
      },
      {
        "id": "IC_kwDOAQzde85rEogB",
        "parentId": null,
        "author": "tygore587",
        "content": "\u003E These problems could be related to the issue [dotnet/runtime#60144](https://github.com/dotnet/runtime/issues/60144) if the exceptions occur after upgrading the dotnet runtime (for example by Windows Update or another service/installer/update) while the application/service is running.\r\n\r\nWe are building self containted packages, so this shouldn\u0027t be an issue. Also it worked like 99% of the time until it randomly stopped working at all.\r\nAt the moment we are still at .net 6 because this breaked our production environment like 3-4 times and some developers started to get the same issue randomly on their laptops.",
        "createdAt": "2023-11-06T20:24:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48244#issuecomment-1796376577"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85l5c7a",
    "title": "HttpLoggingMiddleware: Unique ID for Request/Response ",
    "url": "https://github.com/dotnet/aspnetcore/issues/48235",
    "createdAt": "2023-05-15T08:10:54Z",
    "lastUpdated": "2024-02-13T01:35:55Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Is your feature request related to a problem? Please describe the problem.\r\n\r\nOfficial documentation [HTTP Logging in ASP.NET Core](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-logging/?view=aspnetcore-7.0)\r\n\r\nIf I activate logging in .Net 7.0, the info is written to the standard logger for each request and response.\r\nIs is also possible to write the info with nlog, SerialLogger...., this is good and ok.\r\n\r\nHowever, it is not possible to assign the response to the request because there is no unique ID here.\r\nAlso i don\u0027t find any key to assign respnose and the response-body ?\r\n\r\nYhy not, is it not possible or does this contradict an architecture guideline?\r\n\r\nMy idea was, write a uniuqe id (guid) to every related request/response/body, such a UniueConnectionId or other named. \r\n\r\n### Describe the solution you\u0027d like\r\n\r\nOutput-Example of a Request with the HttpLoggingMiddleware\r\n\u0060\u0060\u0060\r\ninfo: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[1]\r\n      Request:\r\n      Protocol: HTTP/1.1\r\n      Method: POST\r\n      Scheme: http\r\n      UniqueConnectionId: 55b51106-0cc2-4086-81db-de8cadf91cdc  =\u003E NEW \r\n....\r\n\u0060\u0060\u0060\r\nExample of a Request-Body\r\n\u0060\u0060\u0060\r\ninfo: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[2]\r\n      RequestBody: {\r\n          \u0022username\u0022: \u0022josef\u0022,\r\n          \u0022password\u0022: \u0022MyPassword\u0022,\r\n           UniqueConnectionId: 55b51106-0cc2-4086-81db-de8cadf91cdc  =\u003E NEW \r\n      }\r\n\u0060\u0060\u0060\r\nresponse and response body\r\n\u0060\u0060\u0060\r\ninfo: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[1]\r\n      Response:\r\n      StatusCode: 200\r\n      Content-Type: application/json; charset=utf-8\r\n      UniqueConnectionId: 55b51106-0cc2-4086-81db-de8cadf91cdc  =\u003E NEW \r\n\r\ninfo: Microsoft.AspNetCore.HttpLogging.HttpLoggingMiddleware[2]\r\n      ResponseBody: {\u0022token\u0022:\u0022very secret token\u0022}\r\n      UniqueConnectionId: 55b51106-0cc2-4086-81db-de8cadf91cdc  =\u003E NEW \r\n\u0060\u0060\u0060\r\n\r\n### Additional context\r\n\r\n_No response_",
    "upvotes": 2,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85cRyf9",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "Turn on log scopes: https://learn.microsoft.com/aspnet/core/fundamentals/logging/?view=aspnetcore-7.0#log-scopes\r\nAspNet includes a unique ID for every request already in the log scope.",
        "createdAt": "2023-05-15T16:20:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48235#issuecomment-1548167165"
      },
      {
        "id": "IC_kwDOAQzde85cZBbN",
        "parentId": null,
        "author": "michisnewsletter",
        "content": "\u003E Turn on log scopes: https://learn.microsoft.com/aspnet/core/fundamentals/logging/?view=aspnetcore-7.0#log-scopes AspNet includes a unique ID for every request already in the log scope.\r\n\r\nThat\u0027s not the solution for my problem, i can not make a log scope on every controler/endpoint.\r\nBecause i will \u0022only\u0022 use this HttpLoggigMiddleware, and not writing extra-code for http logging. \r\nYes you are right, if a make this by every call, then i could log my own \u0022connection id\u0022, but this was not really my question.",
        "createdAt": "2023-05-16T17:13:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48235#issuecomment-1550063309"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85mggPv",
    "title": "Add a judgment condition in app.UseHttpLogging()",
    "url": "https://github.com/dotnet/aspnetcore/issues/48360",
    "createdAt": "2023-05-22T14:16:17Z",
    "lastUpdated": "2024-02-13T01:35:05Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Is your feature request related to a problem? Please describe the problem.\r\n\r\n I have a scenario like this, there are many endpoints in my project, I use \u0060app.UseHttpLogging()\u0060 middleware to log request and response, It works very well. But I have a special endpoint, when this endpoint return 200, it will not log request/response information. when this endpoint return 400 or any other statuscode, It will log the request/response information. \r\n\r\n### Describe the solution you\u0027d like\r\n\r\nI know I can custom middleware to achieve it, But is it possible that \u0060app.UseHttpLogging()\u0060 will integrate this judgment condition in future versions? I also try :\r\n\u0060\u0060\u0060\r\napp.UseWhen(\r\n        context =\u003E !(context.Request.Path.StartsWithSegments(\u0022/xxx\u0022)\r\n                             \u0026\u0026 context.Response.StatusCode == 200),\r\n        builder =\u003E builder.UseHttpLogging()\r\n    );\r\n\u0060\u0060\u0060\r\nBut when this endpoint return 400, it also will log anything.\r\n\r\n### Additional context\r\n\r\n_No response_",
    "upvotes": 1,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85c1T4I",
        "parentId": null,
        "author": "Tratcher",
        "content": "UseWhen won\u0027t work for this because it\u0027s evaluated before the response is generated (the status code is always 200 by default).\r\n\r\nhttps://github.com/dotnet/aspnetcore/issues/39200 would address this.\r\n\r\n*edit* not quite, that issue covers making a decision on the way in, it can\u0027t check the response. Note that the initial logging of the request happens before the endpoint runs and would not be conditional on the response. We could have a conditional check about logging the response.",
        "createdAt": "2023-05-22T15:56:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48360#issuecomment-1557478920"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85nuzHD",
    "title": "Migrations cannot be applied when project name contains non ASCII character",
    "url": "https://github.com/dotnet/aspnetcore/issues/48604",
    "createdAt": "2023-05-25T19:51:02Z",
    "lastUpdated": "2024-09-19T07:39:36Z",
    "body": "## Error\r\n\r\nWhen project name (i.e. assembly and namespace) contain a non-ascii character, the migrations cannot be applied from the running application (didn\u0027t try the CLI). The error is\r\n\r\n\u0060\u0060\u0060\r\nfail: Microsoft.AspNetCore.Diagnostics.EntityFrameworkCore.MigrationsEndPointMiddleware[3]\r\n      The context type \u0027\\u0160.Data.ApplicationDbContext, \\u0160, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null\u0027 was not found in services. This usually means the context was not registered in services during startup. You probably want to call AddScoped\u003C\u003E() inside the UseServices(...) call in your application startup code.\r\n\u0060\u0060\u0060\r\n\r\nThe DbContext is registered and the error doesn\u0027t appear when the project name is ASCII only.\r\n\r\n## How to reproduce\r\n\r\nCreate new web app from template called \u0060\u0160\u0060, switch to PostgreSQL (because the default Sqlite isn\u0027t applying migrations and magically works from start, I doubt the problem is with Npgsql) \r\n\r\n\u0060\u0060\u0060\r\ndotnet new razor -n \u0160 --auth Individual\r\ncd \u0160\r\ndotnet add package Npgsql.EntityFrameworkCore.PostgreSQL\r\n\u0060\u0060\u0060\r\n\r\n* Change \u0060options.UseSqlite(connectionString)\u0060 to \u0060options.UseNpgsql(connectionString)\u0060 in Program.cs\r\n* Change connection string in appsettings.json to a PostgreSQL server\r\n* Navigate the website, attempt to login\r\n* That errors out, because migrations weren\u0027t applied, click \u0022Apply Migrations\u0022 which also fails with \u0022 An error occurred applying migrations, try applying them from the command line \u0022 \r\n\r\nIf the project is called \u0060S\u0060 instead of \u0060\u0160\u0060, it works as expected (login fails, but then, clicking Apply Migrations works). For more precise reproducibility, I have attached both versions: [S.tar.gz](https://github.com/dotnet/efcore/files/11568557/S.tar.gz), [\u0160.tar.gz](https://github.com/dotnet/efcore/files/11568558/S.tar.gz).\r\n\r\nThe only difference in Program.cs is the namespace, I didn\u0027t touch the other files:\r\n\r\n\u0060\u0060\u0060\r\nexyi@NaN /tmp\u003E diff \u0160/Program.cs S/Program.cs\r\n3c3\r\n\u003C using \u0160.Data;\r\n---\r\n\u003E using S.Data;\r\n\u0060\u0060\u0060\r\n\r\n### System and versions\r\n\r\nEF Core version: 7.0.3\r\nNpgsql version: 7.0.4\r\nTarget framework: net7.0\r\nOperating system: Linux (Arch)\r\nIDE: The Command Line Interface at al.\r\n",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85d6LVn",
        "parentId": null,
        "author": "ajcvickers",
        "content": "Tracked this down to a bug in looking up the context type in MigrationsEndPointMiddleware. See https://github.com/dotnet/aspnetcore/blob/c2488eead6ead7208f543d0a57104b5d167b93f9/src/Middleware/Diagnostics.EntityFrameworkCore/src/MigrationsEndPointMiddleware.cs#L92\r\n\r\nMoving to ASP.NET Core repo.",
        "createdAt": "2023-06-04T11:32:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48604#issuecomment-1575531879"
      },
      {
        "id": "IC_kwDOAQzde85eJgI5",
        "parentId": null,
        "author": "amcasey",
        "content": "Thanks, @ajcvickers!",
        "createdAt": "2023-06-06T22:33:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48604#issuecomment-1579549241"
      },
      {
        "id": "IC_kwDOAQzde85ePZCP",
        "parentId": null,
        "author": "mitchdenny",
        "content": "@ajcvickers did you repro this? I wasn\u0027t able to repro the specific issue on Windows (@exyi reported this issue on Arch Linux which isn\u0027t in our support matrix from what I gather so some localization issue might be a factor).\r\n\r\n@exyi - can you repro this on one of our supported Linux distros?\r\n\r\nhttps://learn.microsoft.com/en-us/dotnet/core/install/linux#packages",
        "createdAt": "2023-06-07T15:45:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48604#issuecomment-1581093007"
      },
      {
        "id": "IC_kwDOAQzde85ePaf0",
        "parentId": null,
        "author": "mitchdenny",
        "content": "Also ... try doing a form post to the \u0060/ApplyDatabaseMigrations\u0060 endpoint passing in the type name from the error above. Substitute the \u0060\\u....\u0060 code with the actual character in the form request.",
        "createdAt": "2023-06-07T15:48:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48604#issuecomment-1581098996"
      },
      {
        "id": "IC_kwDOAQzde85eP3QT",
        "parentId": null,
        "author": "ajcvickers",
        "content": "@mitchdenny Yes, it repros on Windows.",
        "createdAt": "2023-06-07T17:07:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48604#issuecomment-1581216787"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85nl_Yr",
    "title": "\u0060AddHeaderPropagation()\u0060 without providing \u0060Action\u003CHeaderPropagationOptions\u003E configureOptions\u0060 prevents middleware from working correctly",
    "url": "https://github.com/dotnet/aspnetcore/issues/48581",
    "createdAt": "2023-06-02T11:23:12Z",
    "lastUpdated": "2025-01-14T15:45:26Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nWhen trying to configure the header propagation feature using the \u0060HeaderPropagationServiceCollectionExtensions.AddHeaderPropagation(this IServiceCollection services)\u0060 (\r\n[link](https://github.com/dotnet/aspnetcore/blob/d919168952ac4da33be8532c6980547a783a7389/src/Middleware/HeaderPropagation/src/DependencyInjection/HeaderPropagationServiceCollectionExtensions.cs#LL20C6-L20C6)) method, there is no \u0060HeaderPropagationOptions\u0060 instance registered, so the middleware doesn\u0027t capture any headers and header propagation won\u0027t work, even when header names are specified for a specific \u0060HttpClient\u0060, e.g.:\r\n\r\n    services.AddHeaderPropagation();\r\n    services.AddHttpClient\u003CFooClient\u003E().AddHeaderPropagation(o =\u003E o.Headers.Add(\u0022Authorization\u0022));\r\n    services.AddHttpClient\u003CBarClient\u003E().AddHeaderPropagation(o =\u003E o.Headers.Add(\u0022X-Another-Header\u0022));\r\n\r\nThis results in no headers being forwarded.\r\n\r\nInstead, this needs to be done:\r\n\r\n    services.AddHeaderPropagation(o =\u003E\r\n    {\r\n        o.Headers.Add(\u0022Authorization\u0022);\r\n        o.Headers.Add(\u0022X-Another-Header\u0022);\r\n    });\r\n    services.AddHttpClient\u003CFooClient\u003E().AddHeaderPropagation(o =\u003E o.Headers.Add(\u0022Authorization\u0022));\r\n    services.AddHttpClient\u003CBarClient\u003E().AddHeaderPropagation(o =\u003E o.Headers.Add(\u0022X-Another-Header\u0022));\r\n\r\nThis is especially problematic if different \u0060HttpClient\u0060s require forwarding different headers - the \u0060services.AddHeaderPropagation\u0060 call needs to list all those headers, which is code duplication and leads to bugs.\r\n\r\nI propose to either:\r\n 1. Make \u0060AddHeaderPropagation(this IServiceCollection services)\u0060 internal, as it\u0027s useless for users of this library. This way all headers still need to be listed explicitly in the \u0060services.AddHeaderPropagation()\u0060 call, but at least the not working method is hidden.\r\n 2. Change \u0060AddHeaderPropagation(Action\u003CHeaderPropagationMessageHandlerOptions\u003E)\u0060 so that it adds the configured headers to the registered \u0060HeaderPropagationOptions\u0060 (and/or registers it if it\u0027s not yet registered).\r\n\r\nI can create a PR for either of these (I prefer option 2), but looking for some feedback first.\n\n### Expected Behavior\n\n_No response_\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n_No response_\n\n### Anything else?\n\n_No response_",
    "upvotes": 2,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85kIslJ",
        "parentId": null,
        "author": "kavatari",
        "content": "@jjanuszkiewicz Did you register the middleware?\r\n\u0060app.UseHeaderPropagation()\u0060\r\n\r\nsee: https://learn.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-6.0#header-propagation-middleware\r\n\r\nalso an example in this repo: https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HeaderPropagation/samples/HeaderPropagationSample/Startup.cs",
        "createdAt": "2023-08-16T05:50:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48581#issuecomment-1680001353"
      },
      {
        "id": "IC_kwDOAQzde85kLqYm",
        "parentId": null,
        "author": "jjanuszkiewicz",
        "content": "Yes, I register the middleware.\r\n\r\nThe problem is that:\r\n - \u0060HeaderPropagationMiddleware\u0060 takes an instance of \u0060IOptions\u003CHeaderPropagationOptions\u003E\u0060 and [captures only the headers included in those options](https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HeaderPropagation/src/HeaderPropagationMiddleware.cs#L49)\r\n - but the parameterless \u0060IServiceCollection.AddHeaderPropagation()\u0060 [method](https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/HeaderPropagation/src/DependencyInjection/HeaderPropagationServiceCollectionExtensions.cs#L20C38-L20C58) doesn\u0027t register the options,\r\n - so even if options are later provided for a specific HttpClient via \u0060IHttpClientBuilder.AddHeaderPropagation(Action\u003CHeaderPropagationMessageHandlerOptions\u003E configure)\u0060 it doesn\u0027t make the middleware capture any headers, because this method doesn\u0027t register or modify the registered instance of \u0060HeaderPropagationOptions\u0060.\r\n\r\nMy suggestion 2 would address that:\r\n\r\n\u003E Change AddHeaderPropagation(Action\u003CHeaderPropagationMessageHandlerOptions\u003E) so that it adds the configured headers to the registered HeaderPropagationOptions (and/or registers it if it\u0027s not yet registered).",
        "createdAt": "2023-08-16T14:58:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48581#issuecomment-1680778790"
      },
      {
        "id": "IC_kwDOAQzde85kLr_B",
        "parentId": null,
        "author": "jjanuszkiewicz",
        "content": "Like I said, I can create a PR with proposed changes and hopefully also with some tests demonstrating the problem, but I\u0027d like to get some feedback first (e.g. if this is for some reason by design and the PR won\u0027t be considered for merging?)",
        "createdAt": "2023-08-16T15:02:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48581#issuecomment-1680785345"
      },
      {
        "id": "IC_kwDOAQzde85kL3hX",
        "parentId": null,
        "author": "davidfowl",
        "content": "API changes require an [API proposal](https://github.com/dotnet/aspnetcore/issues/new?assignees=\u0026labels=api-suggestion\u0026projects=\u0026template=30_api_proposal.md\u0026title=) and review and number 1 is a non-starter because it\u0027s a binary breaking change.",
        "createdAt": "2023-08-16T15:30:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48581#issuecomment-1680832599"
      },
      {
        "id": "IC_kwDOAQzde85vGWJr",
        "parentId": null,
        "author": "rmja",
        "content": "I am seeing this as well. I was expecting \u0060services.AddHttpClient\u003CFooClient\u003E().AddHeaderPropagation(o =\u003E o.Headers.Add(\u0022Authorization\u0022));\u0060 to automatically add \u0060Authorization\u0060 to the set of headers being captured by the middleware.",
        "createdAt": "2023-12-20T06:41:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48581#issuecomment-1863934571"
      },
      {
        "id": "IC_kwDOAQzde85vUZkT",
        "parentId": null,
        "author": "jjanuszkiewicz",
        "content": "If I have some spare time during holiday, I\u0027ll create a MR with tests showing the problem and maybe a possible solution (#2 from my original post). If time permits.",
        "createdAt": "2023-12-22T12:15:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48581#issuecomment-1867618579"
      },
      {
        "id": "IC_kwDOAQzde86aZMhG",
        "parentId": null,
        "author": "Pikabanga",
        "content": "I fell for this too. This behavior to me is very unintuitive, and unflexible.",
        "createdAt": "2025-01-14T15:45:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/48581#issuecomment-2590296134"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85qdsbv",
    "title": "Short circuit attribute",
    "url": "https://github.com/dotnet/aspnetcore/issues/49181",
    "createdAt": "2023-07-03T13:17:36Z",
    "lastUpdated": "2024-04-08T14:22:19Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Is your feature request related to a problem? Please describe the problem.\r\n\r\nThe short circuit feature only has extension methods for adding the required metadata to endpoints. Should there be an attribute? That would allow MVC actions and gRPC methods to support short circuiting.\r\n\r\nFor example,\r\n\r\n\u0060\u0060\u0060cs\r\npublic class MonitoringController\r\n{\r\n    [ShortCircuit]\r\n    [HttpGet(\u0022/status\u0022)]\r\n    public ActionResult GetStatus()\r\n    {\r\n        // ...\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nBrought up in YouTube video: https://youtu.be/rXdwX2X4-gw?t=422\r\n\r\nNote that a short-circuited MVC action would still execute filters, and a gRPC method would still execute interceptors.\r\n\r\n### Describe the solution you\u0027d like\r\n\r\n* Change internal \u0060ShortCircuitMetadata\u0060 to an interface. (optional)\r\n* Change current metadata to an attribute and make public (implement the interface if present)\r\n\r\n### Additional context\r\n\r\n_No response_",
    "upvotes": 1,
    "labels": [
      "api-approved",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85gdStb",
        "parentId": null,
        "author": "mitchdenny",
        "content": "Given the intention of this wouldn\u0027t it be better to just encourage people to use the minimal version of the API?",
        "createdAt": "2023-07-03T13:41:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49181#issuecomment-1618291547"
      },
      {
        "id": "IC_kwDOAQzde85gdX0i",
        "parentId": null,
        "author": "Kahbazi",
        "content": "\u002B1 On adding \u0060ShortCircuitAttribute\u0060. As long as the metadata is internal, frameworks like YARP can not add have short circuited routes.",
        "createdAt": "2023-07-03T13:47:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49181#issuecomment-1618312482"
      },
      {
        "id": "IC_kwDOAQzde85gtAxh",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E Given the intention of this wouldn\u0027t it be better to just encourage people to use the minimal version of the API?\r\n\r\nControllers (and proxies \uD83D\uDE06) are a lot more expensive than minimal, it\u0027s unclear how much relative cost an MVC endpoint would save with this attribute, and if making it available would be misleading. That said, the inconsistency is also confusing, they may legitimately have an expensive middleware to skip.",
        "createdAt": "2023-07-05T20:00:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49181#issuecomment-1622412385"
      },
      {
        "id": "IC_kwDOAQzde85th17Y",
        "parentId": null,
        "author": "fvoronin",
        "content": " I\u0027m interested in doing this. Can I take a look and submit a PR on that issue?",
        "createdAt": "2023-12-03T20:17:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49181#issuecomment-1837588184"
      },
      {
        "id": "IC_kwDOAQzde85uOhXk",
        "parentId": null,
        "author": "??",
        "content": "Thank you for submitting this for API review. This will be reviewed by @dotnet/aspnet-api-review at the next meeting of the ASP.NET Core API Review group. Please ensure you take a look at [the API review process documentation](https://github.com/dotnet/aspnetcore/blob/main/docs/APIReviewProcess.md) and ensure that:\n\n* The PR contains changes to the reference-assembly that describe the API change. **Or**, you have included a snippet of reference-assembly-style code that illustrates the API change.\n* The PR describes the impact to users, both positive (useful new APIs) and negative (breaking changes).\n* Someone is assigned to \u0022champion\u0022 this change in the meeting, and they understand the impact and design of the change.",
        "createdAt": "2023-12-11T04:19:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49181#issuecomment-1849300452"
      },
      {
        "id": "IC_kwDOAQzde85v7t1X",
        "parentId": null,
        "author": "halter73",
        "content": "API Review Notes:\r\n\r\n- It\u0027s a little surprising there was no public metadata type to begin with.\r\n- It does seem like it could be useful for non-minimal endpoints.\r\n\r\nAPI Approved!\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.AspNetCore.Routing.ShortCircuit;\r\n\r\n\u002B public sealed class ShortCircuitAttribute : Attribute, IShortCircuitMetadata\r\n\u002B {\r\n\u002B    public ShortCircuitAttribute();\r\n\u002B    public ShortCircuitAttribute(int statusCode);\r\n\u002B\r\n\u002B    public int? StatusCode { get; }\r\n\u002B }\r\n\r\n\u002B public interface IShortCircuitMetadata\r\n\u002B {\r\n\u002B    int? StatusCode { get; }\r\n\u002B }\r\n\u0060\u0060\u0060",
        "createdAt": "2024-01-05T00:00:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49181#issuecomment-1877925207"
      },
      {
        "id": "IC_kwDOAQzde85wNPh6",
        "parentId": null,
        "author": "danirzv",
        "content": "If anyone else is not working on it, im interested to work it out, may i send a PR?",
        "createdAt": "2024-01-09T07:09:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49181#issuecomment-1882519674"
      },
      {
        "id": "IC_kwDOAQzde85wNRoY",
        "parentId": null,
        "author": "fvoronin",
        "content": "@danirzv, PR already exists https://github.com/dotnet/aspnetcore/pull/52571 ",
        "createdAt": "2024-01-09T07:19:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49181#issuecomment-1882528280"
      },
      {
        "id": "IC_kwDOAQzde855xAQ-",
        "parentId": null,
        "author": "fvoronin",
        "content": "\u003E API Approved!\r\n\u003E \r\n\u003E \u0060\u0060\u0060diff\r\n\u003E namespace Microsoft.AspNetCore.Routing.ShortCircuit;\r\n\u003E \r\n\u003E \u002B public sealed class ShortCircuitAttribute : Attribute, IShortCircuitMetadata\r\n\u003E \u002B {\r\n\u003E \u002B    public ShortCircuitAttribute();\r\n\u003E \u002B    public ShortCircuitAttribute(int statusCode);\r\n\u003E \u002B\r\n\u003E \u002B    public int? StatusCode { get; }\r\n\u003E \u002B }\r\n\u003E \r\n\u003E \u002B public interface IShortCircuitMetadata\r\n\u003E \u002B {\r\n\u003E \u002B    int? StatusCode { get; }\r\n\u003E \u002B }\r\n\u003E \u0060\u0060\u0060\r\n\r\n@halter73, sorry for long pause.\r\n\r\nIt seems to me that there are some issues with the ambiguity of attribute behaviour  when there is a public constructor with parameter\r\n\r\n\u0060\u0060\u0060cs\r\npublic ShortCircuitAttribute(int statusCode);\r\n\u0060\u0060\u0060\r\n\r\nFor example, how should an application behave, with a controller like this:\r\n\u0060\u0060\u0060cs\r\npublic class TestController : ControllerBase\r\n{\r\n    [ShortCircuit(500)]\r\n    public ActionResult Index()\r\n    {\r\n        if (foo)\r\n            return new UnauthorizedResult();\r\n\r\n        if (bar)\r\n            return new BadRequestResult();\r\n\r\n        return new OkResult();\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\nThe \u0060statusCode\u0060 specified in the \u0060ShortCircuit\u0060 attribute does not match any of those returned from the method.\r\n\r\nWould it still be better to make the constructor with the \u0060statusCode\u0060 parameter as \u0060internal\u0060?\r\n\r\n \u0060\u0060\u0060diff\r\npublic sealed class ShortCircuitAttribute : Attribute, IShortCircuitMetadata\r\n{\r\n   public ShortCircuitAttribute();\r\n-    public ShortCircuitAttribute(int statusCode);\r\n\u002B    internal ShortCircuitAttribute(int statusCode);\r\n\r\n   public int? StatusCode { get; }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nP.S. I\u0027m work on it #52571",
        "createdAt": "2024-04-08T14:22:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49181#issuecomment-2042889278"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85qhI7N",
    "title": "Always set IExceptionHandlerFeature from UseDeveloperExceptionPage",
    "url": "https://github.com/dotnet/aspnetcore/issues/49195",
    "createdAt": "2023-07-04T03:18:33Z",
    "lastUpdated": "2024-02-13T01:31:20Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Is your feature request related to a problem? Please describe the problem.\r\n\r\nThe \u0060DeveloperExceptionPageMiddleware\u0060 catches errors and displays a friendly error page. It can optionally invoke \u0060IProblemDetailsService\u0060 for its response. When \u0060IProblemDetailsService\u0060 is called, \u0060IExceptionHandlerFeature\u0060 is set on the \u0060HttpContext\u0060. That change happened earlier this year: https://github.com/dotnet/aspnetcore/issues/47060\r\n\r\nI think we should consider changing the developer exception page middleware again to always set \u0060IExceptionHandlerFeature\u0060 if the middleware doesn\u0027t rethrow the error. The reason to do this is there is no way for earlier middleware or \u0060HttpResponse.OnComplete\u0060 callbacks to discover what exception was thrown once caught by developer exception middleware.\r\n\r\nI noticed this problem when writing some middleware that cares about the exception and is injected by an \u0060IStartupFilter\u0060:\r\n\r\n* [Folder](https://github.com/JamesNK/MeterFactoryDemo/tree/main/src/AspNetCoreEnricher)\r\n* [StartupFilter](https://github.com/JamesNK/MeterFactoryDemo/blob/main/src/AspNetCoreEnricher/Internal/EnricherStartupFilter.cs) - note that it adds the middleware to the start of the pipeline (start and end are the only options, and the end is rarely really a good choice because it will be after terminal endpoint execution). Adding middleware to the start is before [UseDeveloperExceptionPage is automatically added by WebApplicationBuilder](https://github.com/dotnet/aspnetcore/blob/9da617793b3b387fd16bbc3e0ec06337569ca6ac/src/DefaultBuilder/src/WebApplicationBuilder.cs#L335-L338).\r\n* [Middleware](https://github.com/JamesNK/MeterFactoryDemo/blob/main/src/AspNetCoreEnricher/Internal/RunEnrichersMiddleware.cs) - The middleware wants to ensure the unhandled exception is always available in \u0060HttpResponse.OnComplete\u0060 callback. Unfortunately, if the developer exception page is present, the exception is always caught and thrown away.\t\r\n\r\n### Describe the solution you\u0027d like\r\n\r\nAlways set \u0060IExceptionHandlerFeature\u0060 in developer exception middleware so middleware earlier in the pipeline and \u0060HttpResponse.OnComplete\u0060 can access information about the exception.\r\n\r\n### Additional context\r\n\r\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-middleware",
      "help candidate"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde85rbPjv",
    "title": "Rate limiting middleware OnReject assign bug",
    "url": "https://github.com/dotnet/aspnetcore/issues/49379",
    "createdAt": "2023-07-13T06:39:10Z",
    "lastUpdated": "2024-02-13T01:30:30Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nPlease check the code below\uFF08located 130~134 lines of source code\uFF09\uFF1A\r\n\r\n\u0060\u0060\u0060csharp\r\ninternal sealed partial class RateLimitingMiddleware\r\n{\r\n  private async Task InvokeInternal(HttpContext context, EnableRateLimitingAttribute? enableRateLimitingAttribute)\r\n  {\r\n     policy = enableRateLimitingAttribute?.Policy;\r\n     if (policy is not null)\r\n     {\r\n        thisRequestOnRejected = policy.OnRejected;\r\n     }\r\n  }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nI think we should check if \u0060Policy.OnReject\u0060 is null here, if not null, then use it, else use \u0060OnRejected\u0060 from the \u0060Options\u0060 if available\r\n\r\n### Expected Behavior\r\n\r\n\u0060\u0060\u0060csharp\r\ninternal sealed partial class RateLimitingMiddleware\r\n{\r\n  private async Task InvokeInternal(HttpContext context, EnableRateLimitingAttribute? enableRateLimitingAttribute)\r\n  {\r\n     policy = enableRateLimitingAttribute?.Policy;\r\n     if (policy?.OnRejected is not null)\r\n     {\r\n        thisRequestOnRejected = policy.OnRejected;\r\n     }\r\n  }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n### Steps To Reproduce\r\n\r\n\u0060\u0060\u0060csharp\r\n public class MyRateLimiterPolicy : IRateLimiterPolicy\u003Cstring\u003E\r\n  {\r\n      public MyRateLimiterPolicy()\r\n      {\r\n      }\r\n\r\n      // keep it null\r\n      public Func\u003COnRejectedContext, CancellationToken, ValueTask\u003E? OnRejected { get; }\r\n\r\n      public RateLimitPartition\u003Cstring\u003E GetPartition(HttpContext httpContext)\r\n      {\r\n          return RateLimitPartition.GetFixedWindowLimiter(\u0022anything\u0022, _ =\u003E new FixedWindowRateLimiterOptions\r\n          {\r\n              PermitLimit = 3,\r\n              Window = TimeSpan.FromSeconds(60),\r\n              QueueProcessingOrder = QueueProcessingOrder.OldestFirst,\r\n              QueueLimit = 0\r\n          });\r\n      }\r\n  }\r\n\r\nbuilder.Services.AddRateLimiter(limiterOptions =\u003E\r\n{\r\n  limiterOptions.OnRejected = (context, cancellationToken) =\u003E\r\n    {\r\n        return ValueTask.CompletedTask;\r\n    };\r\n}\r\n\r\napp.MapGet(\u0022LimitTest\u0022, async () =\u003E\r\n{\r\n    return Results.Ok(\u0022Limiter\u0022);\r\n}).RequireRateLimiting(new MyRateLimiterPolicy());\r\n\u0060\u0060\u0060\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n.NET 7, 8\r\n\r\n### Anything else?\r\n\r\n_No response_",
    "upvotes": 0,
    "labels": [
      "Needs: Attention :wave:",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85hYW-z",
        "parentId": null,
        "author": "mitchdenny",
        "content": "Can you provide a bit more detail about your usage scenarios (why you want this fallback behavior?).",
        "createdAt": "2023-07-13T08:12:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49379#issuecomment-1633775539"
      },
      {
        "id": "IC_kwDOAQzde85hYXKE",
        "parentId": null,
        "author": "??",
        "content": "Hi @xiaoxiaotank. We have added the \u0022Needs: Author Feedback\u0022 label to this issue, which indicates that we have an open question for you before we can take further action. This issue will be closed automatically in 7 days if we do not hear back from you by then - please feel free to re-open it if you come back to this issue after that time.",
        "createdAt": "2023-07-13T08:13:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49379#issuecomment-1633776260"
      },
      {
        "id": "IC_kwDOAQzde85hYis-",
        "parentId": null,
        "author": "xiaoxiaotank",
        "content": "\u003E Can you provide a bit more detail about your usage scenarios (why you want this fallback behavior?).\r\n\r\nBy using \u0060AddRateLimiter\u0060, you can register rate limiting service. By using \u0060RateLimiterOptions.OnRejected\u0060, you can set the global default callback logic on rejected. When \u0060OnRejected\u0060 is not specified in the registered rate limiting policy, \u0060RateLimiterOptions.OnRejected\u0060 will be executed. This is because the source code comment states, \u0022Use custom policy OnRejected if available, else use OnRejected from the Options if available.\r\n\r\nPlease refer to the following example code, which should execute \u0060RateLimiterOptions. OnRejected\u0060 after rate limiting rejection, but it did not actually execute:\r\n\u0060\u0060\u0060csharp\r\n  public class MyRateLimiterPolicy : IRateLimiterPolicy\u003Cstring\u003E\r\n  {\r\n      public MyRateLimiterPolicy()\r\n      {\r\n      }\r\n\r\n      // keep it null\r\n      public Func\u003COnRejectedContext, CancellationToken, ValueTask\u003E? OnRejected { get; }\r\n\r\n      public RateLimitPartition\u003Cstring\u003E GetPartition(HttpContext httpContext)\r\n      {\r\n          return RateLimitPartition.GetFixedWindowLimiter(\u0022anything\u0022, _ =\u003E new FixedWindowRateLimiterOptions\r\n          {\r\n              PermitLimit = 3,\r\n              Window = TimeSpan.FromSeconds(60),\r\n              QueueProcessingOrder = QueueProcessingOrder.OldestFirst,\r\n              QueueLimit = 0\r\n          });\r\n      }\r\n  }\r\n\r\nbuilder.Services.AddRateLimiter(limiterOptions =\u003E\r\n{\r\n  limiterOptions.OnRejected = (context, cancellationToken) =\u003E\r\n    {\r\n        return ValueTask.CompletedTask;\r\n    };\r\n}\r\n\r\napp.MapGet(\u0022LimitTest\u0022, async () =\u003E\r\n{\r\n    return Results.Ok(\u0022Limiter\u0022);\r\n}).RequireRateLimiting(new MyRateLimiterPolicy());\r\n\u0060\u0060\u0060\r\n\r\nIf possible, I hope you can take a look at [this](https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/RateLimiting/src/RateLimitingMiddleware.cs#L131), Although \u0060policy\u0060 is not null, but \u0060policy.OnRejected\u0060 may be null. in addition, on line 137, there is a non empty judgment",
        "createdAt": "2023-07-13T08:45:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49379#issuecomment-1633823550"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85r_l0K",
    "title": "WebApplication.UseStatusCodePages() cannot handle unauthorized requests without explicit UseAuthorization() call",
    "url": "https://github.com/dotnet/aspnetcore/issues/49515",
    "createdAt": "2023-07-19T12:21:48Z",
    "lastUpdated": "2024-02-13T01:29:55Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nThese are observations from implementing auth with Server-side rendered pages (SSR) in Blazor Preview 6 - using Razor components instead of MVC Razor pages.\r\n\r\nCookie auth just works, that is great. But there are some issues:\r\n\r\nIssues:\r\n\r\n- \u0060\u0060AuthorizeRouteView\u0060\u0060 doesn\u0027t work with the router. The \u0060\u0060NotAuthorized\u0060\u0060 fragment does not get rendered. Instead I get redirected to a layout-less page saying: \u0060\u0060Error: 401 Unauthorized\u0060\u0060.\r\n\r\n- The \u0060\u0060LoginDisplay\u0060\u0060 doesn\u0027t re-ender when logged in using form. Redirecting to another page would help here.\r\n\r\nQuestions:\r\n- How do I redirect to another URL from a component that server render? \u0060\u0060NavigationManager\u0060\u0060 of course doesn\u0027t work here.\r\n\r\nMy github repo (branch): https://github.com/marinasundstrom/Blazor8Test/tree/auth\r\n\r\n### Expected Behavior\r\n\r\nWhen unauthorized and entering page that requires authorization, \r\nI expect the \u0060\u0060NotAuthorized\u0060\u0060 fragment to be rendered with the \u0060\u0060MainLayout\u0060\u0060.\r\n\r\n### Steps To Reproduce\r\n\r\nhttps://github.com/marinasundstrom/Blazor8Test/tree/auth\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n8.0.100-preview.6.23330.14\r\n\r\n### Anything else?\r\n\r\n_No response_",
    "upvotes": 1,
    "labels": [
      "area-hosting",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85h4oho",
        "parentId": null,
        "author": "javiercn",
        "content": "\u003E How do I redirect to another URL from a component that server render? NavigationManager of course doesn\u0027t work here.\r\n\r\nNavigation manager should work (not sure if it does in Preview6). There might be some conflicts with the SSR navigation manager overriding the static renderer one.",
        "createdAt": "2023-07-19T14:49:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49515#issuecomment-1642236008"
      },
      {
        "id": "IC_kwDOAQzde85h4qst",
        "parentId": null,
        "author": "marinasundstrom",
        "content": "@javiercn OK. Yes. I\u0027m on Preview 6 and it uses the \u0060\u0060RemoteNavigationManager\u0060\u0060 even for server-side rendered page. And when invoking \u0060\u0060NavigateTo\u0060\u0060 on the server, an exception is thrown.\r\n\r\nMy workaround was to build my own \u0022ServerNavigationManager\u0022 (Not inheriting from NavigationManager) which modifies the \u0060\u0060HttpContext.Response\u0060\u0060 to redirect to the specified location.",
        "createdAt": "2023-07-19T14:54:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49515#issuecomment-1642244909"
      },
      {
        "id": "IC_kwDOAQzde85h47v9",
        "parentId": null,
        "author": "javiercn",
        "content": "@marinasundstrom where are you seeing the 401 from the authorizeview?\r\n\r\nOn SSR, the auth middleware should be handling the auth for the page.",
        "createdAt": "2023-07-19T15:33:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49515#issuecomment-1642314749"
      },
      {
        "id": "IC_kwDOAQzde85h48m-",
        "parentId": null,
        "author": "marinasundstrom",
        "content": "@javiercn Here: https://blazor8app.graypebble-0c46426e.westus2.azurecontainerapps.io/auth\r\n\r\n\u0022/auth\u0022 is a page.\r\n\r\nUnless I have missed something in my code.\r\n\r\nhttps://github.com/marinasundstrom/Blazor8Test",
        "createdAt": "2023-07-19T15:36:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49515#issuecomment-1642318270"
      },
      {
        "id": "IC_kwDOAQzde85kmuow",
        "parentId": null,
        "author": "marinasundstrom",
        "content": "I have learned that the component model doesn\u0027t handle the cases the same way with SSR as with Client. That makes sense, since it is about requests.\r\n\r\nBut the symptoms are still here in RC1, somewhere between component and middleware.\r\n\r\nNot even \u0060\u0060app.UseStatusCodePagesWithRedirects(\u0022/error/{0}\u0022);\u0060\u0060 catches it as with other errors.\r\n\r\nStill just a page with the text: \u0060\u0060Error: 401\u0060\u0060\r\n\r\nComponent file: https://github.com/marinasundstrom/Blazor8Test/blob/auth/src/Server/Pages/Auth.razor",
        "createdAt": "2023-08-22T09:58:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49515#issuecomment-1687874096"
      },
      {
        "id": "IC_kwDOAQzde85oroff",
        "parentId": null,
        "author": "??",
        "content": "To learn more about what this message means, what to expect next, and how this issue will be handled you can read our [Triage Process document](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).\nWe\u0027re moving this issue to the .NET 9 Planning milestone for future evaluation / consideration. Because it\u0027s not immediately obvious what is causing this behavior, we would like to keep this around to collect more feedback, which can later help us determine how to handle this. We will re-evaluate this issue, during our next planning meeting(s).\nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact work.",
        "createdAt": "2023-10-10T21:13:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49515#issuecomment-1756268511"
      },
      {
        "id": "IC_kwDOAQzde85q5_D0",
        "parentId": null,
        "author": "halter73",
        "content": "WebApplication\u0027s automatic UseAuthorization() insertion happens before the user-configured UseStatusCodePagesWithRedirecte(). By adding UseAuthorization() explicitly, we can ensure UseStatusCodePagesWithRedirecte() \u0022sees\u0022 unauthorized requests.\r\n\r\nhttps://learn.microsoft.com/en-us/aspnet/core/fundamentals/minimal-apis/middleware?view=aspnetcore-8.0\r\n\r\nI submitted a PR to your github repo to fix the issue. https://github.com/marinasundstrom/Blazor8Test/pull/3\r\n\r\nI don\u0027t think this is a Blazor specific issue, but I do wonder if WebApplication could be a little smarter and insert UserAuthorization after UseStatusCodePages if it\u0027s being used, because this seems really easy to mess up. I don\u0027t want to make the automatic middleware initialization much more complicated than it already is though.",
        "createdAt": "2023-11-05T00:02:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49515#issuecomment-1793585396"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85tyoxb",
    "title": "Add support for running actions during routing",
    "url": "https://github.com/dotnet/aspnetcore/issues/49936",
    "createdAt": "2023-08-08T19:55:24Z",
    "lastUpdated": "2024-02-13T01:27:44Z",
    "body": "As part of the recent work to add better form support for minimal APIs, we\u0027ve needed to add logic in the endpoint routing middleware to ensure that certain metadata is able to configure HTTP features before other middlewares run. The routing middleware is convenient here because it is the earliest point wherein we can set these features before other middleware can run.\r\n\r\nWhile form support and anti-forgery are strong motivating examples, the general model of being able to run \u0022filters\u0022 during routing is helpful enough that we should consider provide a more generic API for this.",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85r8hDi",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 9 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-11-14T19:13:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/49936#issuecomment-1811026146"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85viG-i",
    "title": "Rate limiting / whitelist / change value per Partition key",
    "url": "https://github.com/dotnet/aspnetcore/issues/50391",
    "createdAt": "2023-08-19T22:33:51Z",
    "lastUpdated": "2024-02-13T01:26:43Z",
    "body": "I just want to know if the following use cases are possible or will be possible in the near future.\r\n\r\nLet\u0027s say we have rate limiting per IP address.\r\n\r\n\u003E Use case 1: Is it possible to whitelist the IP/Partition key\r\n\u003E Use case 2: Is it possible to change the rate limit value per IP/Partition key\r\n\r\n\r\nReal-life use cases:\r\n\r\n\u003E I want to whitelist an IP address\r\n\u003E I want to increase the rate limit for specific IP address or virtual host",
    "upvotes": 0,
    "labels": [
      "question",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85lJuPZ",
        "parentId": null,
        "author": "tarekgh",
        "content": "Are you asking generic questions regarding machine configuration? Or your question related to .NET product? ",
        "createdAt": "2023-08-24T19:26:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50391#issuecomment-1697047513"
      },
      {
        "id": "IC_kwDOAQzde85lJuPd",
        "parentId": null,
        "author": "closte",
        "content": "\u003E Are you asking generic questions regarding machine configuration? Or your question related to .NET product?\r\n\r\nNope.\r\n\u003E.NET has a built-in rate-limiting feature, so how do we whitelist some Partition keys or change the limit value for one or more Partition keys?\r\n\r\nExample:\r\n\r\n1. rate limit 60 concurrent connections per IP\r\n2. whitelist 1.1.1.1\r\n3. Increase the limit to 100 connections for 2.2.2.2 and 3.3.3.3\r\n",
        "createdAt": "2023-08-24T22:05:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50391#issuecomment-1697047517"
      },
      {
        "id": "IC_kwDOAQzde85lJuPg",
        "parentId": null,
        "author": "??",
        "content": "Tagging subscribers to this area: @dotnet/ncl\nSee info in [area-owners.md](https://github.com/dotnet/runtime/blob/main/docs/area-owners.md) if you want to be subscribed.\n\u003Cdetails\u003E\n\u003Csummary\u003EIssue Details\u003C/summary\u003E\n\u003Chr /\u003E\n\nI just want to know if the following use cases are possible or will be possible in the near future.\r\n\r\nLet\u0027s say we have rate limiting per IP address.\r\n\r\n\u003E Use case 1: Is it possible to whitelist the IP/Partition key\r\n\u003E Use case 2: Is it possible to change the rate limit value per IP/Partition key\r\n\r\n\r\nReal-life use cases:\r\n\r\n\u003E I want to whitelist an IP address\r\n\u003E I want to increase the rate limit for specific IP address or virtual host\n\n\u003Ctable\u003E\n  \u003Ctr\u003E\n    \u003Cth align=\u0022left\u0022\u003EAuthor:\u003C/th\u003E\n    \u003Ctd\u003Ecloste\u003C/td\u003E\n  \u003C/tr\u003E\n  \u003Ctr\u003E\n    \u003Cth align=\u0022left\u0022\u003EAssignees:\u003C/th\u003E\n    \u003Ctd\u003E-\u003C/td\u003E\n  \u003C/tr\u003E\n  \u003Ctr\u003E\n    \u003Cth align=\u0022left\u0022\u003ELabels:\u003C/th\u003E\n    \u003Ctd\u003E\n\n\u0060question\u0060, \u0060area-System.Net.Http\u0060, \u0060untriaged\u0060, \u0060Team:Libraries\u0060, \u0060needs-area-label\u0060\n\n\u003C/td\u003E\n  \u003C/tr\u003E\n  \u003Ctr\u003E\n    \u003Cth align=\u0022left\u0022\u003EMilestone:\u003C/th\u003E\n    \u003Ctd\u003E-\u003C/td\u003E\n  \u003C/tr\u003E\n\u003C/table\u003E\n\u003C/details\u003E",
        "createdAt": "2023-08-24T22:18:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50391#issuecomment-1697047520"
      },
      {
        "id": "IC_kwDOAQzde85lJuPj",
        "parentId": null,
        "author": "rzikm",
        "content": "This feels more like a question for ASP.NET folks, since the system libraries don\u0027t implement any rate limiting AFAIK.\r\n\r\nEdit: I may have been wrong, I found this blog post which talks about it: https://devblogs.microsoft.com/dotnet/announcing-rate-limiting-for-dotnet/\r\n\r\nWhile the scenario you describe is not directly suppoted, you can probably inherit from \u0060PartitionedRateLimiter\u003Cint\u003E\u0060 and implement your custom logic there.\r\n\r\n",
        "createdAt": "2023-08-25T05:35:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50391#issuecomment-1697047523"
      },
      {
        "id": "IC_kwDOAQzde85lJuPo",
        "parentId": null,
        "author": "karelz",
        "content": "@BrennanConroy do you have any insight here?",
        "createdAt": "2023-08-25T15:31:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50391#issuecomment-1697047528"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85wk729",
    "title": "Reconsider default HSTS max-age value ",
    "url": "https://github.com/dotnet/aspnetcore/issues/50605",
    "createdAt": "2023-09-09T12:50:27Z",
    "lastUpdated": "2024-02-13T01:24:51Z",
    "body": "Currently, the default value for HTTP Strict Transport Security (HSTS) max-age is set to 30 days.\r\nhttps://github.com/dotnet/aspnetcore/blob/410efd482f494d1ab05ce25b932b5788699c2308/src/Middleware/HttpsPolicy/src/HstsOptions.cs#L18\r\n\r\nAccording to [hstspreload.org](https://hstspreload.org/), it is recommended that the minimum value should be at least 1 year, with a preferable value of 2 years.\r\n\r\n\r\nThe current default value may not align with modern security best practices, and it might be beneficial to reconsider it.\r\n\r\n\r\n\r\nI propose that we reconsider the default value and update it to a more secure and recommended value, such as 1 year.\r\n\r\nAlso, setting a longer default max-age value will avoid additional configuration, as it is very common to reconfigure this value as follows:\r\n\r\n\u0060\u0060\u0060cs\r\nbuilder.Services.AddHsts(options =\u003E\r\n{\r\n    options.MaxAge = TimeSpan.FromDays(365); // Common practice to set it to 1 year or more\r\n});\r\n\u0060\u0060\u0060",
    "upvotes": 0,
    "labels": [
      "Security",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85nKAce",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@blowdart What do you think?",
        "createdAt": "2023-09-22T01:49:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50605#issuecomment-1730676510"
      },
      {
        "id": "IC_kwDOAQzde85nKBnU",
        "parentId": null,
        "author": "blowdart",
        "content": "We do, or did, document that setting as needing adjusting for production. The default value was a compromise between production and \u0022oh no I locked myself out of dev and local host\u0022. \n\nIf those code comments are there any more, put them back. Using a production value in dev can end in sadness.",
        "createdAt": "2023-09-22T01:54:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50605#issuecomment-1730681300"
      },
      {
        "id": "IC_kwDOAQzde85nKH0e",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "I don\u0027t see any comments in the docs about it. BTW I\u0027m not sure I understand why 30 days is any better than one year for that situation... seems just as painful if you accidentally get hit by it when you weren\u0027t meaning to?\r\n\r\nIf one were to find themselves in this situation, reducing the max-age and clearing their browser\u0027s HSTS settings (globally or for the specific site) would be the fix right?",
        "createdAt": "2023-09-22T02:09:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50605#issuecomment-1730706718"
      },
      {
        "id": "IC_kwDOAQzde85nNbks",
        "parentId": null,
        "author": "blowdart",
        "content": "Yea. But when we added it the instructions for clearing the HSTS entry for a site were hard to find.\r\n\r\nHeck they\u0027re still hard to find, especially if you don\u0027t know what HSTS is.",
        "createdAt": "2023-09-22T15:02:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50605#issuecomment-1731574060"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85wuXxM",
    "title": "Support zstd Content-Encoding",
    "url": "https://github.com/dotnet/aspnetcore/issues/50643",
    "createdAt": "2023-09-11T20:20:36Z",
    "lastUpdated": "2024-07-17T16:36:20Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\n_No response_\n\n### Describe the solution you\u0027d like\n\n[Zstandard](https://zstd.net), or \u0060zstd\u0060, is a data compression mechanism described in RFC8878. It is a fast lossless compression algorithm, targeting real-time compression scenarios at zlib-level and better compression ratios. The \u0022zstd\u0022 token was added as an IANA-registered Content-Encoding token as per https://datatracker.ietf.org/doc/html/rfc8878#name-content-encoding. \r\n\r\nThe Facebook/Zstd team has published some of their [research](https://raw.githubusercontent.com/facebook/zstd/master/doc/images/DCspeed5.png) on compression level vs. CPU vs. compression ratio.\r\n## Current support\r\n- Chrome: [Planned](https://chromestatus.com/feature/6186023867908096) in version 118\r\n- Safari: Not planned but with [positive position](https://github.com/WebKit/standards-positions/issues/168)\r\n- Mozilla: Not planned with [defer position](https://github.com/mozilla/standards-positions/issues/105)\r\n- Curl: [Released](https://github.com/curl/curl/pull/5453) since version 7.72.0\r\n## Features request\r\n### Request compression\r\n- Support \u0060zstd\u0060 as the token from the \u0060Content-Encoding\u0060 header in the request.\r\n- Decompress with Zstandard the request content.\r\n### Response compression\r\n- Support \u0060zstd\u0060 as a token from the \u0060Accept-Encoding\u0060 header in the request.\r\n- Compress with Zstandard when the \u0060zstd\u0060 token is elected as response compression, and so stored in the \u0060Content-Encoding\u0060 header in the response.\r\n## Zstandard implementation\r\n- Native: https://github.com/facebook/zstd\r\n- .NET Runtime: https://github.com/dotnet/runtime/issues/59591\n\n### Additional context\n\n_No response_",
    "upvotes": 29,
    "labels": [
      "blocked",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85mRNuq",
        "parentId": null,
        "author": "??",
        "content": "We\u0027ve moved this issue to the Backlog milestone. This means that it is not going to be worked on for the coming release. We will reassess the backlog following the current release and consider this item at that time. To learn more about our issue management process and to have better expectation regarding different types of issues you can read our [Triage Process](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-09-12T14:02:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50643#issuecomment-1715788714"
      },
      {
        "id": "IC_kwDOAQzde85zboak",
        "parentId": null,
        "author": "iamcarbon",
        "content": "Chrome has committed to shipping Zstd Content-Encoding in v123, and Safari and Firefox have both indicated a positive position toward the proposal.",
        "createdAt": "2024-02-09T21:24:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50643#issuecomment-1936623268"
      },
      {
        "id": "IC_kwDOAQzde854hFyd",
        "parentId": null,
        "author": "YohanSciubukgian",
        "content": "Chrome 123 release support zstd \r\n- https://developer.chrome.com/blog/new-in-chrome-123#more\r\n- https://github.com/facebook/zstd/releases/tag/v1.5.6\r\n\r\nCould you consider it for .NET 9 ?",
        "createdAt": "2024-03-27T05:03:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50643#issuecomment-2021940381"
      },
      {
        "id": "IC_kwDOAQzde86EnTym",
        "parentId": null,
        "author": "rgueldenpfennig",
        "content": "\u003E Chrome 123 release support zstd\r\n\u003E \r\n\u003E     * https://developer.chrome.com/blog/new-in-chrome-123#more\r\n\u003E \r\n\u003E     * https://github.com/facebook/zstd/releases/tag/v1.5.6\r\n\u003E \r\n\u003E \r\n\u003E Could you consider it for .NET 9 ?\r\n\r\nSince the 126 release Mozilla Firefox also supports zstd compression: https://www.mozilla.org/en-US/firefox/126.0/releasenotes/",
        "createdAt": "2024-07-12T06:35:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50643#issuecomment-2224897190"
      },
      {
        "id": "IC_kwDOAQzde86FAEOm",
        "parentId": null,
        "author": "rgueldenpfennig",
        "content": "In case anyone wants to implement zstd compression support in your ASP.NET Core pipeline, I just merged a [pull request](https://github.com/rgueldenpfennig/Squidlr/pull/6/files) in my side project by utilizing the OSS [ZstdSharp](https://github.com/oleg-st/ZstdSharp) library. It\u0027s a suitable way until the .NET team releases an own implementation.\r\n\r\nWorks splendid on major browsers.",
        "createdAt": "2024-07-16T16:48:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50643#issuecomment-2231387046"
      },
      {
        "id": "IC_kwDOAQzde86FJBTz",
        "parentId": null,
        "author": "QuinnDamerell",
        "content": "@rgueldenpfennig very nice work!",
        "createdAt": "2024-07-17T16:36:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/50643#issuecomment-2233734387"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85zwdPJ",
    "title": "Create an API Gateway/Proxy project template that uses YARP ",
    "url": "https://github.com/dotnet/aspnetcore/issues/51353",
    "createdAt": "2023-10-13T14:34:57Z",
    "lastUpdated": "2024-08-20T16:40:44Z",
    "body": "We should consider adding a project template that makes it easy to get started building an API Gateway / Reverse Proxy using YARP.",
    "upvotes": 1,
    "labels": [
      "feature-templates",
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85pFAmh",
        "parentId": null,
        "author": "davidfowl",
        "content": "cc @adityamandaleeka @samsp-msft @Tratcher ",
        "createdAt": "2023-10-14T13:45:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51353#issuecomment-1762920865"
      },
      {
        "id": "IC_kwDOAQzde85pVIq_",
        "parentId": null,
        "author": "Tratcher",
        "content": "https://github.com/microsoft/reverse-proxy/issues/77",
        "createdAt": "2023-10-17T20:44:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51353#issuecomment-1767148223"
      },
      {
        "id": "IC_kwDOAQzde85pV0qC",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "Yeah, I think it\u0027s worth revisiting \uD83D\uDE03 ",
        "createdAt": "2023-10-17T23:05:02Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51353#issuecomment-1767328386"
      },
      {
        "id": "IC_kwDOAQzde85pV1_c",
        "parentId": null,
        "author": "samsp-msft",
        "content": "As a nuget package that can be installed? As part of the default .NET/VS templates?",
        "createdAt": "2023-10-17T23:11:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51353#issuecomment-1767333852"
      },
      {
        "id": "IC_kwDOAQzde85pV2Lg",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "\u003E As a nuget package that can be installed? As part of the default .NET/VS templates?\r\n\r\nAs part of the default I think.",
        "createdAt": "2023-10-17T23:12:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51353#issuecomment-1767334624"
      },
      {
        "id": "IC_kwDOAQzde85pV8QN",
        "parentId": null,
        "author": "Tratcher",
        "content": "And more interestingly, what do you put in it? YARP doesn\u0027t need much to get started.\r\n- Package dependency\r\n- Services, Map\r\n- appsettings.json\r\n\r\nhttps://github.com/microsoft/reverse-proxy/blob/main/samples/ReverseProxy.Minimal.Sample/Program.cs",
        "createdAt": "2023-10-17T23:38:52Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51353#issuecomment-1767359501"
      },
      {
        "id": "IC_kwDOAQzde85pWCcU",
        "parentId": null,
        "author": "DamianEdwards",
        "content": "That sample looks good, and even includes config-loading which I was going to ask about.",
        "createdAt": "2023-10-18T00:11:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51353#issuecomment-1767384852"
      },
      {
        "id": "IC_kwDOAQzde86JDHSR",
        "parentId": null,
        "author": "captainsafia",
        "content": "@samsp-msft @benjaminpetit Came across this while working through the \u0060area-minimal\u0060 triage backlog. Moving this over to your corner to figure out whether this should be pursued moving forward.",
        "createdAt": "2024-08-20T16:40:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51353#issuecomment-2299294865"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde851l4-C",
    "title": "HttpLoggingInterceptor is not complete enough to use as a true telemetry extension point",
    "url": "https://github.com/dotnet/aspnetcore/issues/51814",
    "createdAt": "2023-11-01T18:16:40Z",
    "lastUpdated": "2024-05-15T08:46:48Z",
    "body": "\u003C!--\r\nThis template is useful to build consensus about whether work should be done, and if so, the high-level shape of how it should be approached. Use this before fixating on a particular implementation.\r\n--\u003E\r\n\r\n## Summary\r\n\r\nThe current incarnation of HttpLoggingInterceptor allows limited extensibility of Log lines, but is insufficient to also be used for other forms of telemetry needed for operational services. Most importantly it is called prior to the response being completely sent - this means that the latency of the call is not known (and cannot be used for manipulating metrics counters) and that there is a risk of an exception being thown after the OnResponseAsync callback occurs leading to erroneous measurements of success.\r\n\r\n## Motivation and goals\r\n\r\nAny services operating at scale will require both logging and metrics as part of their operational telemetry. For HTTP services this means a reliable means of measuring and recording each incoming HTTP request in terms of: \r\n* success (did it complete successfully with an appropriate status code)\r\n* latency (end to end)\r\n* any error details (in the failure case)\r\n\r\nCurrently the HttpLogging middleware does a reasonable job of allowing a logging solution for incoming HTTP requests, although ideally it would allow the developer some control over the LogLevel (so that failing requests could be promoted to Warning or Error), LogCategory (allowing easy rerouting of just the request completion logs), and potentially ID (to help prevent id clashes).\r\nThe current system can be used to log a single combined log line if the CombineLogs option is set in the HttpLoggingOptions, and Duration can be added there to help measure latencies.\r\n\r\nHowever, the callback for OnResponseAsync is fired before the response complete. This can lead to multiple issues:\r\n* The callback can record a log line detailing success for a call which later fails during the response write\r\n* The duration is not available at this point, so the extension point can not be used to update metrics associated with latency (and given the previous point it cannot be used to reliably update metrics around success counts either).\r\n\r\n## In scope\r\n\r\nIdeally the HttpLogging middleware could be expanded to provide a more complete set of extension points for people implementing operational telemetry. Ideally it would guarantee a single callback firing among the following set:\r\n* OnResponseCompletedAsync (after a response is successfully transmitted, with latency data provided)\r\n* OnErrorAsync (after an unhandled exception is thrown, with details of the exception)\r\n\r\nThis starts to look a lot like the current HostingDiagnostics features, which are also currently problematic due to the risk of double counting in error cases, and many of the event payloads being internal/private and requiring reflection to be used. Currently there is no clear path for a developer wishing to add custom telemetry to the system aside from adding a custom middleware layer. When being called at scale this risks accidentally adding large numbers of allocations/GC strain leading to system performance degradation over time.\r\n\r\n## Out of scope\r\n\r\nScenarios you explicitly want to exclude.\r\n\r\n## Risks / unknowns\r\n\r\nThere is some risk here that if the callbacks are inline that they will still potentially impact performance. Ideally there would be some decoupling here to minimize risk.\r\n\r\n## Examples\r\n\r\n\u0060\u0060\u0060\r\npublic class MyHttpTelemetryInterceptor : IHttpLoggingInterceptor\r\n{\r\n        public ValueTask OnResponseCompleteAsync(HttpLoggingInterceptorContext logContext)\r\n        {\r\n            // Enrich log line based on context values\r\n           EnrichLog(logContext.HttpContext);\r\n           \r\n            // Update status based counters\r\n           UpdateSuccessCounters(logContext.HttpContext, logContext.GetDuration());\r\n        }\r\n\r\n        public ValueTask OnErrorAsync(HttpLoggingInterceptorContext logContext)\r\n        {\r\n            // Enrich log line based on exception details\r\n           EnrichLog(logContext.HttpContext, logContext.Exception);\r\n           \r\n            // Update failure counters\r\n           UpdateFailureCounters(logContext.HttpContext, logContext.GetDuration(), logContext.Exception);\r\n        }\r\n}\r\n\r\n\u0060\u0060\u0060",
    "upvotes": 5,
    "labels": [
      "design-proposal",
      "partner",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde854cdcy",
        "parentId": null,
        "author": "svengeance",
        "content": "This sounds similar to some of the pain points I ran into yesterday adopting this feature.\r\n\r\nI was looking for a semi-official way to go about reading the req/resp on failure. I figured there\u0027s something better than me manually rewinding the request with EnableBuffering, and I discovered HttpLoggingInterceptor.\r\n\r\nIt comes very close, but as OP indicated, the ambiguity over the when\u0027s and how\u0027s the logging occurs is difficult. If you take a look at the extensibility points afforded by [interceptors in EF](https://learn.microsoft.com/en-us/dotnet/api/microsoft.entityframeworkcore.diagnostics.iinterceptor?view=efcore-8.0) you can see how comprehensive an API you can get from a seemingly simple set of operations.\r\n\r\nIf it\u0027s appropriate for the context of the thread - me personally, I would like more control over the req/resp body included in the logs. It would be convenient to grab the current \u0060RequestTelemetry\u0060 and attach the bodies as a property, rather than emitting a new log. At least correlation makes it easy. ",
        "createdAt": "2024-03-26T15:20:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51814#issuecomment-2020726578"
      },
      {
        "id": "IC_kwDOAQzde8594E_v",
        "parentId": null,
        "author": "ghelyar",
        "content": "I\u0027ve also been having issues trying to use HTTP logging, particularly around exceptions.\r\n\r\nDue to when the middleware runs, unhandled exceptions show a status code of 200 and there is no exception detail available to them.\r\n\r\nYou can add \u0060UseExceptionHandler\u0060 below \u0060UseHttpLogging\u0060, but that comes with its own problems - it causes all exceptions to become 500, even e.g. \u0060BadHttpRequestException\u0060, which can be thrown when the request does not contain valid json , and it breaks \u0060AddProblemDetails\u0060.\r\n\r\nYou can add a middleware that captures the exception and rethrows it and then use a \u0060IHttpLoggingInterceptor\u0060 to enrich the logs, but that still doesn\u0027t give you an accurate status code, because the status code isn\u0027t really known until the unhandled exception is handled by Kestrel, and some exceptions have different status codes.\r\n\u0060\u0060\u0060csharp\r\napp.UseHttpLogging();\r\napp.Use(static async (context, next) =\u003E\r\n{\r\n    try\r\n    {\r\n        await next(context);\r\n    }\r\n    catch (Exception ex)\r\n    {\r\n        context.Items[\u0022Exception\u0022] = ex;\r\n        ExceptionDispatchInfo.Capture(ex).Throw();\r\n    }\r\n});\r\n\u0060\u0060\u0060",
        "createdAt": "2024-05-15T08:10:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51814#issuecomment-2111852527"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde8513s2o",
    "title": "Add additional strategy to use transactions instead of scripts in StackExchange.Redis implementation",
    "url": "https://github.com/dotnet/aspnetcore/issues/51874",
    "createdAt": "2023-11-04T22:30:27Z",
    "lastUpdated": "2024-02-13T01:18:28Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nThe current implementation of [StackExchange.Redis](https://github.com/dotnet/aspnetcore/blob/main/src/Caching/StackExchangeRedis/src/RedisCache.cs) relies on LUA scripts.\r\nFrom a first look it seems to be so in order to execute HSET/HMSET and EXPIRE as an atomic execution.\r\n\r\nAlthought in some environments EVAL command might be disabled for the users, making the current implementation unusable.\n\n### Describe the solution you\u0027d like\n\nUsing transactions could maybe be a good alternative to scripts, in that case the RedisCacheOptions could expose a way to choose the strategy to use, either stick to the default implementation using scripts, or opt-in the use of transactions.\n\n### Additional context\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "feature-caching",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde8518Lwb",
    "title": "AddExceptionHandler/UseExceptionHandler Fails in a non-Obvious Way",
    "url": "https://github.com/dotnet/aspnetcore/issues/51888",
    "createdAt": "2023-11-06T09:43:07Z",
    "lastUpdated": "2024-09-27T23:47:26Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nWith the new \u0060AddExceptionHandler\u0060 and \u0060IExceptionHandler\u0060 APIs, engaging the exception handler with UseExceptionHandler is confusing. For example, this code fails;\r\n\r\n\u0060\u0060\u0060cs\r\nusing ExHandler;\r\nusing Microsoft.AspNetCore.Diagnostics;\r\n\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\nbuilder.Services.AddExceptionHandler\u003CGlobalExceptionHandler\u003E();\r\n\r\nvar app = builder.Build();\r\n\r\napp.UseExceptionHandler();       // Doesn\u0027t work\r\n\r\napp.MapGet(\u0022/\u0022, () =\u003E {\r\n  throw new Exception(\u0022Bad things happen to good developers\u0022);\r\n});\r\n\r\napp.Run();\r\n\r\npublic class GlobalExceptionHandler : IExceptionHandler\r\n{\r\n  public async ValueTask\u003Cbool\u003E TryHandleAsync(HttpContext httpContext,\r\n    Exception exception,\r\n    CancellationToken cancellationToken)\r\n  {\r\n    httpContext.Response.ContentType = \u0022text/plain\u0022;\r\n    httpContext.Response.StatusCode = 501;\r\n    await httpContext.Response.WriteAsync($\u0022It don\u0027t work: {exception.Message}\u0022);\r\n    return true;\r\n  }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nTo make this work, you must pass in an empty lambda to the \u0060UseExceptionHandler\u0027:\r\n\r\n\u0060\u0060\u0060cs\r\napp.UseExceptionHandler(o =\u003E { }); // Works\r\n\u0060\u0060\u0060\r\n\n\n### Expected Behavior\n\nExpected the empty call to \u0060UseExceptionHandler\u0060 to work. Could not find documentation that explained this. , \n\n### Steps To Reproduce\n\nExample is at: https://github.com/shawnwildermuth/ExceptionHandlerRepro\r\n\r\n\n\n### Exceptions (if any)\n\nI get an arcane message:\r\n\r\n\u0060\u0060\u0060\r\nSystem.InvalidOperationException\r\n  HResult=0x80131509\r\n  Message=An error occurred when configuring the exception handler middleware. Either the \u0027ExceptionHandlingPath\u0027 or the \u0027ExceptionHandler\u0027 property must be set in \u0027UseExceptionHandler()\u0027. Alternatively, set one of the aforementioned properties in \u0027Startup.ConfigureServices\u0027 as follows: \u0027services.AddExceptionHandler(options =\u003E { ... });\u0027 or configure to generate a \u0027ProblemDetails\u0027 response in \u0027service.AddProblemDetails()\u0027.\r\n  Source=Microsoft.AspNetCore.Diagnostics\r\n  StackTrace:\r\n   at Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddlewareImpl..ctor(RequestDelegate next, ILoggerFactory loggerFactory, IOptions\u00601 options, DiagnosticListener diagnosticListener, IEnumerable\u00601 exceptionHandlers, IMeterFactory meterFactory, IProblemDetailsService problemDetailsService)\r\n   at Microsoft.AspNetCore.Builder.ExceptionHandlerExtensions.\u003C\u003Ec__DisplayClass5_0.\u003CSetExceptionHandlerMiddleware\u003Eb__0(RequestDelegate next)\r\n   at Microsoft.AspNetCore.Builder.ApplicationBuilder.Build()\r\n   at Microsoft.AspNetCore.Builder.ApplicationBuilder.Build()\r\n   at Microsoft.AspNetCore.Hosting.GenericWebHostService.\u003CStartAsync\u003Ed__40.MoveNext()\r\n   at Microsoft.Extensions.Hosting.Internal.Host.\u003C\u003CStartAsync\u003Eb__15_1\u003Ed.MoveNext()\r\n   at Microsoft.Extensions.Hosting.Internal.Host.\u003CForeachService\u003Ed__18\u00601.MoveNext()\r\n   at Microsoft.Extensions.Hosting.Internal.Host.\u003CStartAsync\u003Ed__15.MoveNext()\r\n   at Microsoft.Extensions.Hosting.HostingAbstractionsHostExtensions.\u003CRunAsync\u003Ed__4.MoveNext()\r\n   at Microsoft.Extensions.Hosting.HostingAbstractionsHostExtensions.\u003CRunAsync\u003Ed__4.MoveNext()\r\n   at Microsoft.Extensions.Hosting.HostingAbstractionsHostExtensions.Run(IHost host)\r\n   at Program.\u003CMain\u003E$(String[] args) in C:\\projects\\codingshorts\\net8exhandler\\test\\ExHandler\\Program.cs:line 17\r\n\u0060\u0060\u0060\n\n### .NET Version\n\n8.0.100-rc.2.23502.2\n\n### Anything else?\n\nNote the failure is uncommented out, and the one that works is commented out. If this is expected behavior, we need it to be well documented since it is unobvious behavior.",
    "upvotes": 18,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85q_uak",
        "parentId": null,
        "author": "davidfowl",
        "content": "Agreed this should be fixed now that we have exception handlers that can be added via DI.",
        "createdAt": "2023-11-06T15:26:15Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51888#issuecomment-1795090084"
      },
      {
        "id": "IC_kwDOAQzde85rCmd1",
        "parentId": null,
        "author": "captainsafia",
        "content": "PR open against main.\r\n\r\nThis is a good candidate for servicing to 8.0 as well.",
        "createdAt": "2023-11-06T18:24:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51888#issuecomment-1795843957"
      },
      {
        "id": "IC_kwDOAQzde85zEJF7",
        "parentId": null,
        "author": "dotnet-policy-service",
        "content": "Looks like this PR hasn\u0027t been active for some time and the codebase could have been changed in the meantime.\nTo make sure no conflicting changes have occurred, please rerun validation before merging. You can do this by leaving an \u0060/azp run\u0060 comment here (requires commit rights), or by simply closing and reopening.\n\u003C!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003E",
        "createdAt": "2024-02-06T17:50:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51888#issuecomment-1930465659"
      },
      {
        "id": "IC_kwDOAQzde85zEnFg",
        "parentId": null,
        "author": "dotnet-policy-service",
        "content": "Looks like this PR hasn\u0027t been active for some time and the codebase could have been changed in the meantime.\nTo make sure no conflicting changes have occurred, please rerun validation before merging. You can do this by leaving an \u0060/azp run\u0060 comment here (requires commit rights), or by simply closing and reopening.\n\u003C!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003E",
        "createdAt": "2024-02-06T19:10:46Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51888#issuecomment-1930588512"
      },
      {
        "id": "IC_kwDOAQzde85zFPZS",
        "parentId": null,
        "author": "shawnwildermuth",
        "content": "This has been fixed.",
        "createdAt": "2024-02-06T21:08:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51888#issuecomment-1930753618"
      },
      {
        "id": "IC_kwDOAQzde8536G_g",
        "parentId": null,
        "author": "dse-copsfs",
        "content": "The [connected PR](https://github.com/dotnet/aspnetcore/pull/51898) has been closed.\r\n\r\nWe still facing this issue in **8.0.3**, so we have to use the proposed workaround \u0060app.UseExceptionHandler(o =\u003E {});\u0060\r\n\r\nCould you please reopen this issue?",
        "createdAt": "2024-03-21T09:22:05Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51888#issuecomment-2011721696"
      },
      {
        "id": "IC_kwDOAQzde854pKpm",
        "parentId": null,
        "author": "captainsafia",
        "content": "Yes, we never ended up addressing this because the ramifications of the breaking change weren\u0027t fully enumerated.\r\n\r\nI\u0027ll reopen this issue but considering the current prioritizations and the fact that there is a workaround, this will likely go in the backlog.\r\n\r\nI\u0027m open to reviewing a PR with a fix though!",
        "createdAt": "2024-03-27T21:54:56Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51888#issuecomment-2024057446"
      },
      {
        "id": "IC_kwDOAQzde856w6h2",
        "parentId": null,
        "author": "diegocam",
        "content": "Any updates here?",
        "createdAt": "2024-04-16T17:51:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51888#issuecomment-2059642998"
      },
      {
        "id": "IC_kwDOAQzde86CMgQp",
        "parentId": null,
        "author": "latuconsinafr",
        "content": "Still waiting for the update \uD83D\uDC40",
        "createdAt": "2024-06-23T01:45:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51888#issuecomment-2184315945"
      },
      {
        "id": "IC_kwDOAQzde86G6Xnb",
        "parentId": null,
        "author": "socketlink",
        "content": "\u003E Still waiting for the update \uD83D\uDC40\r\n\r\n",
        "createdAt": "2024-08-01T16:12:11Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51888#issuecomment-2263448027"
      },
      {
        "id": "IC_kwDOAQzde86LLuG1",
        "parentId": null,
        "author": "ghhv",
        "content": "fyi, I managed to get this issue on a brand new NET 8.0.8 Blazor Web Application project because I was calling this again by accident in a start-up helper function but without any parameters like so:\r\n\u0060app.UseExceptionHandler();\u0060\r\n\r\nI have this prior in the program.cs\r\n\u0060 app.UseExceptionHandler(\u0022/Error\u0022, createScopeForErrors: true);\u0060\r\n\r\nThe lack of parameters isn\u0027t an issue - it was the calling it twice!",
        "createdAt": "2024-09-07T07:38:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51888#issuecomment-2335105461"
      },
      {
        "id": "IC_kwDOAQzde86MAkgv",
        "parentId": null,
        "author": "Legion-ale",
        "content": "For what i understand I can agree with @ghhv saying that the problem is how we configure the webApp, and not in the method itself.\r\n\r\nI was having the same problem, and I was thinking I\u0027d solved it with: \u0060app.UseExceptionHandler(()=\u003E{});\u0060 but, actually, we\u0027d just bypassed the correct exception management.\r\n\r\nThe real problem seems that you need to register a \u0022default\u0022 response in case your \u0060IExceptionHandler\u0060 return \u0060false\u0060 (Even if every exception is correctly managed inside the \u0060IExceptionHandler\u0060).\r\n\r\nActually adding \u0027AddProblemDetails()\u0027 before your exception handler seems doing the trick:\r\n\r\n\u0060\u0060\u0060\r\n        builder.Services.AddProblemDetails();\r\n        builder.Services.AddExceptionHandler\u003CGlobalExceptionHandler\u003E();\r\n[...]\r\n        var app = builder.Build();\r\n        app.UseExceptionHandler();\r\n\u0060\u0060\u0060\r\n but i\u0027m not sure is the correct behaviour.\r\nI [leave here microsoft link with the method explanation](https://learn.microsoft.com/en-us/aspnet/core/web-api/handle-errors?view=aspnetcore-8.0):\r\n \r\n\r\n\u003E [...] code configures the app to generate a problem details response for all HTTP client and server error responses that don\u0027t have body content yet[...]\r\n\r\n\r\n ",
        "createdAt": "2024-09-13T13:25:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51888#issuecomment-2348959791"
      },
      {
        "id": "IC_kwDOAQzde86N4GAG",
        "parentId": null,
        "author": "kjkrum",
        "content": "I\u0027m also not seeing this issue when using an exception handler in combination with problem details. The order they\u0027re added to the service collection shouldn\u0027t matter.\r\n\r\n\u0060\u0060\u0060\r\nbuilder.Services.AddExceptionHandler\u003CExceptionHandler\u003E();\r\nbuilder.Services.AddProblemDetails(options =\u003E\r\n{\r\n\toptions.CustomizeProblemDetails = context =\u003E\r\n\t{\r\n\t\t...\r\n\t};\r\n});\r\n\r\napp.UseStatusCodePages();\r\napp.UseExceptionHandler();\r\n\u0060\u0060\u0060\r\n\r\nIf (and only if) the \u0060IExceptionHandler\u0060 returns false, the exception is available in the customize action as \u0060ProblemDetailsContext.Exception\u0060. This makes sense, since I think the exception handler returning true means the exception does not propagate.\r\n\r\nBut letting an exception propagate so it appears in \u0060ProblemDetailsContext.Exception\u0060 (e.g., so you can use it to add information to the problem details) triggers another bug. \u0060ProblemDetailsContext.ProblemDetails\u0060 is always initialized as a 500 regardless of the status code set by the exception handler, and there\u0027s no way to leverage the existing defaults to re-initialize it (#47978).",
        "createdAt": "2024-09-27T23:47:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51888#issuecomment-2380292102"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde852WVBQ",
    "title": "HostFilteringMiddleware. It is returning \u0022The host \u0027{Host}\u0027 does not match an allowed host.\u0022 time to time.",
    "url": "https://github.com/dotnet/aspnetcore/issues/51960",
    "createdAt": "2023-11-09T12:54:42Z",
    "lastUpdated": "2024-10-31T11:57:08Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nIn HostFilteringMiddleware we are using IOptionsManager. \r\nDuring reloading the configuration, it clears the state used to evaluate the host.\r\nIn edge cases we may end up with an inconsistent state when calling the main Middleware method, the state can be cleared during the execution of the \u0022Invoke\u0022 method. \r\n\r\n### Expected Behavior\r\n\r\nMiddleware shouldn\u0027t return us badrequest when allowed host are properly configured.\r\n\r\n### Steps To Reproduce\r\n\r\n_No response_\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n_No response_\r\n\r\n### Anything else?\r\n\r\nWe shouldn\u0027t clear state but re-evaluate it during OnChange action.",
    "upvotes": 2,
    "labels": [
      "bug",
      "area-middleware",
      "help candidate"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85rjLko",
        "parentId": null,
        "author": "Tratcher",
        "content": "This change notification code should probably re-calculate the list inline and swap out atomically. _allowAnyNonEmptyHost would also need to be made part of an atomic swap object.\r\nhttps://github.com/dotnet/aspnetcore/blob/da1d588a9afe7d1ae5591b45265045abf270515e/src/Middleware/HostFiltering/src/HostFilteringMiddleware.cs#L49-L55\r\n\r\nAlso call Configure in the constructor and remove EnsureConfigured.\r\nhttps://github.com/dotnet/aspnetcore/blob/da1d588a9afe7d1ae5591b45265045abf270515e/src/Middleware/HostFiltering/src/HostFilteringMiddleware.cs#L76C34-L76C52",
        "createdAt": "2023-11-09T18:47:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51960#issuecomment-1804384552"
      },
      {
        "id": "IC_kwDOAQzde85rkUN4",
        "parentId": null,
        "author": "charytech",
        "content": "I agree with the above comment.\r\nProposal solution for #51960 is to reevaluate _allowAnyNonEmptyHost and _allowedHosts instead of resetting them to empty values.\r\nhttps://github.com/dotnet/aspnetcore/blob/da1d588a9afe7d1ae5591b45265045abf270515e/src/Middleware/HostFiltering/src/HostFilteringMiddleware.cs#L49-L55\r\nThe method will be similar to the already existing  \u0022Configure()\u0022. \r\nhttps://github.com/dotnet/aspnetcore/blob/da1d588a9afe7d1ae5591b45265045abf270515e/src/Middleware/HostFiltering/src/HostFilteringMiddleware.cs#L100-L123\r\nWe should also handle reseteting the _allowAnyNonEmptyHost state when it is not top level wildcard and allow _allowedHosts to be adjusted to empty values instead of throwing an exception.",
        "createdAt": "2023-11-09T21:04:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51960#issuecomment-1804682104"
      },
      {
        "id": "IC_kwDOAQzde85rkU4b",
        "parentId": null,
        "author": "Tratcher",
        "content": "Thanks, do you want to try it and send a PR?\r\n\r\nNote, _allowedHosts and _allowAnyNonEmptyHost will likely need to be combine into a type \u0026 field that can be swapped out atomically. It\u0027s not safe to update them separately.",
        "createdAt": "2023-11-09T21:06:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51960#issuecomment-1804684827"
      },
      {
        "id": "IC_kwDOAQzde85vHqlp",
        "parentId": null,
        "author": "charytech",
        "content": "Hey, @Tratcher are you planning to patch previous versions with the above fix?",
        "createdAt": "2023-12-20T11:04:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51960#issuecomment-1864280425"
      },
      {
        "id": "IC_kwDOAQzde85vJ1pu",
        "parentId": null,
        "author": "Tratcher",
        "content": "What\u0027s the impact on you? E.g. how often does the config change, and how many requests are disrupted in the meantime. Issues have to have significant impact before they\u0027re considered for backport.",
        "createdAt": "2023-12-20T17:16:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51960#issuecomment-1864850030"
      },
      {
        "id": "IC_kwDOAQzde85vwjT4",
        "parentId": null,
        "author": "charytech",
        "content": "In a couple of microservices config is refreshing a couple of times per minute. We have a problem with this every day depends on the traffic, day and luck as it is nondeterministic behavior, but even hundreds of errors per month. From my perspective, it is a significant impact as the error happens all the time day after day.",
        "createdAt": "2024-01-03T08:25:45Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51960#issuecomment-1874998520"
      },
      {
        "id": "IC_kwDOAQzde85vzR1i",
        "parentId": null,
        "author": "Tratcher",
        "content": "@adityamandaleeka for servicing consideration.",
        "createdAt": "2024-01-03T17:22:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51960#issuecomment-1875713378"
      },
      {
        "id": "IC_kwDOAQzde850GZtU",
        "parentId": null,
        "author": "charytech",
        "content": "@adityamandaleeka any updates on the above?",
        "createdAt": "2024-02-16T06:37:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51960#issuecomment-1947835220"
      },
      {
        "id": "IC_kwDOAQzde8513_SB",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "@charytech Are you looking to get this in .NET 8 servicing?",
        "createdAt": "2024-03-04T22:55:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51960#issuecomment-1977611393"
      },
      {
        "id": "IC_kwDOAQzde851_VCJ",
        "parentId": null,
        "author": "charytech",
        "content": "hey @adityamandaleeka\r\nI think both .NET 6 and .NET 8 should be patched as they are still under LTS.\r\nWe are still using NET 6, but now we are starting migration to .NET 8. \r\nWhen do you plan to add it? It\u0027s already been a few months since the PR was merged.\r\n",
        "createdAt": "2024-03-05T20:02:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51960#issuecomment-1979535497"
      },
      {
        "id": "IC_kwDOAQzde86SAxU0",
        "parentId": null,
        "author": "arekgwizdziel",
        "content": "Hey, we started to see this issue in our .NET APIs as well, do we have any update on this? Is there a plan to patch it in .NET8?",
        "createdAt": "2024-10-31T11:57:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/51960#issuecomment-2449675572"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde852rgll",
    "title": "Request timeouts are not applied without the middleware, no error given",
    "url": "https://github.com/dotnet/aspnetcore/issues/52025",
    "createdAt": "2023-11-13T17:26:38Z",
    "lastUpdated": "2024-02-13T01:17:45Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nThe request timeout feature relies on options, middleware, and attributes. If uses supply options or attributes, but forget the middleware, there\u0027s no indication that the timeouts aren\u0027t being applied.\r\n\r\n### Expected Behavior\r\n\r\nConfiguring timeouts on routes (or a default timeout policy ?) without adding the middleware should produce at least a runtime error rather than process the request without a timeout (dangerous). Note we also shouldn\u0027t short circuit endpoints with timeouts, we don\u0027t know what the short circuit logic is going to do.\r\n\r\nAn analyzer might help too.\r\n\r\nWe already have similar checks for auth, cors, and anti-forgery.\r\nhttps://github.com/dotnet/aspnetcore/blob/997a1e8e659e69dbf7e157518da18cbca91f5183/src/Http/Routing/src/EndpointRoutingMiddleware.cs#L161-L178\r\nhttps://github.com/dotnet/aspnetcore/blob/997a1e8e659e69dbf7e157518da18cbca91f5183/src/Http/Routing/src/EndpointMiddleware.cs#L39-L58\r\n\r\nFound when consuming this feature in YARP, and mitigated there: https://github.com/microsoft/reverse-proxy/pull/2307\r\n\r\n### Steps To Reproduce\r\n\r\n\u0060\u0060\u0060csharp\r\nusing Microsoft.AspNetCore.Http.Timeouts;\r\n\r\nvar builder = WebApplication.CreateBuilder(args);\r\nbuilder.Services.AddRequestTimeouts();\r\n\r\nvar app = builder.Build();\r\n// app.UseRequestTimeouts(); // Woops, forgot this, nothing works.\r\n\r\napp.MapGet(\u0022/\u0022, async (HttpContext context) =\u003E {\r\n    try\r\n    {\r\n        await Task.Delay(TimeSpan.FromSeconds(10), context.RequestAborted);\r\n    }\r\n    catch (TaskCanceledException)\r\n    {\r\n        return Results.Content(\u0022Timeout!\u0022, \u0022text/plain\u0022);\r\n    }\r\n\r\n    return Results.Content(\u0022No timeout!\u0022, \u0022text/plain\u0022);\r\n}).WithRequestTimeout(TimeSpan.FromSeconds(2));\r\n// Returns \u0022Timeout!\u0022\r\n\r\napp.MapGet(\u0022/attribute\u0022,\r\n    [RequestTimeout(milliseconds: 2000)] async (HttpContext context) =\u003E {\r\n        try\r\n        {\r\n            await Task.Delay(TimeSpan.FromSeconds(10), context.RequestAborted);\r\n        }\r\n        catch (TaskCanceledException)\r\n        {\r\n            return Results.Content(\u0022Timeout!\u0022, \u0022text/plain\u0022);\r\n        }\r\n\r\n        return Results.Content(\u0022No timeout!\u0022, \u0022text/plain\u0022);\r\n    });\r\n// Returns \u0022Timeout!\u0022\r\n\r\napp.Run();\r\n\u0060\u0060\u0060\r\n\r\n### Exceptions (if any)\r\n\r\nNone (but there should be).\r\n\r\n### .NET Version\r\n\r\n.NET 8\r\n\r\n### Anything else?\r\n\r\nThis enforcement pattern isn\u0027t scalable/extensible. 3rd parties can\u0027t use the Endpoint/RoutingMiddleware to do their own enforcement for the presence of middleware. And for us, if we keep adding checks it\u0027s going to get messy. Could this be abstracted to a service? What happens if the user then forgets to add the service?",
    "upvotes": 0,
    "labels": [
      "area-middleware",
      "area-routing"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85r8goD",
        "parentId": null,
        "author": "captainsafia",
        "content": "We don\u0027t currently have an abstraction for adding these kinds of checks in our API layer.\r\n\r\nA similar issue came up when I was working on the anti-forgery middleware, which checks to see if anti-forgery metadata is provided on an endpoint and ensures the middleware is registered. At the time, I filed https://github.com/dotnet/aspnetcore/issues/49936 to track possible work to create an abstraction layer that allows us to execute these kinds of checks during routing.\r\n\r\nIn some follow-up conversations about this, it was clear that we needed to be cautious about the performance ramifications of this strategy, especially because the code is running in a hot path.\r\n\r\nI\u0027d be curious to see if we could make the API happen with static analysis instead of runtime analysis.\r\n\r\nI wonder if there is a model where we can use a source generator to detect certain attributes and then populate the \u0060UseX\u0060 call into Program.cs?",
        "createdAt": "2023-11-14T19:13:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52025#issuecomment-1811024387"
      },
      {
        "id": "IC_kwDOAQzde85r8hHT",
        "parentId": null,
        "author": "??",
        "content": "Thanks for contacting us.\n\nWe\u0027re moving this issue to the \u0060.NET 9 Planning\u0060 milestone for future evaluation / consideration. We would like to keep this around to collect more feedback, which can help us with prioritizing this work. We will re-evaluate this issue, during our next planning meeting(s). \nIf we later determine, that the issue has no community involvement, or it\u0027s very rare and low-impact issue, we will close it - so that the team can focus on more important and high impact issues.\nTo learn more about what to expect next and how this issue will be handled you can read more about our triage process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/TriageProcess.md).",
        "createdAt": "2023-11-14T19:13:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52025#issuecomment-1811026387"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde853Mlhr",
    "title": "Use IOutputCacheBufferStore.TryGetAsync",
    "url": "https://github.com/dotnet/aspnetcore/issues/52165",
    "createdAt": "2023-11-17T19:33:56Z",
    "lastUpdated": "2024-02-13T01:16:43Z",
    "body": "\u0060IOutputCacheBufferStore.TryGetAsync\u0060 isn\u0027t used anywhere today. We should use it.\r\n\r\ncc @mgravell ",
    "upvotes": 0,
    "labels": [
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde853niPq",
    "title": "OutputCache - Racing condition returns empty response when locking enabled",
    "url": "https://github.com/dotnet/aspnetcore/issues/52310",
    "createdAt": "2023-11-22T18:02:09Z",
    "lastUpdated": "2024-10-21T14:08:40Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nWhen there\u0027s a racing condition on OutputCache, with \u0022Locking\u0022 enabled, and the first request to hit the OutputCache middleware is cancelled by the client, the middleware resolves the second request to an empty response.\r\n\r\nI suspect that the cancelled request ends up caching an empty response and that\u0027s the one served on the subsequent requests.\r\n\r\nNote that it only happens with the locking feature enabled.\r\n\n\n### Expected Behavior\n\nThe OutputCache middleware should not cache the cancelled request, empty response, and the successful request should return content.\n\n### Steps To Reproduce\n\nMinimal repo: https://github.com/FP3ixoto/OutputCacheIssue\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n7.0.404; 8.0.100\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "investigate",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde851s-LP",
        "parentId": null,
        "author": "mgravell",
        "content": "Will aim to investigate and resolve ~~this week~~ (well clearly that didn\u0027t happen)",
        "createdAt": "2024-03-02T08:38:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52310#issuecomment-1974723279"
      },
      {
        "id": "IC_kwDOAQzde86QpHmf",
        "parentId": null,
        "author": "ArkadiyShuvaev",
        "content": "Is there a workaround for this issue?",
        "createdAt": "2024-10-21T13:32:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52310#issuecomment-2426698143"
      },
      {
        "id": "IC_kwDOAQzde86Qpff4",
        "parentId": null,
        "author": "mgravell",
        "content": "The problem is understood; moving to .NET 10 planning; there are two ways we can resolve this:\n\n1. detect the cancellation condition in such a way that one of the other requests becomes activated (this has a niche edge case where a malicious actor could queue up and cancel a bunch of sequential requests, causing another party to be delayed indefinitely)\n2. copy the machinery from \u0060HybridCache\u0060 which tracks all shared consumers, meaning that the down-stream operation is only cancelled if all interested parties cancel\n\nFor the risk stated, 2 is a better option, but is much more complicated. But the basic design exists.",
        "createdAt": "2024-10-21T14:08:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52310#issuecomment-2426796024"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde853_1_L",
    "title": "RETRY_AFTER is null in Lease object in case of SlidingWindow rate limiter",
    "url": "https://github.com/dotnet/aspnetcore/issues/52411",
    "createdAt": "2023-11-27T22:21:14Z",
    "lastUpdated": "2024-10-18T04:00:29Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nAccording to the [documentation](https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit?view=aspnetcore-8.0#limiter-with-onrejected-retryafter-and-globallimiter):\r\n\r\n\u003E retryAfter can be used with the TokenBucketRateLimiter, FixedWindowLimiter, and SlidingWindowLimiter because these algorithms are able to estimate when more permits will be added.\r\n\r\nHowever, when I use a \u0060SlidingWindowLimiter,\u0060 the \u0060RETRY_AFTER\u0060 metadata is null in the lease object. \r\nThe RETRY_AFTER metadata name is present in the MetadataNames enumerable, but the \u0060_retryAfter\u0060 field behind it is null.\r\n\r\nRegister the rate limiter:\r\n\r\n\u0060\u0060\u0060          \r\nrateLimiterOptions.AddSlidingWindowLimiter(\u0022rateLimiterName\u0022, options =\u003E\r\n{\r\n    options.PermitLimit = rateLimiterConfiguration.PermitLimit;\r\n    options.Window = TimeSpan.FromSeconds(rateLimiterConfiguration.TimeWindowInSeconds);\r\n    options.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;\r\n    options.SegmentsPerWindow = 10;\r\n});\r\n\u0060\u0060\u0060\r\n\r\nRead the RETRY_AFTER:\r\n\r\n\u0060\u0060\u0060             \r\nrateLimiterOptions.OnRejected = (context, cancellationToken) =\u003E\r\n{\r\n    if (context.Lease.TryGetMetadata(MetadataName.RetryAfter, out var retryAfter))\r\n    {\r\n        context.HttpContext.Response.Headers.RetryAfter =\r\n            ((int)retryAfter.TotalSeconds).ToString(NumberFormatInfo.InvariantInfo);\r\n    }\r\n};\r\n\u0060\u0060\u0060\r\n\r\n### Expected Behavior\r\n\r\nOn \u0060SlidingWindowLease\u0060 object, \u0060_retryAfter\u0060 field should be estimated and populated.\r\n\r\n### Steps To Reproduce\r\n\r\n[Github repo](https://github.com/ValentinVadasz/SlidingWindowRateLimiterBug)\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\nnet7.0, net8.0\r\n\r\n### Anything else?\r\n\r\n_No response_",
    "upvotes": 12,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86QUeTw",
        "parentId": null,
        "author": "lonix1",
        "content": "Agreed: *this is  bug, and also is documented incorrectly.*\n\nWithout the retry property, the sliding window limiter is effectively useless in most use cases.\n\nCan someone please label it as a bug, as it seems to have been forgotten?\n\nAlso, could it be fixed for v9?",
        "createdAt": "2024-10-18T04:00:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52411#issuecomment-2421286128"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde854CBSv",
    "title": "OutputCache configuration - policy validation",
    "url": "https://github.com/dotnet/aspnetcore/issues/52419",
    "createdAt": "2023-11-28T07:08:35Z",
    "lastUpdated": "2024-08-16T07:59:09Z",
    "body": "## Background and Motivation\r\n\r\nThe ASP.NET Core output caching middleware is great, but \u0022limited\u0022 in terms of policy validation. Let\u0027s start with some code that you can write today in .NET 7:\r\n\u0060\u0060\u0060\r\nbuilder.Services.AddOutputCache(options =\u003E\r\n{\r\n    options.AddPolicy(\u0022customPolicy\u0022, builder =\u003E  builder.Expire(TimeSpan.FromSeconds(20)));\r\n});\r\n\u0060\u0060\u0060\r\nThere is no way to validate that customPolicy actually exists. This is useful when configuring multiple routes from configuration such as is the case for YARP. See https://github.com/microsoft/reverse-proxy/pull/2328\r\n\r\n## Proposed API\r\n\r\nIt would be preferred to something similar to [IAuthorizationPolicyProvider](https://github.com/dotnet/aspnetcore/blob/2b63a5fc7fee6944af03723767be2335f1d9bf9c/src/Security/Authorization/Core/src/IAuthorizationPolicyProvider.cs) implemented via [DefaultAuthorizationPolicyProvider](https://github.com/dotnet/aspnetcore/blob/2b63a5fc7fee6944af03723767be2335f1d9bf9c/src/Security/Authorization/Core/src/DefaultAuthorizationPolicyProvider.cs) and [ICorsPolicyProvider](https://github.com/dotnet/aspnetcore/blob/2b63a5fc7fee6944af03723767be2335f1d9bf9c/src/Middleware/CORS/src/Infrastructure/ICorsPolicyProvider.cs) implemented via [DefaultCorsPolicyProvider](https://github.com/dotnet/aspnetcore/blob/2b63a5fc7fee6944af03723767be2335f1d9bf9c/src/Middleware/CORS/src/Infrastructure/DefaultCorsPolicyProvider.cs)\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.AspNetCore.OutputCaching;\r\n\r\n\u002B public interface IOutputCachePolicyProvider\r\n\u002B {\r\n\u002B     ValueTask\u003CIOutputCachePolicy?\u003E GetPolicyAsync(string policyName);\r\n\u002B }\r\n\u002B\r\n\u002B public class DefaultOutputCachePolicyProvider : IOutputCachePolicyProvider\r\n\u002B {\r\n\u002B     private readonly OutputCacheOptions _options;\r\n\u002B     \r\n\u002B     public DefaultOutputCachePolicyProvider(IOptions\u003COutputCacheOptions\u003E options)\r\n\u002B     {\r\n\u002B     \r\n\u002B     }\r\n\u002B     \r\n\u002B     public ValueTask\u003CIOutputCachePolicy?\u003E GetPolicyAsync(string policyName)\r\n\u002B     {\r\n\u002B         options.NamedPolicies[policyName];\r\n\u002B     }\r\n\u002B }\r\n\u0060\u0060\u0060\r\nOutputCacheOptions.NamedPolicies is internal hence this feature cannot be added in another library or the final application.\r\n\r\n## Usage Examples\r\n\r\nSee YARP: https://github.com/microsoft/reverse-proxy/blob/02435e0e2eb3e757fc928d9157cfcc7f2859910b/src/ReverseProxy/Configuration/RouteValidators/OutputCachePolicyValidator.cs#L27-L33\r\n\r\n## Alternative Designs\r\n\r\nNone\r\n\r\n## Risks\r\n\r\nNone\r\n\r\n",
    "upvotes": 0,
    "labels": [
      "api-approved",
      "feature-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85tCFOk",
        "parentId": null,
        "author": "witskeeper",
        "content": "like #45684 ",
        "createdAt": "2023-11-28T07:36:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52419#issuecomment-1829262244"
      },
      {
        "id": "IC_kwDOAQzde85tFiXD",
        "parentId": null,
        "author": "??",
        "content": "Thank you for submitting this for API review. This will be reviewed by @dotnet/aspnet-api-review at the next meeting of the ASP.NET Core API Review group. Please ensure you take a look at [the API review process documentation](https://github.com/dotnet/aspnetcore/blob/main/docs/APIReviewProcess.md) and ensure that:\n\n* The PR contains changes to the reference-assembly that describe the API change. **Or**, you have included a snippet of reference-assembly-style code that illustrates the API change.\n* The PR describes the impact to users, both positive (useful new APIs) and negative (breaking changes).\n* Someone is assigned to \u0022champion\u0022 this change in the meeting, and they understand the impact and design of the change.",
        "createdAt": "2023-11-28T16:08:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52419#issuecomment-1830168003"
      },
      {
        "id": "IC_kwDOAQzde85uCh_p",
        "parentId": null,
        "author": "halter73",
        "content": "@sebastienros Have you seen this yet? Do you think it\u0027s a good idea?",
        "createdAt": "2023-12-07T21:44:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52419#issuecomment-1846157289"
      },
      {
        "id": "IC_kwDOAQzde85uC4hB",
        "parentId": null,
        "author": "sebastienros",
        "content": "My naive response would be to add a \u0060GetPolicy(string name)\u0060 to the options, but the suggested design would offer more flexibility and allow new patterns to provide custom policies.\r\n\r\nNote that the API suggestion seems to be a copy-paste of the RateLimiting one since it\u0027s referring to \u0060DefaultKeyType\u0060 which is not part of OutputCache. The returned value should be \u0060IOutputCachePolicy\u0060.\r\n\r\n**Update:** API suggestion has been fixed",
        "createdAt": "2023-12-07T23:14:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52419#issuecomment-1846249537"
      },
      {
        "id": "IC_kwDOAQzde85uDBBA",
        "parentId": null,
        "author": "halter73",
        "content": "API Review Notes:\r\n\r\n- We removed references to \u0060DefaultKey\u0060 in the proposal that appears to be copy-pasted from the rate limiter proposal in https://github.com/dotnet/aspnetcore/issues/45684.\r\n- We don\u0027t think the implementation needs to be public.\r\n- Given that this doesn\u0027t need to expose a new key type publicly like the rate limiter proposal, we think we can accept this.\r\n- The current middleware should use this interface without accessing the options directly to make replacing the implementation useful.\r\n\r\nAPI Approved!\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.AspNetCore.OutputCaching;\r\n\r\n\u002B public interface IOutputCachePolicyProvider\r\n\u002B {\r\n\u002B     ValueTask\u003CIOutputCachePolicy?\u003E GetPolicyAsync(string policyName);\r\n\u002B }\r\n\u0060\u0060\u0060",
        "createdAt": "2023-12-07T23:56:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52419#issuecomment-1846284352"
      },
      {
        "id": "IC_kwDOAQzde86IbKV2",
        "parentId": null,
        "author": "onurkanbakirci",
        "content": "I\u0027m working on it",
        "createdAt": "2024-08-14T13:52:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52419#issuecomment-2288821622"
      },
      {
        "id": "IC_kwDOAQzde86IrLsx",
        "parentId": null,
        "author": "onurkanbakirci",
        "content": "Done #57362\r\n\r\n@witskeeper ",
        "createdAt": "2024-08-16T07:58:51Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52419#issuecomment-2293021489"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde855A71j",
    "title": "IExceptionHandler not being called when using UseDeveloperExceptionPage()",
    "url": "https://github.com/dotnet/aspnetcore/issues/52622",
    "createdAt": "2023-12-07T09:32:27Z",
    "lastUpdated": "2024-04-12T14:40:56Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [x] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nProgram.cs:\r\n\r\n\u0060\u0060\u0060\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\nbuilder.Services.AddExceptionHandler\u003CGlobalExceptionHandler\u003E();\r\n\r\nvar app = builder.Build();\r\n\r\n// Configure the HTTP request pipeline.\r\nif (!app.Environment.IsDevelopment())\r\n{\r\n    app.UseExceptionHandler(\u0022/Error\u0022);\r\n    app.UseHsts();\r\n}\r\nelse\r\n{\r\n    app.UseDeveloperExceptionPage();\r\n}\r\n\r\n...\r\n\r\napp.Run();\r\n\u0060\u0060\u0060\r\n\r\nGlobalExceptionHandler.cs:\r\n\r\n\u0060\u0060\u0060\r\npublic class GlobalExceptionHandler : IExceptionHandler\r\n{\r\n    public async ValueTask\u003Cbool\u003E TryHandleAsync(HttpContext httpContext, Exception exception, CancellationToken cancellationToken)\r\n    {\r\n        ...\r\n\r\n        return false;\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nAs stated within the [documentation ](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-8.0), registered exception handlers are triggered when using either **UseExceptionHandler()** or **UseDeveloperExceptionPage()**.\r\n\r\nWhen in production (**UseExceptionHander()**) the GlobalExceptionHandler is triggered successfully, while in development (**UseDeveloperExceptionPage()**) the GlobalExceptionHandler is **NOT** triggered.\r\n\r\n\r\n### .NET Version\r\n\r\n8",
    "upvotes": 2,
    "labels": [
      "Docs",
      "feature-diagnostics",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85t_9N9",
        "parentId": null,
        "author": "yugabe",
        "content": "In the default templates, the exception handler middleware is only added to the pipeline in non-development scenarios, for example:\r\n\u0060\u0060\u0060csharp\r\n    if (app.Environment.IsDevelopment())\r\n    {\r\n        app.UseWebAssemblyDebugging();\r\n    }\r\n    else\r\n    {\r\n        app.UseExceptionHandler(\u0022/error\u0022, createScopeForErrors: true);\r\n        app.UseHsts();\r\n    }\r\n\u0060\u0060\u0060\r\n\r\nAdditionally, in the Development environment, the DeveloperExceptionPage middleware is ambiently added to the pipeline. It will only handle unhandled Exceptions. So if you want to handle the exception yourself, you have to add \u0060app.UseExceptionHandler\u0060 to the pipeline.\r\n\r\nIf you want to register it in Development environment as well, you can do so. Or you can use any of the alternative ways, like a custom (non-\u0060IExceptionHandler\u0060) middleware with \u0060try-catch\u0060. ",
        "createdAt": "2023-12-07T14:51:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52622#issuecomment-1845482365"
      },
      {
        "id": "IC_kwDOAQzde85uA3bC",
        "parentId": null,
        "author": "Kahbazi",
        "content": "@jamezamm This is by design currently the \u0027IExceptionHandler\u0027 only works for the \u0060UseExceptionHandler()\u0060 middleware and not the \u0060UseDeveloperExceptionPage()\u0060. \r\n\r\nPerhaps this would be a good feature to add.",
        "createdAt": "2023-12-07T17:02:43Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52622#issuecomment-1845720770"
      },
      {
        "id": "IC_kwDOAQzde85uEyiJ",
        "parentId": null,
        "author": "jamezamm",
        "content": "@Kahbazi In my opinion this feature is a **MUST** as I cannot use Developer exception pages together with IExceptionHandler. Therefore my only option is not to use the developer exception pages middleware.\r\n\r\nAdditionally, this feature is heavily implied within the [documentation](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-8.0). Specifically:\r\n\r\n\u003E When the preceding code runs in the Development environment:\r\n\u003E \r\n\u003E - The CustomExceptionHandler is called first to handle an exception.\r\n\u003E - After logging the exception, the TryHandleException method returns false, so the [developer exception page](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-8.0#developer-exception-page) is shown.\r\n",
        "createdAt": "2023-12-08T08:21:14Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52622#issuecomment-1846749321"
      },
      {
        "id": "IC_kwDOAQzde85uLOH4",
        "parentId": null,
        "author": "Kahbazi",
        "content": "\u003E Additionally, this feature is heavily implied within the [documentation](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-8.0).\r\n\r\nThis seems like a problem with docs. \r\n\r\nAlso you can use \u0060IDeveloperPageExceptionFilter\u0060 for DeveloperPageException.",
        "createdAt": "2023-12-09T15:08:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52622#issuecomment-1848435192"
      },
      {
        "id": "IC_kwDOAQzde85uNPEF",
        "parentId": null,
        "author": "KennethHoff",
        "content": "This confused me a lot as well, and I resorted to simply remove the call to \u0060UseDeveloperExceptionPage\u0060.\r\n\r\nBasically what I want is for the developer exception page to effectively be the last in the pipeline of exception handlers.\r\n\r\n\u0060\u0060\u0060c#\r\n// Stuff before...\r\nbuilder.Services.AddExceptionHandler\u003CFirstCustomExceptionHandler\u003E() // Handles some specific case\r\nbuilder.Services.AddExceptionHandler\u003CSecondCustomExceptionHandler\u003E() // Handles another specific case\r\n\r\nif (!builder.Environment.IsDevelopment())\r\n{\r\n\tbuilder.Services.AddExceptionHandler\u003CFallbackExceptionHandler\u003E(); // Fallback handler for Prod\r\n}\r\n\r\n// Stuff in-between...\r\n\r\nif (!app.Environment.IsDevelopment())\r\n{\r\n    app.UseExceptionHandler();\r\n}\r\nelse\r\n{\r\n    app.UseDeveloperExceptionPage(); // Fallback handler for development\r\n}\r\n\r\n// Stuff after..\r\n\u0060\u0060\u0060\r\n\r\nMaybe it could even be refactored _into_ an exception handler \u00E1 la this:\r\n\r\n\u0060\u0060\u0060c#\r\n// Stuff before...\r\n\r\nbuilder.Services.AddExceptionHandler\u003CFirstCustomExceptionHandler\u003E();\r\nbuilder.Services.AddExceptionHandler\u003CSecondCustomExceptionHandler\u003E();\r\n\r\nif (!builder.Environment.IsDevelopment())\r\n{\r\n\tbuilder.Services.AddExceptionHandler\u003CFallbackExceptionHandler\u003E();\r\n}\r\nelse\r\n{\r\n\tbuilder.Services.AddExceptionHandler\u003CDeveloperExceptionPageExceptionHandler\u003E() // This is the built-in one.\r\n}\r\n\r\n// Stuff in-between...\r\n\r\napp.UseExceptionHandler();\r\n\r\n// Stuff after..\r\n\u0060\u0060\u0060",
        "createdAt": "2023-12-10T13:17:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52622#issuecomment-1848963333"
      },
      {
        "id": "IC_kwDOAQzde854tDrI",
        "parentId": null,
        "author": "emetrix",
        "content": "I\u0027m facing the same issue. In my opinion and refering to the docs a custom exception handing middleware should ALWAYS be called, whether or not the UseDeveloperExceptionPage() is used ?",
        "createdAt": "2024-03-28T12:32:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52622#issuecomment-2025077448"
      },
      {
        "id": "IC_kwDOAQzde856TVEz",
        "parentId": null,
        "author": "voroninp",
        "content": "[Why?](https://github.com/dotnet/aspnetcore/blob/ba3460aa8247c43e834cb1568b80590b7d218a16/src/Middleware/Diagnostics/src/ExceptionHandler/ExceptionHandlerMiddlewareImpl.cs#L130C9-L130C94)\r\n\r\nWhy is it unhandled, if \u0060IExceptionHandler\u0060 can handle it?\r\n\r\nI see the same exception twice. The first one is from the middleware, and then it is logged by \u0060IExceptionHanlder\u0060.",
        "createdAt": "2024-04-12T14:38:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52622#issuecomment-2051887411"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde855L739",
    "title": "[API Proposal]: Microsoft.AspNetCore.OutputCaching consider adding a way to change expiration time based on logic in IOutputCachePolicy",
    "url": "https://github.com/dotnet/aspnetcore/issues/52670",
    "createdAt": "2023-12-08T15:23:16Z",
    "lastUpdated": "2024-04-11T07:51:10Z",
    "body": "### Background and motivation\n\nTo dynamically set cache expiration based on customer logic.\n\n### API Proposal\n\nNo changes to api\n\n### API Usage\n\n\u0060\u0060\u0060csharp\r\n    ValueTask IOutputCachePolicy.ServeResponseAsync(OutputCacheContext c, CancellationToken ct)\r\n    {\r\n        switch (c.HttpContext.Response.StatusCode)\r\n        {\r\n            case \u003E= 200 and \u003C 300:\r\n                c.AllowCacheStorage = true;\r\n                break;\r\n            \r\n            case \u003E= 400 and \u003C 500 when CachedResponseValidForPropertyInfo != null:\r\n                c.AllowCacheStorage = true;\r\n                // currently ignored by middleware\r\n                c.ResponseExpirationTimeSpan = TimeSpan.FromMinutes(0.5);\r\n                // CachedResponseValidForPropertyInfo.SetValue(c, _errorExpirationBoxed);\r\n                break;\r\n            \r\n            default:\r\n                c.AllowCacheStorage = false;\r\n                break;\r\n        };\r\n\r\n        return ValueTask.CompletedTask;\r\n    }\r\n\u0060\u0060\u0060\r\n\n\n### Alternative Designs\n\n_No response_\n\n### Risks\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "api-suggestion",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde856Iz5_",
        "parentId": null,
        "author": "Raziel233",
        "content": "Please implement this :)",
        "createdAt": "2024-04-11T07:51:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/52670#issuecomment-2049130111"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde855X37u",
    "title": "Output Caching DefaultPolicy allows bypassing cache with any Authorization header even if there\u0027s no [Authorize] attribute specified",
    "url": "https://github.com/dotnet/aspnetcore/issues/52738",
    "createdAt": "2023-12-11T18:38:06Z",
    "lastUpdated": "2024-02-13T01:11:30Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nThe title pretty much says it all.\r\nThere is related issue https://github.com/dotnet/aspnetcore/issues/45469 which pretty much describes this bug/feature but I\u0027d like to focus on the other aspect of the problem. \r\n\r\nOutput caching was introduced in .net7 as more reliable alternative to response caching. One of it\u0027s core features was that unlike response caching it couldn\u0027t be disabled by sending  \u0060max-age=0\u0060 or \u0060no-cache\u0060 in \u0060Cache-control\u0060 header. \r\n\r\nDefault policy for output caching has this check that seems a bit doubtful:\r\nhttps://github.com/dotnet/aspnetcore/blob/e0e1d582a993feddf346e7224c7fbd712376d91f/src/Middleware/OutputCaching/src/Policies/DefaultPolicy.cs#L76\r\n\r\nThis check passes if there\u0027s \u0060Authorization\u0060 header present **regardles of it\u0027s content and of controller\u0027s requirements**, which means any output cache can be effectively bypassed by adding an \u0060Authorization\u0060 header to any request.\r\n\r\nThe question is: should it behave like this **by default?**\r\n\r\nYes, I know that \r\n\u003E authenticated requests are not cached by design \r\n\r\n_Originally posted by @sebastienros in https://github.com/dotnet/aspnetcore/issues/45469#issuecomment-1338323610_\r\n\r\nbut the presence of a single specific header does not make the request authenticated!\r\n\r\nYes, I know that I can configure my own caching policy but shouldn\u0027t something like this be a default?\r\n\n\n### Expected Behavior\n\nIn my humble opinion the correct condition for this chek should be something like:\r\n\r\n\u0060\u0060\u0060csharp\r\nif (request.HttpContext.User?.Identity?.IsAuthenticated == true)\r\n{\r\n    return false;\r\n}\r\n\u0060\u0060\u0060\r\n\r\nIn case of someone putting the correct Bearer Token in a header by mistake. It works only if \u0060[Authorize]\u0060 attribute is present on a controller action. Otherwise \u0060HttpContext.User\u0060 is not authenticated. However this solution has a downside as it will only work with minimal API or if the api controller itself does not have the \u0060[Authorize]\u0060 attribute.\r\n\r\nBut regardless of \u0060[Authorize]\u0060 attribute this also prevents the malicious use of invalid \u0060Authorization\u0060 header to purposely perform a Thundering Herd attack.\n\n### Steps To Reproduce\n\n1. Create a controller action or a minimal API endpoint with Output caching configured. (The controller **and** the action should **not** have \u0060[Authorize]\u0060 attribute if you plan to use valid jwt authentication bearer in the next step). \r\n2. Make a request to an endpoint with the Authorization header present (the value of header doesn\u0027t matter). Observe that the response is not cached.\r\n3. Make the same request to the same endpoint without the Authorization header present. Observe that it will be cached.\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n8.0.100\n\n### Anything else?\n\n_No response_",
    "upvotes": 3,
    "labels": [
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde857YtMR",
    "title": "UseStatusCodePagesWithRedirects not working",
    "url": "https://github.com/dotnet/aspnetcore/issues/53210",
    "createdAt": "2024-01-08T09:44:40Z",
    "lastUpdated": "2024-02-13T01:06:05Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nI added this code to my program.cs but its not getting triggered, i already have my Error page\r\n\r\napp.UseStatusCodePagesWithRedirects(\u0022/Error?code={0}\u0022);\n\n### Expected Behavior\n\nWhen my token is expired the UseStatusCodePagesWithRedirects should automatically detect a 401 error returned by my api call and will automatically redirect to the Error page\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n.NET 8\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85wJpWb",
        "parentId": null,
        "author": "Tratcher",
        "content": "What happens instead?\r\n\r\nWhat do the server logs say?\r\n\r\nPlease show your program.main / startup code in context to ensure the correct ordering.",
        "createdAt": "2024-01-08T18:02:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53210#issuecomment-1881576859"
      },
      {
        "id": "IC_kwDOAQzde85wLnNf",
        "parentId": null,
        "author": "TediSalivio",
        "content": "\u003E What happens instead?\r\n\u003E \r\n\u003E What do the server logs say?\r\n\u003E \r\n\u003E Please show your program.main / startup code in context to ensure the correct ordering.\r\n\r\nThis is the program.cs screenshot\r\n\r\n![program cs screenshot](https://github.com/dotnet/aspnetcore/assets/120305713/2ab66fbc-20f8-4b58-a5f8-7c5f55378b05)\r\n",
        "createdAt": "2024-01-09T00:52:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53210#issuecomment-1882092383"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde857epPT",
    "title": "New users are confused by the \u0022Failed to determine the https port for redirect\u0022 warning",
    "url": "https://github.com/dotnet/aspnetcore/issues/53229",
    "createdAt": "2024-01-09T04:57:39Z",
    "lastUpdated": "2024-02-13T01:05:52Z",
    "body": "We\u0027ve received several reports from new users trying out ASP.NET Core that are confused by the \u0022Failed to determine the https port for redirect\u0022 warning when running with the default http launch profile:\r\n\r\n- https://github.com/dotnet/core/issues/9044\r\n- https://github.com/dotnet/core/issues/9010\r\n- https://github.com/dotnet/core/issues/8960\r\n- https://github.com/dotnet/core/issues/9074\r\n\r\n@mairaw ",
    "upvotes": 6,
    "labels": [
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde858RzYq",
    "title": "Epic: Rate Limiting",
    "url": "https://github.com/dotnet/aspnetcore/issues/53426",
    "createdAt": "2024-01-16T22:02:01Z",
    "lastUpdated": "2024-11-06T19:47:43Z",
    "body": "This issue captures issues related to rate limiting work in .NET 9. Issues and categorizations are subject to change as design and planning is underway.\r\n\r\n* Distributed rate limiting\r\n  - Redis Implementation\r\n  - Any new primitives needed?\r\n* More Configuration\r\n  - Changing config at runtime\r\n  - \u0060IConfiguration\u0060 support?\r\n* Missing features\r\n  - Weighted endpoints (e.g. \u0060POST /buyItem\u0060 costs 2 instead of 1 for \u0060GET /listItems\u0060)\r\n  - Circuit breaker? (X request failures/sec, fail incoming requests to allow service time to self-heal)\r\n* Metrics\r\n  - Any additional metrics needed?\r\n  - At a minimum document how to do manual metric retrieval",
    "upvotes": 35,
    "labels": [
      "Epic",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85yA4jI",
        "parentId": null,
        "author": "aKzenT",
        "content": "What is missing from this list is the support of multiple rate limits per endpoint (as requested in #42691 ). E.g. you want to allow your order endpoint to accept a maximum of five orders per IP per minute, but also a maximum of 100 orders per day. ",
        "createdAt": "2024-01-26T23:43:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53426#issuecomment-1912834248"
      },
      {
        "id": "IC_kwDOAQzde853y9Ml",
        "parentId": null,
        "author": "ShaneCourtrille",
        "content": "@BrennanConroy One scenario we\u0027ve run into is the need for rate limiting for the first 3 minutes of startup after which we can safely switch to no limiter.  Is switching the rate limiter based on config going to be possible? Or would we just be using the concurrency limiter and changing the permit limit?",
        "createdAt": "2024-03-20T15:28:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53426#issuecomment-2009846565"
      },
      {
        "id": "IC_kwDOAQzde85_NH-i",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "Unfortunately, the majority of this work is being pushed back to .NET 10.",
        "createdAt": "2024-05-27T23:47:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53426#issuecomment-2134146978"
      },
      {
        "id": "IC_kwDOAQzde86Avb4D",
        "parentId": null,
        "author": "jakubsemerak",
        "content": "Also priority queues used inside rate limiters would be pretty nice. In our case we needed to skip the queue line by priority communication to minimize response time as much as possible. So we have replaced standard Queue with PriorityQueue and everything works flawlessly. IMO priority queue inside the limiters would be more universal.",
        "createdAt": "2024-06-11T06:43:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53426#issuecomment-2159918595"
      },
      {
        "id": "IC_kwDOAQzde86LvKza",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "Re-titled the issue and moved it to the backlog for now until we find time to work on this area again.",
        "createdAt": "2024-09-11T18:33:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53426#issuecomment-2344398042"
      },
      {
        "id": "IC_kwDOAQzde86R2csF",
        "parentId": null,
        "author": "marekott",
        "content": "Hi guys, \u0060Distributed rate limiting\u0060 seems like a very useful feature that would prevent many of developers from reinventing the wheel. In our case we are planning to introduce rate limiting on our edge microservice that is implementing YARP. Since it is distributed system there are multiple instances of that microservice varying in number between environments. Current implementation of rate limiting is not sufficient for us since we need to synchronize those limits between instances. \n\nOther developers that need to implement it in their distributed systems will face the same issue. All of us will have to create own implementations based on Redis solving the same problems over and over again. It would be cool if you could find time to introduce this feature :)",
        "createdAt": "2024-10-30T12:27:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53426#issuecomment-2446969605"
      },
      {
        "id": "IC_kwDOAQzde86R8nde",
        "parentId": null,
        "author": "rkargMsft",
        "content": "As a \u0022right now\u0022 solution, there is this package implementing distributed rate limiting using Orleans:\nhttps://github.com/managedcode/Orleans.RateLimiting\n\nThis includes exposing the core rate limiting primitives with Orleans as the coordinating state storage and implementations using that for Orleans grain calls as well as using them for [ASP.NET Core calls](https://github.com/managedcode/Orleans.RateLimiting?tab=readme-ov-file#attrubutes-for-webapi).",
        "createdAt": "2024-10-30T22:37:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53426#issuecomment-2448586590"
      },
      {
        "id": "IC_kwDOAQzde86Sql-C",
        "parentId": null,
        "author": "dtila",
        "content": "Hi guys so from my point of view some work has to be done to have unified design.\nHere are my thoughts:\n\n1. A rate limit should allow having OnReject per each limit. \nExpected API:\n\u0060\u0060\u0060\noptions.AddXXX(\u0022policyName\u0022, options =\u003E\n options.OnRejected = .....\n\u0060\u0060\u0060\nCurrently this functionality can be achieved by checking policy name by using if statements. However would be nice to have the reject attached to the policy as well.\nThis is needed in case you want to transmit to the client a response, eventually with the properties from the limit metadata\n\n\n2. An overload with options.AddRateLimit(\u0022name\u0022, PartitionedRateLimiter instance) should be added. With the current design there is a discrepancy when you create a policy using options.AddXX and the GlobalLimiter. \nExpected behavior should be that everywhere should be using a PartitionedRateLimiter instance, similar with the current design of GlobalLimiter.\nAlso all the existing functions to add policy, should should call this new overload \n\n\nFor example, currently if you want to create a chained policy you use this API:\n\u0060\u0060\u0060\n var ipRateLimit = PartitionedRateLimiter.Create\u003CHttpContext, string\u003E(CreateIpLimitPartition);\n var concurrencyLimit = PartitionedRateLimiter.Create\u003CHttpContext, string\u003E(CreateConcurrencyLimitPartition);\n options.GlobalLimiter = PartitionedRateLimiter.CreateChained(ipRateLimit, concurrencyLimit);\n\u0060\u0060\u0060\n\nUsing the same API, you should also use call options.Add(\u0022mypolicy\u0022, result_of_chained_policy)\nCurrently I could not find any way to achieve such a thing, even analysing the code,\n\n\n\n     ",
        "createdAt": "2024-11-06T19:47:42Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53426#issuecomment-2460639106"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde858omvs",
    "title": "RequestDelegate is not injected on middlewares using Primary Constructor",
    "url": "https://github.com/dotnet/aspnetcore/issues/53490",
    "createdAt": "2024-01-19T17:53:40Z",
    "lastUpdated": "2024-02-13T01:03:52Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nWhen using primary constructors, the \u0060RequestDelegate\u0060 comes null, causing \u0060404\u0060 to be returned everytime. When using default constructors, it is injected just fine, which is expected.\r\n\r\n![Imagem do WhatsApp de 2024-01-19 \u00E0(s) 14 45 09_64192b56](https://github.com/dotnet/aspnetcore/assets/54086793/4c9035f9-0028-490f-9900-8526017085bf)\n\n### Expected Behavior\n\nSince primary constructor is the same of having a single construtor definition, it should have the same behaviour as injecting the \u0060RequestDelegate\u0060 in the default constructor.\n\n### Steps To Reproduce\n\n\u2022 Create a middleware \r\n\u2022 Use the new primary constructor to inject the RequestDelegate\r\n\u2022 Verify during debug that it is injected as null\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n8\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85xTTyF",
        "parentId": null,
        "author": "martincostello",
        "content": "Just to rule out in being a scoping thing, if you remove the field and just capture the parameter (so you don\u0027t have a field and a parameter both called \u0060_request\u0060), is it:\n\n1) null and causing a problem _when you use it_ (e.g. a \u0060NullReferenceException\u0060), or:\n2) does it _appear_ null in the debugger but the code works fine.\n\nI have noticed Visual Studio\u0027s debugger do case 2 in places where I\u0027ve used primary constructors, which obviously isn\u0027t ideal, but would be an IDE issue.",
        "createdAt": "2024-01-19T18:20:03Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53490#issuecomment-1900887173"
      },
      {
        "id": "IC_kwDOAQzde85xTW4J",
        "parentId": null,
        "author": "igor-henriques",
        "content": "\u003E Just to rule out in being a scoping thing, if you remove the field and just capture the parameter (so you don\u0027t have a field and a parameter both called \u0060_request\u0060), is it:\r\n\u003E \r\n\u003E 1. null and causing a problem _when you use it_ (e.g. a \u0060NullReferenceException\u0060), or:\r\n\u003E 2. does it _appear_ null in the debugger but the code works fine.\r\n\u003E \r\n\u003E I have noticed Visual Studio\u0027s debugger do case 2 in places where I\u0027ve used primary constructors, which obviously isn\u0027t ideal, but would be an IDE issue.\r\n\r\nActually, I\u0027m getting a 404 because I\u0027m using a MapWhen: \r\n\r\n![image](https://github.com/dotnet/aspnetcore/assets/54086793/eae8ee04-13dc-4747-85f6-1d04f92e6164)\r\n\r\nIf I just add the middleware directly, the pipeline continue just fine to my controller, even with the RequestDelegate coming as null. About what you\u0027re saying, yes, even removing the field, the RequestDelegate comes as null, but it doesn\u0027t early return the pipeline or throw any exception like I suggested in the description (which is weird).\r\n\r\nStill not sure if this is out of the scope of the issue tho. The RequestDelegate coming as null is a fact and doesn\u0027t reflect the same as using the default constructor, but it is not the reason for the 404, as I just explained above.",
        "createdAt": "2024-01-19T18:27:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/53490#issuecomment-1900899849"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85_RRCR",
    "title": "Extend Meta data able to be fetched about a Session ",
    "url": "https://github.com/dotnet/aspnetcore/issues/54044",
    "createdAt": "2024-02-14T21:27:28Z",
    "lastUpdated": "2024-03-03T12:02:22Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nI am trying to implement an actuator for sesssions modeled on the spring defintiion: https://docs.spring.io/spring-boot/docs/current/actuator-api/htmlsingle/#sessions\n\n### Describe the solution you\u0027d like\n\nI would like it to be possible to fetch from the session state additional information about the session such as:\r\n\r\n- Created datetime\r\n- last update datetime\r\n- The idle timeout\r\n\r\nIn the event a user is logged in it should be possible to both fetch the username for that session.\n\n### Additional context\n\nn/a",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde850Bk6P",
        "parentId": null,
        "author": "Tratcher",
        "content": "Note that browser based sessions should not be used for any authenticated user information. Logins and browser sessions are independent mechanics with no lifetime guaranties between them.\r\n\r\nIsn\u0027t the idle timeout the same for all sessions? Or do you mean the current calculated value based on last access?\r\n\r\nCreation date you can do yourself by having a field in the session for that which you ensure is present for each request.\r\n\r\nFor last updated, is that just last modified or does it include sliding expiration based on last accessed? You could track last modified yourself but that would be tedious...",
        "createdAt": "2024-02-15T16:51:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54044#issuecomment-1946570383"
      },
      {
        "id": "IC_kwDOAQzde850FvY-",
        "parentId": null,
        "author": "thompson-tomo",
        "content": "I am simply wanting to provide the data for the actuator, I don\u0027t plan to store user information other username so I can see which browser sessions have a user logged in \u0026 who. Thinking more about the metadata it would be beneficial to also have a flag logged in for when a user logs out but continued their session.\n\nI know it would be possible to track create date \u0026 idle time but was of the thought a common metadata object would be beneficial. Ie Aspire could have a page \u0022sessions\u0022 which lists all sessions including start time \u0026 last action.\n\nBy last updated, I meant last Accessed which I know would be tedious hence wanting it to be available natively which I feel would be easier to achieve.",
        "createdAt": "2024-02-16T02:26:33Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54044#issuecomment-1947661886"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde85_hFJM",
    "title": "HttpsRedirectionMiddleware should not redirect requests to the same port",
    "url": "https://github.com/dotnet/aspnetcore/issues/54082",
    "createdAt": "2024-02-16T20:13:06Z",
    "lastUpdated": "2024-02-20T10:17:51Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nIf HttpsRedirectionMiddleware redirects a request from http://localhost:5001 to https://localhost:5001, the redirected request will fail with a protocol error, since the port isn\u0027t using https.  When you accidentally get into this state, it can be hard to tell what\u0027s happening, so we should also improve the logging.\n\n### Expected Behavior\n\n1. Redirection should fail, rather than redirect to the same port\r\n2. There should be logging for this particular kind of redirection failure\r\n3. If possible, there should be logging about the conflicting configurations that led to the middleware thinking the port was accepting https\n\n### Steps To Reproduce\n\nMake a new webapi project:\r\n\r\nProgram.cs\r\n\u0060\u0060\u0060csharp\r\nvar builder = WebApplication.CreateBuilder(args);\r\n\r\nbuilder.WebHost.UseKestrel(serverOptions =\u003E\r\n{\r\n    serverOptions.ListenAnyIP(5001);\r\n});\r\n\r\nvar app = builder.Build();\r\n\r\napp.UseHttpsRedirection();\r\n\r\napp.Run(async context =\u003E\r\n{\r\n    await context.Response.WriteAsync(\u0022Hello world!\u0022);\r\n});\r\n\r\napp.Run();\r\n\u0060\u0060\u0060\r\n\r\nProperties/launchSettings.json\r\n\u0060\u0060\u0060json\r\n{\r\n  \u0022profiles\u0022: {\r\n    \u0022Kestrel\u0022: {\r\n      \u0022commandName\u0022: \u0022Project\u0022,\r\n      \u0022launchBrowser\u0022: false,\r\n      \u0022environmentVariables\u0022: {\r\n        \u0022ASPNETCORE_ENVIRONMENT\u0022: \u0022Development\u0022\r\n      }\r\n    }\r\n  }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nNote that launchSettings _does not_ specify an application url - this is not the default behavior.\r\n\r\n\u0060\u0060\u0060\r\n$ curl -v http://localhost:5001/\r\n*   Trying [::1]:5001...\r\n* Connected to localhost (::1) port 5001\r\n\u003E GET / HTTP/1.1\r\n\u003E Host: localhost:5001\r\n\u003E User-Agent: curl/8.4.0\r\n\u003E Accept: */*\r\n\u003E\r\n\u003C HTTP/1.1 307 Temporary Redirect\r\n\u003C Content-Length: 0\r\n\u003C Date: Fri, 16 Feb 2024 19:59:12 GMT\r\n\u003C Server: Kestrel\r\n\u003C Location: https://localhost:5001/\r\n\u003C\r\n* Connection #0 to host localhost left intact\r\n\u0060\u0060\u0060\r\n\r\n\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n9b4c5332ef0ef437120bd06454d2bbd335e030ac\n\n### Anything else?\n\nIt happens in HttpSys as well, setting UrlPrefix, rather than calling \u0060ListenAnyIP\u0060.\r\n\r\nAFAICT, because VS is unaware that the URL is being configured in code, it injects \r\n\u0060\u0060\u0060\r\nASPNETCORE_HTTPS_PORT=5001\r\nASPNETCORE_URLS=https://localhost:5001/;http://localhost:5000/\r\n\u0060\u0060\u0060\r\n\r\nAs a result, the middleware sees that https requests should go to port 5001.  Without the env var, the middleware would search existing endpoints to find one supporting https.  Since there isn\u0027t one in this particular repro, it would log a redirection failure and accept the http request as-is.\r\n\r\nIf the configuration in code specified a port other than 5001, the browser would at least show the user redirection to a port they weren\u0027t expecting, but it would still likely fail if the server weren\u0027t listening on that port.",
    "upvotes": 0,
    "labels": [
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde850L7Vf",
        "parentId": null,
        "author": "amcasey",
        "content": "If you change the configuration to\r\n\u0060\u0060\u0060csharp\r\n    serverOptions.ListenAnyIP(5000);\r\n    serverOptions.ListenAnyIP(5002, listenOptions =\u003E\r\n    {\r\n        listenOptions.UseHttps();\r\n    });\r\n\u0060\u0060\u0060\r\nand curl http://localhost:5000, you\u0027ll still get redirected to https://localhost:5001, even though the server isn\u0027t listening on that port.  It\u0027s unfortunate that code beats configuration for determining endpoints, but not for determining redirection.  @Tratcher conjectures \r\n\u003E Oh, actually that ordering might be specific to support container and proxy scenarios where https isn\u0027t locally configured\r\n\r\nIf we can\u0027t make the precedence agree, the solution may be to have the middleware compare the target point to the list of active endpoints (from the \u0060IServerAddressesFeature\u0060) and complain if it\u0027s not an https endpoint.",
        "createdAt": "2024-02-16T20:25:55Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54082#issuecomment-1949283679"
      },
      {
        "id": "IC_kwDOAQzde850MEQC",
        "parentId": null,
        "author": "Tratcher",
        "content": "\u003E and complain if it\u0027s not an https endpoint.\r\n\r\nif present. The port may not be bound locally in the reverse proxy scenairo.",
        "createdAt": "2024-02-16T20:53:00Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54082#issuecomment-1949320194"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86AKqg5",
    "title": "Metrics for caching",
    "url": "https://github.com/dotnet/aspnetcore/issues/54182",
    "createdAt": "2024-02-23T02:51:51Z",
    "lastUpdated": "2024-09-11T15:50:06Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nCaching is a largely invisible operation. It\u0027s useful to have metrics to observe what is happening with caching.\n\n### Describe the solution you\u0027d like\n\nCaching has many APIs and usages in ASP.NET Core. See https://learn.microsoft.com/en-us/aspnet/core/performance/caching/overview?view=aspnetcore-8.0\r\n\r\n* In-memory caching\r\n* Distributed caching\r\n* Output caching\r\n* Response caching\r\n\r\nFind the most useful places to add metrics. Note that we should try to design metrics so that all implementations of a cache benefit. For example, all distributed caching implementations get metrics, rather than just Redis and leaving SQL Server cache out.\n\n### Additional context\n\n_No response_",
    "upvotes": 2,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde8503Vtz",
        "parentId": null,
        "author": "JamesNK",
        "content": "FYI @mgravell (part of caching epic) @eerhardt",
        "createdAt": "2024-02-23T02:52:31Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54182#issuecomment-1960663923"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86AUm9M",
    "title": "Blazor server - Static files from wwwroot doesn\u0027t load using IIS (404)",
    "url": "https://github.com/dotnet/aspnetcore/issues/54216",
    "createdAt": "2024-02-25T18:32:51Z",
    "lastUpdated": "2024-05-18T19:29:51Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nI Have a Blazor Server .NET 8 App. In my local environment using the name \u0022Development\u0022 the application runs correctly. However, after hosting the application on an IIS server side, all the content references at wwwroot are returning 404 like CSS, images, and javascript files. It can\u0027t find any resources (wwroot) even though the folder does exist on the server. As additional information, the application is hosted by  https://www.contoso.com/{MYAPP} and I have configured the App base path described in the documentation at [App Base Path](https://learn.microsoft.com/en-us/aspnet/core/blazor/host-and-deploy/?view=aspnetcore-7.0\u0026tabs=visual-studio#app-base-path). Everything works in the dev environment, but no int the server.\r\n\r\n**Some code examples in the program file**\r\n\u0060WebApplicationBuilder builder = WebApplication.CreateBuilder(args);\u0060\r\n\r\n\u0060builder.WebHost.UseWebRoot(\u0022wwwroot\u0022);\u0060\r\n\u0060builder.WebHost.UseStaticWebAssets();\u0060\r\n\r\n\u0060......\u0060\r\n\r\n\u0060WebApplication app = builder.Build();\u0060\r\n\r\n\u0060app.UseStaticFiles(\u0022/App/Treatment\u0022);\u0060\r\n\u0060app.UsePathBase(\u0022/App/Treatment\u0022);\u0060\r\n\r\n....\r\n\u0060app.UseHttpsRedirection();\u0060\r\n\r\n\u0060app.UseRouting();\u0060\r\n\u0060app.UseCors();\u0060\r\n\r\n\u0060app.UseAntiforgery();\u0060\r\n\r\n\u0060app.UseCookiePolicy();\u0060\r\n\u0060app.UseAuthentication();\u0060\r\n\u0060app.UseAuthorization();\u0060\r\n\u0060app.UseSession();\u0060\r\n\u0060app.UseResponseCaching();\u0060\r\n\r\n\u0060app.MapDefaultControllerRoute();\u0060\r\n\r\n\u0060app.MapRazorComponents\u003CApp\u003E()\u0060\r\n    \u0060.AddInteractiveServerRenderMode();\u0060\r\n\r\n\u0060app.Run();\u0060\r\n\r\n\r\n**App.razor**\r\n\u0060\u003Cbase href=\u0022/App/Treatment/\u0022 /\u003E\u0060\r\n\r\n### Expected Behavior\r\n\r\n_No response_\r\n\r\n### Steps To Reproduce\r\n\r\n_No response_\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n8.0.100\r\n\r\n### Anything else?\r\n\r\n![image](https://github.com/dotnet/aspnetcore/assets/161242684/98363fac-fed3-4931-9cd4-3a01da6cd123)\r\n",
    "upvotes": 0,
    "labels": [
      "feature-iis",
      "area-networking",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde851X1ev",
        "parentId": null,
        "author": "christolo",
        "content": "As a workaround for now I created a virtual directory in IIS for wwwroot and then setup a rewrite rule for /appsettings.json -\u003E wwwroot/appsettings.json until we figure out the issue.",
        "createdAt": "2024-02-28T15:05:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54216#issuecomment-1969182639"
      },
      {
        "id": "IC_kwDOAQzde851aiQl",
        "parentId": null,
        "author": "annibalh07",
        "content": "I believe the issue is related to the **\u0060UseStaticFiles\u0060** middleware and the **\u0060dotnet\u0060** run command, causing an incorrect physical path where it is executed. To address this, I have implemented a workaround by specifying the physical path as follows:\r\n\r\n\u0060\u0060\u0060\r\nWebApplication app = builder.Build();\r\napp.UseDefaultFiles();\r\n\r\nif (builder.Environment.IsDevelopment())\r\n{\r\n    app.UseStaticFiles(\u0022/App/Treatment\u0022);\r\n}\r\nelse\r\n{\r\n    app.UseStaticFiles(new StaticFileOptions()\r\n    {\r\n        FileProvider = new PhysicalFileProvider($@\u0022{AppDomain.CurrentDomain.BaseDirectory}/wwwroot\u0022)\r\n    });\r\n}\r\n\r\napp.UsePathBase(\u0022/App/Treatment\u0022);\r\n\u0060\u0060\u0060\r\nIt worked!",
        "createdAt": "2024-02-28T20:46:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54216#issuecomment-1969890341"
      },
      {
        "id": "IC_kwDOAQzde851arBW",
        "parentId": null,
        "author": "christolo",
        "content": "Nice work. I\u0027ll give it a go myself. Thanks.",
        "createdAt": "2024-02-28T21:13:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54216#issuecomment-1969926230"
      },
      {
        "id": "IC_kwDOAQzde851nZQ_",
        "parentId": null,
        "author": "maxbanas",
        "content": "\u003E I believe the issue is related to the **\u0060UseStaticFiles\u0060** middleware and the **\u0060dotnet\u0060** run command, causing an incorrect physical path where it is executed. To address this, I have implemented a workaround by specifying the physical path as follows:\r\n\u003E \r\n\u003E \u0060\u0060\u0060\r\n\u003E WebApplication app = builder.Build();\r\n\u003E app.UseDefaultFiles();\r\n\u003E \r\n\u003E if (builder.Environment.IsDevelopment())\r\n\u003E {\r\n\u003E     app.UseStaticFiles(\u0022/App/Treatment\u0022);\r\n\u003E }\r\n\u003E else\r\n\u003E {\r\n\u003E     app.UseStaticFiles(new StaticFileOptions()\r\n\u003E     {\r\n\u003E         FileProvider = new PhysicalFileProvider($@\u0022{AppDomain.CurrentDomain.BaseDirectory}/wwwroot\u0022)\r\n\u003E     });\r\n\u003E }\r\n\u003E \r\n\u003E app.UsePathBase(\u0022/App/Treatment\u0022);\r\n\u003E \u0060\u0060\u0060\r\n\u003E \r\n\u003E It worked!\r\n\r\nThis worked for me as well. Thank you! Looks like #51027 may be related?",
        "createdAt": "2024-03-01T14:02:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54216#issuecomment-1973261375"
      },
      {
        "id": "IC_kwDOAQzde856uc2W",
        "parentId": null,
        "author": "azubu23202869",
        "content": "This doesn\u0027t work for me as I still cannot read files under the wwwroot directory.\r\n\r\nI added the following code to my code:\r\n\u0060\u0060\u0060\r\napp.UseStaticFiles(new StaticFileOptions()\r\n{\r\n    FileProvider = new PhysicalFileProvider($@\u0022{AppDomain.CurrentDomain.BaseDirectory}/wwwroot\u0022)\r\n});\r\n\u0060\u0060\u0060\r\n![image](https://github.com/dotnet/aspnetcore/assets/43975713/e717625c-f804-4e9e-8dd8-dd6fa5793295)\r\n\r\n",
        "createdAt": "2024-04-16T12:40:18Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54216#issuecomment-2058997142"
      },
      {
        "id": "IC_kwDOAQzde858iZE6",
        "parentId": null,
        "author": "szijarto68",
        "content": "Not working for me either.  I was hopeful to use Blazor for ongoing UI development, but this is a big fail.  I\u0027ve wasted hours trying to get the static files to get served up.",
        "createdAt": "2024-05-02T01:43:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54216#issuecomment-2089390394"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86BFCfd",
    "title": "Extend ISessionStore to enable fetching a list of all sessions",
    "url": "https://github.com/dotnet/aspnetcore/issues/54331",
    "createdAt": "2024-03-03T21:41:13Z",
    "lastUpdated": "2024-03-03T21:41:18Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nI want to be able to offer an api to obtain a list of all sessions as it is done in spring boot\n\n### Describe the solution you\u0027d like\n\nIt should be possible to fetch a list of all sessions that have been created in the system. This list needs to be distributed across instances if distributed cache is being used.\r\n\r\nI am thinking that we almost need a dedicated session to track the sessions with the keys associated with that session being for each session. This approach would then enable us to fetch the session\u0027s using the createsession method and then via the keys get a list of all other sessions.\n\n### Additional context\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86ByhoN",
    "title": "Allow backwards-forwards navigation caching with antiforgery tokens",
    "url": "https://github.com/dotnet/aspnetcore/issues/54464",
    "createdAt": "2024-03-10T03:33:26Z",
    "lastUpdated": "2024-03-12T16:49:38Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nCurrently, using the [default antiforgery](https://github.com/dotnet/aspnetcore/blob/b3b8dffff4d092058b2d8942268b498cbfdb14ec/src/Antiforgery/src/Internal/DefaultAntiforgery.cs#L373) implementation (\u0060DefaultAntiforgery\u0060) the headers \u0060\u0022no-cache, no-store\u0022\u0060 are supplied.\r\n\r\nThe \u0060no-store\u0060 header has the unfortunate side effect of slowing browser navigation by incurring additional web requests to the server whenever the user navigates using the forward and backward buttons.\r\n\r\nFrom my (limited) understanding of antiforgery tokens, this should be entirely doable.\r\n\r\nThis results in a page diagnostics warning. The rest of the reasons for this error disappear without the debugger attached.\r\n\r\n![image](https://github.com/dotnet/aspnetcore/assets/19309165/ee4eccf8-7e4d-4171-8c91-7dfd65ad4b32)\r\n\r\nDisabling antiforgery site-wide is not simple nor does it appear to be officially supported.\n\n### Expected Behavior\n\nAntiforgery should use \u0060no-cache\u0060 instead of \u0060no-cache, no-store\u0060; or at least make this configurable so that backward-forward caching can be easily enabled.\n\n### Steps To Reproduce\n\n1. Create a blank project\r\n2. Disable dom preservation by replacing\r\n\r\n    \u0060\u0060\u0060html\r\n    \u003Cscript src=\u0022_framework/blazor.web.js\u0022\u003E\u003C/script\u003E\r\n    \u0060\u0060\u0060\r\n    \r\n    With\r\n    \r\n    \u0060\u0060\u0060html\r\n    \u003Cscript src=\u0022_framework/blazor.web.js\u0022 autostart=\u0022false\u0022\u003E\u003C/script\u003E\r\n    \u003Cscript\u003E\r\n        Blazor.start({\r\n            ssr: { disableDomPreservation: true }\r\n        });\r\n    \u003C/script\u003E\r\n    \u0060\u0060\u0060\r\n3. Add the time to the home page so we can see whether it\u0027s being cached\r\n4. Launch the application.\r\n5. Navigate from the home page to another page, and then navigate back to the home page using the back button.\r\n6. Observe that the time has been updated, and in the network tab observe that a web request has been made.\r\n\r\nYou can check out the project here.\\\r\nhttps://github.com/Fydar/AntiforgeryNoCacheIssue\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n8.0.200\n\n### Anything else?\n\nhttps://web.dev/articles/bfcache#minimize-no-store",
    "upvotes": 2,
    "labels": [
      "enhancement",
      "area-middleware",
      "help candidate",
      "feature-antiforgery"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde852s69W",
        "parentId": null,
        "author": "javiercn",
        "content": "@Fydar thanks for contacting us.\r\n\r\nI did a bunch of \u0022archeology\u0022 and it seems that this was done 8 years ago [here](https://github.com/dotnet/aspnetcore/commit/cd4afdc08384fe3fd255ae08fd4c62cdd7c3ee32).\r\n\r\nI\u0027m not 100% sure what the reasoning at the time was. Although I suspect it might have had to do with bugs being present in browsers at the time.\r\n\r\nI think it\u0027s reasonable for us to change this, but we\u0027ll have to do testing to ensure we don\u0027t introduce a regression on the behaviors this was aimed to address.\r\n\r\nI think this might have had to do with proxies also not following the headers correctly.\r\n\r\nNote for triage:\r\n* If we decide to make this change, we should have E2E tests for this area covering all major browsers to ensure we don\u0027t regress anything.\r\n* It\u0027s also likely that we want to rethink the value of the header, as we probably want to mark it as \u0060private\u0060 to avoid storage in shared caches.",
        "createdAt": "2024-03-12T11:58:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54464#issuecomment-1991487318"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86Ccch-",
    "title": "Unhandled exceptions are being logged before custom IExceptionHandler is being called",
    "url": "https://github.com/dotnet/aspnetcore/issues/54554",
    "createdAt": "2024-03-15T13:16:25Z",
    "lastUpdated": "2025-01-17T09:08:28Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nWhen using a custom \u0060IExceptionHandler\u0060 an unhandled exception is being logged (e.g. to console) before the custom exception handler is being called. The exception is being logged with the message:\r\n\r\n\u0060An unhandled exception has occurred while executing the request\u0060\r\n\r\nThis happens in \u0060ExceptionHandlerMiddlewareImpl.cs\u0060 in the method \u0060private async Task HandleException(HttpContext context, ExceptionDispatchInfo edi)\u0060: \u0060DiagnosticsTelemetry.ReportUnhandledException(_logger, context, edi.SourceException);\u0060\r\n\r\nAfter that the custom \u0060IExceptionHandler\u0060  is being called.\n\n### Expected Behavior\n\nIf there is a custom \u0060IExceptionHandler\u0060 registered, it is being called without logging anything before. In the \u0060IExceptionHandler\u0060 the developer can decide if and how to log the unhandled exception.\n\n### Steps To Reproduce\n\nMinimalistic project for reproduction: https://github.com/AlOnestone01/custom-exception-handling\r\n\r\n1. Implement custom \u0060IExceptionHandler\u0060\r\n2. Register the handler: \u0060builder.Services.AddExceptionHandler\u003CGlobalExceptionHandler\u003E();\u0060\r\n3. Register the middleware: app.UseExceptionHandler();\r\n4. Implement an endpoint that throws an exception\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n8.0.202\n\n### Anything else?\n\nSample output of the minimalistic project: \r\n[exception-log.txt](https://github.com/dotnet/aspnetcore/files/14615890/exception-log.txt)\r\n\r\ndotnet --info:\r\n.NET SDK:\r\n Version:           8.0.202\r\n Commit:            25674bb2f4\r\n Workload version:  8.0.200-manifests.8cf8de6d\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.19045\r\n OS Platform: Windows\r\n RID:         win-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\8.0.202\\\r\n\r\n.NET workloads installed:\r\nThere are no installed workloads to display.\r\n\r\nHost:\r\n  Version:      8.0.3\r\n  Architecture: x64\r\n  Commit:       9f4b1f5d66\r\n\r\n.NET SDKs installed:\r\n  8.0.202 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.App 6.0.28 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 7.0.17 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 8.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 6.0.28 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 7.0.17 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 8.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 6.0.28 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 7.0.17 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 8.0.3 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\nOther architectures found:\r\n  x86   [C:\\Program Files (x86)\\dotnet]\r\n    registered at [HKLM\\SOFTWARE\\dotnet\\Setup\\InstalledVersions\\x86\\InstallLocation]\r\n\r\nEnvironment variables:\r\n  Not set\r\n\r\nglobal.json file:\r\n  Not found",
    "upvotes": 12,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde856ASh4",
        "parentId": null,
        "author": "OskarKlintrot",
        "content": "This is a confusing behaviour giving the [example in the docs](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-8.0#iexceptionhandler). In that example implementation of \u0060IExceptionHandler\u0060 logs the exception, which in reality will result in logging the exception twice.",
        "createdAt": "2024-04-10T08:28:10Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54554#issuecomment-2046896248"
      },
      {
        "id": "IC_kwDOAQzde859I85s",
        "parentId": null,
        "author": "captainsafia",
        "content": "@AlOnestone01 Thanks for reporting this issue!\r\n\r\nThis change in behavior is a result of some work we did in .NET 8 to add support for metrics to ASP.NET Core. The docs that @OskarKlintrot references in his comments haven\u0027t been updated to reflect this change in behavior.\r\n\r\n@JamesNK Assuming this behavior change is intentional, did we author a breaking change notice here?",
        "createdAt": "2024-05-08T00:03:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54554#issuecomment-2099498604"
      },
      {
        "id": "IC_kwDOAQzde859RjIt",
        "parentId": null,
        "author": "JamesNK",
        "content": "Is this a change in behavior? I looked at the PR that added \u0060DiagnosticsTelemetry.ReportUnhandledException\u0060 method. The exception was already logged.\r\n\r\nhttps://github.com/dotnet/aspnetcore/pull/46834/files#diff-307cb43e0f10bb8837662fc645a7e0cacaefb6560bdba0cdc8e9648bed392fac\r\n\r\nThe only difference is \u0060error.type\u0060 tag is added to the http metric, but that\u0027s brand new.\r\n\r\n**Update:**\r\n\r\nOk, I looked into this more and \u0060IExceptionHandler\u0060 is new in .NET 8: https://github.com/dotnet/aspnetcore/pull/47923. I wasn\u0027t involved with it so it\u0027s new to me.\r\n\r\nI guess the request here is if an \u0060IExceptionHandler\u0060 returns true from \u0060TryHandleAsync\u0060 then the built-in middleware logging shouldn\u0027t happen. I think some people would want the built in exception, and some people would want to be able to turn it off, so a setting makes sense here. Should the default behavior change? \u0060IExceptionHandler\u0060 was only introduced in .NET 8 so this would be a break from just that version.\r\n\r\nI\u0027m going to move this into 9.0 milestone. I don\u0027t know if there is time, but we should consider addressing this.",
        "createdAt": "2024-05-09T01:18:21Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54554#issuecomment-2101752365"
      },
      {
        "id": "IC_kwDOAQzde86Dc8yx",
        "parentId": null,
        "author": "emyklebost",
        "content": "Just to add to this issue: [A Diagnostic Event will always be sent by the default ExceptionHandler](https://github.com/dotnet/aspnetcore/blob/091da452aab1838fd30f6de1decd921326736146/src/Middleware/Diagnostics/src/ExceptionHandler/ExceptionHandlerMiddlewareImpl.cs#L205-L213), regardless of if it is \u0022handled\u0022 by an \u0060IExceptionHandler\u0060 or not, this will result in the Exception showing up as an unhandled exception in e.g. Application Insights. Don\u0027t know if this is intended behavior or not, but something to address if the implementation is changed to not log when a \u0060IExceptionHandler\u0060 was able to handle it.",
        "createdAt": "2024-07-03T08:26:38Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54554#issuecomment-2205404337"
      },
      {
        "id": "IC_kwDOAQzde86JNxUF",
        "parentId": null,
        "author": "axylophon",
        "content": "I can confirm the problem. I disabled the Log for Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware to mitigate the log issue. The IExceptionHandler should control the logging.\r\n\r\n\r\nThe Application Insights topic is also an issue. Depending on the IExceptionHandler outcome the exception should be added to Application Insights instead for all possible exceptions.",
        "createdAt": "2024-08-21T13:39:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54554#issuecomment-2302088453"
      },
      {
        "id": "IC_kwDOAQzde86QFGro",
        "parentId": null,
        "author": "Sylvain2703",
        "content": "Hi!\nIs there any news regarding this issue? Can a fix (with or without a setting to control this behavior) be included in .NET 9?\n\nIn my opinion, this is a major problem for the adoption of \u0060IExceptionHandler\u0060 ([including the exception handler lambda](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/error-handling?view=aspnetcore-8.0#exception-handler-lambda)), because as its name suggests, it allows to handle exceptions!\nSo finding \u0060An unhandled exception has occurred while executing the request\u0060 in logs is clearly bad, especially when a custom \u0060IExceptionHandler\u0060 handles it by returning \u0060true\u0060 from the \u0060TryHandleAsync\u0060 method.\n\n[As mentioned](https://github.com/dotnet/aspnetcore/issues/54554#issuecomment-2101752365) by @JamesNK, changing this behavior in .NET 9 would be nice to only break with .NET 8.\n\u003E Should the default behavior change? \u0060IExceptionHandler\u0060 was only introduced in .NET 8 so this would be a break from just that version.\n\nAlso, disabling logs from \u0060Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware\u0060 is really a poor workaround since the same logger is also used to [report other errors](https://github.com/dotnet/aspnetcore/blob/c2a442982e736e17ae6bcadbfd8ccba278ee1be6/src/Middleware/Diagnostics/src/ExceptionHandler/ExceptionHandlerMiddlewareImpl.cs#L224C14-L224C48).",
        "createdAt": "2024-10-16T15:58:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54554#issuecomment-2417257192"
      },
      {
        "id": "IC_kwDOAQzde86QIHDg",
        "parentId": null,
        "author": "JamesNK",
        "content": "It\u2019s too late to do it in 9.\n\nWe can look at changing it in 10.",
        "createdAt": "2024-10-16T22:02:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54554#issuecomment-2418045152"
      },
      {
        "id": "IC_kwDOAQzde86QMkAe",
        "parentId": null,
        "author": "andy1547",
        "content": "Note if using Serilog rather than Microsoft logger, the configuration for disabling is:\n  \n\u0060\u0060\u0060\n\u0022Serilog\u0022: {\n    \u0022MinimumLevel\u0022: {\n      \u0022Override\u0022: {\n        // disable default exception logging\n        \u0022Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddleware\u0022: \u0022Fatal\u0022,\n      }\n    }\n\u0060\u0060\u0060\nIn our case, we wanted to treat some thrown exceptions as client errors and others as server errors, returning 400-499 / 500-599 status codes respectively. Disabling the in-built logging to only log server errors inside of IExceptionHandler was necessary to avoid spamming the logs.\n\nOne could take the stance that all exceptions should be logged and instead an IActionResult should be explicitly returned for client errors. Our stack made use of various service layers (that have no knowledge of ASP.NET Core) that throw validation errors (that should be treated as client errors). Duplicating this validation logic or adding a try/catch around each of these calls was infeasible. \nThe other approach was introducing an IExceptionFilter (ran for just MVC pipeline) for handling client thrown exceptions, returning an IActionResult. However, we decided against this approach as using both IExceptionFilter and a IExceptionHandler together added complexity (we prefer to have all exception handling done in a single place).\n\nFunnily we actually had the reverse issue of not logging explicitly returned ObjectResult 500-599 status codes. The workaround was adding logging in an IAlwaysRunResultFilter.\n",
        "createdAt": "2024-10-17T10:59:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54554#issuecomment-2419212318"
      },
      {
        "id": "IC_kwDOAQzde86a1S1M",
        "parentId": null,
        "author": "SamJ26",
        "content": "When can we expect this update to be released?",
        "createdAt": "2025-01-17T08:11:44Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54554#issuecomment-2597662028"
      },
      {
        "id": "IC_kwDOAQzde86a1q2n",
        "parentId": null,
        "author": "martincostello",
        "content": "If it lands in .NET 10, then November.",
        "createdAt": "2025-01-17T09:08:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54554#issuecomment-2597760423"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86DQxQz",
    "title": "OutputCache: allow returning cached responses as fully fresh (Date: now, Age: 0)",
    "url": "https://github.com/dotnet/aspnetcore/issues/54687",
    "createdAt": "2024-03-22T10:44:33Z",
    "lastUpdated": "2024-03-25T10:01:26Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Is your feature request related to a problem? Please describe the problem.\r\n\r\nI am trying to combine OutputCache with the Cache-Control response header.\r\nThe idea is that this allows for 3 layers of caching:\r\n1. The OutputCache\r\n2. Infrastructure cache. In my case caching on Azure FrontDoor POPs.\r\n3. Browser cache.\r\n\r\nThis concept can be nicely implemented by writing a custom \u0060IOutputCachePolicy\u0060. The OutputCache is really nice and allows to control exactly the right things.\r\nExcept two response headers:\r\n1. \u0060Age\u0060 https://github.com/dotnet/aspnetcore/blob/ec293ee75c0c022370951a459b188fa81ec8b7c3/src/Middleware/OutputCaching/src/OutputCacheMiddleware.cs#L307\r\n2. \u0060Date\u0060 https://github.com/dotnet/aspnetcore/blob/ec293ee75c0c022370951a459b188fa81ec8b7c3/src/Middleware/OutputCaching/src/OutputCacheMiddleware.cs#L400\r\n\r\nThese headers are set _after_ all hooks of the Policies are invoked. Therefore one cannot control them in the custom policy.\r\n\r\nWhy does this matter?\r\nWith this approach we are telling the world (proxies such as CDNs and browsers) that the cached responses we are serving have a certain age that needs to be considered. However, if we know that we purge the OutputCache whenever there is new content, we can consider the Age to be 0.\r\n\r\n### Describe the solution you\u0027d like\r\n\r\nI would like to be able to return cached responses with:\r\n- \u0060Date\u0060: Now datetime\r\n- \u0060Age\u0060: \u00600\u0060 (or maybe omitted?)\r\n\r\nBecause I know I will purge all relevant content from the OutputCache using \u0060IOutputCacheStore.EvictByTagAsync(tagName)\u0060 calls, cached OutputCache responses are \u0027as fresh\u0027 as non-cached responses.\r\n\r\nI can then properly use \u0060Cache-Control: max-age\u0060 and \u0060Cache-Control: s-max-age\u0060 to instruct the CDN /  browser when to check whether there is new content. These can then use a rather small age, because the average request will result in a cached OutputCache response.\r\n\r\n### Additional context\r\n\r\nThe implementation of my custom \u0060IOutputCachePolicy\u0060.\r\n\r\n\u0060\u0060\u0060c#\r\npublic record CacheOptions\r\n{\r\n    public required TimeSpan? OutputCacheDuration { get; init; }\r\n    public required CacheControlHeaderValue HttpCacheControlHeader { get; init; }\r\n}\r\n\r\npublic class OutputCacheWithHttpResponseCacheControlHeaderPolicy(CacheOptions options)\r\n    : IOutputCachePolicy\r\n{\r\n    ValueTask IOutputCachePolicy.CacheRequestAsync(\r\n        OutputCacheContext context,\r\n        CancellationToken cancellationToken)\r\n    {\r\n        SetOutputCacheConfiguration(context);\r\n        SetCacheControlResponseHeader(context);\r\n\r\n        return ValueTask.CompletedTask;\r\n    }\r\n\r\n    ValueTask IOutputCachePolicy.ServeFromCacheAsync\r\n        (OutputCacheContext context, CancellationToken cancellationToken)\r\n    {\r\n        return ValueTask.CompletedTask;\r\n    }\r\n\r\n    ValueTask IOutputCachePolicy.ServeResponseAsync\r\n        (OutputCacheContext context, CancellationToken cancellationToken)\r\n    {\r\n        context.AllowCacheStorage = context.HttpContext.Response.IsValidForCaching();\r\n\r\n        return ValueTask.CompletedTask;\r\n    }\r\n\r\n    private void SetOutputCacheConfiguration(OutputCacheContext context)\r\n    {\r\n        var requestValidForOutputCaching =\r\n            options.OutputCacheDuration != null \u0026\u0026\r\n            context.HttpContext.Request.IsValidForCaching();\r\n\r\n        context.EnableOutputCaching = true;\r\n        context.AllowLocking = true;\r\n        context.AllowCacheLookup = requestValidForOutputCaching;\r\n        context.AllowCacheStorage = requestValidForOutputCaching;\r\n        context.ResponseExpirationTimeSpan = options.OutputCacheDuration;\r\n\r\n        context.CacheVaryByRules.QueryKeys = \u0022*\u0022;\r\n        context.CacheVaryByRules.VaryByHost = true;\r\n    }\r\n\r\n    private void SetCacheControlResponseHeader(OutputCacheContext context)\r\n    {\r\n        context.HttpContext.Response.Headers.CacheControl = context.HttpContext.Request.IsValidForCaching()\r\n            ? options.HttpCacheControlHeader.ToString()\r\n            : \u0022no-store,no-cache\u0022;\r\n    }\r\n}\r\n\r\npublic static class OutputCacheExtensions\r\n{\r\n    public static bool IsValidForCaching(this HttpRequest request)\r\n    {\r\n        return\r\n            request.MethodValidForOutputCaching() \u0026\u0026\r\n            !request.IsAuthenticated() \u0026\u0026\r\n            !request.IsCachingDisabledByQuery();\r\n    }\r\n\r\n    public static bool IsValidForCaching(this HttpResponse response)\r\n    {\r\n        return\r\n            !response.HasSetCookieHeader() \u0026\u0026\r\n            response.StatusCodeValidForOutputCaching();\r\n    }\r\n\r\n    private static bool MethodValidForOutputCaching(this HttpRequest request)\r\n    {\r\n        return HttpMethods.IsGet(request.Method) || HttpMethods.IsHead(request.Method);\r\n    }\r\n\r\n    private static bool IsAuthenticated(this HttpRequest request)\r\n    {\r\n        return\r\n            !StringValues.IsNullOrEmpty(request.Headers.Authorization) ||\r\n            request.HttpContext.User.Identity?.IsAuthenticated == true;\r\n    }\r\n\r\n    private static bool IsCachingDisabledByQuery(this HttpRequest request)\r\n    {\r\n        return request.Query[\u0022noCache\u0022] == \u0022true\u0022;\r\n    }\r\n\r\n    private static bool HasSetCookieHeader(this HttpResponse response)\r\n    {\r\n        return !StringValues.IsNullOrEmpty(response.Headers.SetCookie);\r\n    }\r\n\r\n    private static bool StatusCodeValidForOutputCaching(this HttpResponse response)\r\n    {\r\n        return response.StatusCode is\r\n            StatusCodes.Status200OK or\r\n            StatusCodes.Status301MovedPermanently;\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nUsage:\r\n\u0060\u0060\u0060c#\r\npublic static class CachePolicies\r\n{\r\n    public const string ApplicationLongCdnShortBrowserNone = \u0022ApplicationLongCdnShortBrowserNone\u0022;\r\n    public const string ApplicationShortCdnShortBrowserShort = \u0022ApplicationShortCdnShortBrowserShort\u0022;\r\n    public const string None = \u0022None\u0022;\r\n\r\n    public static void AddNamedCustomCachePolicies(this OutputCacheOptions options)\r\n    {\r\n        options.AddPolicy(ApplicationLongCdnShortBrowserNone, new OutputCacheWithHttpResponseCacheControlHeaderPolicy(\r\n            new CacheOptions\r\n            {\r\n                OutputCacheDuration = TimeSpan.FromHours(1),\r\n                HttpCacheControlHeader = new CacheControlHeaderValue\r\n                {\r\n                    Public = true,\r\n                    SharedMaxAge = TimeSpan.FromMinutes(5)\r\n                }\r\n            }));\r\n\r\n        options.AddPolicy(ApplicationShortCdnShortBrowserShort, new OutputCacheWithHttpResponseCacheControlHeaderPolicy(\r\n            new CacheOptions\r\n            {\r\n                OutputCacheDuration = TimeSpan.FromMinutes(5),\r\n                HttpCacheControlHeader = new CacheControlHeaderValue\r\n                {\r\n                    Public = true,\r\n                    MaxAge = TimeSpan.FromMinutes(5)\r\n                }\r\n            }));\r\n\r\n        options.AddPolicy(None, new OutputCacheWithHttpResponseCacheControlHeaderPolicy(\r\n            new CacheOptions\r\n            {\r\n                OutputCacheDuration = null,\r\n                HttpCacheControlHeader = new CacheControlHeaderValue\r\n                {\r\n                    NoStore = true,\r\n                    NoCache = true\r\n                }\r\n            }));\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nAnd on the controller / action:\r\n\u0060\u0060\u0060c#\r\n[OutputCache(PolicyName = CachePolicies.ApplicationLongCdnShortBrowserNone)]\r\n\u0060\u0060\u0060",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde854GBSi",
        "parentId": null,
        "author": "marklagendijk",
        "content": "To be sure the issue is clear I will add an example:\r\n- The OutputCache duration is 1 hour\r\n- The Cache-Control \u0060s-maxage\u0060 is 5 minutes\r\n\r\n1. 00:00 Request 1, OutputCache caches the Response. The CDN also caches the response.\r\n2. 00:10 Request 2: CDN sees that the cached response has expired and fires a new request. OutputCache returns the cached with \u0060Age: 600\u0060, \u0060Cache-Control: public, s-maxage=300\u0060. If the CDN follows the spec it should not cache this response, because it is \u0027stale\u0027: age \u003E s-maxage.",
        "createdAt": "2024-03-22T11:00:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54687#issuecomment-2014844066"
      },
      {
        "id": "IC_kwDOAQzde854QpLj",
        "parentId": null,
        "author": "marklagendijk",
        "content": "Possible solutions would be:\r\n1. A configuration option \u0060ReturnCachedResponsesAsFresh\u0060.\r\n2. Adjustments in code order so that the custom hooks can override the standard behavior, and the custom policy has full control.\r\n3. Both.",
        "createdAt": "2024-03-25T10:01:25Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/54687#issuecomment-2017628899"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86D640q",
    "title": "Brotli compressor not working when compressing small text output",
    "url": "https://github.com/dotnet/aspnetcore/issues/54827",
    "createdAt": "2024-03-28T08:52:19Z",
    "lastUpdated": "2024-04-02T07:21:48Z",
    "body": "### Description\r\n\r\nIn a Microsoft.NET.Sdk.Web project, having one controller having one view with little text, there is NO output when navigating with a browser (Chrome or Firefox), to an url which is served by this controller.  (Using .NET 8.0.3)\r\n\r\n### Reproduction Steps\r\n\r\nProgram.cs\r\n\u0060\u0060\u0060c#\r\nvar builder = WebApplication.CreateBuilder();\r\n\r\nbuilder.Services.AddRazorPages();\r\nbuilder.Services.AddResponseCompression();\r\n\r\nvar app = builder.Build();\r\n\r\napp.MapControllers();\r\napp.UseResponseCompression();\r\napp.Run();\r\n\u0060\u0060\u0060\r\n/Index.cshtml.cs (controller)\r\n\u0060\u0060\u0060C#\r\nusing Microsoft.AspNetCore.Mvc;\r\nnamespace AspNetCoreNotEmpty1;\r\npublic class PopController : Controller\r\n{\r\n\t[HttpGet(\u0022~/\u0022)]\r\n\tpublic IActionResult Index()\r\n\t{\r\n\t\treturn View(\u0022/Index.cshtml\u0022);\r\n\t}\r\n}\r\n\u0060\u0060\u0060\r\n/Index.cshtml\r\n\r\n\u0060\u0060\u0060html\r\n\u003Chtml\u003E\r\n\u003Cbody\u003E\r\n\t\u003Cp\u003EIndex Test 123\u003C/p\u003E\r\n\u003C/body\u003E\r\n\u003C/html\u003E\r\n\u0060\u0060\u0060\r\n[SolutionBugDemo.zip](https://github.com/dotnet/runtime/files/14786334/SolutionBugDemo.zip)\r\n\r\n\r\n### Expected behavior\r\n\r\nWhen starting (debugging) the project, here should be the text \u0027Index Test 123\u0027 on a browser.\r\n\r\n\r\n\r\n\r\n### Actual behavior\r\n\r\nStarting the project, browser is navigating to its debug localhost url.\r\nWhen doing a reload of the localhost url, **nothing appears**. \r\nChrome debug console shows \u0027Failed\u0027 request, however, headers seems to be normal.\r\nFireFox shows \u0027Content encoding error\u0027.\r\n\r\n\r\n\r\n### Regression?\r\n\r\n_No response_\r\n\r\n### Known Workarounds\r\n\r\nChanging text from \u0027Index Test 123\u0027 to \u0027Index Test 1234\u0027 \r\nSimply adding more text. there is output, as expected.\r\n\r\nIt seems that when using small text messages, the Brotli compressor, or the framework calling the compressor does not function correctly. However the headers (Chrome) are intact.\r\n\r\n![Knipsel](https://github.com/dotnet/runtime/assets/2096186/fbf1189b-2040-4175-a797-51e670572973)\r\n\r\n\r\n### Configuration\r\n\r\n_No response_\r\n\r\n### Other information\r\n\r\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86HZ4-8",
    "title": "Request Timeouts dynamically calculated",
    "url": "https://github.com/dotnet/aspnetcore/issues/55437",
    "createdAt": "2024-04-30T14:52:30Z",
    "lastUpdated": "2024-05-15T23:01:18Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nI am trying to set the timeout of my request dynamically, but it seems it must be a constant value. \n\n### Describe the solution you\u0027d like\n\nI would suggest that \u0060UseRequestTimeouts\u0060 have a callback option with the request context to be evaluated and set the timeout value inside of this callback.\n\n### Additional context\n\nI am using .net in Lambda, and I could use \u0060ILambdaContext.RemainingTime - buffer\u0060 to determine when the timeout should happen, but I don\u0027t see how to do so with the current implementation.",
    "upvotes": 2,
    "labels": [
      "api-suggestion",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde858T4RN",
        "parentId": null,
        "author": "martincostello",
        "content": "Taking a quick look at the code, it doesn\u0027t look like it\u0027s possible to dynamically determine the timeout.\r\n\r\nMaybe you could manually do something like the internals do by manually implementing and setting a \u0060IHttpRequestTimeoutFeature\u0060 in a middleware like how the timeout middleware does itself?\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/207bc7d00c00bf454dc83789d6824609b1d8b02a/src/Http/Http/src/Timeouts/RequestTimeoutsMiddleware.cs#L96-L108\r\n",
        "createdAt": "2024-04-30T15:05:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/55437#issuecomment-2085585997"
      },
      {
        "id": "IC_kwDOAQzde858UsVH",
        "parentId": null,
        "author": "bradlis7",
        "content": "\u003E Maybe you could manually do something like the internals do by manually implementing and setting a \u0060IHttpRequestTimeoutFeature\u0060 in a middleware like how the timeout middleware does itself?\r\n\r\nThat\u0027s a good workaround, I\u0027ll do that for now.",
        "createdAt": "2024-04-30T16:07:09Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/55437#issuecomment-2085799239"
      },
      {
        "id": "IC_kwDOAQzde858a1sN",
        "parentId": null,
        "author": "bradlis7",
        "content": "So many internal classes... in order to create a workaround, I have to copy a bunch of classes in. I guess I\u0027ll just use static timeouts for now.",
        "createdAt": "2024-04-30T21:34:57Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/55437#issuecomment-2087410445"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86ILDCZ",
    "title": "New Project Microsoft.Extensions.Caching.Garnet",
    "url": "https://github.com/dotnet/aspnetcore/issues/55593",
    "createdAt": "2024-05-08T03:24:38Z",
    "lastUpdated": "2024-05-08T08:09:24Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nGarnet Better compatibility.\n\n### Describe the solution you\u0027d like\n\n If I use Garnet, I prefer to use \u2018Microsoft.Extensions.Caching.Garnet\u0027 Instead of \u0027Microsoft.Extensions.Caching.StackExchangeRedis\u0027.\n\n### Additional context\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "feature-caching",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86IdVJB",
    "title": "Quarantine Locking_ExecuteAllRequestsWhenDisabled",
    "url": "https://github.com/dotnet/aspnetcore/issues/55652",
    "createdAt": "2024-05-10T09:46:09Z",
    "lastUpdated": "2024-08-21T22:40:33Z",
    "body": "\u003C!--\r\nNote this issue template is specifically for failing tests within the dotnet/aspnetcore repo.\r\n--\u003E\r\n\r\n## Failing Test(s)\r\n\r\n\u003C!--\r\nProvide the fully qualified name(s) of the failing tests.\r\n--\u003E\r\n\r\n- Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\r\n\r\n## Error Message\r\n\r\n\u003C!--\r\nProvide the error message associated with the test failure, if applicable.\r\n--\u003E\r\n\r\nIt times out after 15 minutes, then we see:\r\n\r\n\u0060\u0060\u0060text\r\n2024-05-10T01:10:46.7365460Z The active Test Run was aborted because the host process exited unexpectedly. Please inspect the call stack above, if available, to get more information about where the exception originated from.\r\n2024-05-10T01:10:46.7366106Z The test running when the crash occurred: \r\n2024-05-10T01:10:46.7366181Z Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\r\n\u0060\u0060\u0060\r\n\r\n## Stacktrace\r\n\r\nN/A\r\n\r\n## Logs\r\n\r\n\u003Cdetails\u003E\r\n\u003C!--\r\nIf this is a Helix test failure, include the text of the .log artifact from the failing test.\r\nNote that you have to be signed in to Azure DevOps to see the test artifacts.\r\n--\u003E\r\n\r\n\u0060\u0060\u0060text\r\n2024-05-10T00:56:48.6855694Z [xUnit.net 00:01:06.65] Microsoft.AspNetCore.OutputCaching.Tests: [Long Running Test] \u0027Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\u0027, Elapsed: 00:01:03\r\n2024-05-10T00:57:48.6876886Z [xUnit.net 00:02:06.66] Microsoft.AspNetCore.OutputCaching.Tests: [Long Running Test] \u0027Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\u0027, Elapsed: 00:02:03\r\n2024-05-10T00:58:48.6970931Z [xUnit.net 00:03:06.66] Microsoft.AspNetCore.OutputCaching.Tests: [Long Running Test] \u0027Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\u0027, Elapsed: 00:03:03\r\n2024-05-10T00:59:48.6925528Z [xUnit.net 00:04:06.66] Microsoft.AspNetCore.OutputCaching.Tests: [Long Running Test] \u0027Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\u0027, Elapsed: 00:04:03\r\n2024-05-10T01:00:48.6938560Z [xUnit.net 00:05:06.66] Microsoft.AspNetCore.OutputCaching.Tests: [Long Running Test] \u0027Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\u0027, Elapsed: 00:05:03\r\n2024-05-10T01:01:48.6963906Z [xUnit.net 00:06:06.66] Microsoft.AspNetCore.OutputCaching.Tests: [Long Running Test] \u0027Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\u0027, Elapsed: 00:06:03\r\n2024-05-10T01:02:48.6981432Z [xUnit.net 00:07:06.67] Microsoft.AspNetCore.OutputCaching.Tests: [Long Running Test] \u0027Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\u0027, Elapsed: 00:07:03\r\n2024-05-10T01:03:48.7020073Z [xUnit.net 00:08:06.67] Microsoft.AspNetCore.OutputCaching.Tests: [Long Running Test] \u0027Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\u0027, Elapsed: 00:08:03\r\n2024-05-10T01:04:48.7030050Z [xUnit.net 00:09:06.67] Microsoft.AspNetCore.OutputCaching.Tests: [Long Running Test] \u0027Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\u0027, Elapsed: 00:09:03\r\n2024-05-10T01:05:48.7079207Z [xUnit.net 00:10:06.67] Microsoft.AspNetCore.OutputCaching.Tests: [Long Running Test] \u0027Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\u0027, Elapsed: 00:10:03\r\n2024-05-10T01:06:48.7113056Z [xUnit.net 00:11:06.67] Microsoft.AspNetCore.OutputCaching.Tests: [Long Running Test] \u0027Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\u0027, Elapsed: 00:11:03\r\n2024-05-10T01:07:48.7109936Z [xUnit.net 00:12:06.67] Microsoft.AspNetCore.OutputCaching.Tests: [Long Running Test] \u0027Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\u0027, Elapsed: 00:12:03\r\n2024-05-10T01:08:48.7072597Z [xUnit.net 00:13:06.68] Microsoft.AspNetCore.OutputCaching.Tests: [Long Running Test] \u0027Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\u0027, Elapsed: 00:13:03\r\n2024-05-10T01:09:48.7172041Z [xUnit.net 00:14:06.68] Microsoft.AspNetCore.OutputCaching.Tests: [Long Running Test] \u0027Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\u0027, Elapsed: 00:14:03\r\n2024-05-10T01:10:45.3570443Z Blame: Dumping 196 - dotnet\r\n2024-05-10T01:10:45.3699749Z [createdump] Gathering state for process 196 dotnet\r\n2024-05-10T01:10:45.9817989Z [createdump] Writing full dump to file /home/helixbot/dotnetbuild/dumps/dotnet_196_20240510T011045_hangdump.dmp\r\n2024-05-10T01:10:46.6157294Z [createdump] Written 509468672 bytes (124382 pages) to core file\r\n2024-05-10T01:10:46.6160449Z [createdump] Target process is alive\r\n2024-05-10T01:10:46.6161283Z [createdump] Dump successfully written in 1247ms\r\n2024-05-10T01:10:46.6625734Z The active test run was aborted. Reason: Test host process crashed\r\n2024-05-10T01:10:46.6725270Z Data collector \u0027Blame\u0027 message: VSTEST_DUMP_PATH is specified. Dump files will be saved in: /home/helixbot/dotnetbuild/dumps, and won\u0027t be added to attachments..\r\n2024-05-10T01:10:46.6739678Z Data collector \u0027Blame\u0027 message: The specified inactivity time of 15 minutes has elapsed. Collecting hang dumps from testhost and its child processes.\r\n2024-05-10T01:10:46.6751225Z Data collector \u0027Blame\u0027 message: VSTEST_DUMP_PATH is specified. Dump files will be saved in: /home/helixbot/dotnetbuild/dumps, and won\u0027t be added to attachments..\r\n2024-05-10T01:10:46.7277079Z Results File: /root/helix/work/workitem/e/TestResults/TestResults.xml\r\n2024-05-10T01:10:46.7280804Z \r\n2024-05-10T01:10:46.7320334Z Test Run Aborted.\r\n2024-05-10T01:10:46.7321842Z Total tests: Unknown\r\n2024-05-10T01:10:46.7323443Z      Passed: 306\r\n2024-05-10T01:10:46.7330811Z  Total time: 15.0893 Minutes\r\n2024-05-10T01:10:46.7332307Z \r\n2024-05-10T01:10:46.7365460Z The active Test Run was aborted because the host process exited unexpectedly. Please inspect the call stack above, if available, to get more information about where the exception originated from.\r\n2024-05-10T01:10:46.7366106Z The test running when the crash occurred: \r\n2024-05-10T01:10:46.7366181Z Microsoft.AspNetCore.OutputCaching.Tests.OutputCacheMiddlewareTests_BufferStore.Locking_ExecuteAllRequestsWhenDisabled\r\n2024-05-10T01:10:46.7366205Z \r\n2024-05-10T01:10:46.7366230Z This test may, or may not be the source of the crash.\r\n\u0060\u0060\u0060\r\n\u003C/details\u003E\r\n\r\n## Build\r\n\r\nhttps://dev.azure.com/dnceng-public/public/_build/results?buildId=671084\u0026view=logs\u0026j=8c9dd6ae-5017-5a70-997c-c2386fed4e85\u0026t=e6acbd31-8469-5d42-602d-cb75e71f3b60",
    "upvotes": 0,
    "labels": [
      "test-failure",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86JfVZJ",
    "title": "Expose \u0060OutputCachePolicyBuilder.AddPolicy(IOutputCachePolicy)\u0060 as \u0060public\u0060",
    "url": "https://github.com/dotnet/aspnetcore/issues/55809",
    "createdAt": "2024-05-20T20:02:27Z",
    "lastUpdated": "2024-05-21T10:30:26Z",
    "body": "## Background and Motivation\r\n\r\nI want to create a parameterized custom policy to dynamically generate tags based on route values so that I can evict only a subset of the cached contents later on on one of my APIs.\r\n\r\nTo allow me to tag cache entries based on route values, I need to pass the name of the route parameter to my custom policy, as well as the tag prefix to use. Both values are primitive \u0060string\u0060s.\r\n\r\nHowever, due to the way \u0060OutputCachePolicyBuilder\u0060 works today, it only allows one to pass a custom policy object by specifying a \u0060Type\u0060:\r\n\u0060\u0060\u0060csharp\r\npublic OutputCachePolicyBuilder AddPolicy(Type)\r\n\u0060\u0060\u0060\r\n\r\nOr by specifing the type via generics and letting the container resolve the policy automatically:\r\n\u0060\u0060\u0060csharp\r\npublic OutputCachePolicyBuilder AddPolicy\u003CT\u003E()\r\n    where T : IOutputCachePolicy\r\n\u0060\u0060\u0060\r\n\r\nThis makes it extremely convoluted to pass a parameterized policy like this:\r\n\u0060\u0060\u0060csharp\r\npublic sealed class TagPerRouteOutputCachePolicy : IOutputCachePolicy\r\n{\r\n    private readonly string tagPrefix;\r\n    private readonly string routeValueName;\r\n\r\n    public TagPerRouteOutputCachePolicy(string tagPrefix, string routeValueName)\r\n    {\r\n        ArgumentNullException.ThrowIfNull(tagPrefix);\r\n        ArgumentNullException.ThrowIfNull(routeValueName);\r\n\r\n        this.tagPrefix = tagPrefix;\r\n        this.routeValueName = routeValueName;\r\n    }\r\n\r\n    ...\r\n\u0060\u0060\u0060\r\n\r\nThe only way I see to allow for my use case would be to somehow pre-register the type in the container with a lambda factory and hardcoded values, but that\u0027s not possible since the values I\u0027m passing are coming from the policy setup logic which happens in a different place.\r\n\r\nI\u0027m now forced to completely change the design of my object to use some sort of fake mutable container object so I can pass in values from the outside using the container in a convoluted manner.\r\n\r\nI\u0027d rather simply pass the instance directly using the currently \u0060internal\u0060 overload:\r\n\u0060\u0060\u0060csharp\r\ninternal OutputCachePolicyBuilder AddPolicy(IOutputCachePolicy)\r\n\u0060\u0060\u0060\r\n\r\n\u003C!--\r\nWe welcome API proposals! We have a process to evaluate the value and shape of new API. There is an overview of our process [here](https://github.com/dotnet/aspnetcore/blob/main/docs/APIReviewProcess.md). This template will help us gather the information we need to start the review process.\r\nFirst, please describe the purpose and value of the new API here.\r\n--\u003E\r\n\r\n## Proposed API\r\n\r\n\u003C!--\r\nPlease provide the specific public API signature diff that you are proposing. For example:\r\n\u0060\u0060\u0060diff\r\npublic sealed class OutputCachePolicyBuilder\r\n{\r\n-    internal OutputCachePolicyBuilder AddPolicy(IOutputCachePolicy)\r\n\u002B    public OutputCachePolicyBuilder AddPolicy(IOutputCachePolicy)\r\n}\r\n\u0060\u0060\u0060\r\nYou may find the [Framework Design Guidelines](https://github.com/dotnet/runtime/blob/master/docs/coding-guidelines/framework-design-guidelines-digest.md) helpful.\r\n--\u003E\r\n\r\n\u0060\u0060\u0060diff\r\npublic sealed class OutputCachePolicyBuilder\r\n{\r\n-    internal OutputCachePolicyBuilder AddPolicy(IOutputCachePolicy)\r\n\u002B    public OutputCachePolicyBuilder AddPolicy(IOutputCachePolicy)\r\n}\r\n\u0060\u0060\u0060\r\n\r\n## Usage Examples\r\n\r\n\u0060\u0060\u0060csharp\r\npublic static class OutputCachePolicyBuilderExtensions\r\n{\r\n    public static OutputCachePolicyBuilder TagByRouteValue(\r\n        this OutputCachePolicyBuilder builder,\r\n        string tagPrefix,\r\n        string routeValueName)\r\n    {\r\n        ArgumentNullException.ThrowIfNull(builder);\r\n        ArgumentNullException.ThrowIfNull(tagPrefix);\r\n        ArgumentNullException.ThrowIfNull(routeValueName);\r\n\r\n        return builder.AddPolicy(new TagPerRouteOutputCachePolicy(tagPrefix, routeValueName));\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThis API is also used extensively for all existing extensions and policy operations as the way policy builder works relies on composing several smaller implementations of \u0060IOutputCachePolicy\u0060.\r\n\r\n## Alternative Designs\r\n\r\n\u003C!--\r\nWere there other options you considered, such as alternative API shapes?\r\nHow does this compare to analogous APIs in other ecosystems and libraries?\r\n--\u003E\r\n\r\nI don\u0027t see any alternative design that allows me to add a parameterized policy from the builder perspective. I\u0027d have to forcefully introduce hard-to-use mutable fake \u0022parameter container\u0022 objects in DI, then pass those in as my parameters in the policy. Then, before I call \u0060AddPolicy\u003CMyPolicy\u003E()\u0060, I\u0027d have to resolve those fake container objects and set the values in them so that I can later fetch the values from the DI-injected instance.\r\n\r\nSomething like this which is absolutely terrible design:\r\n\u0060\u0060\u0060csharp\r\npublic interface IParameterPosition;\r\n\r\npublic sealed class FirstParameterPosition : IParameterPosition;\r\npublic sealed class SecondParameterPosition : IParameterPosition;\r\n\r\npublic sealed class TagPerRouteOutputCachePolicy : IOutputCachePolicy\r\n{\r\n    private readonly string tagPrefix;\r\n    private readonly string routeValueName;\r\n\r\n    public TagPerRouteOutputCachePolicy(\r\n        ParameterContainer\u003CTagPerRouteOutputCachePolicy, string, FirstParameterPosition\u003E tagPrefix,\r\n        ParameterContainer\u003CTagPerRouteOutputCachePolicy, string, SecondParameterPosition\u003ErouteValueName)\r\n    {\r\n        this.tagPrefix = tagPrefix.Value;\r\n        this.routeValueName = routeValueName.Value;\r\n    }\r\n\u0060\u0060\u0060\r\n\r\nAnd even then, this would only work if I have a single instance of this class. It is completely unmanageable.\r\n\r\n## Risks\r\n\r\n\u003C!--\r\nPlease mention any risks that to your knowledge the API proposal might entail, such as breaking changes, performance regressions, etc.\r\n--\u003E\r\n\r\nI see zero risk in exposing the widely used \u0060internal\u0060 method as it relies on public-facing interfaces already.",
    "upvotes": 0,
    "labels": [
      "api-suggestion",
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86KJMHb",
    "title": "Backport #52687 to .NET8",
    "url": "https://github.com/dotnet/aspnetcore/issues/55892",
    "createdAt": "2024-05-26T11:50:27Z",
    "lastUpdated": "2024-05-26T19:27:19Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nHi,\r\n\r\nPlease backport fix #52687 to .NET 8.\r\n\r\nSome MudBlazor customers report (https://github.com/MudBlazor/MudBlazor/issues/7879) that they get exceptions when using:\r\n\u0060\u0060\u0060C#\r\napp.UseExceptionHandler(\u0022/Error\u0022, createScopeForErrors: true);\r\n\u0060\u0060\u0060\r\nor when they use Azure (https://github.com/MudBlazor/MudBlazor/discussions/8850).\r\n\r\nThe main problem is that our services added to the DI are implementing only \u0060IAsyncDisposable\u0060. We find this justified as we need to use some async code during disposal, and you can\u0027t use \u0060GetAwaiter().GetResult()\u0060 in Blazor WASM. We also don\u0027t think that fire-and-forget is a good practice either.\r\n\r\nI find that it\u0027s a bug in .NET 8 that it\u0027s calling \u0060CreateScope\u0060 instead of \u0060CreateAsyncScope\u0060. Since it was fixed for .NET 9, it should be ported to .NET 8 as it\u0027s still supported. I don\u0027t see any breaking change risks here nor it doesn\u0027t require any new API.\r\n\r\nThank you.\r\n\r\n### Expected Behavior\r\n\r\nNot to throw exception.\r\n\r\n### Steps To Reproduce\r\n\r\n_No response_\r\n\r\n### Exceptions (if any)\r\n\r\n\u0060\u0060\u0060\r\nSystem.InvalidOperationException: \u0027MudBlazor.BrowserViewportService\u0027 type only implements IAsyncDisposable. Use DisposeAsync to dispose the container.\r\nat Microsoft.Extensions.DependencyInjection.ServiceLookup.ServiceProviderEngineScope.Dispose()\r\nat Microsoft.AspNetCore.Diagnostics.ExceptionHandlerMiddlewareImpl.HandleException(HttpContext context, ExceptionDispatchInfo edi)\r\n\u0060\u0060\u0060\r\n\r\n### .NET Version\r\n\r\n_No response_\r\n\r\n### Anything else?\r\n\r\n_No response_",
    "upvotes": 1,
    "labels": [
      "feature-diagnostics",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86KsX1b",
    "title": "ArgumentException while OutputCache is cached",
    "url": "https://github.com/dotnet/aspnetcore/issues/55988",
    "createdAt": "2024-05-31T03:23:41Z",
    "lastUpdated": "2024-05-31T07:47:08Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nHi,\r\n\r\nI got error message in log while i swear my endpoint output is cached\r\nAny how I can find what the cause of this exception?\r\n\r\nMoved from https://github.com/StackExchange/StackExchange.Redis/issues/2732\n\n### Expected Behavior\n\n- No exception at all\r\n- A way to debug the exception? log the key for example\r\n- Or simply warn, this key is null instead of throwing exception\n\n### Steps To Reproduce\n\n- The code is nothing fancy\r\nIt is based on example https://learn.microsoft.com/en-us/aspnet/core/performance/caching/output?view=aspnetcore-8.0\r\n- New custom policy\r\n- VaryByQuery *\r\n- VarByHeader Authorization\r\n- I removed part where if there is Authorization, do not cache (which mean I do need to cache authorized request)\r\n- I used yarp\n\n### Exceptions (if any)\n\nSystem.ArgumentException: A null value is not valid in this context\r\n   at StackExchange.Redis.RedisValue.AssertNotNull() in /_/src/StackExchange.Redis/RedisValue.cs:line 308\r\n   at StackExchange.Redis.RedisDatabase.ScriptEvalMessage..ctor(Int32 db, CommandFlags flags, RedisCommand command, String script, Byte[] hexHash, RedisKey[] keys, RedisValue[] values) in /_/src/StackExchange.Redis/RedisDatabase.cs:line 4814\r\n   at StackExchange.Redis.RedisDatabase.ScriptEvalMessage..ctor(Int32 db, CommandFlags flags, RedisCommand command, String script, RedisKey[] keys, RedisValue[] values) in /_/src/StackExchange.Redis/RedisDatabase.cs:line 4790\r\n   at StackExchange.Redis.RedisDatabase.ScriptEvaluateAsync(String script, RedisKey[] keys, RedisValue[] values, CommandFlags flags) in /_/src/StackExchange.Redis/RedisDatabase.cs:line 1547\r\n   at Microsoft.AspNetCore.OutputCaching.StackExchangeRedis.RedisOutputCacheStore.Microsoft.AspNetCore.OutputCaching.IOutputCacheBufferStore.SetAsync(String key, ReadOnlySequence\u00601 value, ReadOnlyMemory\u00601 tags, TimeSpan validFor, CancellationToken cancellationToken)\r\n   at Microsoft.AspNetCore.OutputCaching.OutputCacheEntryFormatter.StoreAsync(String key, OutputCacheEntry value, HashSet\u00601 tags, TimeSpan duration, IOutputCacheStore store, ILogger logger, CancellationToken cancellationToken)\n\n### .NET Version\n\n8\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde85_oAMA",
        "parentId": null,
        "author": "abratv",
        "content": "Just learned how to debug aspnetcore source code...\r\n\r\nThe issue caused by null tag (not the value of the cache itself)\r\nI have more than one tags, one of it has null value\r\n\r\nmaybe context.Tags.Add(xxx); //if xxx is null, then throw over here already?",
        "createdAt": "2024-05-31T04:01:40Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/55988#issuecomment-2141192960"
      },
      {
        "id": "IC_kwDOAQzde85_oAln",
        "parentId": null,
        "author": "abratv",
        "content": "but having exception in policy is not nice\r\njust log it with warn? reason is that cache tag may or may not available\r\nthe endpoint queries might be there or not there",
        "createdAt": "2024-05-31T04:03:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/55988#issuecomment-2141194599"
      },
      {
        "id": "IC_kwDOAQzde85_o1tH",
        "parentId": null,
        "author": "mgravell",
        "content": "Propose there are 2 bugs here:\r\n\r\n- the backend is the immediate bug; need to investigate\r\n- IMO the middleware layer should mask such errors turning them into logged errors but making failed writes simply continue (logged) and failed reads (logged) manifest as misses",
        "createdAt": "2024-05-31T07:47:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/55988#issuecomment-2141412167"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86MSESM",
    "title": "\u0060DistributedSession\u0060 tries to refresh non-existent keys",
    "url": "https://github.com/dotnet/aspnetcore/issues/56233",
    "createdAt": "2024-06-14T14:50:31Z",
    "lastUpdated": "2024-06-14T14:50:36Z",
    "body": "\u0060DistributedSession.CommitAsync\u0060 branches on \u0060_isModified\u0060 and either calls \u0060_cache.SetAsync\u0060 to write the modified session content to the cache, or it calls \u0060_cache.RefreshAsync\u0060 to refresh the cache entry and extend its sliding expiration window.\r\n\r\nWhen handling a request without a session cookie, the \u0060SessionMiddleware\u0060 will generate a new session key and later on end up calling \u0060DistributedSession.CommitAsync\u0060. If the session hasn\u0027t been modified by the endpoint, the call to \u0060_cache.RefreshAsync\u0060 will happen with the newly generated session key. Since the session is newly created and wasn\u0027t modified, it cannot exist in the cache at this point and the attempt to refresh the cache entry seems to be pointless.\r\n\r\nIf the application only requires access to the session in some specific areas, this will cause every single request to hit the cache backend with a refresh for a non-existent key.\r\n\r\nWhile the performance and latency penalty (depending on the cache backend) are likely negligible, I would have expected \u0060DistributedSession.CommitAsync\u0060 to account for it by checking \u0060_isNewSessionKey\u0060.\r\n\r\n\u0060\u0060\u0060\r\nif (_isModified)\r\n{\r\n   // update cache entry\r\n}\r\nelse if (!_isNewSessionKey)  // \u003C-- else if instead of else\r\n{\r\n    // refresh cache entry\r\n}\r\n\u0060\u0060\u0060\r\n\r\nIs there a reason this isn\u0027t done?",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86NTw_G",
    "title": "Output caching middleware caches empty response body when request cancelled",
    "url": "https://github.com/dotnet/aspnetcore/issues/56427",
    "createdAt": "2024-06-24T17:40:25Z",
    "lastUpdated": "2024-06-25T09:21:16Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nThe output caching middleware returns an empty response body for subsequent requests when an in progress request for the same resource is cancelled by the client.\r\n\r\nI believe this is because the request cancellation causes the cancellation of writing the JSON stream to the response buffer however the caching middleware still considers this response buffer to be valid cacheable output and returns that incomplete buffer to all other pending / subsequent requests until the cache expires.\r\n\r\n### Expected Behavior\r\n\r\nEmpty / partial output from a cancelled request should not be cached.\r\n\r\n### Steps To Reproduce\r\n\r\nHere is a minimal API that reproduces the issue:\r\n\u0060\u0060\u0060c#\r\nvar builder = WebApplication.CreateBuilder(args);\r\nbuilder.Services.AddOutputCache(o =\u003E\r\n{\r\n    o.AddBasePolicy(b =\u003E b.Expire(TimeSpan.FromSeconds(10)));\r\n});\r\n\r\nvar app = builder.Build();\r\napp.UseOutputCache();\r\napp.MapGet(\u0022/time\u0022, async () =\u003E\r\n{\r\n    await Task.Delay(TimeSpan.FromSeconds(5));\r\n    return new { Time = DateTimeOffset.UtcNow.ToString(\u0022O\u0022) };\r\n}).CacheOutput();\r\napp.Run();\r\n\u0060\u0060\u0060\r\nThe API takes 5 seconds to return some JSON with the current time, simulating a slow response. This should be cached for 10 seconds.\r\n\r\nLoading \u0060/time\u0060 in the browser and hitting refresh a few times in the 5 seconds while the page loads will cause an empty response to be returned instead of the JSON. Subsequent requests will immediately return the invalid empty cached response.\r\n\r\nIf you wait 10 seconds for the cache to expire and load the page a single time, a valid JSON response is returned and cached for subsequent requests.\r\n\r\nI was unable to reproduce the issue using \u0060TestServer\u0060 in memory integration tests - I think this might be because [the test \u0060HttpClient\u0060 doesn\u0027t properly reproduce request cancellation](https://github.com/dotnet/aspnetcore/issues/5938).\r\n\r\nThis console app sends a request to the above API every second, but cancels the first request.\r\n\u0060\u0060\u0060c#\r\nvar client = new HttpClient\r\n{\r\n    BaseAddress = new Uri(\u0022http://localhost:5268\u0022)\r\n};\r\n\r\nvar cts = new CancellationTokenSource();\r\nList\u003CTask\u003E requests = [ SendRequest(0, cts.Token) ];\r\nawait Task.Delay(TimeSpan.FromSeconds(1));\r\ncts.Cancel();\r\n\r\nfor (var i = 1; i \u003C 15; i\u002B\u002B)\r\n{\r\n    requests.Add(SendRequest(i));\r\n    await Task.Delay(1000);\r\n}\r\n\r\nawait Task.WhenAll(requests);\r\n\r\nasync Task SendRequest(int i, CancellationToken cancellationToken = default)\r\n{\r\n    try\r\n    {\r\n        var response = await client.GetStringAsync(\u0022time\u0022, cancellationToken);\r\n        Log(i, $\u0022response: {response}\u0022);\r\n    }\r\n    catch (TaskCanceledException)\r\n    {\r\n        Log(i, \u0022cancelled\u0022);\r\n    }\r\n}\r\n\r\nvoid Log(int i, string msg) =\u003E Console.WriteLine($\u0022{Now()} Request {i} \u0022 \u002B msg);\r\nstring Now() =\u003E DateTimeOffset.UtcNow.ToString(\u0022T\u0022);\r\n\u0060\u0060\u0060\r\n\r\nThe invalid empty cache response can be seen in the logs, which resolves after the cache expires:\r\n\u0060\u0060\u0060\r\n17:35:57 Request 0 cancelled\r\n17:36:01 Request 4 response:\r\n17:36:01 Request 5 response:\r\n17:36:01 Request 3 response:\r\n17:36:01 Request 1 response:\r\n17:36:01 Request 2 response:\r\n17:36:07 Request 7 response: {\u0022time\u0022:\u00222024-06-24T17:36:07.8436504\u002B00:00\u0022}\r\n17:36:07 Request 10 response: {\u0022time\u0022:\u00222024-06-24T17:36:07.8436504\u002B00:00\u0022}\r\n17:36:07 Request 8 response: {\u0022time\u0022:\u00222024-06-24T17:36:07.8436504\u002B00:00\u0022}\r\n17:36:07 Request 9 response: {\u0022time\u0022:\u00222024-06-24T17:36:07.8436504\u002B00:00\u0022}\r\n17:36:07 Request 6 response: {\u0022time\u0022:\u00222024-06-24T17:36:07.8436504\u002B00:00\u0022}\r\n17:36:07 Request 11 response: {\u0022time\u0022:\u00222024-06-24T17:36:07.8436504\u002B00:00\u0022}\r\n17:36:08 Request 12 response: {\u0022time\u0022:\u00222024-06-24T17:36:07.8436504\u002B00:00\u0022}\r\n17:36:09 Request 13 response: {\u0022time\u0022:\u00222024-06-24T17:36:07.8436504\u002B00:00\u0022}\r\n17:36:10 Request 14 response: {\u0022time\u0022:\u00222024-06-24T17:36:07.8436504\u002B00:00\u0022}\r\n\u0060\u0060\u0060\r\n\r\n### .NET Version\r\n\r\n8.0.200",
    "upvotes": 1,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86CXPO9",
        "parentId": null,
        "author": "gnjack",
        "content": "A possible workaround is to implement a custom \u0060IOutputCachePolicy\u0060 which disables \u0060AllowCacheStorage\u0060 when the request is cancelled:\r\n\u0060\u0060\u0060c#\r\npublic ValueTask ServeResponseAsync(OutputCacheContext context, CancellationToken cancellationToken)\r\n{\r\n    if (cancellationToken.IsCancellationRequested)\r\n    {\r\n        context.AllowCacheStorage = false;\r\n        return ValueTask.CompletedTask;\r\n    }\r\n    ...\r\n    return ValueTask.CompletedTask;\r\n}\r\n\u0060\u0060\u0060\r\n\r\nWhich should possibly be part of the default policy?\r\n\r\nHowever, when combined with resource locking this can cause nasty cache stampedes. Resource locking ensures that all requests for a given response wait for the first request to populate the cache and is the default cache behaviour.\r\n\r\nCurrently, if you disable \u0060AllowCacheStorage\u0060 in \u0060ServeResponseAsync\u0060 while using the default \u0060LockingPolicy.Enabled\u0060 then all queued requests locked behind the single running request will all be allowed through at once by the caching middleware, resulting in many concurrent non-cached requests for the same resource.\r\n\r\nIf the application is running slowly due to load and a request is aborted due to timeout, this can result in undesirable behaviour where a struggling application now needs to serve many concurrent uncached requests for a resource, instead of only one at a time.\r\n\r\nWe\u0027ve instead opted to use \u0060cancellationToken.ThrowIfCancellationRequested();\u0060 in \u0060ServeResponseAsync\u0060. This will ensure empty responses from cancelled requests are not cached due to the thrown expetion. Any pending requests that were waiting on the cancelled request to populate the cache will receive a 500 error. Having one client cancelling a request cause other clients to receive an error is not ideal, but allows the clients to retry while still only allowing a single concurrent request to attempt to populate the cache on retry - preventing a cache stampede.\r\n\r\nIdeally the caching middleware should only allow one request at a time to attempt to populate the cache when locking is enabled, even if the first request failed to populate the cache, to prevent failures from causing cache stampedes.",
        "createdAt": "2024-06-24T18:07:20Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/56427#issuecomment-2187129789"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86OEMxh",
    "title": "\u0060DatabaseDeveloperPageExceptionFilter\u0060 produces bizzare exception if model fails to initialize",
    "url": "https://github.com/dotnet/aspnetcore/issues/56539",
    "createdAt": "2024-07-01T10:31:16Z",
    "lastUpdated": "2024-07-01T16:01:33Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\n\u0060DatabaseDeveloperPageExceptionFilter\u0060 attempts to get \u0060IModel\u0060s from all registered \u0060DbContextOptions\u0060:\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/d301328737c4912b95f236c4b349cf46ef7a473a/src/Middleware/Diagnostics.EntityFrameworkCore/src/DatabaseDeveloperPageExceptionFilter.cs#L58-L69\r\n\r\nIn our case, some of the registered \u0060DbContext\u0060s are expected to be used under very specific circumstances and throw an exception otherwise. Since \u0060GetContextDetailsAsync\u0060 is not guarded against exceptions in any way, the \u0022final\u0022 exception is the \u0060DbContext\u0060 initialization failure, not the original exception, hindering debugging.\r\n\r\n### Expected Behavior\r\n\r\nOriginal exception is clearly reported\r\n\r\n### Steps To Reproduce\r\n\r\n1) \u0060DbContext\u0060 with \r\n\r\n\u0060\u0060\u0060cs\r\n    protected override void OnModelCreating(ModelBuilder modelBuilder)\r\n    {\r\n        throw new Exception(\u0022Bad DbContext\u0022);\r\n    }\r\n\u0060\u0060\u0060\r\n\r\n2) Throw exception in any endpoint (doesn\u0027t matter if controller/razor page/minimal api)\r\n\r\nThe logs will report \u0060Bad DbContext\u0060; likewise the debugger will break there.\r\n\r\n**Original exception will be buried very deep in debug output.**\r\n\r\n### Exceptions (if any)\r\n\r\n_See above_\r\n\r\n### .NET Version\r\n\r\n8.0.300\r\n\r\n### Anything else?\r\n\r\n\u0060\u0060\u0060\r\n.NET SDK:\r\n Version:           8.0.300\r\n Commit:            326f6e68b2\r\n Workload version:  8.0.300-manifests.5273bb1c\r\n MSBuild version:   17.10.4\u002B10fbfbf2e\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.19045\r\n OS Platform: Windows\r\n RID:         win-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\8.0.300\\\r\n\r\n.NET workloads installed:\r\n [aspire]\r\n   Installation Source: VS 17.10.35004.147\r\n   Manifest Version:    8.0.0/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.aspire\\8.0.0\\WorkloadManifest.json\r\n   Install Type:        FileBased\r\n\r\n\r\nHost:\r\n  Version:      8.0.5\r\n  Architecture: x64\r\n  Commit:       087e15321b\r\n\r\n.NET SDKs installed:\r\n  8.0.300 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.App 7.0.19 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 8.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 7.0.19 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 8.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 7.0.19 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 8.0.5 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\nOther architectures found:\r\n  x86   [C:\\Program Files (x86)\\dotnet]\r\n    registered at [HKLM\\SOFTWARE\\dotnet\\Setup\\InstalledVersions\\x86\\InstallLocation]\r\n\r\nEnvironment variables:\r\n  Not set\r\n\r\nglobal.json file:\r\n  Not found\r\n\u0060\u0060\u0060\r\n\r\nThis appears to be very similar to #32976, just under different circumstances ",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86PUQA6",
    "title": "Sliding expiry for hybrid cache",
    "url": "https://github.com/dotnet/aspnetcore/issues/56754",
    "createdAt": "2024-07-12T00:53:46Z",
    "lastUpdated": "2024-11-13T20:53:49Z",
    "body": "Are there any plans to implement a sliding expiration for \u0060HybridCacheEntryOptions\u0060? \r\n\r\nThe existing \u0060DistributedCacheEntryOptions\u0060 has a \u0060SlidingExpiration\u0060 property which has been working well for my team and I. We have another mechanism to invalidate cache keys when updates to the underlying data occurs so we like to keep the data in Redis for as long as it is being used and eventually expire when that particular data is not regularly accessed.\r\n\r\n### Desired Solution\r\n\r\nIdeally, the same \u0060SlidingExpiration\u0060 property would be added to \u0060HybridCacheEntryOptions\u0060 and the value would be passed along in \u0060ToDistributedCacheEntryOptions\u0060 and handled in the downstream \u0060IDistributedCache\u0060 calls\r\n",
    "upvotes": 13,
    "labels": [
      "feature-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86Tgd-m",
        "parentId": null,
        "author": "broline",
        "content": "BUMP",
        "createdAt": "2024-11-13T20:53:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/56754#issuecomment-2474762150"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86PWxom",
    "title": "Auth middleware should respond with ProblemDetails",
    "url": "https://github.com/dotnet/aspnetcore/issues/56757",
    "createdAt": "2024-07-12T09:09:27Z",
    "lastUpdated": "2024-07-12T14:27:13Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nI want all 4xx and 5xx status codes to respond with the ProblemDetails format. I have configured \u0060.AddProblemDetails()\u0060, yet when auth middleware returns 401 it is not in the ProblemDetails format. I know it is possible to override, but I think ProblemDetails should be the default.\r\n\r\n- [ ] \n\n### Describe the solution you\u0027d like\n\nMake ProblemDetails the default response format for 401, or at least when using \u0060.AddProblemDetails()\u0060.\n\n### Additional context\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86PdPBz",
    "title": "Allow Response Caching for Authorized Endpoints",
    "url": "https://github.com/dotnet/aspnetcore/issues/56769",
    "createdAt": "2024-07-13T08:50:15Z",
    "lastUpdated": "2024-09-07T11:13:51Z",
    "body": "## Background and Motivation\r\n\r\nWhen designing intranet based web enabled database systems, which always require authorization and are accessed from secure company computers using an internal IP address, it would greatly enhance speed to be able to cache some page content.  There are often long lists of data, frequently 10\u002BMb of data, that changes infrequently and must currently be added to every page load. Sometimes these apps are used remotely over a slow VPN connection.\r\nThis change would give developers the choice to cache content data.\r\n\r\nAn alternative that may be suggested is AJAX partial loading, however this is not much more efficient and on slow connections can severely affect responsiveness. The best model IMO is one that has a long initial page load, but then only short delays for small AJAX payloads and short subsequent page loads, ie. cached data.\r\n\r\nAt the moment, the only option to achieve this in DotNet is to mod up a custom version of the middleware, which is surely far more fraught. \r\n\r\n## Proposed API\r\n\r\n\u0060\u0060\u0060diff\r\nnamespace Microsoft.AspNetCore.ResponseCaching;\r\n\r\npublic class ResponseCachingOptions\r\n{\r\n\u002B    /// \u003Csummary\u003E\r\n\u002B    /// \u003Cc\u003Etrue\u003C/c\u003E if caching is allowed for authorised endpoints\r\n\u002B    /// \u003C/summary\u003E\r\n\u002B    public bool AllowAuthorizedEndpoint { get; set; } = false;\r\n}\r\n\u0060\u0060\u0060\r\n\r\n## Usage Examples\r\n\r\nIn Startup.cs:\r\n\r\n    public void ConfigureServices(IServiceCollection services) {\r\n      ...\r\n      services.AddResponseCaching(options =\u003E { options.AllowAuthorizedEndpoint = true; });\r\n      ...\r\n   }\r\n\r\n## Alternative Designs\r\n\r\nNone. This proposal simply exposes a new member to enable missing functionality.\r\n\r\n## Risks\r\n\r\nThere are no explicit risks. It is a non breaking change, and as such the new option defaults to existing behaviour and does not need to be specified.\r\n\r\nIn terms of implicit risk, the reason that has been given re the lack of configurability to date around authorized endpoints is that cached authorized data is a security risk. I would argue that while this is often the case, it is not always the case. The developer should be able to configure the framework so as to acheive their own desired balance of security, network performance and device CPU/resource loading.\r\n\r\nTo further protect cached data, it would also be possible to cache it in encrypted form and use javascript to decrypt before parsing to JSON, using an encryption key passed only with authorized page loads. This would sacrifice client CPU loading for network bandwidth, very likely a productive swap in terms of page load speed. \r\n\r\nSee PR to implement the full functionality: https://github.com/dotnet/aspnetcore/pull/56768",
    "upvotes": 0,
    "labels": [
      "feature-response-caching",
      "api-suggestion",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86Fjf-j",
        "parentId": null,
        "author": "halter73",
        "content": "It does seem pretty scary to enable something like this globally.\r\n\r\nIs there a reason that you\u0027re proposing this API specifically for [response caching](https://learn.microsoft.com//aspnet/core/performance/caching/response) and not [output caching](https://learn.microsoft.com/aspnet/core/performance/caching/response)? Most people seem to prefer output caching because it will cache more often even if the client is a web browser that doesn\u0027t send \u0060Cache-Control\u0060 headers explicitly allowing for stale content.\r\n\r\nOutput caching also allows you to specify [custom policies](https://learn.microsoft.com/aspnet/core/performance/caching/output?view=aspnetcore-8.0#override-the-default-policy) globally or per-endpoint which allow caching even authenticated requests. @sebastienros might be able to provide more details.",
        "createdAt": "2024-07-19T23:31:04Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/56769#issuecomment-2240675747"
      },
      {
        "id": "IC_kwDOAQzde86FmLVu",
        "parentId": null,
        "author": "6pac",
        "content": "@halter73 It depends on your niche - as I say, this application is used on an intranet. I think poor design - which is rife - is far more dangerous by leaking unwanted information in AJAX datasets *within* authenticated pages.\r\n\r\nAs to enabling it globally, (1) it\u0027s off by default, and (2) without adding cache headers specifically to an authorised endpoint, it won\u0027t be cached.  I suppose the change could, however, be framed as a per-endpoint setting. If you think that would be more likely to succeed, I could look into a change to approach it that way instead.\r\n\r\nNote that I am wanting the client (ie. web browser) to be able to cache the data from specific dedicated URLs/endpoints. From what I understand, output caching is server side, which I don\u0027t care about at all. Most of my apps have less than 100 users and run on about the third to bottom tier AWS VM costing maybe $60 a month - traffic and server load is almost negligible. These are internal facing custom database solutions, not public facing websites doing high traffic volume.\r\n\r\nIf I\u0027ve gotten the caching configuration wrong, please let me know - if there is any way to do what I want in the existing framework, I\u0027m completely happy to use it.\r\n\r\nPerhaps I\u0027ll run down my scenario.\r\n\r\nClearly all the static assets in my sites are already being cached. I came to this because I wanted to start caching specific dynamic response datasets.  \r\nMy total page load for some apps is typically ~12Mb and it\u0027s the same 11.5Mb of background data being loaded every time (for example a list of all 4500 clients and 400 staff in the system) - the actual page HTML and page specific data can be meaured in kb.  \r\nSo this gives me two options, (1) to either move to AJAX loading or (2) to work out how to cache the dataset for a period of time (say 2 weeks).  \r\nI dislike AJAX loading for any but truly enormous datasets, simply because it kills page responsiveness, especially on slow connections (and I live and work in a remote area where occasionally we are using a satellite internet connection which is very slow - the yardstick I use for my designs is \u0027how well will it work over a 1 Mbps connection at 1000 ping?\u0027). \r\nI coded up a system that will detect the differences to the cached dataset since it was first generated, so for example we cache the user dataset at a dedicated URL and then for the next two weeks the page load will contain only the user data that has changed since the time the cached dataset was read, and this is used to update the cached data. It worked flawlessly - until I noticed that the file wasn\u0027t actually being cached, despite the cache headers.\r\n\r\nMy only other option would be, I suppose, to write the data as a .js file to the site and serve it up as static content, but that feels quite hacky, and I think *would* have more serious security risks associated with it, not to mention the locking and contention issues.\r\n\r\nAs I have said, I think the framework needs to acknowledge that there is a line where it needs to hand the responsibility over to the developers to do things the right way. We can\u0027t block useful features just because they *could* be misused.\r\n",
        "createdAt": "2024-07-21T01:51:07Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/56769#issuecomment-2241377646"
      },
      {
        "id": "IC_kwDOAQzde86FwQAS",
        "parentId": null,
        "author": "halter73",
        "content": "\u003E Note that I am wanting the client (ie. web browser) to be able to cache the data from specific dedicated URLs/endpoints. From what I understand, output caching is server side, which I don\u0027t care about at all.\r\n\r\nThe response caching middleware is also server-side which is why it\u0027s potentially dangerous. Not only will it return a 304 if the client sends the right If-None-Match or If-Modified-Since headers, it will also return a 200 with the cached response body given the right Cache-Control response headers unless the client sends request headers that prevent it.\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/95039134856e8af85aeccd7d404ec96ec5bb73d4/src/Middleware/ResponseCaching/src/ResponseCachingMiddleware.cs#L183-L189\r\n\r\nFurthermore, output cache middleware will also return a 304 instead of just returning a 200 with the cached response if given the right If-None-Match or If-Modified-Since headers.\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/95039134856e8af85aeccd7d404ec96ec5bb73d4/src/Middleware/OutputCaching/src/OutputCacheMiddleware.cs#L283-L295\r\n\r\nThe primary difference between ASP.NET Core response caching and output caching is that output caching allows more configurable caching rules instead of strictly basing caching decisions based on request headers.\r\n\r\n\u003E - Is typically not beneficial for UI apps such as Razor Pages because browsers generally set request headers that prevent caching. [Output caching](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/output?view=aspnetcore-8.0), which is available in ASP.NET Core 7.0 and later, benefits UI apps. With output caching, configuration decides what should be cached independently of HTTP headers.\r\n\r\nhttps://learn.microsoft.com/aspnet/core/performance/caching/response?view=aspnetcore-8.0\r\n\r\nAnd you can see that the \u0022Authorization\u0022 header is specifically called out one of the non-configurable headers that response caching depends on:\r\n\r\n\u003E - The \u0060Authorization\u0060 header must not be present.\r\n\r\nhttps://learn.microsoft.com/aspnet/core/performance/caching/middleware?view=aspnetcore-8.0#cfc\r\n\r\nThere are a lot of headers that you cannot make the response caching middleware ignore. The Authorization header is just one of them. Rather than adding global flags for each and every one of these headers, we introduced the new output caching middleware which gives you far more control of what does and doesn\u0027t get cached and defaults to serving cached results even if the client sends something like \u0060Cache-Control: no-cache\u0060 as a request header.\r\n\r\nHowever, output caching still allows you to respect the  \u0060Cache-Control: no-cache\u0060 with a custom policy if you keep \u0060OutputCacheContext.AllowCacheLookup = false\u0060 for that request. It\u0027s just the defaults that are different from response caching. Otherwise, output caching just the newer, more flexible version of response caching.\r\n\r\nhttps://learn.microsoft.com/aspnet/core/performance/caching/output?view=aspnetcore-8.0#override-the-default-policy",
        "createdAt": "2024-07-23T00:09:23Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/56769#issuecomment-2244018194"
      },
      {
        "id": "IC_kwDOAQzde86FwTTg",
        "parentId": null,
        "author": "6pac",
        "content": "Thanks for the info, it will take me a little while to digest. I\u0027m sorry if I misunderstand the fundamentals - I realise that your time is valuable and I don\u0027t want to waste it.  \r\nComing from the database and desktop world, my knowledge of HTTP is informal and I\u0027m not at all familiar with the nitty gritty of caching header types and behaviours.\r\n\r\nI didn\u0027t realise that there were server-side security issues, I thought it was all about cached data for the authorised endpoint being stored on the client.  \r\nSurely though, if the page is subject to authorisation, an unauthorised user can\u0027t access it, regardless of cache settings? I\u0027ve always assumed that the authorization is ahead of caching in the pipeline, otherwise this would be a huge security issue.\r\n\r\nAlso, can we just turn off server side caching altogether? I\u0027m just a little puzzled as to why, when all I\u0027m after is some client side caching, I\u0027m being dragged into a discussion of the security issues around server side caching.  \r\nSurely the framework should be able to separate these two? If it\u0027s blocking client side caching because of server side caching issues, isn\u0027t that a fundamental architectural flaw?\r\n\r\nFrom what I understand, client side caching works like this:\r\n1) Server flags that an endpoint/url is allowed to be cached (via a header not containing NO-CACHE)\r\n2) Browser stores (caches) endpoint content\r\n3) Browser subsequently ignores requests to the endpoint/url and substitutes the cached data, for the caching period\r\n4) This can be overridden by a hard refresh. From a server-side perspective, if updated data is issued, a different unique ID is added to the querystring so that the URL changes and the content is updated.\r\n\r\nThe only security issue here is the storage of the data by the browser. Other than the \u0027NO-CACHE\u0027 header flag, the server is not even involved in the caching process.\r\n\r\nThe issue here as I understand it is that (1) ASP NET adds the NO-CACHE flag to dynamic endpoints, (2) to circumvent that, one must turn on Response Caching, (3) Response Caching cannot be used for authorised endpoints.",
        "createdAt": "2024-07-23T00:23:19Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/56769#issuecomment-2244031712"
      },
      {
        "id": "IC_kwDOAQzde86GtW2d",
        "parentId": null,
        "author": "6pac",
        "content": "@halter73 I\u0027ve read up on your above points and it looks to me like they are 100% referring to server side caching. I\u0027m starting to think that this reflects a fundamental architectural problem in the framework, ie. that logic for client and server side caching cannot be separated. I think there are some good points in my above reply. Could you respond?\r\n\r\nParticularly:\r\n- there seems to be no way to enable client side caching without server side caching, when these are entirely separate functionalities and should be treated using separate APIs/middleware\r\n- does my explanation of client side caching above sound accurate to you?\r\n- I also note that the auth step in the pipeline does occur before \u0027custom handlers\u0027 (according to https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-8.0) ",
        "createdAt": "2024-07-31T09:11:39Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/56769#issuecomment-2260037021"
      },
      {
        "id": "IC_kwDOAQzde86HcRt5",
        "parentId": null,
        "author": "halter73",
        "content": "\u003E (1) ASP NET adds the NO-CACHE flag to dynamic endpoint\r\n\r\nThere are a lot of times ASP.NET Core components like the cookie authentication handler do set the \u0060Cache-Control\u0060 and \u0060Pragma\u0060 to \u0060no-cache\u0060, but it\u0027s not just any dynamic endpoint. Generally, it\u0027s for a good reason like not wanting to cache a \u0060Set-Cookie\u0060 header which could even be bad even for client caching if it causes a fresh cookie to get overwritten by a stale one. Or not wanting to cache an error page.\t\r\n\r\n\u003E  (2) to circumvent that, one must turn on Response Caching\r\n\r\nWe\u0027d recommend output caching over response caching for most scenarios these days, but there are other options. There\u0027s nothing stopping you from removing \u0060no-cache\u0060 from every response inside of a \u0060HttpContext.Response.OnStarting\u0060 callback, not that we\u0027d recommend that. It would probably be best to determine exactly which component is adding \u0060no-cache\u0060 and preventing that component from running if it\u0027s really unneeded.\r\n\r\n\u003E (3) Response Caching cannot be used for authorised endpoints.\r\n\r\nBut output caching can be used for authorized endpoints if you really want to. But it\u0027s a security risk, so you have to go out of your way to allow it with a custom \u0060IOutputCachePolicy\u0060.\r\n\r\n\u003E there seems to be no way to enable client side caching without server side caching, when these are entirely separate functionalities and should be treated using separate APIs/middleware\r\n\r\nThis I agree more with. I\u0027m not sure that these should be entirely separate middleware considering configuring things like per-endpoint cache expiration policies would largely be the same. I cannot see a scenario where you would want to use a server cache over a client cache if the client sent a request with an If-None-Match header indicating their cache is up to date.\r\n\r\nI do however agree it would be nice if the output caching middleware\u0027s support for client caching didn\u0027t rely on caching the entire response body on the server. Caching response bodies shouldn\u0027t be necessary just to appropriately with 304s based on what policy is configured, what ETags were sent in previous responses, and whether any cache entries were evicted. I talked to @sebastienros and he agrees. However, as far as we know, you\u0027re the first person to request this functionality. I wonder if everyone else is just writing custom middleware for this, there isn\u0027t a big demand, or people just don\u0027t know they want this.\r\n\r\nThis diverges quite a bit from the original issue title to \u0022Allow Response Caching for Authorized Endpoints\u0022 though. Would you be fine if we renamed this issue to \u0022Add support for client-only caching to output caching\u0022? If not, please feel free to file a separate issue with that request. I don\u0027t think there\u0027s going to be any interest in supporting any kind of caching for authorized endpoints by default, server or client. But as I mentioned, it\u0027s at least possible to configure output caching to ignore whether or not the current user is authenticated.",
        "createdAt": "2024-08-06T23:33:29Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/56769#issuecomment-2272336761"
      },
      {
        "id": "IC_kwDOAQzde86HdqeF",
        "parentId": null,
        "author": "6pac",
        "content": "Thanks for getting back. Again, I\u0027ll have to investigate \u0060\u0060\u0060IOutputCachePolicy\u0060\u0060\u0060.\r\n\r\nThought I should mention, I have found a way of only doing client side only caching with ResponseCaching:\r\n \r\n     [ResponseCache(Duration = 6000, Location = ResponseCacheLocation.Client)]\r\n\r\nOther \u0060\u0060\u0060ResponseCacheLocation\u0060\u0060\u0060 values are \u0060\u0060\u0060All\u0060\u0060\u0060 (client \u002B server) and \u0060\u0060\u0060None\u0060\u0060\u0060 (caching turned off). So for example, allowing authorized endpoints might be acceptable only for endpoints with the \u0060\u0060\u0060Client\u0060\u0060\u0060 location.  However the dependency injection model appears to make it very difficult to bring the configuration of the endpoint and the policy together.  \r\nI\u0027m probably getting ahead of myself here, so I\u0027ll investigate more before posting again.\r\n\r\nRe renaming the issue - be my guest.  \r\n\r\nNote that there are a lot of people with my scenario and echoing my sentiments out there in support posts, and I haven\u0027t seen anyone with a solution yet, so if a good workaround comes out of this, I\u0027m happy to publicise it.",
        "createdAt": "2024-08-07T06:17:30Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/56769#issuecomment-2272700293"
      },
      {
        "id": "IC_kwDOAQzde86KesbB",
        "parentId": null,
        "author": "6pac",
        "content": "@halter73 after all this, it looks like this is all I need:\r\n\r\n    using System;\r\n    using System.Text;\r\n    using System.Collections.Generic;\r\n    using Microsoft.AspNetCore.Http;\r\n    using Microsoft.AspNetCore.Mvc.Filters;\r\n    using Microsoft.AspNetCore.Mvc.Infrastructure;\r\n    using Microsoft.AspNetCore.Mvc;\r\n    using Microsoft.Net.Http.Headers;\r\n    \r\n    namespace AspMvcApp {\r\n      // https://stackoverflow.com/questions/67901155/why-is-asp-net-core-setting-cache-control-headers-on-error-responses\r\n    \r\n      public class CacheControlAttribute : ActionFilterAttribute {\r\n        public int DurationSec { get; set; } = 0;\r\n    \r\n        public override void OnActionExecuted(ActionExecutedContext context) {\r\n            SetCacheControlHeaders(context.HttpContext.Response);\r\n        }\r\n    \r\n        private void SetCacheControlHeaders(HttpResponse response) {\r\n          response.Headers[HeaderNames.CacheControl] = $\u0022private,max-age={DurationSec}\u0022;\r\n        }\r\n      }\r\n    }\r\n\r\nimplemented like so:\r\n\r\n    namespace AspMvcApp.Controllers { \r\n      [Authorize]\r\n      [CacheControl(DurationSec = 2629746)]  // cache for a month\r\n      public class ScriptController : Controller {\r\n          [Route(\u0022Script/list-view-cache.js\u0022)]\r\n          public IActionResult list_view_cache(string hash) {\r\n            var scriptText= ListViewCache.GetLVFlexTableCacheItemByHash(hash).FlexTableBaseDataSerialised;\r\n            return Content(scriptText, \u0022text/javascript\u0022);\r\n          }\r\n      }\r\n    }\r\n\r\nMy immediate question is: why on earth was it so hard to find this information!? It is not discussed *anywhere* in MS documentation as far as I can see.   \r\nThe obvious follow up question: is this really all there is to it, or am I missing something?",
        "createdAt": "2024-09-01T11:40:26Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/56769#issuecomment-2323302081"
      },
      {
        "id": "IC_kwDOAQzde86LK9vY",
        "parentId": null,
        "author": "halter73",
        "content": "If all you need is to add \u0060Cache-Control: $\u0022private,max-age={DurationSec}\u0022\u0060 to responses produced by MVC, your solution is fine. Is there a particular reason you didn\u0027t use the \u0060[ResponseCache]\u0060 attribute since you\u0027re just focused on MVC? That shouldn\u0027t have the limitation around authorized endpoints like the middleware does unless I\u0027m missing something.",
        "createdAt": "2024-09-06T22:43:34Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/56769#issuecomment-2334907352"
      },
      {
        "id": "IC_kwDOAQzde86LL6RY",
        "parentId": null,
        "author": "6pac",
        "content": "Sorry, are you saying that we can use the \u0060\u0060\u0060[ResponseCache]\u0060\u0060\u0060 attribute without using the middleware? Is that documented anywhere?",
        "createdAt": "2024-09-07T11:13:50Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/56769#issuecomment-2335155288"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86QRZdb",
    "title": "Please provide a way to disable the DeveloperExceptionPage during development.",
    "url": "https://github.com/dotnet/aspnetcore/issues/56906",
    "createdAt": "2024-07-20T02:05:59Z",
    "lastUpdated": "2024-11-27T21:50:07Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Is your feature request related to a problem? Please describe the problem.\r\n\r\nIf I am using the \u0060WebApplication.Create\u0060 method, the DeveloperExceptionPage is automatically enabled in the development environment.\r\nPlease provide a way to disable this.\r\n\r\n### Describe the solution you\u0027d like\r\n\r\nThere are multiple ways to do this. Any method is fine.\r\n\r\nFor example:\r\n\r\n\u0060\u0060\u0060cs\r\nservices.DisableDeveloperExceptionPage();\r\n\u0060\u0060\u0060\r\n\r\nOr\r\n\r\n\u0060\u0060\u0060cs\r\nWebApplication.CreateBuilder(\r\n  new WebApplicationOptions {\r\n    Args = args,\r\n    DisableDeveloperExceptionPage = true\r\n  });\r\n\u0060\u0060\u0060\r\n\r\n### Additional context\r\n\r\nSimilar requests have been submitted and rejected in the past. (#43870, #47293)\r\n\r\nI want to observe the behavior when an exception occurs in the production environment during development.\r\nBut when DeveloperExceptionPage is enabled, a user-friendly display is shown, and I don\u0027t get the actual error that would be returned in the production environment (e.g. \u0060application/problem\u002Bjson\u0060).\r\n\r\nSolutions such as setting the \u0060DOTNET_ENVIRONMENT\u0060 environment variable to \u0060Production\u0060 or using \u0060WebApplication.CreateSlimBuilder\u0060 method are difficult to use.\r\n\r\nIf the \u0060DOTNET_ENVIRONMENT\u0060 environment variable is changed, the \u0060appsettings.*.json\u0060 file that is loaded will change, which may result in settings that are unsuitable for the development environment, for example, preventing database connections.\r\n\r\nAnd if I use the \u0060WebApplication.CreateSlimBuilder\u0060 method instead of the \u0060WebApplication.Create\u0060 method, there are some services that will be disabled, so I have to investigate and supplement them.\r\nI only want to disable the DeveloperExceptionPage, and I don\u0027t want to disable any other services.\r\n\r\nI don\u0027t want to complete and deploy this application with DeveloperExceptionPage disabled. I only want to temporarily disable it in local environment with minimal changes.\r\nThe method mentioned above is too costly for this purpose.",
    "upvotes": 2,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86FlSRP",
        "parentId": null,
        "author": "aetos382",
        "content": "I will now give you a more specific example of something I recently encountered.\r\n\r\nI recently upgraded my application from .NET 7.0 to .NET 8.0.\r\n\r\nWhen using .NET 7.0, I was setting the \u0060JsonTypeInfoResolver\u0060 as follows to accelerate the (de)serialization of API request/response payloads.\r\n\r\n\u0060\u0060\u0060cs\r\nservices\r\n    .AddControllers()\r\n    .AddJsonOptions(static options =\u003E\r\n    {\r\n        options.JsonSerializerOptions.TypeInfoResolver = JsonTypeInfoResolver.Combine(\r\n            MyApiPayloadsSerializerContext.Default,\r\n            new DefaultJsonTypeInfoResolver());\r\n    });\r\n\u0060\u0060\u0060\r\n\r\nIt is important to combine \u0060MyApiPayloadsSerializerContext.Default\u0060 with \u0060new DefaultJsonTypeInfoResolver()\u0060.\r\nIf I only set \u0060MyApiPayloadsSerializerContext.Default\u0060 as follows, it will fail to serialize objects that it does not support (e.g. \u0060ProblemDetails\u0060) if they are returned.\r\n\r\n\u0060\u0060\u0060cs\r\nservices\r\n    .AddControllers()\r\n    .AddJsonOptions(static options =\u003E\r\n    {\r\n        options.JsonSerializerOptions.TypeInfoResolver = MyApiPayloadsSerializerContext.Default;\r\n    });\r\n\u0060\u0060\u0060\r\n\r\nWhen writing as above, if the application receives an invalid request, the framework will try to return \u0060ProblemDetails\u0060 to indicate that the request is invalid, but an error will occur that it cannot be serialized, so the original error will be masked.\r\n\r\nIn .NET 8.0, it would be better to rewrite it as follows.\r\n\r\n\u0060\u0060\u0060cs\r\nservices\r\n    .AddControllers()\r\n    .AddJsonOptions(static options =\u003E\r\n    {\r\n        options.JsonSerializerOptions.TypeInfoResolverChain.Insert(0, MyApiPayloadsSerializerContext.Default);\r\n    });\r\n\u0060\u0060\u0060\r\n\r\nThe \u0060TypeInfoResolverChain\u0060 includes the reflection-based \u0060DefaultJsonTypeInfoResolver\u0060 by default, so there is no need to explicitly add it as before.\r\n\r\nI wanted to verify that my application was not broken by this change.\r\nIn other words, I wanted to make sure that if I sent an invalid request to the application, I would receive a response in the \u0060application/problem\u002Bjson\u0060 format that correctly indicated that the request was invalid, rather than an error that \u0060ProblemDetails\u0060 could not be serialized.\r\n\r\nHowever, if DeveloperExceptionPage is enabled, even if I send a request using \u0060curl\u0060, the console displays the error message generated by DeveloperExceptionPage, rather than the response in \u0060application/problem\u002Bjson\u0060 format.\r\n\r\nI just want to confirm it, but if I change the \u0060DOTNET_ENVIRONMENT\u0060 environment variable or use the \u0060WebApplication.CreateSlimBuilder\u0060 method, a lot of other changes will be required.\r\nSo, without doing those things, I just want to disable the DeveloperExceptionPage.",
        "createdAt": "2024-07-20T12:53:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/56906#issuecomment-2241143887"
      },
      {
        "id": "IC_kwDOAQzde86GKc3G",
        "parentId": null,
        "author": "amcasey",
        "content": "Thanks for the detailed explanation of your scenario and motivation!",
        "createdAt": "2024-07-25T16:25:35Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/56906#issuecomment-2250886598"
      },
      {
        "id": "IC_kwDOAQzde86VMnbE",
        "parentId": null,
        "author": "davidfowl",
        "content": "@captainsafia have we seen other requests for this?",
        "createdAt": "2024-11-27T07:30:58Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/56906#issuecomment-2503112388"
      },
      {
        "id": "IC_kwDOAQzde86VTNEm",
        "parentId": null,
        "author": "captainsafia",
        "content": "\u003E [@captainsafia](https://github.com/captainsafia) have we seen other requests for this?\n\nOutside of the ones linked in the original issue, there are semi-related ones like https://github.com/dotnet/aspnetcore/issues/52622.\n\nIt seems like the overall goal people have here is to be able to model behavior that happens in production environments when exceptions occur locally.\n\nI think the \u0022right\u0022 thing to do here is to use a non-Development environment if you want to replicate Production-behavior locally but there definitely is a cliff you follow of because this will disable other features that are behind a Development check, like validating scopes on services in the DI container or injection of user secrets.\n\nAdding \u0060DisableDeveloperExceptionPage\u0060 to \u0060WebApplicationOptions\u0060 could help here but given how targeted the API is I don\u0027t see overwhelming demand for it.\n",
        "createdAt": "2024-11-27T21:50:06Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/56906#issuecomment-2504839462"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86SJzZk",
    "title": "DatabaseDeveloperPage is not shown for pending model changed by default with EF 9.0",
    "url": "https://github.com/dotnet/aspnetcore/issues/57204",
    "createdAt": "2024-08-07T02:05:48Z",
    "lastUpdated": "2024-08-07T02:07:42Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nEF 9 now throws an exception by default when \u0060MigrateAsync\u0060 is called when there are pending model changes and this isn\u0027t detected by DatabaseDeveloperPage.\r\n\r\nAs a workaround, it can be configured to just log a message, see https://github.com/dotnet/aspnetcore/pull/57060/commits/c7cc6eba2c60e11f359b429a01fa0554e8975cf7\r\n\r\n### Expected Behavior\r\n\r\nConsider special-casing this exception.\r\n\r\n### Steps To Reproduce\r\n\r\n_No response_\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n9.0-rc1\r\n\r\n### Anything else?\r\n\r\n_No response_",
    "upvotes": 0,
    "labels": [
      "feature-diagnostics",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86SbPFF",
    "title": "Unexpected behavior in HttpLoggingMiddleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/57242",
    "createdAt": "2024-08-08T20:58:41Z",
    "lastUpdated": "2024-08-08T22:03:00Z",
    "body": "https://github.com/dotnet/aspnetcore/blob/e31445e897e416b743f436b27cb81f3c87c56d27/src/Middleware/HttpLogging/src/HttpLoggingMiddleware.cs#L261C27-L261C28\r\n\r\nIn the HttpLoggingMiddleware, when opting into duration, an additional entry is created. Expected behavior would be that the duration is added as a property of the response log",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86HtCvJ",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "The \u0060CombineLogs\u0060 option exists if you want all the logs to be under a single log message\r\nhttps://github.com/dotnet/aspnetcore/blob/e31445e897e416b743f436b27cb81f3c87c56d27/src/Middleware/HttpLogging/src/HttpLoggingOptions.cs#L117",
        "createdAt": "2024-08-08T21:52:53Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57242#issuecomment-2276731849"
      },
      {
        "id": "IC_kwDOAQzde86HtDna",
        "parentId": null,
        "author": "SemaphoreSlim1",
        "content": "I did see that, but I want the request/response log entries to be separate",
        "createdAt": "2024-08-08T21:56:24Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57242#issuecomment-2276735450"
      },
      {
        "id": "IC_kwDOAQzde86HtFW-",
        "parentId": null,
        "author": "SemaphoreSlim1",
        "content": "I guess the confusing thing is that you opt into it via HttpLoggingFields.Duration - but it\u0027s not a field added to the entry, it\u0027s a completely new entry all on its own. \r\n\r\nI can say the same thing about HttpLoggingFields.RequestBody and HttpLoggingFields.ResponseBody as well - opting into these makes 4 distinct log entries when I would expect two",
        "createdAt": "2024-08-08T22:02:59Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57242#issuecomment-2276742590"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86UMKZc",
    "title": "OutputCache: expose \u0060OutputCacheStream \u0060 for reading in \u0060ServeResponseAsync(..)\u0060 so response tags can be built",
    "url": "https://github.com/dotnet/aspnetcore/issues/57517",
    "createdAt": "2024-08-26T08:02:35Z",
    "lastUpdated": "2024-08-27T06:55:14Z",
    "body": "## Background and Motivation\r\n\r\nFor outout caching its often useful to be able to create tags based on the response. This occurs where different requests all touch the same underlying data and the tag representing this underlying data cannot be constructed based on the request data. For example, say, requests for a same user details based on UserId, Identity and EmailAddress. \r\n\r\n\u0060\u0060\u0060\r\nhttps://api.com/userdetailsbyid?userid=1234\r\nhttps://api.com/userdetailsbyemail?emailaddress=ua@oa.com\r\nhttps://api.com/userdetailsbyidentity?identityprovider=https://idp.com\u0026subject=abc\r\n\u0060\u0060\u0060\r\n\r\nAt the moment the only way to build the tags for these queries is to use the request data. The problem is that any command handlers would need to look up these details, and evict all these tags separately\r\n\r\n\u0060\u0060\u0060c#\r\nawait _outputCacheStore.EvictByTagAsync(\u0022Tag_User_by_userid=...);\r\nawait _outputCacheStore.EvictByTagAsync(\u0022Tag_User_by_emailaddress=...);\r\nawait _outputCacheStore.EvictByTagAsync(\u0022Tag_User_by_identity=...);\r\netc\r\n\u0060\u0060\u0060\r\n\r\nWhat I\u0027d like to do is to add a tag for each request in a custom policy by using the response which in my example contains the userid\r\n\r\n\u0060\u0060\u0060c#\r\nawait _outputCacheStore.EvictByTagAsync(\r\n    \u0022Tag_UserId_1234\u0022,\r\n    CancellationToken.None\r\n);\r\n\u0060\u0060\u0060\r\n\r\nThe workaround is to use reflection in the \u0060ServeResponseAsync(..)\u0060 to get the value of the \u0060outputCacheContext.OutputCacheStream\u0060 then invoke the \u0060GetCachedResponseBody()\u0060 in the internal \u0060OutputCacheStream\u0060 before reading the response (my policy is a generic typed policy so it\u0027s easy to deserialise and add the tags to the tags collection: \r\n\r\n\u0060\u0060\u0060c#\r\nif (_responseTags.Count != 0)\r\n{\r\n     var responseBodyJson = await ExtractResponseBodyAsync(\r\n\tcontext: context, \r\n\tcancellationToken: cancellationToken\r\n    );\r\n\r\n  var view = JsonConvert.DeserializeObject\u003CTView\u003E(responseBodyJson);\r\n\r\n  if (view is not null)\r\n  {\r\n\t  foreach (var tag in _responseTags)\r\n\t  {\r\n\t\t  context.Tags.Add(tag.Compile().Invoke(view));\r\n\t  }\r\n  }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThen somehow write it back. Who knows what this breaks...\r\n\r\n## Proposed API\r\n\r\nMake the \u0060OutputCacheStream\u0060 property public or provide a public method to \u0060GetCachedResponseBody()\u0060 from the \u0060OutputCacheContext\u0060 in the \u0060ServeResponseAsync(...)\u0060 method. \r\n\r\n## Usage Examples\r\n\r\n\u0060\u0060\u0060c#\r\npublic async ValueTask ServeResponseAsync(\r\n\t    OutputCacheContext context, \r\n\t    CancellationToken cancellationToken)\r\n    {\r\n     var responseBody= await context.GetCachedResponseBody();\r\n    //etc\r\n}\r\n\u0060\u0060\u0060\r\n\r\n",
    "upvotes": 0,
    "labels": [
      "api-suggestion",
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86JqhPA",
        "parentId": null,
        "author": "martincostello",
        "content": "Have reported the post above to GitHub for posting what\u0027s likely malware. Received an identical comment from a different account in the Swashbuckle repo today as well.",
        "createdAt": "2024-08-26T08:18:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57517#issuecomment-2309624768"
      },
      {
        "id": "IC_kwDOAQzde86JyfR_",
        "parentId": null,
        "author": "brettwinters",
        "content": "[Stackoverflow ](https://stackoverflow.com/q/78917485/9388563)",
        "createdAt": "2024-08-27T06:55:12Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57517#issuecomment-2311713919"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86UWjfE",
    "title": "allow configure static files  with \u0060IOptions\u003CT\u003E\u0060 and \u0060IConfiguration\u0060",
    "url": "https://github.com/dotnet/aspnetcore/issues/57544",
    "createdAt": "2024-08-27T10:33:05Z",
    "lastUpdated": "2024-08-27T10:33:10Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nwhen I create a  proxy service with \u0060YARP\u0060 , I need to serve static files like nginx,  but  it need to be able to configure mime type mapping throw \u0060appsettings.json\u0060.\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/369b2dedc04c58d20322a71d2d8eb255615d5757/src/Middleware/StaticFiles/src/StaticFileExtensions.cs#L25-L30\r\n\r\nthe \u0022default\u0022  \u0060UseStaticFile\u0060 indeed use \u0060IOptions\u003CStaticFileOptions\u003E\u0060, but it  is  a  \u0060Singleton\u0060 service injected to \u0060constructor\u0060  \r\nand it can not to configure it through \u0060appsettings.json\u0060\r\n\n\n### Describe the solution you\u0027d like\n\n1. use a new base method \u0060UseStaticFile(this IApplicationBuilder app,Func\u003CIServiceProvider, IOptionsMonitor\u003CStaticFileOptions\u003E\u003E)\u0060   \r\n2. middleware use \u0060IOptionsMonitor\u003CStaticFileOptions\u003E\u003E\u0060\r\n3. add an easy configuration structure\r\n\r\n\u0060\u0060\u0060jsonc\r\n{\r\n  \u0022StaticFile\u0022: {\r\n    \u0022AllowDefaultMappings\u0022: true, // default to true,   false will clear all default mime mappings\r\n    \u0022Mappings\u0022 : {\r\n        \u0022.apk\u0022:\u0022application/vnd.android.package-archive\u0022,\r\n        \u0022.xxx\u0022:\u0022yyyyyyyy\u0022\r\n    },\r\n    \u0022ServeUnknownFileTypes\u0022:false,\r\n    \u0022RedirectToAppendTrailingSlash\u0022:fase,\r\n    \u0022DefaultFileNames\u0022:[  // this is for configure  UseDefaultFiles\r\n      \u0022index.html\u0022,\r\n      \u0022index.htm\u0022\r\n    ]\r\n  }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\n\n### Additional context\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86UXTk6",
    "title": "[API Proposal]: Add \u0060CorsPolicyBuilder.AllowAnyExposedHeader\u0060",
    "url": "https://github.com/dotnet/aspnetcore/issues/57546",
    "createdAt": "2024-08-27T12:00:21Z",
    "lastUpdated": "2024-08-27T13:35:49Z",
    "body": "## Background and Motivation\r\n\r\nThe header Access-Control-Expose-Headers supports wildcard as with other cors headers.\r\n\r\n## Proposed API\r\n\u0060\u0060\u0060cs\r\nnamespace Microsoft.AspNetCore.Cors.Infrastructure;\r\n\r\npublic class CorsPolicyBuilder\r\n{\r\n\u002B    public CorsPolicyBuilder AllowAnyExposedHeader();\r\n}\r\n\u0060\u0060\u0060\r\n## Usage Examples\r\n\u0060\u0060\u0060cs\r\npolicyBuilder.AllowAnyExposedHeader();\r\n\u0060\u0060\u0060\r\n\r\n## Alternative Designs\r\n\r\n\u003C!--\r\nWere there other options you considered, such as alternative API shapes?\r\nHow does this compare to analogous APIs in other ecosystems and libraries?\r\n--\u003E\r\n\r\n## Risks\r\n\r\nJust like \u0060AnyOrigins\u0060 this is not gonna work with \u0060AllowCredentials\u0060. Perhaps an analyzer could flag misusage for both.\r\n\r\n",
    "upvotes": 0,
    "labels": [
      "api-suggestion",
      "feature-cors",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86VUSVH",
    "title": "ForwardedHeadersMiddleware seems not to pick up original host from Azure App Gateway",
    "url": "https://github.com/dotnet/aspnetcore/issues/57687",
    "createdAt": "2024-09-04T11:50:26Z",
    "lastUpdated": "2024-09-05T22:12:31Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nI have an ASP.NET Core app running in Azure Container Apps, which is protected by Azure App Gateway. Users access the app via the url of the app gateway.\r\n\r\nThe documentation at https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/proxy-load-balancer seems not to lead to a working setup where the \u0060ForwardedHeadersMiddleware\u0060 understands the original host (app gateway hostname) that users used to send requests to the app. See https://github.com/MicrosoftDocs/azure-docs/issues/97027#issuecomment-1229143586 for a similar thread.\r\n\r\n[The Application Gateway sends the original host name in the \u0060X-Original-Host\u0060 header](https://learn.microsoft.com/en-us/azure/application-gateway/how-application-gateway-works#:~:text=X%2Doriginal%2Dhost%20header%20contains%20the%20original%20host%20header%20with%20which%20the%20request%20arrived). I see that the \u0060ForwardedHeadersOptions\u0060 has [\u0060OriginalHostHeaderName\u0060](https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder.forwardedheadersoptions.originalhostheadername#microsoft-aspnetcore-builder-forwardedheadersoptions-originalhostheadername) but [the \u0060ForwardedHeadersMiddleware\u0060 seems to overwrite that value instead of using it](https://github.com/dotnet/aspnetcore/blob/16e32c0594a55bf68c9589a9416dd64b60376e3e/src/Middleware/HttpOverrides/src/ForwardedHeadersMiddleware.cs#L348).\r\n\r\nIn any case, the resulting effect I see is that links generated using the [\u0060LinkGenerator\u0060](https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing.Abstractions/src/LinkGenerator.cs) do not have the hostname that users are using.\r\n\r\n### Expected Behavior\r\n\r\n- Understandable documentation on how to setup ASP.NET Core behind Application Gateway.\r\n- LinkGenerator generating links that are correct for end users, with the application being aware of the original host (from app gateway) that users are using.\r\n\r\n### Steps To Reproduce\r\n\r\nI tried configuring my app according to the documentation:\r\n- I [set \u0060ASPNETCORE_FORWARDEDHEADERS_ENABLED\u0060 to \u0060true\u0060](https://learn.microsoft.com/en-us/aspnet/core/host-and-deploy/proxy-load-balancer?view=aspnetcore-8.0#forward-the-scheme-for-linux-and-non-iis-reverse-proxies) in the container app\u0027s environment variables\r\n- I added \u0060app.UseForwardedHeaders()\u0060 (default settings) in \u0060Program.cs\u0060\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n8.0.401\r\n\r\n### Anything else?\r\n\r\nOutput of \u0060dotnet --info\u0060:\r\n\r\n\u0060\u0060\u0060\r\n.NET SDK:\r\n Version:           8.0.401\r\n Commit:            811edcc344\r\n Workload version:  8.0.400-manifests.57f7c351\r\n MSBuild version:   17.11.4\u002B37eb419ad\r\n\r\nRuntime Environment:\r\n OS Name:     Windows\r\n OS Version:  10.0.22631\r\n OS Platform: Windows\r\n RID:         win-x64\r\n Base Path:   C:\\Program Files\\dotnet\\sdk\\8.0.401\\\r\n\r\n.NET workloads installed:\r\nConfigured to use loose manifests when installing new manifests.\r\n [android]\r\n   Installation Source: SDK 8.0.400, VS 17.12.35209.166\r\n   Manifest Version:    34.0.113/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.android\\34.0.113\\WorkloadManifest.json\r\n   Install Type:        FileBased\r\n\r\n [aspire]\r\n   Installation Source: SDK 8.0.400, VS 17.12.35209.166\r\n   Manifest Version:    8.2.0/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.aspire\\8.2.0\\WorkloadManifest.json\r\n   Install Type:        FileBased\r\n\r\n [ios]\r\n   Installation Source: SDK 8.0.400, VS 17.12.35209.166\r\n   Manifest Version:    17.5.8020/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.ios\\17.5.8020\\WorkloadManifest.json\r\n   Install Type:        FileBased\r\n\r\n [maccatalyst]\r\n   Installation Source: SDK 8.0.400, VS 17.12.35209.166\r\n   Manifest Version:    17.5.8020/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.maccatalyst\\17.5.8020\\WorkloadManifest.json\r\n   Install Type:        FileBased\r\n\r\n [maui-windows]\r\n   Installation Source: SDK 8.0.400, VS 17.12.35209.166\r\n   Manifest Version:    8.0.72/8.0.100\r\n   Manifest Path:       C:\\Program Files\\dotnet\\sdk-manifests\\8.0.100\\microsoft.net.sdk.maui\\8.0.72\\WorkloadManifest.json\r\n   Install Type:        FileBased\r\n\r\n\r\nHost:\r\n  Version:      9.0.0-preview.7.24405.7\r\n  Architecture: x64\r\n  Commit:       static\r\n\r\n.NET SDKs installed:\r\n  8.0.401 [C:\\Program Files\\dotnet\\sdk]\r\n  9.0.100-preview.7.24407.12 [C:\\Program Files\\dotnet\\sdk]\r\n\r\n.NET runtimes installed:\r\n  Microsoft.AspNetCore.App 8.0.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 8.0.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.AspNetCore.App 9.0.0-preview.7.24406.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.AspNetCore.App]\r\n  Microsoft.NETCore.App 8.0.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 8.0.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.NETCore.App 9.0.0-preview.7.24405.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.NETCore.App]\r\n  Microsoft.WindowsDesktop.App 8.0.7 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 8.0.8 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n  Microsoft.WindowsDesktop.App 9.0.0-preview.7.24405.2 [C:\\Program Files\\dotnet\\shared\\Microsoft.WindowsDesktop.App]\r\n\r\nOther architectures found:\r\n  x86   [C:\\Program Files (x86)\\dotnet]\r\n    registered at [HKLM\\SOFTWARE\\dotnet\\Setup\\InstalledVersions\\x86\\InstallLocation]\r\n\r\nEnvironment variables:\r\n  Not set\r\n\r\nglobal.json file:\r\n  X:\\source\\ra\\mobile-app-backend\\global.json\r\n\r\nLearn more:\r\n  https://aka.ms/dotnet/info\r\n\r\nDownload .NET:\r\n  https://aka.ms/dotnet/download\r\n\u0060\u0060\u0060",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86K1zVw",
        "parentId": null,
        "author": "hansmbakker",
        "content": "I found this documentation for Container Apps: https://learn.microsoft.com/en-us/azure/container-apps/dotnet-overview#define-x-forwarded-headers\r\n\r\nIt recommends clearing KnownNetworks / KnownProxies in order to remove the loopback restriction.",
        "createdAt": "2024-09-04T15:20:54Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57687#issuecomment-2329359728"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86VXRj7",
    "title": "Mod Rewrite - RewriteRule - redirections with absolute urls doesn\u0027t work",
    "url": "https://github.com/dotnet/aspnetcore/issues/57693",
    "createdAt": "2024-09-04T17:16:21Z",
    "lastUpdated": "2024-09-05T08:53:54Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Describe the bug\r\n\r\nWhen creating mod_rewrite _RewriteRule_  with redirection to different host/domain name (absolute url) it doesn\u0027t work properly because instead changing entire redirected url, destination is appended to requested url.\r\n\r\n### Expected Behavior\r\n\r\nFor redirections _RewriteRule_ is internaly creating _RedirectAction_ object that takes path base url always from: \u0060context.HttpContext.Request.PathBase\u0060 but what if redirection destination is full url to other hostname/domain? In such case base url should be taken from destination and not like now from requested url.\r\n\r\nWhen for example I have rule:\r\nRewriteCond %{REQUEST_URI} ^.*/test/.*$ [NC]\r\nRewriteRule ^(.*)$ https://google.pl$1 [R=307,L]\r\n\r\nWhen I enter: https://myhost.mydomain/test/abc I expect to be redirected to https://google.pl/test/abc but instead final url is:  https://myhost.mydomainhttps://google.pl/test/abc\r\n\r\n### Steps To Reproduce\r\n\r\n_No response_\r\n\r\n### Exceptions (if any)\r\n\r\n_No response_\r\n\r\n### .NET Version\r\n\r\n9.0.100-preview.7.24407.12\r\n\r\n### Anything else?\r\n\r\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86WauSn",
    "title": "Is there a way to evict a cache entry by value in addition to evicting by tag  - OutputCaching Asp.Net Core",
    "url": "https://github.com/dotnet/aspnetcore/issues/57850",
    "createdAt": "2024-09-13T00:30:39Z",
    "lastUpdated": "2024-09-16T12:25:18Z",
    "body": "### Is there an existing issue for this?\r\n\r\n- [X] I have searched the existing issues\r\n\r\n### Is your feature request related to a problem? Please describe the problem.\r\n\r\nHi,\r\n\r\nI am using Output Caching with Redis in my .NET 8 web API. The IOutputCacheStore API only provides a method for evicting cache by tags and not by cache keys. This is limiting, as the Tag() method in the CacheOutput fluent API chain only accepts strings as parameters and does not allow for delegates, unlike the VaryByValue() method, where we can access the HttpContext and query parameters to dynamically create cache keys. As a result, it\u0027s not possible to dynamically create a tag in the same way as in VaryByValue() to use as input for the EvictByTag() method.\r\n\r\nI have overridden the caching policy to allow output caching of authenticated requests, enabling me to cache by an ID value (e.g., user ID) and evict the cache entry associated with that specific value.\r\n\r\nIs there a way to address this issue, allowing more granular cache eviction by user or query parameter, without having to evict the entire cache for the endpoint in ASP.NET Core Output Caching?\r\n\r\n### Describe the solution you\u0027d like\r\n\r\nAn fluent api that allows evicting cache entries by value in Asp.Net Core OutputCaching\r\n\r\n### Additional context\r\n\r\n_No response_",
    "upvotes": 6,
    "labels": [
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86MPHOJ",
        "parentId": null,
        "author": "TheEagleByte",
        "content": "\u002B1 on this request.",
        "createdAt": "2024-09-16T12:25:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/57850#issuecomment-2352771977"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86XVyBx",
    "title": "The Rewrite middleware changes middleware ordering",
    "url": "https://github.com/dotnet/aspnetcore/issues/57987",
    "createdAt": "2024-09-20T15:13:01Z",
    "lastUpdated": "2024-09-20T15:13:07Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nWhen the URL has been modified by the rewrite middleware, it will force to run the routing middleware just after, disregarding the order configured by the developer.\r\n\r\nThis is an issue because routing might find a suitable endpoint before we had a chance to execute any other middleware (like the static file middleware).\r\n\n\n### Expected Behavior\n\nThe rewrite middleware doesn\u0027t change the middleware order when the URL has been modified.\n\n### Steps To Reproduce\n\nGood repro here from  @sgarnovsky https://github.com/sgarnovsky/AspNetCoreIssues/tree/main/BlazorAppUrlRewritingTest\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n8\n\n### Anything else?\n\nRelated issue: https://github.com/microsoft/reverse-proxy/issues/2532",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86YOYp9",
    "title": "Problem details middleware ignores response status code when handling an exception.",
    "url": "https://github.com/dotnet/aspnetcore/issues/58130",
    "createdAt": "2024-09-28T00:14:07Z",
    "lastUpdated": "2024-09-28T17:01:49Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nI tried to use problem details middleware and exception handler middleware in this manner:\r\n\r\n\u0060\u0060\u0060\r\nbuilder.Services.AddExceptionHandler\u003CMyExceptionHandler\u003E();\r\nbuilder.Services.AddProblemDetails(options =\u003E\r\n{\r\n\toptions.CustomizeProblemDetails = context =\u003E\r\n\t{\r\n\t\tif (context.Exception is MyUserFacingException)\r\n\t\t{\r\n\t\t\tcontext.ProblemDetails.Details = context.Exception.Message;\r\n\t\t}\t\r\n\t};\r\n});\r\n\r\napp.UseStatusCodePages();\r\napp.UseExceptionHandler();\r\n\u0060\u0060\u0060\r\n\r\nIf the exception handler returns true then \u0060ProblemDetailsContext.Exception\u0060 is null. I think this makes sense since the handler returning true means the exception does not propagate. The problem details middleware initializes \u0060ProblemDetailsContext.ProblemDetails\u0060 to whatever status code was set by the exception handling middleware.\r\n\r\nIf the exception handler returns false, then the exception is available in \u0060ProblemDetailsContext.Exception\u0060, which is good. But now the problem details middleware always initializes \u0060ProblemDetailsContext.ProblemDetails\u0060 as a 500, ignoring the status code set by the exception handler middleware. And there\u0027s no way to leverage the existing defaults to re-initialize it (https://github.com/dotnet/aspnetcore/issues/47978). The actual HTTP response code is the one set by the exception handler, not the 500 shown in the problem details.\r\n\r\nSearching the code base for uses of \u0060ProblemDetailsDefaults.Apply\u0060, the only place it\u0027s called with a null status code that would result in it defaulting to 500 is here:\r\n\r\nhttps://github.com/dotnet/aspnetcore/blob/6b9bba1472da66a9f02ae3cd0f564ad6e2bb5fff/src/Http/Http.Results/src/ProblemHttpResult.cs#L24\n\n### Expected Behavior\n\nThe problem details middleware should always initialize \u0060ProblemDetailsContext.ProblemDetails\u0060 using \u0060HttpContext.Response.StatusCode\u0060.\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n8.0.400\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86N6Kmj",
        "parentId": null,
        "author": "kjkrum",
        "content": "My workaround is for the exception handler to always return true and pass user-facing information to problem details via \u0060HttpContext.Items\u0060.",
        "createdAt": "2024-09-28T17:01:48Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/58130#issuecomment-2380835235"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86Yb86a",
    "title": "Response cache middleware corrupts data",
    "url": "https://github.com/dotnet/aspnetcore/issues/58164",
    "createdAt": "2024-09-30T19:18:49Z",
    "lastUpdated": "2024-09-30T19:46:51Z",
    "body": "### Is there an existing issue for this?\n\n- [X] I have searched the existing issues\n\n### Describe the bug\n\nTime to time webpage receives corrupted json text:\r\n\r\n\u0022\\u0000\\u0000\\u0000 ... \\u0000\\u0000\\u0000\\u00009cd8-287f-4df0-a645-558e5cff0c63\u0022,\u0022name\u0022:\u0022Corn\u0022,\u0022symbols\u0022:[\u0022ZCE?1\u0022,\u0022ZCE?2\u0022,\u0022ZCE?3\u0022,\u0022ZCE?4\u0022,\u0022ZCE?5\u0022,\u0022ZCE?6\u0022,\u0022F.US.ZCEZ24\u0022]},{\u0022id\u0022:\u0022de2579b3-5340-40ff-9ab3-dea0dbe774dc\u0022,\u0022name\u0022:\u0022MN Spring Wheat\u0022,\u0022symbols\u0022:[\u0022F.US.MWEU23\u0022,\u0022F.US.MWEZ23\u0022,\u0022F.US.MWEH24\u0022,\u0022F.US.MWEK24\u0022,\u0022F.US.MWEN24\u0022,\u0022F.US.MWEU24\u0022,\u0022F.US.MWEZ24\u0022]},{\u0022id\u0022:\u0022e4300ad3-ae20-4ea1-ba6e-fcae7b12b41f\u0022,\u0022name\u0022:\u0022Metals\u0022,\u0022symbols\u0022:[\u0022GCE\u0022,\u0022FGD\u0022,\u0022CPE\u0022,\u0022TGD\u0022,\u0022SIE\u0022,\u0022LDKZ\u0022,\u0022GCES2\u0022,\u0022PLE\u0022,\u0022TPL\u0022,\u0022LALZ\u0022,\u0022LZHZ\u0022,\u0022PA\u0022,\u0022PAE\u0022,\u0022LNIZ\u0022,\u0022TMG\u0022]},{\u0022id\u0022:\u0022ee406e54-b082-4dce-9eb0-361467ebd4a2\u0022,\u0022name\u0022:\u0022Corn\u0022,\u0022symbols\u0022:[\u0022ZCE?1\u0022,\u0022ZCE?2\u0022,\u0022ZCE?3\u0022,\u0022ZCE?4\u0022,\u0022ZCE?5\u0022,\u0022ZCE?6\u0022,\u0022F.US.ZCEZ24\u0022]}]\u0022\r\n\r\nI.e. significant part of the response is replaced by \\u0000. It looks as if memory buffer was partially erased.\r\n\r\nI am using ASP.NET Core 8 with response caching, hosted within docker container in kuber cluster.\r\n\r\nController code:\r\n\u0060\u0060\u0060\r\n[ResponseCache(VaryByQueryKeys = [\u0022ts\u0022, \u0022brandName\u0022], Duration = 2592000 /* 30 days */)]\r\npublic async Task\u003CIActionResult\u003E GetBrandSymbolLists(string brandName) {\r\n    try \r\n    {\r\n        AssetPackageSymbolListDto[] result = [];\r\n        var brand = await em.Brand.GetBrandByNameAsync(brandName);\r\n        var packageId = await em.BrandContentProfile.GetProfilePackageIdAsync(brand.ProfileId);\r\n\r\n        if (packageId.HasValue) \r\n        {\r\n            result = (await em.AssetPackageSymbolList\r\n                              .GetByPackageIdAsync(packageId.Value))\r\n                     .Select(l =\u003E new AssetPackageSymbolListDto(l))\r\n                     .ToArray();\r\n        }\r\n\r\n        return Ok(result);\r\n    } \r\n    catch (Exception ex) \r\n    {\r\n        logger.LogError(ex, \u0022Failed to get profile symbol lists\u0022);\r\n        return StatusCode(StatusCodes.Status500InternalServerError, ex.Message);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\nThis happens once a month, not so often but it happens. Already get several complains from our clients.\r\nPreviously I tried using response caching middleware for static files. Time to time server started serving zeroed content. Removing \u0060public\u0060 cache-control directive helped to workaround the problem but also disabled server cache.\r\n\r\nWe started observing this issue since we migrated to asp.net 8.0 from 6.0.\n\n### Expected Behavior\n\nNo data corruption when serving response.\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n8.0.7\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "feature-response-caching",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86Z-fye",
    "title": "After using services.AddHttpLogging(), the ResponseBody cannot be passed to Serilog for file logging.",
    "url": "https://github.com/dotnet/aspnetcore/issues/58380",
    "createdAt": "2024-10-12T17:54:35Z",
    "lastUpdated": "2024-10-12T17:54:46Z",
    "body": "### Is there an existing issue for this?\n\n- [x] I have searched the existing issues\n\n### Describe the bug\n\nI reviewed the source code and found that adding \u0022ResponseBody\u0022 to the logContext\u0027s \u0022Parameters\u0022 occurs after the interceptor\u0027s \u0022OnResponseAsync\u0022 method is executed. I want to access the \u0022ResponseBody\u0022 within this method and add it to the diagnostic context for logging with Serilog, but I have found that this is currently not achievable.\n![Image](https://github.com/user-attachments/assets/7a36fcfb-583e-4a87-9b34-bc71375a22c1)\n\nI expect to add the \u0022ResponseBody\u0022 to the diagnostic context in the red box area in the diagram, so that it can be provided to Serilog for file logging, like in the line diagnosticContext.Set(\u0022RequestBody\u0022, requestBody);\n![Image](https://github.com/user-attachments/assets/4a966af6-8250-4101-aecf-440d19bb1686)\n\nThe log template content for Serilog is like this:\n![Image](https://github.com/user-attachments/assets/637a7837-1fea-453c-950b-13553c2a47d6)\n\n\n\n\n### Expected Behavior\n\nIn the SampleHttpLoggingInterceptor\u0027s OnResponseAsync method, read the ResponseBody from the logContext\u0027s Parameters, and then add it to the diagnostic context using diagnosticContext.Set(\u0022RequestBody\u0022, requestBody); to provide it to Serilog for file logging.\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n.net 8.0\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86ahsqs",
    "title": "UseForwardedHeaders should raise more prominent errors for unknown proxies",
    "url": "https://github.com/dotnet/aspnetcore/issues/58461",
    "createdAt": "2024-10-16T17:09:39Z",
    "lastUpdated": "2024-10-16T17:15:28Z",
    "body": "We have a general rule that errors that can be caused by a misbehaving client connected to a well-configured and functioning web app should not raise log messages higher than the debug level because it could allow attackers to effectively spam the logs. This is a principle we follow in the \u0060ForwardedHeadersMiddleware\u0060. However, this makes it much harder to figure out what\u0027s going on when the middleware ignores \u0060X-Forwarded-...\u0060 headers because the request comes from an \u0022unknown\u0022 proxy in development. See #58455 and #57650 for some recent examples of this.\n\nThe only indication that things are going wrong (other than \u0060HttpRequest.Host\u0060 and some other properties not getting set to the expected forwarded values) is the following log:\n\n\u003E \u0060\u0060\u0060\n\u003E dbug: Microsoft.AspNetCore.HttpOverrides.ForwardedHeadersMiddleware[1]\n\u003E      Unknown proxy: [::ffff:10.0.0.100]:54321\n\u003E \u0060\u0060\u0060\n\nRaising the severity of the log only in development seems like one of the easiest possible fixes, but most of the time this issue only occurs after deploying to a production environment. Another option would be to reject requests containing \u0060X-Forwarded-\u0060 headers from an unknown source with a 400 status and a description of the issue in the response body even in production, but that seems like a very risky breaking change.\n\nI\u0027m not sure what the best solution is, but the current behavior has wasted a lot of people\u0027s time debugging.",
    "upvotes": 1,
    "labels": [
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86b4q7C",
    "title": "WriteAsJsonAsync doesn\u0027t write to the response body when used inside a RequestTimeoutPolicy of the RequestTimeoutsMiddleware",
    "url": "https://github.com/dotnet/aspnetcore/issues/58643",
    "createdAt": "2024-10-25T23:05:01Z",
    "lastUpdated": "2024-10-28T20:36:04Z",
    "body": "### Is there an existing issue for this?\n\n- [x] I have searched the existing issues\n\n### Describe the bug\n\nWriteAsJsonAsync will not write to the response body when used inside a RequestTimeoutPolicy of the RequestTimeoutsMiddleware.\n\nFor example, a user could be configuring the WriteTimeoutResponse delegate to return an error type for the policy.\nThe middleware will successfully execute the policy, the response status code will be correctly set but the response body will stay empty.\n\nI investigated and I found that the problem is in the slow path of the extension method.\nIf a user doesn\u2019t pass a cancellable CancellationToken to WriteAsJsonAsync, then it will use the token from the httpContext \u0060\u0060response.HttpContext.RequestAborted\u0060\u0060. If that token is cancelled then the call that it does to JsonSerializer.SerializeAsync will be cancelled.\n\nIn this scenario with the TimeoutMiddleware, when the delegate for the RequestTimeoutPolicy is executed the request is already aborted and the call to WriteAsJsonAsync will be immediately cancelled, which is why the response body remains empty.\n\nAs a workaround a user can create a new CancellationTokenSource in the scope of the delegate and pass its token to WriteAsJsonAsync.\n\ncontext.Response.WriteAsync doesn\u0027t have this problem.\n\n### Expected Behavior\n\nWriteAsJsonAsync should write to the request body when used inside the WriteTimeoutResponse delegate of a RequestTimeoutPolicy when called without a CancellationToken.\n\n### Steps To Reproduce\n\n\nHere\u0027s a minimal repro case made with ASP.NET Core Web API.\n\nMake sure to start the program without debugging or the TimeoutMiddleware will not be enabled.\n\n\u0060\u0060\u0060\n// Program.cs\n\nusing Microsoft.AspNetCore.Http.Timeouts;\nusing System;\n\nvar summaries = new[]\n{\n    \u0022Freezing\u0022, \u0022Bracing\u0022, \u0022Chilly\u0022, \u0022Cool\u0022, \u0022Mild\u0022, \u0022Warm\u0022, \u0022Balmy\u0022, \u0022Hot\u0022, \u0022Sweltering\u0022, \u0022Scorching\u0022\n};\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container.\nbuilder.Services.AddRequestTimeouts(options =\u003E\n{\n    options.DefaultPolicy = new RequestTimeoutPolicy\n    {\n        Timeout = TimeSpan.FromSeconds(2),\n        WriteTimeoutResponse = async (HttpContext context) =\u003E\n        {\n            var weather = new WeatherForecast\n            (\n                DateOnly.FromDateTime(DateTime.Now),\n                Random.Shared.Next(-20, 55),\n                summaries[Random.Shared.Next(summaries.Length)]\n            );\n\n            await context.Response.WriteAsJsonAsync(weather);\n        }\n    };\n});\n\nvar app = builder.Build();\napp.UseRequestTimeouts();\n\n// Configure the HTTP request pipeline.\n\napp.MapGet(\u0022/\u0022, async (HttpContext context) =\u003E\n{\n    await Task.Delay(TimeSpan.FromSeconds(10), context.RequestAborted);\n    return Results.Content(\u0022No timeout!\u0022, \u0022text/plain\u0022);\n});\n\n\n\napp.Run();\n\ninternal record WeatherForecast(DateOnly Date, int TemperatureC, string? Summary)\n{\n    public int TemperatureF =\u003E 32 \u002B (int)(TemperatureC / 0.5556);\n}\n\u0060\u0060\u0060\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n8.0.403\n\n### Anything else?\n\nASP.NET Core Web API\nVisual Studio Version 17.11.5\n\n\u0060\u0060\u0060\n.NET SDK:\n Version:           8.0.403\n Commit:            c64aa40a71\n Workload version:  8.0.400-manifests.e99c892e\n MSBuild version:   17.11.9\u002Ba69bbaaf5\n\nRuntime Environment:\n OS Name:     Windows\n OS Version:  10.0.22631\n OS Platform: Windows\n RID:         win-x64\n Base Path:   c:\\program files\\dotnet\\sdk\\8.0.403\\\n\u0060\u0060\u0060",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86RlrTG",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "We might want to set\n\u0060context.RequestAborted = originalToken;\u0060\nbefore calling the policy so \u0060WriteAsJsonAsync\u0060 will only see an error if the client canceled the request.\nhttps://github.com/dotnet/aspnetcore/blob/1d98312ff65d4e668bc93a843e985fdacb7d2e7c/src/Http/Http/src/Timeouts/RequestTimeoutsMiddleware.cs#L124",
        "createdAt": "2024-10-28T20:35:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/58643#issuecomment-2442572998"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86cqiC-",
    "title": "Introduce ability to disable response compression",
    "url": "https://github.com/dotnet/aspnetcore/issues/58737",
    "createdAt": "2024-11-01T06:02:37Z",
    "lastUpdated": "2024-11-01T06:23:08Z",
    "body": "## Background and Motivation\n\nSometimes, we may want to avoid response compression for some endpoints, such as small responses; it may cause bad performance for small responses, and some may want to get rid of response compression.\n\n## Proposed API\n\n\u0060\u0060\u0060diff\nnamespace Microsoft.AspNetCore.Http.Metadata;\n\n\u002B public interface IDisableResponseCompressionMetadata\n\u002B {\n\u002B }\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060diff\nnamespace Microsoft.AspNetCore.Http;\n\n\u002B public sealed class DisableResponseCompressionAttribute : Attribute, IDisableResponseCompressionMetadata\n\u002B {\n\u002B }\n\n\u002B public static class HttpMetricsEndpointConventionBuilderExtensions\n\u002B {\n\u002B     public static IEndpointConventionBuilder DisableResponseCompression(this IEndpointConventionBuilder builder);\n\u002B }\n\u0060\u0060\u0060\n\n\n## Usage Examples\n\n\u0060\u0060\u0060cs\napp.UseResponseCompression();\napp.MapGet(\u0022/deploy-info\u0022, (IOptions\u003CDeployInfo\u003E option) =\u003E Results.Ok(option.Value)).DisableResponseCompression();\napp.MapMetrics().DisableHttpMetrics().DisableResponseCompression();\n\u0060\u0060\u0060\n\n## Alternative Designs\n\n\u0060\u0060\u0060diff\nnamespace Microsoft.AspNetCore.ResponseCompression;\n\npublic class ResponseCompressionOptions\n{\n\u002B   public Func\u003CHttpContext, ValueTask\u003Cbool\u003E\u003E Predict { get; set; }\n}\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060c#\nservices.AddResponseCompression(options =\u003E\n{\n    options.Predict = context =\u003E \n    {\n        var noCompressionExists = context.Request.Headers.TryGetValue(\u0022no-compression\u0022, out _);\n        return noCompressionExists is not true;\n    };\n});\n\u0060\u0060\u0060\n\n\n\u0060\u0060\u0060c#\nservices.AddResponseCompression(options =\u003E\n{\n    options.Predict = context =\u003E \n    {\n        var contentLength = context.Response.ContentLength;\n        return contentLength.HasValue \u0026\u0026 contentLength.Value \u003E 1024;\n    };\n});\n\u0060\u0060\u0060\n\n## Risks\n\n\u003C!--\nPlease mention any risks that to your knowledge the API proposal might entail, such as breaking changes, performance regressions, etc.\n--\u003E\n\n",
    "upvotes": 0,
    "labels": [
      "api-suggestion",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86c_YA9",
    "title": "The Tags Property in OutputCache attribute is not working when using custom policies.",
    "url": "https://github.com/dotnet/aspnetcore/issues/58785",
    "createdAt": "2024-11-04T21:12:58Z",
    "lastUpdated": "2024-11-05T17:57:18Z",
    "body": "### Is there an existing issue for this?\n\n- [x] I have searched the existing issues\n\n### Describe the bug\n\nHey, I\u0027m trying to implement OutputCache with MultiTenancy Support, So I had to create a custom policy for that, I also used tags so that I can evict cache by tags \u002B tenant id, this is how I\u0027m doing it:\n\nCustom OutputCache policy, MultitenantCachePolicy:\n\n\u0060\u0060\u0060\npublic class MultitenantCachePolicy : IOutputCachePolicy\n{\n    public ValueTask CacheRequestAsync(OutputCacheContext context, CancellationToken cancellation)\n    {\n        var attemptOutputCaching = AttemptOutputCaching(context);\n        context.EnableOutputCaching = true;\n        context.AllowCacheLookup = attemptOutputCaching;\n        context.AllowCacheStorage = attemptOutputCaching;\n        context.AllowLocking = true;\n        context.CacheVaryByRules.QueryKeys = \u0022*\u0022;\n\n        var tenantId = context.HttpContext.Items[\u0022tenantId\u0022] as string ?? \u0022\u0022;\n\n        HashSet\u003Cstring\u003E newTags = [];\n\n        foreach (var tag in context.Tags)\n        {\n            newTags.Add($\u0022tenant:{tenantId}:{tag}\u0022);\n        }\n\n        newTags.Add($\u0022tenant:{tenantId}\u0022);\n        context.Tags.UnionWith(newTags);\n\n        return ValueTask.CompletedTask;\n    }\n\n    public ValueTask ServeFromCacheAsync(OutputCacheContext context, CancellationToken cancellation)\n    {\n        var response = context.HttpContext.Response;\n\n        if (!StringValues.IsNullOrEmpty(response.Headers.SetCookie))\n        {\n            context.AllowCacheStorage = false;\n            return ValueTask.CompletedTask;\n        }\n\n        if (response.StatusCode != StatusCodes.Status200OK)\n        {\n            context.AllowCacheStorage = false;\n            return ValueTask.CompletedTask;\n        }\n\n        return ValueTask.CompletedTask;\n    }\n\n    public ValueTask ServeResponseAsync(OutputCacheContext context, CancellationToken cancellation)\n        =\u003E ValueTask.CompletedTask;\n\n    private static bool AttemptOutputCaching(OutputCacheContext context)\n    {\n        var request = context.HttpContext.Request;\n\n        if (!HttpMethods.IsGet(request.Method) \u0026\u0026 !HttpMethods.IsHead(request.Method))\n        {\n            return false;\n        }\n\n        return true;\n    }\n}\n\u0060\u0060\u0060\n\nAnd this is how I register it:\n\n\u0060\u0060\u0060\nservices.AddOutputCache(options =\u003E\n{\n    options.AddPolicy(CacheConfig.CachePolicies.MultiTenantCache, o =\u003E\n    {\n        o.Expire(TimeSpan.FromMinutes(10))\n            .VaryByValue(context =\u003E CacheExtension.VaryByTenantId(context))\n            .AddPolicy\u003CMultitenantCachePolicy\u003E();\n    });\n}\n\u0060\u0060\u0060\nAnd this is how I use it in controller endpoints:\n\n\u0060[OutputCache(PolicyName = CacheConfig.CachePolicies.MultiTenantCache, Tags = [CacheConfig.CacheTags.DummyTag])]\u0060\n\nThe problem is that the \u0060DummyTag\u0060is not getting used at all, when i set a breakpoint in \u0060CacheRequestAsync\u0060the context Tags list is empty, however, if i set the Tag using this way:\n\u0060\u0060\u0060\noptions.AddPolicy(CacheConfig.CachePolicies.MultiTenantCache, o =\u003E\n    {\n        o.Expire(TimeSpan.FromMinutes(10))\n            .VaryByValue(context =\u003E CacheExtension.VaryByTenantId(context))\n            .AddPolicy\u003CMultitenantCachePolicy\u003E()\n            .Tag(CacheConfig.CacheTags.DummyTag);\n    });\n\u0060\u0060\u0060\n\nIt works this way, what am I doing wrong here?\n\n### Expected Behavior\n\nI should be able to register one custom policy, however, when I use that policy in the OutputCache attribute, I should be able to use the \u0060Tags\u0060 property so that each controller endpoint has its Tag while sharing the same policy.\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n8.0.403\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86SYyP7",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "Have you tried looking at \u0060Tags\u0060 in \u0060ServeFromCacheAsync\u0060? I believe attribute policies run after policies from options.",
        "createdAt": "2024-11-05T00:22:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/58785#issuecomment-2455970811"
      },
      {
        "id": "IC_kwDOAQzde86SdJoB",
        "parentId": null,
        "author": "skillmaker-dev",
        "content": "@BrennanConroy The method doesn\u0027t get hit, But i checked ServeResponseAsync and it contains the tag",
        "createdAt": "2024-11-05T13:04:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/58785#issuecomment-2457115137"
      },
      {
        "id": "IC_kwDOAQzde86Sf4eA",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "Sure, whichever method is called will have the tag. This seems like expected behavior then.",
        "createdAt": "2024-11-05T17:57:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/58785#issuecomment-2457831296"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86dqSJJ",
    "title": "RequestLocalizationMiddleware does not handle CultureInfo.InvariantCulture since version 8",
    "url": "https://github.com/dotnet/aspnetcore/issues/58843",
    "createdAt": "2024-11-08T20:34:01Z",
    "lastUpdated": "2024-11-09T10:32:47Z",
    "body": "### Is there an existing issue for this?\n\n- [x] I have searched the existing issues\n\n### Describe the bug\n\nThe RequestLocalizationMiddleware sets the culture to default even if the \u0060\u0060\u0060RequestLocalizationOptions\u0060\u0060\u0060 supports \u0060\u0060\u0060CultureInfo.InvariantCulture\u0060\u0060\u0060 since version 8.\n\nExample:\n\u0060\u0060\u0060c#\nbuilder.Services.Configure\u003CRequestLocalizationOptions\u003E(options =\u003E {\n    var supportedCultures = new[]\n    {\n        CultureInfo.InvariantCulture,\n        CultureInfo.GetCultureInfo(\u0022fr\u0022),\n        CultureInfo.GetCultureInfo(\u0022en\u0022),\n    };\n\n    options.DefaultRequestCulture = new(supportedCultures[1]);\n    options.SupportedCultures = supportedCultures;\n    options.SupportedUICultures = supportedCultures;\n\n    options.RequestCultureProviders =\n    [\n        new DefaultRequestCultureProvider()\n    ];\n});\n\npublic class DefaultRequestCultureProvider : IRequestCultureProvider\n{\n    public Task\u003CProviderCultureResult?\u003E DetermineProviderCultureResult(HttpContext httpContext)\n    {\n        var result = new ProviderCultureResult(culture: CultureInfo.InvariantCulture.Name, uiCulture: CultureInfo.CurrentUICulture.Name);\n\n        return Task.FromResult\u003CProviderCultureResult?\u003E(result);\n    }\n}\n\u0060\u0060\u0060 \n\nAt the end, \u0060\u0060\u0060CultureInfo.CurrentCulture\u0060\u0060\u0060 was always the \u0060\u0060\u0060DefaultRequestCulture\u0060\u0060\u0060 instead of \u0060\u0060\u0060CultureInfo.InvariantCulture\u0060\u0060\u0060.\n\nNote: this code worked until version 8\n\n\n### Expected Behavior\n\n_No response_\n\n### Steps To Reproduce\n\n_No response_\n\n### Exceptions (if any)\n\n_No response_\n\n### .NET Version\n\n_No response_\n\n### Anything else?\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86S-waW",
        "parentId": null,
        "author": "adityamandaleeka",
        "content": "It seems like not returning InvariantCulture here was an intentional decision: https://github.com/dotnet/aspnetcore/pull/46637#issuecomment-1482094780\n\n@mitchdenny, what are your thoughts?",
        "createdAt": "2024-11-09T00:10:08Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/58843#issuecomment-2465924758"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86fgDOJ",
    "title": "Add \u0060ExceptionHandlerOptions.SuppressLoggingOnHandledException\u0060",
    "url": "https://github.com/dotnet/aspnetcore/issues/59075",
    "createdAt": "2024-11-20T14:03:39Z",
    "lastUpdated": "2025-01-23T23:20:38Z",
    "body": "## Background and Motivation\n\nA config option to only log in exception handler middleware if the exception is unhandled.\n\nFor https://github.com/dotnet/aspnetcore/issues/54554\n\n## Proposed API\n\n\u0060\u0060\u0060diff\nnamespace Microsoft.AspNetCore.Builder;\n\npublic class ExceptionHandlerOptions\n{\n\u002B    public bool SuppressLoggingIExceptionHandler { get; set; }\n}\n\u0060\u0060\u0060\n\nDefaults to false.\n\n## Usage Examples\n\n\u0060\u0060\u0060csharp\napp.UseExceptionHandler(new ExceptionHandlerOptions()\n{\n    SuppressLoggingIExceptionHandler = true\n});\n\u0060\u0060\u0060\n\n## Alternative Designs\n\nCould make the new behavior the default. I don\u0027t think that is a good idea for backwards compatibility reasons, and some people might prefer the current behavior.\n\n## Risks\n\n\u003C!--\nPlease mention any risks that to your knowledge the API proposal might entail, such as breaking changes, performance regressions, etc.\n--\u003E\n\n",
    "upvotes": 0,
    "labels": [
      "api-needs-work",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86UVhkU",
        "parentId": null,
        "author": "dotnet-policy-service",
        "content": "Thank you for submitting this for API review. This will be reviewed by @dotnet/aspnet-api-review at the next meeting of the ASP.NET Core API Review group. Please ensure you take a look at [the API review process documentation](https://github.com/dotnet/aspnetcore/blob/main/docs/APIReviewProcess.md) and ensure that:\n\n* The PR contains changes to the reference-assembly that describe the API change. **Or**, you have included a snippet of reference-assembly-style code that illustrates the API change.\n* The PR describes the impact to users, both positive (useful new APIs) and negative (breaking changes).\n* Someone is assigned to \u0022champion\u0022 this change in the meeting, and they understand the impact and design of the change.\n\u003C!-- Policy app identification https://img.shields.io/static/v1?label=PullRequestIssueManagement. --\u003E",
        "createdAt": "2024-11-20T14:03:47Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59075#issuecomment-2488670484"
      },
      {
        "id": "IC_kwDOAQzde86UlUlP",
        "parentId": null,
        "author": "mitchdenny",
        "content": "This seems reasonable to me in terms of the feature. Naming wise ... Suppress vs. Disable vs. Other options. I\u0027m assuming you are using a negative property name because you want the default value to be false?",
        "createdAt": "2024-11-22T03:36:32Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59075#issuecomment-2492811599"
      },
      {
        "id": "IC_kwDOAQzde86UlX1K",
        "parentId": null,
        "author": "JamesNK",
        "content": "Yes. Suppress is common in our APIs: https://learn.microsoft.com/en-us/dotnet/api/?view=aspnetcore-9.0\u0026term=Suppress",
        "createdAt": "2024-11-22T03:53:36Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59075#issuecomment-2492824906"
      },
      {
        "id": "IC_kwDOAQzde86bo-6O",
        "parentId": null,
        "author": "halter73",
        "content": "API Review Notes:\n\n- What\u0027s the default? \u0060false\u0060\n- What\u0027s the log level? \u0060Error\u0060\n- The current proposed name is \u0060SuppressLoggingIExceptionHandler\u0060. What other names could we use?\n  - \u0060DisableLoggingIExceptionHandlerWhenHandled\u0060\n  - \u0060DisableLoggingExceptionsWhenHandled\u0060\n  - \u0060DisableLoggingOnHandledException\u0060\n  - \u0060DisableLoggingHandledExceptions\u0060\n- Could we suppress logging all unhandled exceptions? Maybe\n\nWe\u0027d like to know whether or not it makes sense to suppress logging all unhandled exceptions before deciding on a name for the bool option.",
        "createdAt": "2025-01-23T23:20:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59075#issuecomment-2611211918"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86gKEaA",
    "title": "Output-caching should support custom cache invalidation through IOutputCachePolicy",
    "url": "https://github.com/dotnet/aspnetcore/issues/59127",
    "createdAt": "2024-11-24T03:26:16Z",
    "lastUpdated": "2024-11-27T00:56:35Z",
    "body": "### Is there an existing issue for this?\n\n- [x] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\nI was working to migrate from my old caching mechanism to Output Cache, but I was struggled on an issue. I was trying to revalidate the cache in IOutputCachePolicy.ServeFromCacheAsync because the document said that at that point the freshness of the cached response can be updated. What I found out is.\n\n1. There is no way to tell the framework from within IOutputCachePolicy.ServeFromCacheAsync that the cache is not fresh anymore. From my investigation, the [only logic implemented in the middleware](https://github.com/dotnet/aspnetcore/blob/0a5f4deafc371a78e89eea7bfaa615404c52cd6a/src/Middleware/OutputCaching/src/OutputCacheMiddleware.cs#L270) is just determining the age of the cache.\n2. Even if the earlier were possible, the cached response is not publicly accessible through OutputCacheContext. This makes it impossible to inspect from outside if the cached response is still fresh or not. For example, we at least need to inspect the cached response\u0027s Etag to determine the freshness.\n\n### Describe the solution you\u0027d like\n\nI would like to suggest the following solution.\n1. Allow IOutputCachePolicy to tell the framework that the cache is already invalid inside ServeFromCacheAsync. This could be a simple method added to OutputContext, e.g. \u0060MarkCacheInvalid()\u0060.\n2. Allow IOutputCachePolicy to inspect cached response inside IOutputCachePolicy.ServeFromCacheAsync through OutputCacheContext\n\n### Additional context\n\nNow it is possible by hacking through internal members by reflection, but I believe it should be implemented because right now there is not much we can do related to the cache in IOutputCachePolicy.ServeFromCacheAsync.",
    "upvotes": 0,
    "labels": [
      "Needs: Attention :wave:",
      "feature-output-caching",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86U8wXB",
        "parentId": null,
        "author": "captainsafia",
        "content": "@tiakun Thanks for filling this issue!\n\nIt seems like you\u0027d like to propose some new API to solve the problem that you\u0027re running into here.\n\n\u003E  I was trying to revalidate the cache in IOutputCachePolicy.ServeFromCacheAsync because the document said that at that point the freshness of the cached response can be updated. What I found out is.\n\nCan you share an example of the code you wish you could write with the missing APIs to solve this problem?",
        "createdAt": "2024-11-25T20:20:37Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59127#issuecomment-2498954689"
      },
      {
        "id": "IC_kwDOAQzde86U_Hoj",
        "parentId": null,
        "author": "tiakun",
        "content": "\u003E [@tiakun](https://github.com/tiakun) Thanks for filling this issue!\n\u003E \n\u003E It seems like you\u0027d like to propose some new API to solve the problem that you\u0027re running into here.\n\u003E \n\u003E \u003E I was trying to revalidate the cache in IOutputCachePolicy.ServeFromCacheAsync because the document said that at that point the freshness of the cached response can be updated. What I found out is.\n\u003E \n\u003E Can you share an example of the code you wish you could write with the missing APIs to solve this problem?\n\nMy pleasure. Here is an example of IOutputCachePolicy I would like to write\n\n\u0060\u0060\u0060\nclass MyOutputCachePolicy : IOutputCachePolicy \n{\n     public async ValueTask ServeFromCacheAsync(OutputCacheContext context, CancellationToken cancellation)\n     {\n         var cachedEtag = context.GetCachedResponseEtag();\n         // IsFresh here is my own method to check if the cache is fresh or not\n         if (!await IsFreshAsync(context, cachedEtag)) \n         {\n              context.MarkCachedResponseInvalid();\n         }\n     }\n     ...    \n}\n\u0060\u0060\u0060\n\nFrom the example, \u0060GetCachedResponseEtag\u0060 returns cached etag and \u0060MarkCachedResponseInvalid\u0060 flag the cached response to be stale, effectively prevent the middleware to return the cache and allow the middleware to evict the cache.\n\nI\u0027m not sure if I should have used an API proposal template instead. I could do it if it is more appropriate.\n",
        "createdAt": "2024-11-26T03:26:41Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59127#issuecomment-2499574307"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86jumnA",
    "title": "Redundant checks in ResponseCachingKeyProvider",
    "url": "https://github.com/dotnet/aspnetcore/issues/59537",
    "createdAt": "2024-12-18T06:25:01Z",
    "lastUpdated": "2024-12-18T06:25:10Z",
    "body": "There are two places, where Null-Conditional Operator (\u0060?.\u0060) using seems redundant in \u0060CreateStorageVaryByKey()\u0060 method of \u0060internal class ResponseCachingKeyProvider\u0060.\n\nhttps://github.com/dotnet/aspnetcore/blob/6ae3ea387b20f6497b82897d613e9b8a6e31d69c/src/Middleware/ResponseCaching/src/ResponseCachingKeyProvider.cs#L99\n\nand\n\nhttps://github.com/dotnet/aspnetcore/blob/6ae3ea387b20f6497b82897d613e9b8a6e31d69c/src/Middleware/ResponseCaching/src/ResponseCachingKeyProvider.cs#L126\n\nThere is sufficient check of \u0060varyByRules\u0060 value at the start of the method. Isn\u0027t it?\n\nhttps://github.com/dotnet/aspnetcore/blob/6ae3ea387b20f6497b82897d613e9b8a6e31d69c/src/Middleware/ResponseCaching/src/ResponseCachingKeyProvider.cs#L80-L83\n\nFound by Linux Verification Center (linuxtesting.org) with SVACE.",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86mLEWB",
    "title": "ResponseCompressionMiddlewareTests failing in release/8.0 on Fedora41",
    "url": "https://github.com/dotnet/aspnetcore/issues/59870",
    "createdAt": "2025-01-14T17:51:40Z",
    "lastUpdated": "2025-01-14T22:49:29Z",
    "body": "\u003C!--\nNote this issue template is specifically for failing tests within the dotnet/aspnetcore repo.\n--\u003E\n\n## Failing Test(s)\n\n\u003C!--\nProvide the fully qualified name(s) of the failing tests.\n--\u003E\n\n- Failed Microsoft.AspNetCore.ResponseCompression.Tests.ResponseCompressionMiddlewareTest.SendFileAsync_AfterFirstWrite_CompressesAndFlushes\n\n## Error Message\n\n\u003C!--\nProvide the error message associated with the test failure, if applicable.\n--\u003E\n\n\u0060\u0060\u0060text\n2025-01-14T10:02:12.7516868Z Expected: 46\n2025-01-14T10:02:12.7516920Z Actual:   43\n\u0060\u0060\u0060\n\n## Stacktrace\n\n\u003Cdetails\u003E\n\u003C!--\nProvide the stack trace associated with the test failure, if applicable.\n--\u003E\n\n\u0060\u0060\u0060text\n2025-01-14T10:02:12.7532953Z      at Microsoft.AspNetCore.ResponseCompression.Tests.ResponseCompressionMiddlewareTest.CheckResponseCompressed(HttpResponseMessage response, Nullable\u00601 expectedBodyLength, String expectedEncoding) in /_/src/Middleware/ResponseCompression/test/ResponseCompressionMiddlewareTest.cs:line 1303\n2025-01-14T10:02:12.7533052Z    at Microsoft.AspNetCore.ResponseCompression.Tests.ResponseCompressionMiddlewareTest.SendFileAsync_AfterFirstWrite_CompressesAndFlushes() in /_/src/Middleware/ResponseCompression/test/ResponseCompressionMiddlewareTest.cs:line 1167\n\u0060\u0060\u0060\n\u003C/details\u003E\n\n\n## Logs\n\n\u003Cdetails\u003E\n\u003C!--\nIf this is a Helix test failure, include the text of the .log artifact from the failing test.\nNote that you have to be signed in to Azure DevOps to see the test artifacts.\n--\u003E\n\n\u0060\u0060\u0060text\n\n\u0060\u0060\u0060\n\u003C/details\u003E\n\n## Build\n\n\u003C!--\nProvide a link to the build where the test failure occurred.\n--\u003E\n\nhttps://dev.azure.com/dnceng-public/public/_build/results?buildId=916632\u0026view=results\n\nOther tests such as \u0060Failed Microsoft.AspNetCore.ResponseCompression.Tests.ResponseCompressionMiddlewareTest.SendFileAsync_FirstWrite_CompressesAndFlushes\u0060 fail in a similar way:\n\n\u003E 2025-01-14T10:02:13.9643316Z Expected: 34\n2025-01-14T10:02:13.9643333Z Actual:   31\n\nLikely related to the recent update from Fedore38 to Fedora41",
    "upvotes": 0,
    "labels": [
      "test-failure",
      "area-middleware"
    ],
    "comments": [
      {
        "id": "IC_kwDOAQzde86aazBV",
        "parentId": null,
        "author": "wtgodbe",
        "content": "CC @adityamandaleeka new 8.0 test failures on Fedora41",
        "createdAt": "2025-01-14T17:52:17Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59870#issuecomment-2590715989"
      },
      {
        "id": "IC_kwDOAQzde86aa51G",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "Compression (at least zlib probably other algorithms too) don\u0027t have a guaranteed size between algorithm versions. We either do the simple \u0022fix\u0022 of changing the expected size, or we try to be a little looser in our checks by checking a range potentially.\n\ne.g.\n\u0060Assert.InRange(compressedSize, 20, 40);\u0060",
        "createdAt": "2025-01-14T18:03:13Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59870#issuecomment-2590743878"
      },
      {
        "id": "IC_kwDOAQzde86abcI8",
        "parentId": null,
        "author": "wtgodbe",
        "content": "Did we already make that change in \u0060main\u0060? I don\u0027t see the same failures there",
        "createdAt": "2025-01-14T18:59:22Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59870#issuecomment-2590884412"
      },
      {
        "id": "IC_kwDOAQzde86abdsU",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "I remember we did the lazy fix during a runtime update when the runtime changed the zlib library. It might not be affected by the OS change in the same way.",
        "createdAt": "2025-01-14T19:02:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59870#issuecomment-2590890772"
      },
      {
        "id": "IC_kwDOAQzde86abf8i",
        "parentId": null,
        "author": "wtgodbe",
        "content": "Looks like that was https://github.com/dotnet/aspnetcore/pull/56684 - that doesn\u0027t touch \u0060SendFileAsync_AfterFirstWrite_CompressesAndFlushes\u0060 though, so it\u0027s not obvious to me why we\u0027re not seeing failure on main",
        "createdAt": "2025-01-14T19:07:27Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59870#issuecomment-2590900002"
      },
      {
        "id": "IC_kwDOAQzde86abwdu",
        "parentId": null,
        "author": "BrennanConroy",
        "content": "\u003E runtime changed the zlib library. It might not be affected by the OS change in the same way.\n\n",
        "createdAt": "2025-01-14T19:45:16Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59870#issuecomment-2590967662"
      },
      {
        "id": "IC_kwDOAQzde86ac5e3",
        "parentId": null,
        "author": "wtgodbe",
        "content": "Should we just update the 8.0 tests to use a range then? Are you the right person to make the fix?",
        "createdAt": "2025-01-14T22:49:28Z",
        "url": "https://github.com/dotnet/aspnetcore/issues/59870#issuecomment-2591266743"
      }
    ]
  },
  {
    "id": "I_kwDOAQzde86malxC",
    "title": "Retriving RateLimiterStatistics from PartitionedRateLimiter without providing a resource",
    "url": "https://github.com/dotnet/aspnetcore/issues/59899",
    "createdAt": "2025-01-16T08:12:21Z",
    "lastUpdated": "2025-01-16T08:12:24Z",
    "body": "## Background and Motivation\n\nCurrently, retrieving RateLimitStatistics from a PartitionedRateLimiter requires specifying the resource for which the statistics are needed. This parameter is used to identify the appropriate rate limiter associated with those resources. However, in certain use cases, it may be desirable to retrieve the statistics for all rate limiters managed by the PartitionedRateLimiter.\n\n## Proposed API\n\n\u0060\u0060\u0060diff\nnamespace System.Threading.RateLimiting;\n\npublic abstract class PartitionedRateLimiter\u003CTResource\u003E : IAsyncDisposable, IDisposable\n{\n\u002B    public abstract RateLimiterStatistics[] GetStatistics();\n}\n\u0060\u0060\u0060\n\n## Usage Examples\n\n\u0060\u0060\u0060csharp\npublic class RateLimiterHealthCheck : BackgroundService {\n   private readonly PartitionedRateLimiter\u003CHttpContext\u003E _partitionedRateLimiter\n   public RateLimiterHealthCheck(PartitionedRateLimiter\u003CHttpContext\u003E partitionedRateLimiter){\n      _partitionedRateLimiter = partitionedRateLimiter\n   }\n\n   protected override async Task ExecuteAsync(CancellationToken stoppingToken) {\n      while(!stoppingToken.IsCancellationRequested) {\n         foreach(var stats in _partitionedRateLimiter.GetStatistics()){\n            //Sending measurement\n            MeasurementSender.Send(stats)\n         }\n      }\n   }\n}\n\u0060\u0060\u0060\n\n## Alternative Designs\n\nWe attempted to retrieve metrics from metric \u0060Microsoft.AspNetCore.RateLimiting\u0060, but found that the provided data is aggregated, which may not satisfy scenarios requiring more detailed or per-partition insights.\n\n## Risks\n\nThere is a possibility of encountering race conditions when accessing the dictionary that holds rate limiter instances.\n\n",
    "upvotes": 1,
    "labels": [
      "api-suggestion",
      "area-middleware"
    ],
    "comments": []
  },
  {
    "id": "I_kwDOAQzde86nQ28n",
    "title": "Support RFC 5861 Cache-Control Extensions",
    "url": "https://github.com/dotnet/aspnetcore/issues/60008",
    "createdAt": "2025-01-23T08:11:02Z",
    "lastUpdated": "2025-01-23T08:11:05Z",
    "body": "### Is there an existing issue for this?\n\n- [x] I have searched the existing issues\n\n### Is your feature request related to a problem? Please describe the problem.\n\n[https://httpwg.org/specs/rfc5861.html](RFC 5861)  extends the Cache-Control header to include two new directives for http responses, \u0060stale-while-revalidate\u0060 and \u0060stale-if-error\u0060.\n\n\u0060stale-while-revalidate\u0060 in particular is supported by all main browsers, \u0060stale-if-error\u0060 whilst doesn\u0027t appear to have browser support is in use by some cdns.\n\nCurrently to set either of these means having to manually play about with the Cache-Control header and/or implementing your own middleware.\n\n### Describe the solution you\u0027d like\n\nIt would be nice if either of these could be supported by the \u0060ResponseCachingMiddleware\u0060 in order to signal clients how caching should be handled.\n\n### Additional context\n\n_No response_",
    "upvotes": 0,
    "labels": [
      "area-middleware"
    ],
    "comments": []
  }
]